webpackJsonpac__name_([5],{

/***/ 1006:
/* exports provided: Calendar */
/* exports used: Calendar */
/*!******************************************************!*\
  !*** ./src/app/extra/calendar/calendar.component.ts ***!
  \******************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(jQuery, moment) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(/*! @angular/core */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ng2_bootstrap__ = __webpack_require__(/*! ng2-bootstrap */ 705);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ng2_bootstrap___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_ng2_bootstrap__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Calendar; });\n\r\n\r\nvar Calendar = (function () {\r\n    function Calendar() {\r\n        var _this = this;\r\n        this.dragOptions = { zIndex: 999, revert: true, revertDuration: 0 };\r\n        this.event = {};\r\n        this.calendarEvent = null;\r\n        var date = new Date();\r\n        var d = date.getDate();\r\n        var m = date.getMonth();\r\n        var y = date.getFullYear();\r\n        this.calendarOptions = {\r\n            header: {\r\n                left: '',\r\n                center: '',\r\n                right: ''\r\n            },\r\n            events: [\r\n                {\r\n                    title: 'All Day Event',\r\n                    start: new Date(y, m, 1),\r\n                    backgroundColor: '#79A5F0',\r\n                    textColor: '#fff',\r\n                    description: 'Will be busy throughout the whole day'\r\n                },\r\n                {\r\n                    title: 'Long Event',\r\n                    start: new Date(y, m, d + 5),\r\n                    end: new Date(y, m, d + 7),\r\n                    description: 'This conference should be worse visiting'\r\n                },\r\n                {\r\n                    id: 999,\r\n                    title: 'Blah Blah Car',\r\n                    start: new Date(y, m, d - 3, 16, 0),\r\n                    allDay: false,\r\n                    description: 'Agree with this guy on arrival time'\r\n                },\r\n                {\r\n                    id: 1000,\r\n                    title: 'Buy this template',\r\n                    start: new Date(y, m, d + 3, 12, 0),\r\n                    allDay: false,\r\n                    backgroundColor: '#555',\r\n                    textColor: '#fff',\r\n                    description: 'Make sure everything is consistent first'\r\n                },\r\n                {\r\n                    title: 'Got to school',\r\n                    start: new Date(y, m, d + 16, 12, 0),\r\n                    end: new Date(y, m, d + 16, 13, 0),\r\n                    backgroundColor: '#64bd63',\r\n                    textColor: '#fff',\r\n                    description: 'Time to go back'\r\n                },\r\n                {\r\n                    title: 'Study some Node',\r\n                    start: new Date(y, m, d + 18, 12, 0),\r\n                    end: new Date(y, m, d + 18, 13, 0),\r\n                    backgroundColor: '#79A5F0',\r\n                    textColor: '#fff',\r\n                    description: 'Node.js is a platform built ' +\r\n                        'on Chrome\\'s JavaScript runtime for easily' +\r\n                        ' building fast, scalable network applications.' +\r\n                        ' Node.js uses an event-driven, non-blocking' +\r\n                        ' I/O model that makes it lightweight and' +\r\n                        ' efficient, perfect for data-intensive real-time' +\r\n                        ' applications that run across distributed devices.'\r\n                },\r\n                {\r\n                    title: 'Click for Flatlogic',\r\n                    start: new Date(y, m, 28),\r\n                    end: new Date(y, m, 29),\r\n                    url: 'http://flatlogic.com/',\r\n                    backgroundColor: '#e5603b',\r\n                    textColor: '#fff',\r\n                    description: 'Creative solutions'\r\n                }\r\n            ],\r\n            selectable: true,\r\n            selectHelper: true,\r\n            select: function (start, end, allDay) {\r\n                _this.createEvent = function () {\r\n                    var title = _this.event.title;\r\n                    if (title) {\r\n                        _this.$calendar.fullCalendar('renderEvent', {\r\n                            title: title,\r\n                            start: start,\r\n                            end: end,\r\n                            allDay: allDay,\r\n                            backgroundColor: '#64bd63',\r\n                            textColor: '#fff'\r\n                        }, true // make the event \"stick\"\r\n                        );\r\n                    }\r\n                    _this.$calendar.fullCalendar('unselect');\r\n                    _this.calendarEvent = null;\r\n                    _this.modalWindow.hide();\r\n                };\r\n                _this.calendarEvent = 'create';\r\n                _this.modalWindow.show();\r\n            },\r\n            eventClick: function (event) {\r\n                _this.event = event;\r\n                _this.calendarEvent = 'show';\r\n                _this.modalWindow.show();\r\n            },\r\n            editable: true,\r\n            droppable: true,\r\n            drop: function (dateItem, event) {\r\n                // retrieve the dropped element's stored Event Object\r\n                var originalEventObject = {\r\n                    // use the element's text as the event title\r\n                    title: jQuery.trim(jQuery(event.target).text())\r\n                };\r\n                // we need to copy it, so that multiple events don't have a reference to the same object\r\n                var copiedEventObject = jQuery.extend({}, originalEventObject);\r\n                // assign it the date that was reported\r\n                copiedEventObject.start = dateItem;\r\n                copiedEventObject.allDay = !dateItem.hasTime();\r\n                var $categoryClass = jQuery(event.target).data('event-class');\r\n                if ($categoryClass) {\r\n                    copiedEventObject.className = [$categoryClass];\r\n                }\r\n                // render the event on the calendar\r\n                // the last `true` argument determines if\r\n                // the event 'sticks'\r\n                // http://arshaw.com/fullcalendar/docs/event_rendering/renderEvent/)\r\n                _this.$calendar.fullCalendar('renderEvent', copiedEventObject, true);\r\n                jQuery(event.target).remove();\r\n            },\r\n        };\r\n    }\r\n    ;\r\n    Calendar.prototype.addEvent = function (event) {\r\n        this.calendarOptions.events.push(event);\r\n    };\r\n    ;\r\n    Calendar.prototype.changeView = function (view) {\r\n        this.$calendar.fullCalendar('changeView', view);\r\n    };\r\n    ;\r\n    Calendar.prototype.currentMonth = function () {\r\n        return moment(this.$calendar.fullCalendar('getDate')).format('MMM YYYY');\r\n    };\r\n    ;\r\n    Calendar.prototype.currentDay = function () {\r\n        return moment(this.$calendar.fullCalendar('getDate')).format('dddd');\r\n    };\r\n    ;\r\n    Calendar.prototype.prev = function () {\r\n        this.$calendar.fullCalendar('prev');\r\n    };\r\n    ;\r\n    Calendar.prototype.next = function () {\r\n        this.$calendar.fullCalendar('next');\r\n    };\r\n    ;\r\n    Calendar.prototype.ngOnInit = function () {\r\n        this.$calendar = jQuery('#calendar');\r\n        this.$calendar.fullCalendar(this.calendarOptions);\r\n        jQuery('.draggable').draggable(this.dragOptions);\r\n    };\r\n    __decorate([\r\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ViewChild\"])('modalWindow'), \r\n        __metadata('design:type', __WEBPACK_IMPORTED_MODULE_1_ng2_bootstrap__[\"ModalDirective\"])\r\n    ], Calendar.prototype, \"modalWindow\", void 0);\r\n    Calendar = __decorate([\r\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Component\"])({\r\n            selector: '[extra-calendar]',\r\n            template: __webpack_require__(/*! ./calendar.template.html */ 1145),\r\n            encapsulation: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ViewEncapsulation\"].None,\r\n            styles: [__webpack_require__(/*! ./calendar.style.scss */ 1122)]\r\n        }), \r\n        __metadata('design:paramtypes', [])\r\n    ], Calendar);\r\n    return Calendar;\r\n}());\r\n\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(/*! jquery */ 41), __webpack_require__(/*! moment */ 702)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAwNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvZXh0cmEvY2FsZW5kYXIvY2FsZW5kYXIuY29tcG9uZW50LnRzP2ZlOTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBWaWV3RW5jYXBzdWxhdGlvbiwgT25Jbml0LCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgTW9kYWxEaXJlY3RpdmUgfSBmcm9tICduZzItYm9vdHN0cmFwJztcclxuZGVjbGFyZSB2YXIgalF1ZXJ5OiBhbnk7XHJcbmRlY2xhcmUgdmFyIG1vbWVudDogYW55O1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICdbZXh0cmEtY2FsZW5kYXJdJyxcclxuICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9jYWxlbmRhci50ZW1wbGF0ZS5odG1sJyksXHJcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcclxuICBzdHlsZXM6IFtyZXF1aXJlKCcuL2NhbGVuZGFyLnN0eWxlLnNjc3MnKV1cclxufSlcclxuZXhwb3J0IGNsYXNzIENhbGVuZGFyIGltcGxlbWVudHMgT25Jbml0IHtcclxuICBjYWxlbmRhck9wdGlvbnM6IGFueTtcclxuICAkY2FsZW5kYXI6IGFueTtcclxuICBkcmFnT3B0aW9uczogT2JqZWN0ID0geyB6SW5kZXg6IDk5OSwgcmV2ZXJ0OiB0cnVlLCByZXZlcnREdXJhdGlvbjogMCB9O1xyXG4gIGV2ZW50OiBhbnkgPSB7fTtcclxuICBjcmVhdGVFdmVudDogYW55O1xyXG4gIGNhbGVuZGFyRXZlbnQ6IHN0cmluZyA9IG51bGw7XHJcblxyXG4gIEBWaWV3Q2hpbGQoJ21vZGFsV2luZG93JykgcHVibGljIG1vZGFsV2luZG93OiBNb2RhbERpcmVjdGl2ZTtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBsZXQgZGF0ZSA9IG5ldyBEYXRlKCk7XHJcbiAgICBsZXQgZCA9IGRhdGUuZ2V0RGF0ZSgpO1xyXG4gICAgbGV0IG0gPSBkYXRlLmdldE1vbnRoKCk7XHJcbiAgICBsZXQgeSA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcclxuXHJcbiAgICB0aGlzLmNhbGVuZGFyT3B0aW9ucyA9IHtcclxuICAgICAgaGVhZGVyOiB7XHJcbiAgICAgICAgbGVmdDogJycsXHJcbiAgICAgICAgY2VudGVyOiAnJyxcclxuICAgICAgICByaWdodDogJydcclxuICAgICAgfSxcclxuICAgICAgZXZlbnRzOiBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgdGl0bGU6ICdBbGwgRGF5IEV2ZW50JyxcclxuICAgICAgICAgIHN0YXJ0OiBuZXcgRGF0ZSh5LCBtLCAxKSxcclxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJyM3OUE1RjAnLFxyXG4gICAgICAgICAgdGV4dENvbG9yOiAnI2ZmZicsXHJcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ1dpbGwgYmUgYnVzeSB0aHJvdWdob3V0IHRoZSB3aG9sZSBkYXknXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICB0aXRsZTogJ0xvbmcgRXZlbnQnLFxyXG4gICAgICAgICAgc3RhcnQ6IG5ldyBEYXRlKHksIG0sIGQgKyA1KSxcclxuICAgICAgICAgIGVuZDogbmV3IERhdGUoeSwgbSwgZCArIDcpLFxyXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdUaGlzIGNvbmZlcmVuY2Ugc2hvdWxkIGJlIHdvcnNlIHZpc2l0aW5nJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgaWQ6IDk5OSxcclxuICAgICAgICAgIHRpdGxlOiAnQmxhaCBCbGFoIENhcicsXHJcbiAgICAgICAgICBzdGFydDogbmV3IERhdGUoeSwgbSwgZCAtIDMsIDE2LCAwKSxcclxuICAgICAgICAgIGFsbERheTogZmFsc2UsXHJcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ0FncmVlIHdpdGggdGhpcyBndXkgb24gYXJyaXZhbCB0aW1lJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgaWQ6IDEwMDAsXHJcbiAgICAgICAgICB0aXRsZTogJ0J1eSB0aGlzIHRlbXBsYXRlJyxcclxuICAgICAgICAgIHN0YXJ0OiBuZXcgRGF0ZSh5LCBtLCBkICsgMywgMTIsIDApLFxyXG4gICAgICAgICAgYWxsRGF5OiBmYWxzZSxcclxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJyM1NTUnLFxyXG4gICAgICAgICAgdGV4dENvbG9yOiAnI2ZmZicsXHJcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ01ha2Ugc3VyZSBldmVyeXRoaW5nIGlzIGNvbnNpc3RlbnQgZmlyc3QnXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICB0aXRsZTogJ0dvdCB0byBzY2hvb2wnLFxyXG4gICAgICAgICAgc3RhcnQ6IG5ldyBEYXRlKHksIG0sIGQgKyAxNiwgMTIsIDApLFxyXG4gICAgICAgICAgZW5kOiBuZXcgRGF0ZSh5LCBtLCBkICsgMTYsIDEzLCAwKSxcclxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJyM2NGJkNjMnLFxyXG4gICAgICAgICAgdGV4dENvbG9yOiAnI2ZmZicsXHJcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ1RpbWUgdG8gZ28gYmFjaydcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIHRpdGxlOiAnU3R1ZHkgc29tZSBOb2RlJyxcclxuICAgICAgICAgIHN0YXJ0OiBuZXcgRGF0ZSh5LCBtLCBkICsgMTgsIDEyLCAwKSxcclxuICAgICAgICAgIGVuZDogbmV3IERhdGUoeSwgbSwgZCArIDE4LCAxMywgMCksXHJcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjNzlBNUYwJyxcclxuICAgICAgICAgIHRleHRDb2xvcjogJyNmZmYnLFxyXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdOb2RlLmpzIGlzIGEgcGxhdGZvcm0gYnVpbHQgJyArXHJcbiAgICAgICAgICAnb24gQ2hyb21lXFwncyBKYXZhU2NyaXB0IHJ1bnRpbWUgZm9yIGVhc2lseScgK1xyXG4gICAgICAgICAgJyBidWlsZGluZyBmYXN0LCBzY2FsYWJsZSBuZXR3b3JrIGFwcGxpY2F0aW9ucy4nICtcclxuICAgICAgICAgICcgTm9kZS5qcyB1c2VzIGFuIGV2ZW50LWRyaXZlbiwgbm9uLWJsb2NraW5nJyArXHJcbiAgICAgICAgICAnIEkvTyBtb2RlbCB0aGF0IG1ha2VzIGl0IGxpZ2h0d2VpZ2h0IGFuZCcgK1xyXG4gICAgICAgICAgJyBlZmZpY2llbnQsIHBlcmZlY3QgZm9yIGRhdGEtaW50ZW5zaXZlIHJlYWwtdGltZScgK1xyXG4gICAgICAgICAgJyBhcHBsaWNhdGlvbnMgdGhhdCBydW4gYWNyb3NzIGRpc3RyaWJ1dGVkIGRldmljZXMuJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgdGl0bGU6ICdDbGljayBmb3IgRmxhdGxvZ2ljJyxcclxuICAgICAgICAgIHN0YXJ0OiBuZXcgRGF0ZSh5LCBtLCAyOCksXHJcbiAgICAgICAgICBlbmQ6IG5ldyBEYXRlKHksIG0sIDI5KSxcclxuICAgICAgICAgIHVybDogJ2h0dHA6Ly9mbGF0bG9naWMuY29tLycsXHJcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZTU2MDNiJyxcclxuICAgICAgICAgIHRleHRDb2xvcjogJyNmZmYnLFxyXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdDcmVhdGl2ZSBzb2x1dGlvbnMnXHJcbiAgICAgICAgfVxyXG4gICAgICBdLFxyXG4gICAgICBzZWxlY3RhYmxlOiB0cnVlLFxyXG4gICAgICBzZWxlY3RIZWxwZXI6IHRydWUsXHJcbiAgICAgIHNlbGVjdDogKHN0YXJ0LCBlbmQsIGFsbERheSk6IHZvaWQgPT4ge1xyXG4gICAgICAgIHRoaXMuY3JlYXRlRXZlbnQgPSAoKSA9PiB7XHJcbiAgICAgICAgICBsZXQgdGl0bGUgPSB0aGlzLmV2ZW50LnRpdGxlO1xyXG4gICAgICAgICAgaWYgKHRpdGxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuJGNhbGVuZGFyLmZ1bGxDYWxlbmRhcigncmVuZGVyRXZlbnQnLFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZSxcclxuICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuICAgICAgICAgICAgICAgIGVuZDogZW5kLFxyXG4gICAgICAgICAgICAgICAgYWxsRGF5OiBhbGxEYXksXHJcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjNjRiZDYzJyxcclxuICAgICAgICAgICAgICAgIHRleHRDb2xvcjogJyNmZmYnXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB0cnVlIC8vIG1ha2UgdGhlIGV2ZW50IFwic3RpY2tcIlxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGhpcy4kY2FsZW5kYXIuZnVsbENhbGVuZGFyKCd1bnNlbGVjdCcpO1xyXG4gICAgICAgICAgdGhpcy5jYWxlbmRhckV2ZW50ID0gbnVsbDtcclxuICAgICAgICAgIHRoaXMubW9kYWxXaW5kb3cuaGlkZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5jYWxlbmRhckV2ZW50ID0gJ2NyZWF0ZSc7XHJcbiAgICAgICAgdGhpcy5tb2RhbFdpbmRvdy5zaG93KCk7XHJcbiAgICAgIH0sXHJcbiAgICAgIGV2ZW50Q2xpY2s6IChldmVudCk6IHZvaWQgPT4ge1xyXG4gICAgICAgIHRoaXMuZXZlbnQgPSBldmVudDtcclxuICAgICAgICB0aGlzLmNhbGVuZGFyRXZlbnQgPSAnc2hvdyc7XHJcbiAgICAgICAgdGhpcy5tb2RhbFdpbmRvdy5zaG93KCk7XHJcbiAgICAgIH0sXHJcbiAgICAgIGVkaXRhYmxlOiB0cnVlLFxyXG4gICAgICBkcm9wcGFibGU6IHRydWUsXHJcblxyXG4gICAgICBkcm9wOiAoZGF0ZUl0ZW0sIGV2ZW50KTogdm9pZCA9PiB7IC8vIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gc29tZXRoaW5nIGlzIGRyb3BwZWRcclxuICAgICAgICAvLyByZXRyaWV2ZSB0aGUgZHJvcHBlZCBlbGVtZW50J3Mgc3RvcmVkIEV2ZW50IE9iamVjdFxyXG4gICAgICAgIGxldCBvcmlnaW5hbEV2ZW50T2JqZWN0ID0ge1xyXG4gICAgICAgICAgLy8gdXNlIHRoZSBlbGVtZW50J3MgdGV4dCBhcyB0aGUgZXZlbnQgdGl0bGVcclxuICAgICAgICAgIHRpdGxlOiBqUXVlcnkudHJpbShqUXVlcnkoZXZlbnQudGFyZ2V0KS50ZXh0KCkpXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gd2UgbmVlZCB0byBjb3B5IGl0LCBzbyB0aGF0IG11bHRpcGxlIGV2ZW50cyBkb24ndCBoYXZlIGEgcmVmZXJlbmNlIHRvIHRoZSBzYW1lIG9iamVjdFxyXG4gICAgICAgIGxldCBjb3BpZWRFdmVudE9iamVjdCA9IGpRdWVyeS5leHRlbmQoe30sIG9yaWdpbmFsRXZlbnRPYmplY3QpO1xyXG5cclxuICAgICAgICAvLyBhc3NpZ24gaXQgdGhlIGRhdGUgdGhhdCB3YXMgcmVwb3J0ZWRcclxuICAgICAgICBjb3BpZWRFdmVudE9iamVjdC5zdGFydCA9IGRhdGVJdGVtO1xyXG4gICAgICAgIGNvcGllZEV2ZW50T2JqZWN0LmFsbERheSA9ICFkYXRlSXRlbS5oYXNUaW1lKCk7XHJcblxyXG4gICAgICAgIGxldCAkY2F0ZWdvcnlDbGFzcyA9IGpRdWVyeShldmVudC50YXJnZXQpLmRhdGEoJ2V2ZW50LWNsYXNzJyk7XHJcbiAgICAgICAgaWYgKCRjYXRlZ29yeUNsYXNzKSB7IGNvcGllZEV2ZW50T2JqZWN0LmNsYXNzTmFtZSA9IFskY2F0ZWdvcnlDbGFzc107IH1cclxuXHJcbiAgICAgICAgLy8gcmVuZGVyIHRoZSBldmVudCBvbiB0aGUgY2FsZW5kYXJcclxuICAgICAgICAvLyB0aGUgbGFzdCBgdHJ1ZWAgYXJndW1lbnQgZGV0ZXJtaW5lcyBpZlxyXG4gICAgICAgIC8vIHRoZSBldmVudCAnc3RpY2tzJ1xyXG4gICAgICAgIC8vIGh0dHA6Ly9hcnNoYXcuY29tL2Z1bGxjYWxlbmRhci9kb2NzL2V2ZW50X3JlbmRlcmluZy9yZW5kZXJFdmVudC8pXHJcbiAgICAgICAgdGhpcy4kY2FsZW5kYXIuZnVsbENhbGVuZGFyKCdyZW5kZXJFdmVudCcsIGNvcGllZEV2ZW50T2JqZWN0LCB0cnVlKTtcclxuXHJcbiAgICAgICAgalF1ZXJ5KGV2ZW50LnRhcmdldCkucmVtb3ZlKCk7XHJcblxyXG4gICAgICB9LFxyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICBhZGRFdmVudChldmVudCk6IHZvaWQge1xyXG4gICAgdGhpcy5jYWxlbmRhck9wdGlvbnMuZXZlbnRzLnB1c2goZXZlbnQpO1xyXG4gIH07XHJcblxyXG4gIGNoYW5nZVZpZXcodmlldyk6IHZvaWQge1xyXG4gICAgdGhpcy4kY2FsZW5kYXIuZnVsbENhbGVuZGFyKCdjaGFuZ2VWaWV3Jywgdmlldyk7XHJcbiAgfTtcclxuXHJcbiAgY3VycmVudE1vbnRoKCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gbW9tZW50KHRoaXMuJGNhbGVuZGFyLmZ1bGxDYWxlbmRhcignZ2V0RGF0ZScpKS5mb3JtYXQoJ01NTSBZWVlZJyk7XHJcbiAgfTtcclxuXHJcbiAgY3VycmVudERheSgpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIG1vbWVudCh0aGlzLiRjYWxlbmRhci5mdWxsQ2FsZW5kYXIoJ2dldERhdGUnKSkuZm9ybWF0KCdkZGRkJyk7XHJcbiAgfTtcclxuXHJcbiAgcHJldigpOiB2b2lkIHtcclxuICAgIHRoaXMuJGNhbGVuZGFyLmZ1bGxDYWxlbmRhcigncHJldicpO1xyXG4gIH07XHJcblxyXG4gIG5leHQoKTogdm9pZCB7XHJcbiAgICB0aGlzLiRjYWxlbmRhci5mdWxsQ2FsZW5kYXIoJ25leHQnKTtcclxuICB9O1xyXG5cclxuICBuZ09uSW5pdCgpOiB2b2lkIHtcclxuICAgIHRoaXMuJGNhbGVuZGFyID0galF1ZXJ5KCcjY2FsZW5kYXInKTtcclxuICAgIHRoaXMuJGNhbGVuZGFyLmZ1bGxDYWxlbmRhcih0aGlzLmNhbGVuZGFyT3B0aW9ucyk7XHJcbiAgICBqUXVlcnkoJy5kcmFnZ2FibGUnKS5kcmFnZ2FibGUodGhpcy5kcmFnT3B0aW9ucyk7XHJcbiAgfVxyXG59XHJcblxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL34vYW5ndWxhci1yb3V0ZXItbG9hZGVyL3NyYz9sb2FkZXI9c3lzdGVtJmdlbkRpcj1jb21waWxlZC9hcHAmYW90PWZhbHNlIS4vc3JjL2FwcC9leHRyYS9jYWxlbmRhci9jYWxlbmRhci5jb21wb25lbnQudHMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFVQTtBQVVBO0FBVkE7QUFHQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXRLQTtBQUFBOztBQUFBO0FBZEE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQUE7QUFnTEE7QUFBQTs7Ozs7OyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 1007:
/* exports provided: routes, ExtraModule */
/* all exports used */
/*!***************************************!*\
  !*** ./src/app/extra/extra.module.ts ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_fullcalendar_dist_fullcalendar_js__ = __webpack_require__(/*! fullcalendar/dist/fullcalendar.js */ 1073);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_fullcalendar_dist_fullcalendar_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_fullcalendar_dist_fullcalendar_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_jquery_ui_ui_draggable_js__ = __webpack_require__(/*! jquery-ui/ui/draggable.js */ 1079);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_jquery_ui_ui_draggable_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_jquery_ui_ui_draggable_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_magnific_popup_dist_jquery_magnific_popup_min_js__ = __webpack_require__(/*! magnific-popup/dist/jquery.magnific-popup.min.js */ 1084);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_magnific_popup_dist_jquery_magnific_popup_min_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_magnific_popup_dist_jquery_magnific_popup_min_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_shufflejs_dist_shuffle_js__ = __webpack_require__(/*! shufflejs/dist/shuffle.js */ 980);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_shufflejs_dist_shuffle_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_shufflejs_dist_shuffle_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_moment_moment_js__ = __webpack_require__(/*! moment/moment.js */ 702);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_moment_moment_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_moment_moment_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__angular_common__ = __webpack_require__(/*! @angular/common */ 78);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__angular_forms__ = __webpack_require__(/*! @angular/forms */ 169);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__angular_core__ = __webpack_require__(/*! @angular/core */ 0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__angular_router__ = __webpack_require__(/*! @angular/router */ 118);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_ng2_bootstrap__ = __webpack_require__(/*! ng2-bootstrap */ 705);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_ng2_bootstrap___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_ng2_bootstrap__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__calendar_calendar_component__ = __webpack_require__(/*! ./calendar/calendar.component */ 1006);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__invoice_invoice_component__ = __webpack_require__(/*! ./invoice/invoice.component */ 1009);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__search_results_search_results_component__ = __webpack_require__(/*! ./search-results/search-results.component */ 1010);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__time_line_time_line_component__ = __webpack_require__(/*! ./time-line/time-line.component */ 1011);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__gallery_gallery_component__ = __webpack_require__(/*! ./gallery/gallery.component */ 1008);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_angular2_google_maps_core__ = __webpack_require__(/*! angular2-google-maps/core */ 763);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_angular2_google_maps_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_15_angular2_google_maps_core__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"routes\", function() { return routes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ExtraModule\", function() { return ExtraModule; });\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar routes = [\r\n    { path: '', redirectTo: 'calendar', pathMatch: 'full' },\r\n    { path: 'calendar', component: __WEBPACK_IMPORTED_MODULE_10__calendar_calendar_component__[\"a\" /* Calendar */] },\r\n    { path: 'invoice', component: __WEBPACK_IMPORTED_MODULE_11__invoice_invoice_component__[\"a\" /* Invoice */] },\r\n    { path: 'search', component: __WEBPACK_IMPORTED_MODULE_12__search_results_search_results_component__[\"a\" /* SearchResults */] },\r\n    { path: 'timeline', component: __WEBPACK_IMPORTED_MODULE_13__time_line_time_line_component__[\"a\" /* TimeLine */] },\r\n    { path: 'gallery', component: __WEBPACK_IMPORTED_MODULE_14__gallery_gallery_component__[\"a\" /* Gallery */] }\r\n];\r\nvar ExtraModule = (function () {\r\n    function ExtraModule() {\r\n    }\r\n    ExtraModule.routes = routes;\r\n    ExtraModule = __decorate([\r\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__angular_core__[\"NgModule\"])({\r\n            declarations: [\r\n                // Components / Directives/ Pipes\r\n                __WEBPACK_IMPORTED_MODULE_10__calendar_calendar_component__[\"a\" /* Calendar */],\r\n                __WEBPACK_IMPORTED_MODULE_11__invoice_invoice_component__[\"a\" /* Invoice */],\r\n                __WEBPACK_IMPORTED_MODULE_12__search_results_search_results_component__[\"a\" /* SearchResults */],\r\n                __WEBPACK_IMPORTED_MODULE_13__time_line_time_line_component__[\"a\" /* TimeLine */],\r\n                __WEBPACK_IMPORTED_MODULE_14__gallery_gallery_component__[\"a\" /* Gallery */]\r\n            ],\r\n            imports: [\r\n                __WEBPACK_IMPORTED_MODULE_5__angular_common__[\"CommonModule\"],\r\n                __WEBPACK_IMPORTED_MODULE_6__angular_forms__[\"FormsModule\"],\r\n                __WEBPACK_IMPORTED_MODULE_8__angular_router__[\"a\" /* RouterModule */].forChild(routes),\r\n                __WEBPACK_IMPORTED_MODULE_9_ng2_bootstrap__[\"AlertModule\"].forRoot(),\r\n                __WEBPACK_IMPORTED_MODULE_9_ng2_bootstrap__[\"TooltipModule\"].forRoot(),\r\n                __WEBPACK_IMPORTED_MODULE_9_ng2_bootstrap__[\"ModalModule\"],\r\n                __WEBPACK_IMPORTED_MODULE_9_ng2_bootstrap__[\"ButtonsModule\"].forRoot(),\r\n                __WEBPACK_IMPORTED_MODULE_9_ng2_bootstrap__[\"DropdownModule\"].forRoot(),\r\n                __WEBPACK_IMPORTED_MODULE_15_angular2_google_maps_core__[\"AgmCoreModule\"].forRoot({\r\n                    apiKey: 'AIzaSyDe_oVpi9eRSN99G4o6TwVjJbFBNr58NxE'\r\n                })\r\n            ],\r\n            schemas: [__WEBPACK_IMPORTED_MODULE_7__angular_core__[\"CUSTOM_ELEMENTS_SCHEMA\"]]\r\n        }), \r\n        __metadata('design:paramtypes', [])\r\n    ], ExtraModule);\r\n    return ExtraModule;\r\n}());\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAwNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvZXh0cmEvZXh0cmEubW9kdWxlLnRzP2E1OGIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICdmdWxsY2FsZW5kYXIvZGlzdC9mdWxsY2FsZW5kYXIuanMnO1xyXG5pbXBvcnQgJ2pxdWVyeS11aS91aS9kcmFnZ2FibGUuanMnO1xyXG5pbXBvcnQgJ21hZ25pZmljLXBvcHVwL2Rpc3QvanF1ZXJ5Lm1hZ25pZmljLXBvcHVwLm1pbi5qcyc7XHJcbmltcG9ydCAnc2h1ZmZsZWpzL2Rpc3Qvc2h1ZmZsZS5qcyc7XHJcbmltcG9ydCAnbW9tZW50L21vbWVudC5qcyc7XHJcblxyXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5pbXBvcnQgeyBGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcclxuaW1wb3J0IHsgTmdNb2R1bGUsIENVU1RPTV9FTEVNRU5UU19TQ0hFTUEgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgUm91dGVyTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcclxuaW1wb3J0IHsgQWxlcnRNb2R1bGUsIFRvb2x0aXBNb2R1bGUsXHJcbiAgQnV0dG9uc01vZHVsZSwgRHJvcGRvd25Nb2R1bGUgfSBmcm9tICduZzItYm9vdHN0cmFwJztcclxuaW1wb3J0IHsgTW9kYWxNb2R1bGUgfSBmcm9tICduZzItYm9vdHN0cmFwJztcclxuXHJcbmltcG9ydCB7IENhbGVuZGFyIH0gZnJvbSAnLi9jYWxlbmRhci9jYWxlbmRhci5jb21wb25lbnQnO1xyXG5pbXBvcnQgeyBJbnZvaWNlIH0gZnJvbSAnLi9pbnZvaWNlL2ludm9pY2UuY29tcG9uZW50JztcclxuaW1wb3J0IHsgU2VhcmNoUmVzdWx0cyB9IGZyb20gJy4vc2VhcmNoLXJlc3VsdHMvc2VhcmNoLXJlc3VsdHMuY29tcG9uZW50JztcclxuaW1wb3J0IHsgVGltZUxpbmUgfSBmcm9tICcuL3RpbWUtbGluZS90aW1lLWxpbmUuY29tcG9uZW50JztcclxuaW1wb3J0IHsgR2FsbGVyeSB9IGZyb20gJy4vZ2FsbGVyeS9nYWxsZXJ5LmNvbXBvbmVudCc7XHJcblxyXG5pbXBvcnQgeyBBZ21Db3JlTW9kdWxlIH0gZnJvbSAnYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZSc7XHJcblxyXG5leHBvcnQgY29uc3Qgcm91dGVzID0gW1xyXG4gIHtwYXRoOiAnJywgcmVkaXJlY3RUbzogJ2NhbGVuZGFyJywgcGF0aE1hdGNoOiAnZnVsbCd9LFxyXG4gIHtwYXRoOiAnY2FsZW5kYXInLCBjb21wb25lbnQ6IENhbGVuZGFyfSxcclxuICB7cGF0aDogJ2ludm9pY2UnLCBjb21wb25lbnQ6IEludm9pY2V9LFxyXG4gIHtwYXRoOiAnc2VhcmNoJywgY29tcG9uZW50OiBTZWFyY2hSZXN1bHRzfSxcclxuICB7cGF0aDogJ3RpbWVsaW5lJywgY29tcG9uZW50OiBUaW1lTGluZX0sXHJcbiAge3BhdGg6ICdnYWxsZXJ5JywgY29tcG9uZW50OiBHYWxsZXJ5fVxyXG5dO1xyXG5cclxuQE5nTW9kdWxlKHtcclxuICBkZWNsYXJhdGlvbnM6IFtcclxuICAgIC8vIENvbXBvbmVudHMgLyBEaXJlY3RpdmVzLyBQaXBlc1xyXG4gICAgQ2FsZW5kYXIsXHJcbiAgICBJbnZvaWNlLFxyXG4gICAgU2VhcmNoUmVzdWx0cyxcclxuICAgIFRpbWVMaW5lLFxyXG4gICAgR2FsbGVyeVxyXG4gIF0sXHJcbiAgaW1wb3J0czogW1xyXG4gICAgQ29tbW9uTW9kdWxlLFxyXG4gICAgRm9ybXNNb2R1bGUsXHJcbiAgICBSb3V0ZXJNb2R1bGUuZm9yQ2hpbGQocm91dGVzKSxcclxuICAgIEFsZXJ0TW9kdWxlLmZvclJvb3QoKSxcclxuICAgIFRvb2x0aXBNb2R1bGUuZm9yUm9vdCgpLFxyXG4gICAgTW9kYWxNb2R1bGUsXHJcbiAgICBCdXR0b25zTW9kdWxlLmZvclJvb3QoKSxcclxuICAgIERyb3Bkb3duTW9kdWxlLmZvclJvb3QoKSxcclxuICAgIEFnbUNvcmVNb2R1bGUuZm9yUm9vdCh7XHJcbiAgICAgIGFwaUtleTogJ0FJemFTeURlX29WcGk5ZVJTTjk5RzRvNlR3VmpKYkZCTnI1OE54RSdcclxuICAgIH0pXHJcbiAgXSxcclxuICBzY2hlbWFzOiAgWyBDVVNUT01fRUxFTUVOVFNfU0NIRU1BIF1cclxufSlcclxuZXhwb3J0IGNsYXNzIEV4dHJhTW9kdWxlIHtcclxuICBzdGF0aWMgcm91dGVzID0gcm91dGVzO1xyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBub2RlX21vZHVsZXMvYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vfi9hbmd1bGFyLXJvdXRlci1sb2FkZXIvc3JjP2xvYWRlcj1zeXN0ZW0mZ2VuRGlyPWNvbXBpbGVkL2FwcCZhb3Q9ZmFsc2UhLi9zcmMvYXBwL2V4dHJhL2V4dHJhLm1vZHVsZS50cyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEwQkE7QUFBQTtBQUVBO0FBREE7QUF6QkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQUE7QUFHQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 1008:
/* exports provided: Gallery */
/* exports used: Gallery */
/*!****************************************************!*\
  !*** ./src/app/extra/gallery/gallery.component.ts ***!
  \****************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(jQuery, Shuffle) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(/*! @angular/core */ 0);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Gallery; });\n\r\nvar Gallery = (function () {\r\n    function Gallery() {\r\n        this.magnificOptions = {\r\n            delegate: '.img-thumbnail > a',\r\n            type: 'image',\r\n            gallery: { enabled: true }\r\n        };\r\n        this.items = [\r\n            {\r\n                'name': 'Mountains',\r\n                'groups': [\r\n                    'nature'\r\n                ],\r\n                'src': 'assets/img/pictures/1.jpg',\r\n                'date': '10 mins'\r\n            },\r\n            {\r\n                'name': 'Empire State Pigeon',\r\n                'groups': [\r\n                    'people'\r\n                ],\r\n                'src': 'assets/img/pictures/2.jpg',\r\n                'date': '1 hour',\r\n                'like': true\r\n            },\r\n            {\r\n                'name': 'Big Lake',\r\n                'groups': [\r\n                    'nature'\r\n                ],\r\n                'src': 'assets/img/pictures/3.jpg',\r\n                'date': '2 mins',\r\n                'like': true\r\n            },\r\n            {\r\n                'name': 'Forest',\r\n                'groups': [\r\n                    'nature'\r\n                ],\r\n                'src': 'assets/img/pictures/4.jpg',\r\n                'date': '2 mins',\r\n                'like': true\r\n            },\r\n            {\r\n                'name': 'Smile',\r\n                'groups': [\r\n                    'people'\r\n                ],\r\n                'src': 'assets/img/pictures/5.jpg',\r\n                'date': '2 mins'\r\n            },\r\n            {\r\n                'name': 'Smile',\r\n                'groups': [\r\n                    'people'\r\n                ],\r\n                'src': 'assets/img/pictures/6.jpg',\r\n                'date': '1 hour',\r\n                'like': true\r\n            },\r\n            {\r\n                'name': 'Fog',\r\n                'groups': [\r\n                    'nature'\r\n                ],\r\n                'src': 'assets/img/pictures/8.jpg',\r\n                'date': '2 mins',\r\n                'like': true\r\n            },\r\n            {\r\n                'name': 'Beach',\r\n                'groups': [\r\n                    'people'\r\n                ],\r\n                'src': 'assets/img/pictures/9.jpg',\r\n                'date': '2 mins'\r\n            },\r\n            {\r\n                'name': 'Pause',\r\n                'groups': [\r\n                    'people'\r\n                ],\r\n                'src': 'assets/img/pictures/10.jpg',\r\n                'date': '3 hour',\r\n                'like': true\r\n            },\r\n            {\r\n                'name': 'Space',\r\n                'groups': [\r\n                    'space'\r\n                ],\r\n                'src': 'assets/img/pictures/11.jpg',\r\n                'date': '3 hour',\r\n                'like': true\r\n            },\r\n            {\r\n                'name': 'Shuttle',\r\n                'groups': [\r\n                    'space'\r\n                ],\r\n                'src': 'assets/img/pictures/13.jpg',\r\n                'date': '35 mins',\r\n                'like': true\r\n            },\r\n            {\r\n                'name': 'Sky',\r\n                'groups': [\r\n                    'space'\r\n                ],\r\n                'src': 'assets/img/pictures/14.jpg',\r\n                'date': '2 mins'\r\n            }\r\n        ];\r\n        this.activeGroup = 'all';\r\n        this.order = false;\r\n        this.shuffleOptions = {\r\n            itemSelector: '.gallery-item',\r\n            sizer: '.js-shuffle-sizer',\r\n            delimeter: ','\r\n        };\r\n    }\r\n    Gallery.prototype.activeGroupSelected = function (group) {\r\n        this.shuffle.filter(group);\r\n        this.activeGroup = group;\r\n    };\r\n    Gallery.prototype.orderSelected = function (order) {\r\n        function sortByTitle(element) {\r\n            return element.getAttribute('data-title').toLowerCase();\r\n        }\r\n        this.shuffle.sort({\r\n            reverse: order,\r\n            by: sortByTitle\r\n        });\r\n        this.order = order;\r\n    };\r\n    Gallery.prototype.ngOnInit = function () {\r\n        var _this = this;\r\n        this.$gallery = jQuery('#magnific');\r\n        this.$gallery.magnificPopup(this.magnificOptions);\r\n        setTimeout(function () {\r\n            _this.shuffle = new Shuffle(_this.$gallery, _this.shuffleOptions);\r\n            setTimeout(function () {\r\n                _this.activeGroupSelected('all');\r\n            });\r\n        });\r\n    };\r\n    Gallery = __decorate([\r\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Component\"])({\r\n            selector: '[extra-gallery]',\r\n            template: __webpack_require__(/*! ./gallery.template.html */ 1146),\r\n            encapsulation: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ViewEncapsulation\"].None,\r\n            styles: [__webpack_require__(/*! ./gallery.style.scss */ 1123)]\r\n        }), \r\n        __metadata('design:paramtypes', [])\r\n    ], Gallery);\r\n    return Gallery;\r\n}());\r\n\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(/*! jquery */ 41), __webpack_require__(/*! shufflejs */ 980)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAwOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvZXh0cmEvZ2FsbGVyeS9nYWxsZXJ5LmNvbXBvbmVudC50cz82Yjc5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgVmlld0VuY2Fwc3VsYXRpb24gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbmRlY2xhcmUgdmFyIGpRdWVyeTogYW55O1xyXG5kZWNsYXJlIHZhciBTaHVmZmxlOiBhbnk7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ1tleHRyYS1nYWxsZXJ5XScsXHJcbiAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vZ2FsbGVyeS50ZW1wbGF0ZS5odG1sJyksXHJcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcclxuICBzdHlsZXM6IFtyZXF1aXJlKCcuL2dhbGxlcnkuc3R5bGUuc2NzcycpXVxyXG59KVxyXG5leHBvcnQgY2xhc3MgR2FsbGVyeSB7XHJcbiAgbWFnbmlmaWNPcHRpb25zOiBhbnkgPSB7XHJcbiAgICBkZWxlZ2F0ZTogJy5pbWctdGh1bWJuYWlsID4gYScsXHJcbiAgICB0eXBlOiAnaW1hZ2UnLFxyXG4gICAgZ2FsbGVyeTogeyBlbmFibGVkOiB0cnVlICB9XHJcbiAgfTtcclxuICBpdGVtczogQXJyYXk8YW55PiA9IFtcclxuICB7XHJcbiAgICAnbmFtZSc6ICdNb3VudGFpbnMnLFxyXG4gICAgJ2dyb3Vwcyc6IFtcclxuICAgICAgJ25hdHVyZSdcclxuICAgIF0sXHJcbiAgICAnc3JjJzogJ2Fzc2V0cy9pbWcvcGljdHVyZXMvMS5qcGcnLFxyXG4gICAgJ2RhdGUnOiAnMTAgbWlucydcclxuICB9LFxyXG4gIHtcclxuICAgICduYW1lJzogJ0VtcGlyZSBTdGF0ZSBQaWdlb24nLFxyXG4gICAgJ2dyb3Vwcyc6IFtcclxuICAgICAgJ3Blb3BsZSdcclxuICAgIF0sXHJcbiAgICAnc3JjJzogJ2Fzc2V0cy9pbWcvcGljdHVyZXMvMi5qcGcnLFxyXG4gICAgJ2RhdGUnOiAnMSBob3VyJyxcclxuICAgICdsaWtlJzogdHJ1ZVxyXG4gIH0sXHJcbiAge1xyXG4gICAgJ25hbWUnOiAnQmlnIExha2UnLFxyXG4gICAgJ2dyb3Vwcyc6IFtcclxuICAgICAgJ25hdHVyZSdcclxuICAgIF0sXHJcbiAgICAnc3JjJzogJ2Fzc2V0cy9pbWcvcGljdHVyZXMvMy5qcGcnLFxyXG4gICAgJ2RhdGUnOiAnMiBtaW5zJyxcclxuICAgICdsaWtlJzogdHJ1ZVxyXG4gIH0sXHJcbiAge1xyXG4gICAgJ25hbWUnOiAnRm9yZXN0JyxcclxuICAgICdncm91cHMnOiBbXHJcbiAgICAgICduYXR1cmUnXHJcbiAgICBdLFxyXG4gICAgJ3NyYyc6ICdhc3NldHMvaW1nL3BpY3R1cmVzLzQuanBnJyxcclxuICAgICdkYXRlJzogJzIgbWlucycsXHJcbiAgICAnbGlrZSc6IHRydWVcclxuICB9LFxyXG4gIHtcclxuICAgICduYW1lJzogJ1NtaWxlJyxcclxuICAgICdncm91cHMnOiBbXHJcbiAgICAgICdwZW9wbGUnXHJcbiAgICBdLFxyXG4gICAgJ3NyYyc6ICdhc3NldHMvaW1nL3BpY3R1cmVzLzUuanBnJyxcclxuICAgICdkYXRlJzogJzIgbWlucydcclxuICB9LFxyXG4gIHtcclxuICAgICduYW1lJzogJ1NtaWxlJyxcclxuICAgICdncm91cHMnOiBbXHJcbiAgICAgICdwZW9wbGUnXHJcbiAgICBdLFxyXG4gICAgJ3NyYyc6ICdhc3NldHMvaW1nL3BpY3R1cmVzLzYuanBnJyxcclxuICAgICdkYXRlJzogJzEgaG91cicsXHJcbiAgICAnbGlrZSc6IHRydWVcclxuICB9LFxyXG4gIHtcclxuICAgICduYW1lJzogJ0ZvZycsXHJcbiAgICAnZ3JvdXBzJzogW1xyXG4gICAgICAnbmF0dXJlJ1xyXG4gICAgXSxcclxuICAgICdzcmMnOiAnYXNzZXRzL2ltZy9waWN0dXJlcy84LmpwZycsXHJcbiAgICAnZGF0ZSc6ICcyIG1pbnMnLFxyXG4gICAgJ2xpa2UnOiB0cnVlXHJcbiAgfSxcclxuICB7XHJcbiAgICAnbmFtZSc6ICdCZWFjaCcsXHJcbiAgICAnZ3JvdXBzJzogW1xyXG4gICAgICAncGVvcGxlJ1xyXG4gICAgXSxcclxuICAgICdzcmMnOiAnYXNzZXRzL2ltZy9waWN0dXJlcy85LmpwZycsXHJcbiAgICAnZGF0ZSc6ICcyIG1pbnMnXHJcbiAgfSxcclxuICB7XHJcbiAgICAnbmFtZSc6ICdQYXVzZScsXHJcbiAgICAnZ3JvdXBzJzogW1xyXG4gICAgICAncGVvcGxlJ1xyXG4gICAgXSxcclxuICAgICdzcmMnOiAnYXNzZXRzL2ltZy9waWN0dXJlcy8xMC5qcGcnLFxyXG4gICAgJ2RhdGUnOiAnMyBob3VyJyxcclxuICAgICdsaWtlJzogdHJ1ZVxyXG4gIH0sXHJcbiAge1xyXG4gICAgJ25hbWUnOiAnU3BhY2UnLFxyXG4gICAgJ2dyb3Vwcyc6IFtcclxuICAgICAgJ3NwYWNlJ1xyXG4gICAgXSxcclxuICAgICdzcmMnOiAnYXNzZXRzL2ltZy9waWN0dXJlcy8xMS5qcGcnLFxyXG4gICAgJ2RhdGUnOiAnMyBob3VyJyxcclxuICAgICdsaWtlJzogdHJ1ZVxyXG4gIH0sXHJcbiAge1xyXG4gICAgJ25hbWUnOiAnU2h1dHRsZScsXHJcbiAgICAnZ3JvdXBzJzogW1xyXG4gICAgICAnc3BhY2UnXHJcbiAgICBdLFxyXG4gICAgJ3NyYyc6ICdhc3NldHMvaW1nL3BpY3R1cmVzLzEzLmpwZycsXHJcbiAgICAnZGF0ZSc6ICczNSBtaW5zJyxcclxuICAgICdsaWtlJzogdHJ1ZVxyXG4gIH0sXHJcbiAge1xyXG4gICAgJ25hbWUnOiAnU2t5JyxcclxuICAgICdncm91cHMnOiBbXHJcbiAgICAgICdzcGFjZSdcclxuICAgIF0sXHJcbiAgICAnc3JjJzogJ2Fzc2V0cy9pbWcvcGljdHVyZXMvMTQuanBnJyxcclxuICAgICdkYXRlJzogJzIgbWlucydcclxuICB9XHJcbl07XHJcbiAgYWN0aXZlR3JvdXA6IHN0cmluZyA9ICdhbGwnO1xyXG4gIG9yZGVyOiBib29sZWFuID0gZmFsc2U7XHJcbiAgJGdhbGxlcnk6IGFueTtcclxuICBzaHVmZmxlOiBhbnk7XHJcbiAgc2h1ZmZsZU9wdGlvbnM6IE9iamVjdCA9IHtcclxuICAgIGl0ZW1TZWxlY3RvcjogJy5nYWxsZXJ5LWl0ZW0nLFxyXG4gICAgc2l6ZXI6ICcuanMtc2h1ZmZsZS1zaXplcicsXHJcbiAgICBkZWxpbWV0ZXI6ICcsJ1xyXG4gIH07XHJcblxyXG4gIGFjdGl2ZUdyb3VwU2VsZWN0ZWQoZ3JvdXApOiB2b2lkIHtcclxuICAgIHRoaXMuc2h1ZmZsZS5maWx0ZXIoZ3JvdXApO1xyXG4gICAgdGhpcy5hY3RpdmVHcm91cCA9IGdyb3VwO1xyXG4gIH1cclxuXHJcbiAgb3JkZXJTZWxlY3RlZChvcmRlcik6IHZvaWQge1xyXG4gICAgZnVuY3Rpb24gc29ydEJ5VGl0bGUoZWxlbWVudCk6IHN0cmluZyB7XHJcbiAgICAgIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS10aXRsZScpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zaHVmZmxlLnNvcnQoe1xyXG4gICAgICByZXZlcnNlOiBvcmRlcixcclxuICAgICAgYnk6IHNvcnRCeVRpdGxlXHJcbiAgICB9KTtcclxuICAgIHRoaXMub3JkZXIgPSBvcmRlcjtcclxuICB9XHJcblxyXG4gIG5nT25Jbml0KCk6IHZvaWQge1xyXG4gICAgdGhpcy4kZ2FsbGVyeSA9IGpRdWVyeSgnI21hZ25pZmljJyk7XHJcbiAgICB0aGlzLiRnYWxsZXJ5Lm1hZ25pZmljUG9wdXAodGhpcy5tYWduaWZpY09wdGlvbnMpO1xyXG5cclxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICB0aGlzLnNodWZmbGUgPSBuZXcgU2h1ZmZsZSh0aGlzLiRnYWxsZXJ5LCB0aGlzLnNodWZmbGVPcHRpb25zKTtcclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVHcm91cFNlbGVjdGVkKCdhbGwnKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBub2RlX21vZHVsZXMvYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vfi9hbmd1bGFyLXJvdXRlci1sb2FkZXIvc3JjP2xvYWRlcj1zeXN0ZW0mZ2VuRGlyPWNvbXBpbGVkL2FwcCZhb3Q9ZmFsc2UhLi9zcmMvYXBwL2V4dHJhL2dhbGxlcnkvZ2FsbGVyeS5jb21wb25lbnQudHMiXSwibWFwcGluZ3MiOiJBQUFBO0FBV0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBOEJBO0FBNUJBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBM0pBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUFBO0FBdUpBO0FBQUE7Ozs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 1009:
/* exports provided: Invoice */
/* exports used: Invoice */
/*!****************************************************!*\
  !*** ./src/app/extra/invoice/invoice.component.ts ***!
  \****************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(/*! @angular/core */ 0);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Invoice; });\n\r\nvar Invoice = (function () {\r\n    function Invoice() {\r\n    }\r\n    Invoice.prototype.print = function () {\r\n        window.print();\r\n    };\r\n    ;\r\n    Invoice = __decorate([\r\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Component\"])({\r\n            selector: '[extra-invoice]',\r\n            template: __webpack_require__(/*! ./invoice.template.html */ 1147),\r\n            encapsulation: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ViewEncapsulation\"].None,\r\n            styles: [__webpack_require__(/*! ./invoice.style.scss */ 1124)]\r\n        }), \r\n        __metadata('design:paramtypes', [])\r\n    ], Invoice);\r\n    return Invoice;\r\n}());\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAwOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvZXh0cmEvaW52b2ljZS9pbnZvaWNlLmNvbXBvbmVudC50cz82ZDNmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgVmlld0VuY2Fwc3VsYXRpb24gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gIHNlbGVjdG9yOiAnW2V4dHJhLWludm9pY2VdJyxcclxuICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9pbnZvaWNlLnRlbXBsYXRlLmh0bWwnKSxcclxuICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxyXG4gIHN0eWxlczogW3JlcXVpcmUoJy4vaW52b2ljZS5zdHlsZS5zY3NzJyldXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBJbnZvaWNlIHtcclxuICBwcmludCgpOiB2b2lkIHtcclxuICAgIHdpbmRvdy5wcmludCgpO1xyXG4gIH07XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9+L2FuZ3VsYXItcm91dGVyLWxvYWRlci9zcmM/bG9hZGVyPXN5c3RlbSZnZW5EaXI9Y29tcGlsZWQvYXBwJmFvdD1mYWxzZSEuL3NyYy9hcHAvZXh0cmEvaW52b2ljZS9pbnZvaWNlLmNvbXBvbmVudC50cyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFRQTtBQUFBO0FBSUE7QUFIQTtBQUNBO0FBQ0E7O0FBVEE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQUE7QUFLQTtBQUFBOzs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 1010:
/* exports provided: SearchResults */
/* exports used: SearchResults */
/*!******************************************************************!*\
  !*** ./src/app/extra/search-results/search-results.component.ts ***!
  \******************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(/*! @angular/core */ 0);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return SearchResults; });\n\r\nvar SearchResults = (function () {\r\n    function SearchResults() {\r\n    }\r\n    SearchResults = __decorate([\r\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Component\"])({\r\n            selector: '[extra-search-results]',\r\n            template: __webpack_require__(/*! ./search-results.template.html */ 1148),\r\n            encapsulation: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ViewEncapsulation\"].None,\r\n            styles: [__webpack_require__(/*! ./search-results.style.scss */ 1125)]\r\n        }), \r\n        __metadata('design:paramtypes', [])\r\n    ], SearchResults);\r\n    return SearchResults;\r\n}());\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAxMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvZXh0cmEvc2VhcmNoLXJlc3VsdHMvc2VhcmNoLXJlc3VsdHMuY29tcG9uZW50LnRzPzZlZTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBWaWV3RW5jYXBzdWxhdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICdbZXh0cmEtc2VhcmNoLXJlc3VsdHNdJyxcclxuICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9zZWFyY2gtcmVzdWx0cy50ZW1wbGF0ZS5odG1sJyksXHJcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcclxuICBzdHlsZXM6IFtyZXF1aXJlKCcuL3NlYXJjaC1yZXN1bHRzLnN0eWxlLnNjc3MnKV1cclxufSlcclxuZXhwb3J0IGNsYXNzIFNlYXJjaFJlc3VsdHMge1xyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBub2RlX21vZHVsZXMvYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vfi9hbmd1bGFyLXJvdXRlci1sb2FkZXIvc3JjP2xvYWRlcj1zeXN0ZW0mZ2VuRGlyPWNvbXBpbGVkL2FwcCZhb3Q9ZmFsc2UhLi9zcmMvYXBwL2V4dHJhL3NlYXJjaC1yZXN1bHRzL3NlYXJjaC1yZXN1bHRzLmNvbXBvbmVudC50cyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFRQTtBQUFBO0FBQ0E7QUFQQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFBQTtBQUVBO0FBQUE7OzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 1011:
/* exports provided: TimeLine */
/* exports used: TimeLine */
/*!********************************************************!*\
  !*** ./src/app/extra/time-line/time-line.component.ts ***!
  \********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(/*! @angular/core */ 0);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return TimeLine; });\n\r\nvar TimeLine = (function () {\r\n    function TimeLine() {\r\n    }\r\n    TimeLine = __decorate([\r\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Component\"])({\r\n            selector: '[extra-time-line]',\r\n            template: __webpack_require__(/*! ./time-line.template.html */ 1149),\r\n            encapsulation: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"ViewEncapsulation\"].None,\r\n            styles: [__webpack_require__(/*! ./time-line.style.scss */ 1126)]\r\n        }), \r\n        __metadata('design:paramtypes', [])\r\n    ], TimeLine);\r\n    return TimeLine;\r\n}());\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAxMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvZXh0cmEvdGltZS1saW5lL3RpbWUtbGluZS5jb21wb25lbnQudHM/MGZmMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIFZpZXdFbmNhcHN1bGF0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ1tleHRyYS10aW1lLWxpbmVdJyxcclxuICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi90aW1lLWxpbmUudGVtcGxhdGUuaHRtbCcpLFxyXG4gIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXHJcbiAgc3R5bGVzOiBbcmVxdWlyZSgnLi90aW1lLWxpbmUuc3R5bGUuc2NzcycpXVxyXG59KVxyXG5leHBvcnQgY2xhc3MgVGltZUxpbmUge1xyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBub2RlX21vZHVsZXMvYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vfi9hbmd1bGFyLXJvdXRlci1sb2FkZXIvc3JjP2xvYWRlcj1zeXN0ZW0mZ2VuRGlyPWNvbXBpbGVkL2FwcCZhb3Q9ZmFsc2UhLi9zcmMvYXBwL2V4dHJhL3RpbWUtbGluZS90aW1lLWxpbmUuY29tcG9uZW50LnRzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQVFBO0FBQUE7QUFDQTtBQVBBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUFBO0FBRUE7QUFBQTs7OyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 1073:
/* unknown exports provided */
/*!*********************************************!*\
  !*** ./~/fullcalendar/dist/fullcalendar.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * FullCalendar v3.0.1\n * Docs & License: http://fullcalendar.io/\n * (c) 2016 Adam Shaw\n */\n\n(function(factory) {\n\tif (true) {\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(/*! jquery */ 41), __webpack_require__(/*! moment */ 702) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t}\n\telse if (typeof exports === 'object') { // Node/CommonJS\n\t\tmodule.exports = factory(require('jquery'), require('moment'));\n\t}\n\telse {\n\t\tfactory(jQuery, moment);\n\t}\n})(function($, moment) {\n\n;;\n\nvar FC = $.fullCalendar = {\n\tversion: \"3.0.1\",\n\tinternalApiVersion: 6\n};\nvar fcViews = FC.views = {};\n\n\n$.fn.fullCalendar = function(options) {\n\tvar args = Array.prototype.slice.call(arguments, 1); // for a possible method call\n\tvar res = this; // what this function will return (this jQuery object by default)\n\n\tthis.each(function(i, _element) { // loop each DOM element involved\n\t\tvar element = $(_element);\n\t\tvar calendar = element.data('fullCalendar'); // get the existing calendar object (if any)\n\t\tvar singleRes; // the returned value of this single method call\n\n\t\t// a method call\n\t\tif (typeof options === 'string') {\n\t\t\tif (calendar && $.isFunction(calendar[options])) {\n\t\t\t\tsingleRes = calendar[options].apply(calendar, args);\n\t\t\t\tif (!i) {\n\t\t\t\t\tres = singleRes; // record the first method call result\n\t\t\t\t}\n\t\t\t\tif (options === 'destroy') { // for the destroy method, must remove Calendar object data\n\t\t\t\t\telement.removeData('fullCalendar');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// a new calendar initialization\n\t\telse if (!calendar) { // don't initialize twice\n\t\t\tcalendar = new Calendar(element, options);\n\t\t\telement.data('fullCalendar', calendar);\n\t\t\tcalendar.render();\n\t\t}\n\t});\n\t\n\treturn res;\n};\n\n\nvar complexOptions = [ // names of options that are objects whose properties should be combined\n\t'header',\n\t'buttonText',\n\t'buttonIcons',\n\t'themeButtonIcons'\n];\n\n\n// Merges an array of option objects into a single object\nfunction mergeOptions(optionObjs) {\n\treturn mergeProps(optionObjs, complexOptions);\n}\n\n;;\n\n// exports\nFC.intersectRanges = intersectRanges;\nFC.applyAll = applyAll;\nFC.debounce = debounce;\nFC.isInt = isInt;\nFC.htmlEscape = htmlEscape;\nFC.cssToStr = cssToStr;\nFC.proxy = proxy;\nFC.capitaliseFirstLetter = capitaliseFirstLetter;\n\n\n/* FullCalendar-specific DOM Utilities\n----------------------------------------------------------------------------------------------------------------------*/\n\n\n// Given the scrollbar widths of some other container, create borders/margins on rowEls in order to match the left\n// and right space that was offset by the scrollbars. A 1-pixel border first, then margin beyond that.\nfunction compensateScroll(rowEls, scrollbarWidths) {\n\tif (scrollbarWidths.left) {\n\t\trowEls.css({\n\t\t\t'border-left-width': 1,\n\t\t\t'margin-left': scrollbarWidths.left - 1\n\t\t});\n\t}\n\tif (scrollbarWidths.right) {\n\t\trowEls.css({\n\t\t\t'border-right-width': 1,\n\t\t\t'margin-right': scrollbarWidths.right - 1\n\t\t});\n\t}\n}\n\n\n// Undoes compensateScroll and restores all borders/margins\nfunction uncompensateScroll(rowEls) {\n\trowEls.css({\n\t\t'margin-left': '',\n\t\t'margin-right': '',\n\t\t'border-left-width': '',\n\t\t'border-right-width': ''\n\t});\n}\n\n\n// Make the mouse cursor express that an event is not allowed in the current area\nfunction disableCursor() {\n\t$('body').addClass('fc-not-allowed');\n}\n\n\n// Returns the mouse cursor to its original look\nfunction enableCursor() {\n\t$('body').removeClass('fc-not-allowed');\n}\n\n\n// Given a total available height to fill, have `els` (essentially child rows) expand to accomodate.\n// By default, all elements that are shorter than the recommended height are expanded uniformly, not considering\n// any other els that are already too tall. if `shouldRedistribute` is on, it considers these tall rows and \n// reduces the available height.\nfunction distributeHeight(els, availableHeight, shouldRedistribute) {\n\n\t// *FLOORING NOTE*: we floor in certain places because zoom can give inaccurate floating-point dimensions,\n\t// and it is better to be shorter than taller, to avoid creating unnecessary scrollbars.\n\n\tvar minOffset1 = Math.floor(availableHeight / els.length); // for non-last element\n\tvar minOffset2 = Math.floor(availableHeight - minOffset1 * (els.length - 1)); // for last element *FLOORING NOTE*\n\tvar flexEls = []; // elements that are allowed to expand. array of DOM nodes\n\tvar flexOffsets = []; // amount of vertical space it takes up\n\tvar flexHeights = []; // actual css height\n\tvar usedHeight = 0;\n\n\tundistributeHeight(els); // give all elements their natural height\n\n\t// find elements that are below the recommended height (expandable).\n\t// important to query for heights in a single first pass (to avoid reflow oscillation).\n\tels.each(function(i, el) {\n\t\tvar minOffset = i === els.length - 1 ? minOffset2 : minOffset1;\n\t\tvar naturalOffset = $(el).outerHeight(true);\n\n\t\tif (naturalOffset < minOffset) {\n\t\t\tflexEls.push(el);\n\t\t\tflexOffsets.push(naturalOffset);\n\t\t\tflexHeights.push($(el).height());\n\t\t}\n\t\telse {\n\t\t\t// this element stretches past recommended height (non-expandable). mark the space as occupied.\n\t\t\tusedHeight += naturalOffset;\n\t\t}\n\t});\n\n\t// readjust the recommended height to only consider the height available to non-maxed-out rows.\n\tif (shouldRedistribute) {\n\t\tavailableHeight -= usedHeight;\n\t\tminOffset1 = Math.floor(availableHeight / flexEls.length);\n\t\tminOffset2 = Math.floor(availableHeight - minOffset1 * (flexEls.length - 1)); // *FLOORING NOTE*\n\t}\n\n\t// assign heights to all expandable elements\n\t$(flexEls).each(function(i, el) {\n\t\tvar minOffset = i === flexEls.length - 1 ? minOffset2 : minOffset1;\n\t\tvar naturalOffset = flexOffsets[i];\n\t\tvar naturalHeight = flexHeights[i];\n\t\tvar newHeight = minOffset - (naturalOffset - naturalHeight); // subtract the margin/padding\n\n\t\tif (naturalOffset < minOffset) { // we check this again because redistribution might have changed things\n\t\t\t$(el).height(newHeight);\n\t\t}\n\t});\n}\n\n\n// Undoes distrubuteHeight, restoring all els to their natural height\nfunction undistributeHeight(els) {\n\tels.height('');\n}\n\n\n// Given `els`, a jQuery set of <td> cells, find the cell with the largest natural width and set the widths of all the\n// cells to be that width.\n// PREREQUISITE: if you want a cell to take up width, it needs to have a single inner element w/ display:inline\nfunction matchCellWidths(els) {\n\tvar maxInnerWidth = 0;\n\n\tels.find('> *').each(function(i, innerEl) {\n\t\tvar innerWidth = $(innerEl).outerWidth();\n\t\tif (innerWidth > maxInnerWidth) {\n\t\t\tmaxInnerWidth = innerWidth;\n\t\t}\n\t});\n\n\tmaxInnerWidth++; // sometimes not accurate of width the text needs to stay on one line. insurance\n\n\tels.width(maxInnerWidth);\n\n\treturn maxInnerWidth;\n}\n\n\n// Given one element that resides inside another,\n// Subtracts the height of the inner element from the outer element.\nfunction subtractInnerElHeight(outerEl, innerEl) {\n\tvar both = outerEl.add(innerEl);\n\tvar diff;\n\n\t// effin' IE8/9/10/11 sometimes returns 0 for dimensions. this weird hack was the only thing that worked\n\tboth.css({\n\t\tposition: 'relative', // cause a reflow, which will force fresh dimension recalculation\n\t\tleft: -1 // ensure reflow in case the el was already relative. negative is less likely to cause new scroll\n\t});\n\tdiff = outerEl.outerHeight() - innerEl.outerHeight(); // grab the dimensions\n\tboth.css({ position: '', left: '' }); // undo hack\n\n\treturn diff;\n}\n\n\n/* Element Geom Utilities\n----------------------------------------------------------------------------------------------------------------------*/\n\nFC.getOuterRect = getOuterRect;\nFC.getClientRect = getClientRect;\nFC.getContentRect = getContentRect;\nFC.getScrollbarWidths = getScrollbarWidths;\n\n\n// borrowed from https://github.com/jquery/jquery-ui/blob/1.11.0/ui/core.js#L51\nfunction getScrollParent(el) {\n\tvar position = el.css('position'),\n\t\tscrollParent = el.parents().filter(function() {\n\t\t\tvar parent = $(this);\n\t\t\treturn (/(auto|scroll)/).test(\n\t\t\t\tparent.css('overflow') + parent.css('overflow-y') + parent.css('overflow-x')\n\t\t\t);\n\t\t}).eq(0);\n\n\treturn position === 'fixed' || !scrollParent.length ? $(el[0].ownerDocument || document) : scrollParent;\n}\n\n\n// Queries the outer bounding area of a jQuery element.\n// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).\n// Origin is optional.\nfunction getOuterRect(el, origin) {\n\tvar offset = el.offset();\n\tvar left = offset.left - (origin ? origin.left : 0);\n\tvar top = offset.top - (origin ? origin.top : 0);\n\n\treturn {\n\t\tleft: left,\n\t\tright: left + el.outerWidth(),\n\t\ttop: top,\n\t\tbottom: top + el.outerHeight()\n\t};\n}\n\n\n// Queries the area within the margin/border/scrollbars of a jQuery element. Does not go within the padding.\n// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).\n// Origin is optional.\n// NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.\nfunction getClientRect(el, origin) {\n\tvar offset = el.offset();\n\tvar scrollbarWidths = getScrollbarWidths(el);\n\tvar left = offset.left + getCssFloat(el, 'border-left-width') + scrollbarWidths.left - (origin ? origin.left : 0);\n\tvar top = offset.top + getCssFloat(el, 'border-top-width') + scrollbarWidths.top - (origin ? origin.top : 0);\n\n\treturn {\n\t\tleft: left,\n\t\tright: left + el[0].clientWidth, // clientWidth includes padding but NOT scrollbars\n\t\ttop: top,\n\t\tbottom: top + el[0].clientHeight // clientHeight includes padding but NOT scrollbars\n\t};\n}\n\n\n// Queries the area within the margin/border/padding of a jQuery element. Assumed not to have scrollbars.\n// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).\n// Origin is optional.\nfunction getContentRect(el, origin) {\n\tvar offset = el.offset(); // just outside of border, margin not included\n\tvar left = offset.left + getCssFloat(el, 'border-left-width') + getCssFloat(el, 'padding-left') -\n\t\t(origin ? origin.left : 0);\n\tvar top = offset.top + getCssFloat(el, 'border-top-width') + getCssFloat(el, 'padding-top') -\n\t\t(origin ? origin.top : 0);\n\n\treturn {\n\t\tleft: left,\n\t\tright: left + el.width(),\n\t\ttop: top,\n\t\tbottom: top + el.height()\n\t};\n}\n\n\n// Returns the computed left/right/top/bottom scrollbar widths for the given jQuery element.\n// NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.\nfunction getScrollbarWidths(el) {\n\tvar leftRightWidth = el.innerWidth() - el[0].clientWidth; // the paddings cancel out, leaving the scrollbars\n\tvar widths = {\n\t\tleft: 0,\n\t\tright: 0,\n\t\ttop: 0,\n\t\tbottom: el.innerHeight() - el[0].clientHeight // the paddings cancel out, leaving the bottom scrollbar\n\t};\n\n\tif (getIsLeftRtlScrollbars() && el.css('direction') == 'rtl') { // is the scrollbar on the left side?\n\t\twidths.left = leftRightWidth;\n\t}\n\telse {\n\t\twidths.right = leftRightWidth;\n\t}\n\n\treturn widths;\n}\n\n\n// Logic for determining if, when the element is right-to-left, the scrollbar appears on the left side\n\nvar _isLeftRtlScrollbars = null;\n\nfunction getIsLeftRtlScrollbars() { // responsible for caching the computation\n\tif (_isLeftRtlScrollbars === null) {\n\t\t_isLeftRtlScrollbars = computeIsLeftRtlScrollbars();\n\t}\n\treturn _isLeftRtlScrollbars;\n}\n\nfunction computeIsLeftRtlScrollbars() { // creates an offscreen test element, then removes it\n\tvar el = $('<div><div/></div>')\n\t\t.css({\n\t\t\tposition: 'absolute',\n\t\t\ttop: -1000,\n\t\t\tleft: 0,\n\t\t\tborder: 0,\n\t\t\tpadding: 0,\n\t\t\toverflow: 'scroll',\n\t\t\tdirection: 'rtl'\n\t\t})\n\t\t.appendTo('body');\n\tvar innerEl = el.children();\n\tvar res = innerEl.offset().left > el.offset().left; // is the inner div shifted to accommodate a left scrollbar?\n\tel.remove();\n\treturn res;\n}\n\n\n// Retrieves a jQuery element's computed CSS value as a floating-point number.\n// If the queried value is non-numeric (ex: IE can return \"medium\" for border width), will just return zero.\nfunction getCssFloat(el, prop) {\n\treturn parseFloat(el.css(prop)) || 0;\n}\n\n\n/* Mouse / Touch Utilities\n----------------------------------------------------------------------------------------------------------------------*/\n\nFC.preventDefault = preventDefault;\n\n\n// Returns a boolean whether this was a left mouse click and no ctrl key (which means right click on Mac)\nfunction isPrimaryMouseButton(ev) {\n\treturn ev.which == 1 && !ev.ctrlKey;\n}\n\n\nfunction getEvX(ev) {\n\tif (ev.pageX !== undefined) {\n\t\treturn ev.pageX;\n\t}\n\tvar touches = ev.originalEvent.touches;\n\tif (touches) {\n\t\treturn touches[0].pageX;\n\t}\n}\n\n\nfunction getEvY(ev) {\n\tif (ev.pageY !== undefined) {\n\t\treturn ev.pageY;\n\t}\n\tvar touches = ev.originalEvent.touches;\n\tif (touches) {\n\t\treturn touches[0].pageY;\n\t}\n}\n\n\nfunction getEvIsTouch(ev) {\n\treturn /^touch/.test(ev.type);\n}\n\n\nfunction preventSelection(el) {\n\tel.addClass('fc-unselectable')\n\t\t.on('selectstart', preventDefault);\n}\n\n\n// Stops a mouse/touch event from doing it's native browser action\nfunction preventDefault(ev) {\n\tev.preventDefault();\n}\n\n\n// attach a handler to get called when ANY scroll action happens on the page.\n// this was impossible to do with normal on/off because 'scroll' doesn't bubble.\n// http://stackoverflow.com/a/32954565/96342\n// returns `true` on success.\nfunction bindAnyScroll(handler) {\n\tif (window.addEventListener) {\n\t\twindow.addEventListener('scroll', handler, true); // useCapture=true\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\n// undoes bindAnyScroll. must pass in the original function.\n// returns `true` on success.\nfunction unbindAnyScroll(handler) {\n\tif (window.removeEventListener) {\n\t\twindow.removeEventListener('scroll', handler, true); // useCapture=true\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\n/* General Geometry Utils\n----------------------------------------------------------------------------------------------------------------------*/\n\nFC.intersectRects = intersectRects;\n\n// Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false\nfunction intersectRects(rect1, rect2) {\n\tvar res = {\n\t\tleft: Math.max(rect1.left, rect2.left),\n\t\tright: Math.min(rect1.right, rect2.right),\n\t\ttop: Math.max(rect1.top, rect2.top),\n\t\tbottom: Math.min(rect1.bottom, rect2.bottom)\n\t};\n\n\tif (res.left < res.right && res.top < res.bottom) {\n\t\treturn res;\n\t}\n\treturn false;\n}\n\n\n// Returns a new point that will have been moved to reside within the given rectangle\nfunction constrainPoint(point, rect) {\n\treturn {\n\t\tleft: Math.min(Math.max(point.left, rect.left), rect.right),\n\t\ttop: Math.min(Math.max(point.top, rect.top), rect.bottom)\n\t};\n}\n\n\n// Returns a point that is the center of the given rectangle\nfunction getRectCenter(rect) {\n\treturn {\n\t\tleft: (rect.left + rect.right) / 2,\n\t\ttop: (rect.top + rect.bottom) / 2\n\t};\n}\n\n\n// Subtracts point2's coordinates from point1's coordinates, returning a delta\nfunction diffPoints(point1, point2) {\n\treturn {\n\t\tleft: point1.left - point2.left,\n\t\ttop: point1.top - point2.top\n\t};\n}\n\n\n/* Object Ordering by Field\n----------------------------------------------------------------------------------------------------------------------*/\n\nFC.parseFieldSpecs = parseFieldSpecs;\nFC.compareByFieldSpecs = compareByFieldSpecs;\nFC.compareByFieldSpec = compareByFieldSpec;\nFC.flexibleCompare = flexibleCompare;\n\n\nfunction parseFieldSpecs(input) {\n\tvar specs = [];\n\tvar tokens = [];\n\tvar i, token;\n\n\tif (typeof input === 'string') {\n\t\ttokens = input.split(/\\s*,\\s*/);\n\t}\n\telse if (typeof input === 'function') {\n\t\ttokens = [ input ];\n\t}\n\telse if ($.isArray(input)) {\n\t\ttokens = input;\n\t}\n\n\tfor (i = 0; i < tokens.length; i++) {\n\t\ttoken = tokens[i];\n\n\t\tif (typeof token === 'string') {\n\t\t\tspecs.push(\n\t\t\t\ttoken.charAt(0) == '-' ?\n\t\t\t\t\t{ field: token.substring(1), order: -1 } :\n\t\t\t\t\t{ field: token, order: 1 }\n\t\t\t);\n\t\t}\n\t\telse if (typeof token === 'function') {\n\t\t\tspecs.push({ func: token });\n\t\t}\n\t}\n\n\treturn specs;\n}\n\n\nfunction compareByFieldSpecs(obj1, obj2, fieldSpecs) {\n\tvar i;\n\tvar cmp;\n\n\tfor (i = 0; i < fieldSpecs.length; i++) {\n\t\tcmp = compareByFieldSpec(obj1, obj2, fieldSpecs[i]);\n\t\tif (cmp) {\n\t\t\treturn cmp;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\nfunction compareByFieldSpec(obj1, obj2, fieldSpec) {\n\tif (fieldSpec.func) {\n\t\treturn fieldSpec.func(obj1, obj2);\n\t}\n\treturn flexibleCompare(obj1[fieldSpec.field], obj2[fieldSpec.field]) *\n\t\t(fieldSpec.order || 1);\n}\n\n\nfunction flexibleCompare(a, b) {\n\tif (!a && !b) {\n\t\treturn 0;\n\t}\n\tif (b == null) {\n\t\treturn -1;\n\t}\n\tif (a == null) {\n\t\treturn 1;\n\t}\n\tif ($.type(a) === 'string' || $.type(b) === 'string') {\n\t\treturn String(a).localeCompare(String(b));\n\t}\n\treturn a - b;\n}\n\n\n/* FullCalendar-specific Misc Utilities\n----------------------------------------------------------------------------------------------------------------------*/\n\n\n// Computes the intersection of the two ranges. Will return fresh date clones in a range.\n// Returns undefined if no intersection.\n// Expects all dates to be normalized to the same timezone beforehand.\n// TODO: move to date section?\nfunction intersectRanges(subjectRange, constraintRange) {\n\tvar subjectStart = subjectRange.start;\n\tvar subjectEnd = subjectRange.end;\n\tvar constraintStart = constraintRange.start;\n\tvar constraintEnd = constraintRange.end;\n\tvar segStart, segEnd;\n\tvar isStart, isEnd;\n\n\tif (subjectEnd > constraintStart && subjectStart < constraintEnd) { // in bounds at all?\n\n\t\tif (subjectStart >= constraintStart) {\n\t\t\tsegStart = subjectStart.clone();\n\t\t\tisStart = true;\n\t\t}\n\t\telse {\n\t\t\tsegStart = constraintStart.clone();\n\t\t\tisStart =  false;\n\t\t}\n\n\t\tif (subjectEnd <= constraintEnd) {\n\t\t\tsegEnd = subjectEnd.clone();\n\t\t\tisEnd = true;\n\t\t}\n\t\telse {\n\t\t\tsegEnd = constraintEnd.clone();\n\t\t\tisEnd = false;\n\t\t}\n\n\t\treturn {\n\t\t\tstart: segStart,\n\t\t\tend: segEnd,\n\t\t\tisStart: isStart,\n\t\t\tisEnd: isEnd\n\t\t};\n\t}\n}\n\n\n/* Date Utilities\n----------------------------------------------------------------------------------------------------------------------*/\n\nFC.computeIntervalUnit = computeIntervalUnit;\nFC.divideRangeByDuration = divideRangeByDuration;\nFC.divideDurationByDuration = divideDurationByDuration;\nFC.multiplyDuration = multiplyDuration;\nFC.durationHasTime = durationHasTime;\n\nvar dayIDs = [ 'sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat' ];\nvar intervalUnits = [ 'year', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond' ];\n\n\n// Diffs the two moments into a Duration where full-days are recorded first, then the remaining time.\n// Moments will have their timezones normalized.\nfunction diffDayTime(a, b) {\n\treturn moment.duration({\n\t\tdays: a.clone().stripTime().diff(b.clone().stripTime(), 'days'),\n\t\tms: a.time() - b.time() // time-of-day from day start. disregards timezone\n\t});\n}\n\n\n// Diffs the two moments via their start-of-day (regardless of timezone). Produces whole-day durations.\nfunction diffDay(a, b) {\n\treturn moment.duration({\n\t\tdays: a.clone().stripTime().diff(b.clone().stripTime(), 'days')\n\t});\n}\n\n\n// Diffs two moments, producing a duration, made of a whole-unit-increment of the given unit. Uses rounding.\nfunction diffByUnit(a, b, unit) {\n\treturn moment.duration(\n\t\tMath.round(a.diff(b, unit, true)), // returnFloat=true\n\t\tunit\n\t);\n}\n\n\n// Computes the unit name of the largest whole-unit period of time.\n// For example, 48 hours will be \"days\" whereas 49 hours will be \"hours\".\n// Accepts start/end, a range object, or an original duration object.\nfunction computeIntervalUnit(start, end) {\n\tvar i, unit;\n\tvar val;\n\n\tfor (i = 0; i < intervalUnits.length; i++) {\n\t\tunit = intervalUnits[i];\n\t\tval = computeRangeAs(unit, start, end);\n\n\t\tif (val >= 1 && isInt(val)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn unit; // will be \"milliseconds\" if nothing else matches\n}\n\n\n// Computes the number of units (like \"hours\") in the given range.\n// Range can be a {start,end} object, separate start/end args, or a Duration.\n// Results are based on Moment's .as() and .diff() methods, so results can depend on internal handling\n// of month-diffing logic (which tends to vary from version to version).\nfunction computeRangeAs(unit, start, end) {\n\n\tif (end != null) { // given start, end\n\t\treturn end.diff(start, unit, true);\n\t}\n\telse if (moment.isDuration(start)) { // given duration\n\t\treturn start.as(unit);\n\t}\n\telse { // given { start, end } range object\n\t\treturn start.end.diff(start.start, unit, true);\n\t}\n}\n\n\n// Intelligently divides a range (specified by a start/end params) by a duration\nfunction divideRangeByDuration(start, end, dur) {\n\tvar months;\n\n\tif (durationHasTime(dur)) {\n\t\treturn (end - start) / dur;\n\t}\n\tmonths = dur.asMonths();\n\tif (Math.abs(months) >= 1 && isInt(months)) {\n\t\treturn end.diff(start, 'months', true) / months;\n\t}\n\treturn end.diff(start, 'days', true) / dur.asDays();\n}\n\n\n// Intelligently divides one duration by another\nfunction divideDurationByDuration(dur1, dur2) {\n\tvar months1, months2;\n\n\tif (durationHasTime(dur1) || durationHasTime(dur2)) {\n\t\treturn dur1 / dur2;\n\t}\n\tmonths1 = dur1.asMonths();\n\tmonths2 = dur2.asMonths();\n\tif (\n\t\tMath.abs(months1) >= 1 && isInt(months1) &&\n\t\tMath.abs(months2) >= 1 && isInt(months2)\n\t) {\n\t\treturn months1 / months2;\n\t}\n\treturn dur1.asDays() / dur2.asDays();\n}\n\n\n// Intelligently multiplies a duration by a number\nfunction multiplyDuration(dur, n) {\n\tvar months;\n\n\tif (durationHasTime(dur)) {\n\t\treturn moment.duration(dur * n);\n\t}\n\tmonths = dur.asMonths();\n\tif (Math.abs(months) >= 1 && isInt(months)) {\n\t\treturn moment.duration({ months: months * n });\n\t}\n\treturn moment.duration({ days: dur.asDays() * n });\n}\n\n\n// Returns a boolean about whether the given duration has any time parts (hours/minutes/seconds/ms)\nfunction durationHasTime(dur) {\n\treturn Boolean(dur.hours() || dur.minutes() || dur.seconds() || dur.milliseconds());\n}\n\n\nfunction isNativeDate(input) {\n\treturn  Object.prototype.toString.call(input) === '[object Date]' || input instanceof Date;\n}\n\n\n// Returns a boolean about whether the given input is a time string, like \"06:40:00\" or \"06:00\"\nfunction isTimeString(str) {\n\treturn /^\\d+\\:\\d+(?:\\:\\d+\\.?(?:\\d{3})?)?$/.test(str);\n}\n\n\n/* Logging and Debug\n----------------------------------------------------------------------------------------------------------------------*/\n\nFC.log = function() {\n\tvar console = window.console;\n\n\tif (console && console.log) {\n\t\treturn console.log.apply(console, arguments);\n\t}\n};\n\nFC.warn = function() {\n\tvar console = window.console;\n\n\tif (console && console.warn) {\n\t\treturn console.warn.apply(console, arguments);\n\t}\n\telse {\n\t\treturn FC.log.apply(FC, arguments);\n\t}\n};\n\n\n/* General Utilities\n----------------------------------------------------------------------------------------------------------------------*/\n\nvar hasOwnPropMethod = {}.hasOwnProperty;\n\n\n// Merges an array of objects into a single object.\n// The second argument allows for an array of property names who's object values will be merged together.\nfunction mergeProps(propObjs, complexProps) {\n\tvar dest = {};\n\tvar i, name;\n\tvar complexObjs;\n\tvar j, val;\n\tvar props;\n\n\tif (complexProps) {\n\t\tfor (i = 0; i < complexProps.length; i++) {\n\t\t\tname = complexProps[i];\n\t\t\tcomplexObjs = [];\n\n\t\t\t// collect the trailing object values, stopping when a non-object is discovered\n\t\t\tfor (j = propObjs.length - 1; j >= 0; j--) {\n\t\t\t\tval = propObjs[j][name];\n\n\t\t\t\tif (typeof val === 'object') {\n\t\t\t\t\tcomplexObjs.unshift(val);\n\t\t\t\t}\n\t\t\t\telse if (val !== undefined) {\n\t\t\t\t\tdest[name] = val; // if there were no objects, this value will be used\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if the trailing values were objects, use the merged value\n\t\t\tif (complexObjs.length) {\n\t\t\t\tdest[name] = mergeProps(complexObjs);\n\t\t\t}\n\t\t}\n\t}\n\n\t// copy values into the destination, going from last to first\n\tfor (i = propObjs.length - 1; i >= 0; i--) {\n\t\tprops = propObjs[i];\n\n\t\tfor (name in props) {\n\t\t\tif (!(name in dest)) { // if already assigned by previous props or complex props, don't reassign\n\t\t\t\tdest[name] = props[name];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dest;\n}\n\n\n// Create an object that has the given prototype. Just like Object.create\nfunction createObject(proto) {\n\tvar f = function() {};\n\tf.prototype = proto;\n\treturn new f();\n}\n\n\nfunction copyOwnProps(src, dest) {\n\tfor (var name in src) {\n\t\tif (hasOwnProp(src, name)) {\n\t\t\tdest[name] = src[name];\n\t\t}\n\t}\n}\n\n\nfunction hasOwnProp(obj, name) {\n\treturn hasOwnPropMethod.call(obj, name);\n}\n\n\n// Is the given value a non-object non-function value?\nfunction isAtomic(val) {\n\treturn /undefined|null|boolean|number|string/.test($.type(val));\n}\n\n\nfunction applyAll(functions, thisObj, args) {\n\tif ($.isFunction(functions)) {\n\t\tfunctions = [ functions ];\n\t}\n\tif (functions) {\n\t\tvar i;\n\t\tvar ret;\n\t\tfor (i=0; i<functions.length; i++) {\n\t\t\tret = functions[i].apply(thisObj, args) || ret;\n\t\t}\n\t\treturn ret;\n\t}\n}\n\n\nfunction firstDefined() {\n\tfor (var i=0; i<arguments.length; i++) {\n\t\tif (arguments[i] !== undefined) {\n\t\t\treturn arguments[i];\n\t\t}\n\t}\n}\n\n\nfunction htmlEscape(s) {\n\treturn (s + '').replace(/&/g, '&amp;')\n\t\t.replace(/</g, '&lt;')\n\t\t.replace(/>/g, '&gt;')\n\t\t.replace(/'/g, '&#039;')\n\t\t.replace(/\"/g, '&quot;')\n\t\t.replace(/\\n/g, '<br />');\n}\n\n\nfunction stripHtmlEntities(text) {\n\treturn text.replace(/&.*?;/g, '');\n}\n\n\n// Given a hash of CSS properties, returns a string of CSS.\n// Uses property names as-is (no camel-case conversion). Will not make statements for null/undefined values.\nfunction cssToStr(cssProps) {\n\tvar statements = [];\n\n\t$.each(cssProps, function(name, val) {\n\t\tif (val != null) {\n\t\t\tstatements.push(name + ':' + val);\n\t\t}\n\t});\n\n\treturn statements.join(';');\n}\n\n\n// Given an object hash of HTML attribute names to values,\n// generates a string that can be injected between < > in HTML\nfunction attrsToStr(attrs) {\n\tvar parts = [];\n\n\t$.each(attrs, function(name, val) {\n\t\tif (val != null) {\n\t\t\tparts.push(name + '=\"' + htmlEscape(val) + '\"');\n\t\t}\n\t});\n\n\treturn parts.join(' ');\n}\n\n\nfunction capitaliseFirstLetter(str) {\n\treturn str.charAt(0).toUpperCase() + str.slice(1);\n}\n\n\nfunction compareNumbers(a, b) { // for .sort()\n\treturn a - b;\n}\n\n\nfunction isInt(n) {\n\treturn n % 1 === 0;\n}\n\n\n// Returns a method bound to the given object context.\n// Just like one of the jQuery.proxy signatures, but without the undesired behavior of treating the same method with\n// different contexts as identical when binding/unbinding events.\nfunction proxy(obj, methodName) {\n\tvar method = obj[methodName];\n\n\treturn function() {\n\t\treturn method.apply(obj, arguments);\n\t};\n}\n\n\n// Returns a function, that, as long as it continues to be invoked, will not\n// be triggered. The function will be called after it stops being called for\n// N milliseconds. If `immediate` is passed, trigger the function on the\n// leading edge, instead of the trailing.\n// https://github.com/jashkenas/underscore/blob/1.6.0/underscore.js#L714\nfunction debounce(func, wait, immediate) {\n\tvar timeout, args, context, timestamp, result;\n\n\tvar later = function() {\n\t\tvar last = +new Date() - timestamp;\n\t\tif (last < wait) {\n\t\t\ttimeout = setTimeout(later, wait - last);\n\t\t}\n\t\telse {\n\t\t\ttimeout = null;\n\t\t\tif (!immediate) {\n\t\t\t\tresult = func.apply(context, args);\n\t\t\t\tcontext = args = null;\n\t\t\t}\n\t\t}\n\t};\n\n\treturn function() {\n\t\tcontext = this;\n\t\targs = arguments;\n\t\ttimestamp = +new Date();\n\t\tvar callNow = immediate && !timeout;\n\t\tif (!timeout) {\n\t\t\ttimeout = setTimeout(later, wait);\n\t\t}\n\t\tif (callNow) {\n\t\t\tresult = func.apply(context, args);\n\t\t\tcontext = args = null;\n\t\t}\n\t\treturn result;\n\t};\n}\n\n\n// HACK around jQuery's now A+ promises: execute callback synchronously if already resolved.\n// thenFunc shouldn't accept args.\n// similar to whenResources in Scheduler plugin.\nfunction syncThen(promise, thenFunc) {\n\t// not a promise, or an already-resolved promise?\n\tif (!promise || !promise.then || promise.state() === 'resolved') {\n\t\treturn $.when(thenFunc()); // resolve immediately\n\t}\n\telse if (thenFunc) {\n\t\treturn promise.then(thenFunc);\n\t}\n}\n\n;;\n\n/*\nGENERAL NOTE on moments throughout the *entire rest* of the codebase:\nAll moments are assumed to be ambiguously-zoned unless otherwise noted,\nwith the NOTABLE EXCEOPTION of start/end dates that live on *Event Objects*.\nAmbiguously-TIMED moments are assumed to be ambiguously-zoned by nature.\n*/\n\nvar ambigDateOfMonthRegex = /^\\s*\\d{4}-\\d\\d$/;\nvar ambigTimeOrZoneRegex =\n\t/^\\s*\\d{4}-(?:(\\d\\d-\\d\\d)|(W\\d\\d$)|(W\\d\\d-\\d)|(\\d\\d\\d))((T| )(\\d\\d(:\\d\\d(:\\d\\d(\\.\\d+)?)?)?)?)?$/;\nvar newMomentProto = moment.fn; // where we will attach our new methods\nvar oldMomentProto = $.extend({}, newMomentProto); // copy of original moment methods\n\n// tell momentjs to transfer these properties upon clone\nvar momentProperties = moment.momentProperties;\nmomentProperties.push('_fullCalendar');\nmomentProperties.push('_ambigTime');\nmomentProperties.push('_ambigZone');\n\n\n// Creating\n// -------------------------------------------------------------------------------------------------\n\n// Creates a new moment, similar to the vanilla moment(...) constructor, but with\n// extra features (ambiguous time, enhanced formatting). When given an existing moment,\n// it will function as a clone (and retain the zone of the moment). Anything else will\n// result in a moment in the local zone.\nFC.moment = function() {\n\treturn makeMoment(arguments);\n};\n\n// Sames as FC.moment, but forces the resulting moment to be in the UTC timezone.\nFC.moment.utc = function() {\n\tvar mom = makeMoment(arguments, true);\n\n\t// Force it into UTC because makeMoment doesn't guarantee it\n\t// (if given a pre-existing moment for example)\n\tif (mom.hasTime()) { // don't give ambiguously-timed moments a UTC zone\n\t\tmom.utc();\n\t}\n\n\treturn mom;\n};\n\n// Same as FC.moment, but when given an ISO8601 string, the timezone offset is preserved.\n// ISO8601 strings with no timezone offset will become ambiguously zoned.\nFC.moment.parseZone = function() {\n\treturn makeMoment(arguments, true, true);\n};\n\n// Builds an enhanced moment from args. When given an existing moment, it clones. When given a\n// native Date, or called with no arguments (the current time), the resulting moment will be local.\n// Anything else needs to be \"parsed\" (a string or an array), and will be affected by:\n//    parseAsUTC - if there is no zone information, should we parse the input in UTC?\n//    parseZone - if there is zone information, should we force the zone of the moment?\nfunction makeMoment(args, parseAsUTC, parseZone) {\n\tvar input = args[0];\n\tvar isSingleString = args.length == 1 && typeof input === 'string';\n\tvar isAmbigTime;\n\tvar isAmbigZone;\n\tvar ambigMatch;\n\tvar mom;\n\n\tif (moment.isMoment(input) || isNativeDate(input) || input === undefined) {\n\t\tmom = moment.apply(null, args);\n\t}\n\telse { // \"parsing\" is required\n\t\tisAmbigTime = false;\n\t\tisAmbigZone = false;\n\n\t\tif (isSingleString) {\n\t\t\tif (ambigDateOfMonthRegex.test(input)) {\n\t\t\t\t// accept strings like '2014-05', but convert to the first of the month\n\t\t\t\tinput += '-01';\n\t\t\t\targs = [ input ]; // for when we pass it on to moment's constructor\n\t\t\t\tisAmbigTime = true;\n\t\t\t\tisAmbigZone = true;\n\t\t\t}\n\t\t\telse if ((ambigMatch = ambigTimeOrZoneRegex.exec(input))) {\n\t\t\t\tisAmbigTime = !ambigMatch[5]; // no time part?\n\t\t\t\tisAmbigZone = true;\n\t\t\t}\n\t\t}\n\t\telse if ($.isArray(input)) {\n\t\t\t// arrays have no timezone information, so assume ambiguous zone\n\t\t\tisAmbigZone = true;\n\t\t}\n\t\t// otherwise, probably a string with a format\n\n\t\tif (parseAsUTC || isAmbigTime) {\n\t\t\tmom = moment.utc.apply(moment, args);\n\t\t}\n\t\telse {\n\t\t\tmom = moment.apply(null, args);\n\t\t}\n\n\t\tif (isAmbigTime) {\n\t\t\tmom._ambigTime = true;\n\t\t\tmom._ambigZone = true; // ambiguous time always means ambiguous zone\n\t\t}\n\t\telse if (parseZone) { // let's record the inputted zone somehow\n\t\t\tif (isAmbigZone) {\n\t\t\t\tmom._ambigZone = true;\n\t\t\t}\n\t\t\telse if (isSingleString) {\n\t\t\t\tmom.utcOffset(input); // if not a valid zone, will assign UTC\n\t\t\t}\n\t\t}\n\t}\n\n\tmom._fullCalendar = true; // flag for extended functionality\n\n\treturn mom;\n}\n\n\n// Week Number\n// -------------------------------------------------------------------------------------------------\n\n\n// Returns the week number, considering the locale's custom week number calcuation\n// `weeks` is an alias for `week`\nnewMomentProto.week = newMomentProto.weeks = function(input) {\n\tvar weekCalc = this._locale._fullCalendar_weekCalc;\n\n\tif (input == null && typeof weekCalc === 'function') { // custom function only works for getter\n\t\treturn weekCalc(this);\n\t}\n\telse if (weekCalc === 'ISO') {\n\t\treturn oldMomentProto.isoWeek.apply(this, arguments); // ISO getter/setter\n\t}\n\n\treturn oldMomentProto.week.apply(this, arguments); // local getter/setter\n};\n\n\n// Time-of-day\n// -------------------------------------------------------------------------------------------------\n\n// GETTER\n// Returns a Duration with the hours/minutes/seconds/ms values of the moment.\n// If the moment has an ambiguous time, a duration of 00:00 will be returned.\n//\n// SETTER\n// You can supply a Duration, a Moment, or a Duration-like argument.\n// When setting the time, and the moment has an ambiguous time, it then becomes unambiguous.\nnewMomentProto.time = function(time) {\n\n\t// Fallback to the original method (if there is one) if this moment wasn't created via FullCalendar.\n\t// `time` is a generic enough method name where this precaution is necessary to avoid collisions w/ other plugins.\n\tif (!this._fullCalendar) {\n\t\treturn oldMomentProto.time.apply(this, arguments);\n\t}\n\n\tif (time == null) { // getter\n\t\treturn moment.duration({\n\t\t\thours: this.hours(),\n\t\t\tminutes: this.minutes(),\n\t\t\tseconds: this.seconds(),\n\t\t\tmilliseconds: this.milliseconds()\n\t\t});\n\t}\n\telse { // setter\n\n\t\tthis._ambigTime = false; // mark that the moment now has a time\n\n\t\tif (!moment.isDuration(time) && !moment.isMoment(time)) {\n\t\t\ttime = moment.duration(time);\n\t\t}\n\n\t\t// The day value should cause overflow (so 24 hours becomes 00:00:00 of next day).\n\t\t// Only for Duration times, not Moment times.\n\t\tvar dayHours = 0;\n\t\tif (moment.isDuration(time)) {\n\t\t\tdayHours = Math.floor(time.asDays()) * 24;\n\t\t}\n\n\t\t// We need to set the individual fields.\n\t\t// Can't use startOf('day') then add duration. In case of DST at start of day.\n\t\treturn this.hours(dayHours + time.hours())\n\t\t\t.minutes(time.minutes())\n\t\t\t.seconds(time.seconds())\n\t\t\t.milliseconds(time.milliseconds());\n\t}\n};\n\n// Converts the moment to UTC, stripping out its time-of-day and timezone offset,\n// but preserving its YMD. A moment with a stripped time will display no time\n// nor timezone offset when .format() is called.\nnewMomentProto.stripTime = function() {\n\n\tif (!this._ambigTime) {\n\n\t\tthis.utc(true); // keepLocalTime=true (for keeping *date* value)\n\n\t\t// set time to zero\n\t\tthis.set({\n\t\t\thours: 0,\n\t\t\tminutes: 0,\n\t\t\tseconds: 0,\n\t\t\tms: 0\n\t\t});\n\n\t\t// Mark the time as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),\n\t\t// which clears all ambig flags.\n\t\tthis._ambigTime = true;\n\t\tthis._ambigZone = true; // if ambiguous time, also ambiguous timezone offset\n\t}\n\n\treturn this; // for chaining\n};\n\n// Returns if the moment has a non-ambiguous time (boolean)\nnewMomentProto.hasTime = function() {\n\treturn !this._ambigTime;\n};\n\n\n// Timezone\n// -------------------------------------------------------------------------------------------------\n\n// Converts the moment to UTC, stripping out its timezone offset, but preserving its\n// YMD and time-of-day. A moment with a stripped timezone offset will display no\n// timezone offset when .format() is called.\nnewMomentProto.stripZone = function() {\n\tvar wasAmbigTime;\n\n\tif (!this._ambigZone) {\n\n\t\twasAmbigTime = this._ambigTime;\n\n\t\tthis.utc(true); // keepLocalTime=true (for keeping date and time values)\n\n\t\t// the above call to .utc()/.utcOffset() unfortunately might clear the ambig flags, so restore\n\t\tthis._ambigTime = wasAmbigTime || false;\n\n\t\t// Mark the zone as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),\n\t\t// which clears the ambig flags.\n\t\tthis._ambigZone = true;\n\t}\n\n\treturn this; // for chaining\n};\n\n// Returns of the moment has a non-ambiguous timezone offset (boolean)\nnewMomentProto.hasZone = function() {\n\treturn !this._ambigZone;\n};\n\n\n// implicitly marks a zone\nnewMomentProto.local = function(keepLocalTime) {\n\n\t// for when converting from ambiguously-zoned to local,\n\t// keep the time values when converting from UTC -> local\n\toldMomentProto.local.call(this, this._ambigZone || keepLocalTime);\n\n\t// ensure non-ambiguous\n\t// this probably already happened via local() -> utcOffset(), but don't rely on Moment's internals\n\tthis._ambigTime = false;\n\tthis._ambigZone = false;\n\n\treturn this; // for chaining\n};\n\n\n// implicitly marks a zone\nnewMomentProto.utc = function(keepLocalTime) {\n\n\toldMomentProto.utc.call(this, keepLocalTime);\n\n\t// ensure non-ambiguous\n\t// this probably already happened via utc() -> utcOffset(), but don't rely on Moment's internals\n\tthis._ambigTime = false;\n\tthis._ambigZone = false;\n\n\treturn this;\n};\n\n\n// implicitly marks a zone (will probably get called upon .utc() and .local())\nnewMomentProto.utcOffset = function(tzo) {\n\n\tif (tzo != null) { // setter\n\t\t// these assignments needs to happen before the original zone method is called.\n\t\t// I forget why, something to do with a browser crash.\n\t\tthis._ambigTime = false;\n\t\tthis._ambigZone = false;\n\t}\n\n\treturn oldMomentProto.utcOffset.apply(this, arguments);\n};\n\n\n// Formatting\n// -------------------------------------------------------------------------------------------------\n\nnewMomentProto.format = function() {\n\tif (this._fullCalendar && arguments[0]) { // an enhanced moment? and a format string provided?\n\t\treturn formatDate(this, arguments[0]); // our extended formatting\n\t}\n\tif (this._ambigTime) {\n\t\treturn oldMomentFormat(this, 'YYYY-MM-DD');\n\t}\n\tif (this._ambigZone) {\n\t\treturn oldMomentFormat(this, 'YYYY-MM-DD[T]HH:mm:ss');\n\t}\n\treturn oldMomentProto.format.apply(this, arguments);\n};\n\nnewMomentProto.toISOString = function() {\n\tif (this._ambigTime) {\n\t\treturn oldMomentFormat(this, 'YYYY-MM-DD');\n\t}\n\tif (this._ambigZone) {\n\t\treturn oldMomentFormat(this, 'YYYY-MM-DD[T]HH:mm:ss');\n\t}\n\treturn oldMomentProto.toISOString.apply(this, arguments);\n};\n\n;;\n\n// Single Date Formatting\n// -------------------------------------------------------------------------------------------------\n\n\n// call this if you want Moment's original format method to be used\nfunction oldMomentFormat(mom, formatStr) {\n\treturn oldMomentProto.format.call(mom, formatStr); // oldMomentProto defined in moment-ext.js\n}\n\n\n// Formats `date` with a Moment formatting string, but allow our non-zero areas and\n// additional token.\nfunction formatDate(date, formatStr) {\n\treturn formatDateWithChunks(date, getFormatStringChunks(formatStr));\n}\n\n\nfunction formatDateWithChunks(date, chunks) {\n\tvar s = '';\n\tvar i;\n\n\tfor (i=0; i<chunks.length; i++) {\n\t\ts += formatDateWithChunk(date, chunks[i]);\n\t}\n\n\treturn s;\n}\n\n\n// addition formatting tokens we want recognized\nvar tokenOverrides = {\n\tt: function(date) { // \"a\" or \"p\"\n\t\treturn oldMomentFormat(date, 'a').charAt(0);\n\t},\n\tT: function(date) { // \"A\" or \"P\"\n\t\treturn oldMomentFormat(date, 'A').charAt(0);\n\t}\n};\n\n\nfunction formatDateWithChunk(date, chunk) {\n\tvar token;\n\tvar maybeStr;\n\n\tif (typeof chunk === 'string') { // a literal string\n\t\treturn chunk;\n\t}\n\telse if ((token = chunk.token)) { // a token, like \"YYYY\"\n\t\tif (tokenOverrides[token]) {\n\t\t\treturn tokenOverrides[token](date); // use our custom token\n\t\t}\n\t\treturn oldMomentFormat(date, token);\n\t}\n\telse if (chunk.maybe) { // a grouping of other chunks that must be non-zero\n\t\tmaybeStr = formatDateWithChunks(date, chunk.maybe);\n\t\tif (maybeStr.match(/[1-9]/)) {\n\t\t\treturn maybeStr;\n\t\t}\n\t}\n\n\treturn '';\n}\n\n\n// Date Range Formatting\n// -------------------------------------------------------------------------------------------------\n// TODO: make it work with timezone offset\n\n// Using a formatting string meant for a single date, generate a range string, like\n// \"Sep 2 - 9 2013\", that intelligently inserts a separator where the dates differ.\n// If the dates are the same as far as the format string is concerned, just return a single\n// rendering of one date, without any separator.\nfunction formatRange(date1, date2, formatStr, separator, isRTL) {\n\tvar localeData;\n\n\tdate1 = FC.moment.parseZone(date1);\n\tdate2 = FC.moment.parseZone(date2);\n\n\tlocaleData = date1.localeData();\n\n\t// Expand localized format strings, like \"LL\" -> \"MMMM D YYYY\"\n\tformatStr = localeData.longDateFormat(formatStr) || formatStr;\n\t// BTW, this is not important for `formatDate` because it is impossible to put custom tokens\n\t// or non-zero areas in Moment's localized format strings.\n\n\tseparator = separator || ' - ';\n\n\treturn formatRangeWithChunks(\n\t\tdate1,\n\t\tdate2,\n\t\tgetFormatStringChunks(formatStr),\n\t\tseparator,\n\t\tisRTL\n\t);\n}\nFC.formatRange = formatRange; // expose\n\n\nfunction formatRangeWithChunks(date1, date2, chunks, separator, isRTL) {\n\tvar unzonedDate1 = date1.clone().stripZone(); // for formatSimilarChunk\n\tvar unzonedDate2 = date2.clone().stripZone(); // \"\n\tvar chunkStr; // the rendering of the chunk\n\tvar leftI;\n\tvar leftStr = '';\n\tvar rightI;\n\tvar rightStr = '';\n\tvar middleI;\n\tvar middleStr1 = '';\n\tvar middleStr2 = '';\n\tvar middleStr = '';\n\n\t// Start at the leftmost side of the formatting string and continue until you hit a token\n\t// that is not the same between dates.\n\tfor (leftI=0; leftI<chunks.length; leftI++) {\n\t\tchunkStr = formatSimilarChunk(date1, date2, unzonedDate1, unzonedDate2, chunks[leftI]);\n\t\tif (chunkStr === false) {\n\t\t\tbreak;\n\t\t}\n\t\tleftStr += chunkStr;\n\t}\n\n\t// Similarly, start at the rightmost side of the formatting string and move left\n\tfor (rightI=chunks.length-1; rightI>leftI; rightI--) {\n\t\tchunkStr = formatSimilarChunk(date1, date2, unzonedDate1, unzonedDate2,  chunks[rightI]);\n\t\tif (chunkStr === false) {\n\t\t\tbreak;\n\t\t}\n\t\trightStr = chunkStr + rightStr;\n\t}\n\n\t// The area in the middle is different for both of the dates.\n\t// Collect them distinctly so we can jam them together later.\n\tfor (middleI=leftI; middleI<=rightI; middleI++) {\n\t\tmiddleStr1 += formatDateWithChunk(date1, chunks[middleI]);\n\t\tmiddleStr2 += formatDateWithChunk(date2, chunks[middleI]);\n\t}\n\n\tif (middleStr1 || middleStr2) {\n\t\tif (isRTL) {\n\t\t\tmiddleStr = middleStr2 + separator + middleStr1;\n\t\t}\n\t\telse {\n\t\t\tmiddleStr = middleStr1 + separator + middleStr2;\n\t\t}\n\t}\n\n\treturn leftStr + middleStr + rightStr;\n}\n\n\nvar similarUnitMap = {\n\tY: 'year',\n\tM: 'month',\n\tD: 'day', // day of month\n\td: 'day', // day of week\n\t// prevents a separator between anything time-related...\n\tA: 'second', // AM/PM\n\ta: 'second', // am/pm\n\tT: 'second', // A/P\n\tt: 'second', // a/p\n\tH: 'second', // hour (24)\n\th: 'second', // hour (12)\n\tm: 'second', // minute\n\ts: 'second' // second\n};\n// TODO: week maybe?\n\n\n// Given a formatting chunk, and given that both dates are similar in the regard the\n// formatting chunk is concerned, format date1 against `chunk`. Otherwise, return `false`.\nfunction formatSimilarChunk(date1, date2, unzonedDate1, unzonedDate2, chunk) {\n\tvar token;\n\tvar unit;\n\n\tif (typeof chunk === 'string') { // a literal string\n\t\treturn chunk;\n\t}\n\telse if ((token = chunk.token)) {\n\t\tunit = similarUnitMap[token.charAt(0)];\n\n\t\t// are the dates the same for this unit of measurement?\n\t\t// use the unzoned dates for this calculation because unreliable when near DST (bug #2396)\n\t\tif (unit && unzonedDate1.isSame(unzonedDate2, unit)) {\n\t\t\treturn oldMomentFormat(date1, token); // would be the same if we used `date2`\n\t\t\t// BTW, don't support custom tokens\n\t\t}\n\t}\n\n\treturn false; // the chunk is NOT the same for the two dates\n\t// BTW, don't support splitting on non-zero areas\n}\n\n\n// Chunking Utils\n// -------------------------------------------------------------------------------------------------\n\n\nvar formatStringChunkCache = {};\n\n\nfunction getFormatStringChunks(formatStr) {\n\tif (formatStr in formatStringChunkCache) {\n\t\treturn formatStringChunkCache[formatStr];\n\t}\n\treturn (formatStringChunkCache[formatStr] = chunkFormatString(formatStr));\n}\n\n\n// Break the formatting string into an array of chunks\nfunction chunkFormatString(formatStr) {\n\tvar chunks = [];\n\tvar chunker = /\\[([^\\]]*)\\]|\\(([^\\)]*)\\)|(LTS|LT|(\\w)\\4*o?)|([^\\w\\[\\(]+)/g; // TODO: more descrimination\n\tvar match;\n\n\twhile ((match = chunker.exec(formatStr))) {\n\t\tif (match[1]) { // a literal string inside [ ... ]\n\t\t\tchunks.push(match[1]);\n\t\t}\n\t\telse if (match[2]) { // non-zero formatting inside ( ... )\n\t\t\tchunks.push({ maybe: chunkFormatString(match[2]) });\n\t\t}\n\t\telse if (match[3]) { // a formatting token\n\t\t\tchunks.push({ token: match[3] });\n\t\t}\n\t\telse if (match[5]) { // an unenclosed literal string\n\t\t\tchunks.push(match[5]);\n\t\t}\n\t}\n\n\treturn chunks;\n}\n\n\n// Misc Utils\n// -------------------------------------------------------------------------------------------------\n\n\n// granularity only goes up until day\n// TODO: unify with similarUnitMap\nvar tokenGranularities = {\n\tY: { value: 1, unit: 'year' },\n\tM: { value: 2, unit: 'month' },\n\tW: { value: 3, unit: 'week' },\n\tw: { value: 3, unit: 'week' },\n\tD: { value: 4, unit: 'day' }, // day of month\n\td: { value: 4, unit: 'day' } // day of week\n};\n\n// returns a unit string, either 'year', 'month', 'day', or null\n// for the most granular formatting token in the string.\nFC.queryMostGranularFormatUnit = function(formatStr) {\n\tvar chunks = getFormatStringChunks(formatStr);\n\tvar i, chunk;\n\tvar candidate;\n\tvar best;\n\n\tfor (i = 0; i < chunks.length; i++) {\n\t\tchunk = chunks[i];\n\t\tif (chunk.token) {\n\t\t\tcandidate = tokenGranularities[chunk.token.charAt(0)];\n\t\t\tif (candidate) {\n\t\t\t\tif (!best || candidate.value > best.value) {\n\t\t\t\t\tbest = candidate;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (best) {\n\t\treturn best.unit;\n\t}\n\n\treturn null;\n};\n\n;;\n\nFC.Class = Class; // export\n\n// Class that all other classes will inherit from\nfunction Class() { }\n\n\n// Called on a class to create a subclass.\n// Last argument contains instance methods. Any argument before the last are considered mixins.\nClass.extend = function() {\n\tvar len = arguments.length;\n\tvar i;\n\tvar members;\n\n\tfor (i = 0; i < len; i++) {\n\t\tmembers = arguments[i];\n\t\tif (i < len - 1) { // not the last argument?\n\t\t\tmixIntoClass(this, members);\n\t\t}\n\t}\n\n\treturn extendClass(this, members || {}); // members will be undefined if no arguments\n};\n\n\n// Adds new member variables/methods to the class's prototype.\n// Can be called with another class, or a plain object hash containing new members.\nClass.mixin = function(members) {\n\tmixIntoClass(this, members);\n};\n\n\nfunction extendClass(superClass, members) {\n\tvar subClass;\n\n\t// ensure a constructor for the subclass, forwarding all arguments to the super-constructor if it doesn't exist\n\tif (hasOwnProp(members, 'constructor')) {\n\t\tsubClass = members.constructor;\n\t}\n\tif (typeof subClass !== 'function') {\n\t\tsubClass = members.constructor = function() {\n\t\t\tsuperClass.apply(this, arguments);\n\t\t};\n\t}\n\n\t// build the base prototype for the subclass, which is an new object chained to the superclass's prototype\n\tsubClass.prototype = createObject(superClass.prototype);\n\n\t// copy each member variable/method onto the the subclass's prototype\n\tcopyOwnProps(members, subClass.prototype);\n\n\t// copy over all class variables/methods to the subclass, such as `extend` and `mixin`\n\tcopyOwnProps(superClass, subClass);\n\n\treturn subClass;\n}\n\n\nfunction mixIntoClass(theClass, members) {\n\tcopyOwnProps(members, theClass.prototype);\n}\n;;\n\nvar EmitterMixin = FC.EmitterMixin = {\n\n\t// jQuery-ification via $(this) allows a non-DOM object to have\n\t// the same event handling capabilities (including namespaces).\n\n\n\ton: function(types, handler) {\n\n\t\t// handlers are always called with an \"event\" object as their first param.\n\t\t// sneak the `this` context and arguments into the extra parameter object\n\t\t// and forward them on to the original handler.\n\t\tvar intercept = function(ev, extra) {\n\t\t\treturn handler.apply(\n\t\t\t\textra.context || this,\n\t\t\t\textra.args || []\n\t\t\t);\n\t\t};\n\n\t\t// mimick jQuery's internal \"proxy\" system (risky, I know)\n\t\t// causing all functions with the same .guid to appear to be the same.\n\t\t// https://github.com/jquery/jquery/blob/2.2.4/src/core.js#L448\n\t\t// this is needed for calling .off with the original non-intercept handler.\n\t\tif (!handler.guid) {\n\t\t\thandler.guid = $.guid++;\n\t\t}\n\t\tintercept.guid = handler.guid;\n\n\t\t$(this).on(types, intercept);\n\n\t\treturn this; // for chaining\n\t},\n\n\n\toff: function(types, handler) {\n\t\t$(this).off(types, handler);\n\n\t\treturn this; // for chaining\n\t},\n\n\n\ttrigger: function(types) {\n\t\tvar args = Array.prototype.slice.call(arguments, 1); // arguments after the first\n\n\t\t// pass in \"extra\" info to the intercept\n\t\t$(this).triggerHandler(types, { args: args });\n\n\t\treturn this; // for chaining\n\t},\n\n\n\ttriggerWith: function(types, context, args) {\n\n\t\t// `triggerHandler` is less reliant on the DOM compared to `trigger`.\n\t\t// pass in \"extra\" info to the intercept.\n\t\t$(this).triggerHandler(types, { context: context, args: args });\n\n\t\treturn this; // for chaining\n\t}\n\n};\n\n;;\n\n/*\nUtility methods for easily listening to events on another object,\nand more importantly, easily unlistening from them.\n*/\nvar ListenerMixin = FC.ListenerMixin = (function() {\n\tvar guid = 0;\n\tvar ListenerMixin = {\n\n\t\tlistenerId: null,\n\n\t\t/*\n\t\tGiven an `other` object that has on/off methods, bind the given `callback` to an event by the given name.\n\t\tThe `callback` will be called with the `this` context of the object that .listenTo is being called on.\n\t\tCan be called:\n\t\t\t.listenTo(other, eventName, callback)\n\t\tOR\n\t\t\t.listenTo(other, {\n\t\t\t\teventName1: callback1,\n\t\t\t\teventName2: callback2\n\t\t\t})\n\t\t*/\n\t\tlistenTo: function(other, arg, callback) {\n\t\t\tif (typeof arg === 'object') { // given dictionary of callbacks\n\t\t\t\tfor (var eventName in arg) {\n\t\t\t\t\tif (arg.hasOwnProperty(eventName)) {\n\t\t\t\t\t\tthis.listenTo(other, eventName, arg[eventName]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (typeof arg === 'string') {\n\t\t\t\tother.on(\n\t\t\t\t\targ + '.' + this.getListenerNamespace(), // use event namespacing to identify this object\n\t\t\t\t\t$.proxy(callback, this) // always use `this` context\n\t\t\t\t\t\t// the usually-undesired jQuery guid behavior doesn't matter,\n\t\t\t\t\t\t// because we always unbind via namespace\n\t\t\t\t);\n\t\t\t}\n\t\t},\n\n\t\t/*\n\t\tCauses the current object to stop listening to events on the `other` object.\n\t\t`eventName` is optional. If omitted, will stop listening to ALL events on `other`.\n\t\t*/\n\t\tstopListeningTo: function(other, eventName) {\n\t\t\tother.off((eventName || '') + '.' + this.getListenerNamespace());\n\t\t},\n\n\t\t/*\n\t\tReturns a string, unique to this object, to be used for event namespacing\n\t\t*/\n\t\tgetListenerNamespace: function() {\n\t\t\tif (this.listenerId == null) {\n\t\t\t\tthis.listenerId = guid++;\n\t\t\t}\n\t\t\treturn '_listener' + this.listenerId;\n\t\t}\n\n\t};\n\treturn ListenerMixin;\n})();\n;;\n\n// simple class for toggle a `isIgnoringMouse` flag on delay\n// initMouseIgnoring must first be called, with a millisecond delay setting.\nvar MouseIgnorerMixin = {\n\n\tisIgnoringMouse: false, // bool\n\tdelayUnignoreMouse: null, // method\n\n\n\tinitMouseIgnoring: function(delay) {\n\t\tthis.delayUnignoreMouse = debounce(proxy(this, 'unignoreMouse'), delay || 1000);\n\t},\n\n\n\t// temporarily ignore mouse actions on segments\n\ttempIgnoreMouse: function() {\n\t\tthis.isIgnoringMouse = true;\n\t\tthis.delayUnignoreMouse();\n\t},\n\n\n\t// delayUnignoreMouse eventually calls this\n\tunignoreMouse: function() {\n\t\tthis.isIgnoringMouse = false;\n\t}\n\n};\n\n;;\n\n/* A rectangular panel that is absolutely positioned over other content\n------------------------------------------------------------------------------------------------------------------------\nOptions:\n\t- className (string)\n\t- content (HTML string or jQuery element set)\n\t- parentEl\n\t- top\n\t- left\n\t- right (the x coord of where the right edge should be. not a \"CSS\" right)\n\t- autoHide (boolean)\n\t- show (callback)\n\t- hide (callback)\n*/\n\nvar Popover = Class.extend(ListenerMixin, {\n\n\tisHidden: true,\n\toptions: null,\n\tel: null, // the container element for the popover. generated by this object\n\tmargin: 10, // the space required between the popover and the edges of the scroll container\n\n\n\tconstructor: function(options) {\n\t\tthis.options = options || {};\n\t},\n\n\n\t// Shows the popover on the specified position. Renders it if not already\n\tshow: function() {\n\t\tif (this.isHidden) {\n\t\t\tif (!this.el) {\n\t\t\t\tthis.render();\n\t\t\t}\n\t\t\tthis.el.show();\n\t\t\tthis.position();\n\t\t\tthis.isHidden = false;\n\t\t\tthis.trigger('show');\n\t\t}\n\t},\n\n\n\t// Hides the popover, through CSS, but does not remove it from the DOM\n\thide: function() {\n\t\tif (!this.isHidden) {\n\t\t\tthis.el.hide();\n\t\t\tthis.isHidden = true;\n\t\t\tthis.trigger('hide');\n\t\t}\n\t},\n\n\n\t// Creates `this.el` and renders content inside of it\n\trender: function() {\n\t\tvar _this = this;\n\t\tvar options = this.options;\n\n\t\tthis.el = $('<div class=\"fc-popover\"/>')\n\t\t\t.addClass(options.className || '')\n\t\t\t.css({\n\t\t\t\t// position initially to the top left to avoid creating scrollbars\n\t\t\t\ttop: 0,\n\t\t\t\tleft: 0\n\t\t\t})\n\t\t\t.append(options.content)\n\t\t\t.appendTo(options.parentEl);\n\n\t\t// when a click happens on anything inside with a 'fc-close' className, hide the popover\n\t\tthis.el.on('click', '.fc-close', function() {\n\t\t\t_this.hide();\n\t\t});\n\n\t\tif (options.autoHide) {\n\t\t\tthis.listenTo($(document), 'mousedown', this.documentMousedown);\n\t\t}\n\t},\n\n\n\t// Triggered when the user clicks *anywhere* in the document, for the autoHide feature\n\tdocumentMousedown: function(ev) {\n\t\t// only hide the popover if the click happened outside the popover\n\t\tif (this.el && !$(ev.target).closest(this.el).length) {\n\t\t\tthis.hide();\n\t\t}\n\t},\n\n\n\t// Hides and unregisters any handlers\n\tremoveElement: function() {\n\t\tthis.hide();\n\n\t\tif (this.el) {\n\t\t\tthis.el.remove();\n\t\t\tthis.el = null;\n\t\t}\n\n\t\tthis.stopListeningTo($(document), 'mousedown');\n\t},\n\n\n\t// Positions the popover optimally, using the top/left/right options\n\tposition: function() {\n\t\tvar options = this.options;\n\t\tvar origin = this.el.offsetParent().offset();\n\t\tvar width = this.el.outerWidth();\n\t\tvar height = this.el.outerHeight();\n\t\tvar windowEl = $(window);\n\t\tvar viewportEl = getScrollParent(this.el);\n\t\tvar viewportTop;\n\t\tvar viewportLeft;\n\t\tvar viewportOffset;\n\t\tvar top; // the \"position\" (not \"offset\") values for the popover\n\t\tvar left; //\n\n\t\t// compute top and left\n\t\ttop = options.top || 0;\n\t\tif (options.left !== undefined) {\n\t\t\tleft = options.left;\n\t\t}\n\t\telse if (options.right !== undefined) {\n\t\t\tleft = options.right - width; // derive the left value from the right value\n\t\t}\n\t\telse {\n\t\t\tleft = 0;\n\t\t}\n\n\t\tif (viewportEl.is(window) || viewportEl.is(document)) { // normalize getScrollParent's result\n\t\t\tviewportEl = windowEl;\n\t\t\tviewportTop = 0; // the window is always at the top left\n\t\t\tviewportLeft = 0; // (and .offset() won't work if called here)\n\t\t}\n\t\telse {\n\t\t\tviewportOffset = viewportEl.offset();\n\t\t\tviewportTop = viewportOffset.top;\n\t\t\tviewportLeft = viewportOffset.left;\n\t\t}\n\n\t\t// if the window is scrolled, it causes the visible area to be further down\n\t\tviewportTop += windowEl.scrollTop();\n\t\tviewportLeft += windowEl.scrollLeft();\n\n\t\t// constrain to the view port. if constrained by two edges, give precedence to top/left\n\t\tif (options.viewportConstrain !== false) {\n\t\t\ttop = Math.min(top, viewportTop + viewportEl.outerHeight() - height - this.margin);\n\t\t\ttop = Math.max(top, viewportTop + this.margin);\n\t\t\tleft = Math.min(left, viewportLeft + viewportEl.outerWidth() - width - this.margin);\n\t\t\tleft = Math.max(left, viewportLeft + this.margin);\n\t\t}\n\n\t\tthis.el.css({\n\t\t\ttop: top - origin.top,\n\t\t\tleft: left - origin.left\n\t\t});\n\t},\n\n\n\t// Triggers a callback. Calls a function in the option hash of the same name.\n\t// Arguments beyond the first `name` are forwarded on.\n\t// TODO: better code reuse for this. Repeat code\n\ttrigger: function(name) {\n\t\tif (this.options[name]) {\n\t\t\tthis.options[name].apply(this, Array.prototype.slice.call(arguments, 1));\n\t\t}\n\t}\n\n});\n\n;;\n\n/*\nA cache for the left/right/top/bottom/width/height values for one or more elements.\nWorks with both offset (from topleft document) and position (from offsetParent).\n\noptions:\n- els\n- isHorizontal\n- isVertical\n*/\nvar CoordCache = FC.CoordCache = Class.extend({\n\n\tels: null, // jQuery set (assumed to be siblings)\n\tforcedOffsetParentEl: null, // options can override the natural offsetParent\n\torigin: null, // {left,top} position of offsetParent of els\n\tboundingRect: null, // constrain cordinates to this rectangle. {left,right,top,bottom} or null\n\tisHorizontal: false, // whether to query for left/right/width\n\tisVertical: false, // whether to query for top/bottom/height\n\n\t// arrays of coordinates (offsets from topleft of document)\n\tlefts: null,\n\trights: null,\n\ttops: null,\n\tbottoms: null,\n\n\n\tconstructor: function(options) {\n\t\tthis.els = $(options.els);\n\t\tthis.isHorizontal = options.isHorizontal;\n\t\tthis.isVertical = options.isVertical;\n\t\tthis.forcedOffsetParentEl = options.offsetParent ? $(options.offsetParent) : null;\n\t},\n\n\n\t// Queries the els for coordinates and stores them.\n\t// Call this method before using and of the get* methods below.\n\tbuild: function() {\n\t\tvar offsetParentEl = this.forcedOffsetParentEl || this.els.eq(0).offsetParent();\n\n\t\tthis.origin = offsetParentEl.offset();\n\t\tthis.boundingRect = this.queryBoundingRect();\n\n\t\tif (this.isHorizontal) {\n\t\t\tthis.buildElHorizontals();\n\t\t}\n\t\tif (this.isVertical) {\n\t\t\tthis.buildElVerticals();\n\t\t}\n\t},\n\n\n\t// Destroys all internal data about coordinates, freeing memory\n\tclear: function() {\n\t\tthis.origin = null;\n\t\tthis.boundingRect = null;\n\t\tthis.lefts = null;\n\t\tthis.rights = null;\n\t\tthis.tops = null;\n\t\tthis.bottoms = null;\n\t},\n\n\n\t// When called, if coord caches aren't built, builds them\n\tensureBuilt: function() {\n\t\tif (!this.origin) {\n\t\t\tthis.build();\n\t\t}\n\t},\n\n\n\t// Populates the left/right internal coordinate arrays\n\tbuildElHorizontals: function() {\n\t\tvar lefts = [];\n\t\tvar rights = [];\n\n\t\tthis.els.each(function(i, node) {\n\t\t\tvar el = $(node);\n\t\t\tvar left = el.offset().left;\n\t\t\tvar width = el.outerWidth();\n\n\t\t\tlefts.push(left);\n\t\t\trights.push(left + width);\n\t\t});\n\n\t\tthis.lefts = lefts;\n\t\tthis.rights = rights;\n\t},\n\n\n\t// Populates the top/bottom internal coordinate arrays\n\tbuildElVerticals: function() {\n\t\tvar tops = [];\n\t\tvar bottoms = [];\n\n\t\tthis.els.each(function(i, node) {\n\t\t\tvar el = $(node);\n\t\t\tvar top = el.offset().top;\n\t\t\tvar height = el.outerHeight();\n\n\t\t\ttops.push(top);\n\t\t\tbottoms.push(top + height);\n\t\t});\n\n\t\tthis.tops = tops;\n\t\tthis.bottoms = bottoms;\n\t},\n\n\n\t// Given a left offset (from document left), returns the index of the el that it horizontally intersects.\n\t// If no intersection is made, returns undefined.\n\tgetHorizontalIndex: function(leftOffset) {\n\t\tthis.ensureBuilt();\n\n\t\tvar lefts = this.lefts;\n\t\tvar rights = this.rights;\n\t\tvar len = lefts.length;\n\t\tvar i;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (leftOffset >= lefts[i] && leftOffset < rights[i]) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t},\n\n\n\t// Given a top offset (from document top), returns the index of the el that it vertically intersects.\n\t// If no intersection is made, returns undefined.\n\tgetVerticalIndex: function(topOffset) {\n\t\tthis.ensureBuilt();\n\n\t\tvar tops = this.tops;\n\t\tvar bottoms = this.bottoms;\n\t\tvar len = tops.length;\n\t\tvar i;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (topOffset >= tops[i] && topOffset < bottoms[i]) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t},\n\n\n\t// Gets the left offset (from document left) of the element at the given index\n\tgetLeftOffset: function(leftIndex) {\n\t\tthis.ensureBuilt();\n\t\treturn this.lefts[leftIndex];\n\t},\n\n\n\t// Gets the left position (from offsetParent left) of the element at the given index\n\tgetLeftPosition: function(leftIndex) {\n\t\tthis.ensureBuilt();\n\t\treturn this.lefts[leftIndex] - this.origin.left;\n\t},\n\n\n\t// Gets the right offset (from document left) of the element at the given index.\n\t// This value is NOT relative to the document's right edge, like the CSS concept of \"right\" would be.\n\tgetRightOffset: function(leftIndex) {\n\t\tthis.ensureBuilt();\n\t\treturn this.rights[leftIndex];\n\t},\n\n\n\t// Gets the right position (from offsetParent left) of the element at the given index.\n\t// This value is NOT relative to the offsetParent's right edge, like the CSS concept of \"right\" would be.\n\tgetRightPosition: function(leftIndex) {\n\t\tthis.ensureBuilt();\n\t\treturn this.rights[leftIndex] - this.origin.left;\n\t},\n\n\n\t// Gets the width of the element at the given index\n\tgetWidth: function(leftIndex) {\n\t\tthis.ensureBuilt();\n\t\treturn this.rights[leftIndex] - this.lefts[leftIndex];\n\t},\n\n\n\t// Gets the top offset (from document top) of the element at the given index\n\tgetTopOffset: function(topIndex) {\n\t\tthis.ensureBuilt();\n\t\treturn this.tops[topIndex];\n\t},\n\n\n\t// Gets the top position (from offsetParent top) of the element at the given position\n\tgetTopPosition: function(topIndex) {\n\t\tthis.ensureBuilt();\n\t\treturn this.tops[topIndex] - this.origin.top;\n\t},\n\n\t// Gets the bottom offset (from the document top) of the element at the given index.\n\t// This value is NOT relative to the offsetParent's bottom edge, like the CSS concept of \"bottom\" would be.\n\tgetBottomOffset: function(topIndex) {\n\t\tthis.ensureBuilt();\n\t\treturn this.bottoms[topIndex];\n\t},\n\n\n\t// Gets the bottom position (from the offsetParent top) of the element at the given index.\n\t// This value is NOT relative to the offsetParent's bottom edge, like the CSS concept of \"bottom\" would be.\n\tgetBottomPosition: function(topIndex) {\n\t\tthis.ensureBuilt();\n\t\treturn this.bottoms[topIndex] - this.origin.top;\n\t},\n\n\n\t// Gets the height of the element at the given index\n\tgetHeight: function(topIndex) {\n\t\tthis.ensureBuilt();\n\t\treturn this.bottoms[topIndex] - this.tops[topIndex];\n\t},\n\n\n\t// Bounding Rect\n\t// TODO: decouple this from CoordCache\n\n\t// Compute and return what the elements' bounding rectangle is, from the user's perspective.\n\t// Right now, only returns a rectangle if constrained by an overflow:scroll element.\n\tqueryBoundingRect: function() {\n\t\tvar scrollParentEl = getScrollParent(this.els.eq(0));\n\n\t\tif (!scrollParentEl.is(document)) {\n\t\t\treturn getClientRect(scrollParentEl);\n\t\t}\n\t},\n\n\tisPointInBounds: function(leftOffset, topOffset) {\n\t\treturn this.isLeftInBounds(leftOffset) && this.isTopInBounds(topOffset);\n\t},\n\n\tisLeftInBounds: function(leftOffset) {\n\t\treturn !this.boundingRect || (leftOffset >= this.boundingRect.left && leftOffset < this.boundingRect.right);\n\t},\n\n\tisTopInBounds: function(topOffset) {\n\t\treturn !this.boundingRect || (topOffset >= this.boundingRect.top && topOffset < this.boundingRect.bottom);\n\t}\n\n});\n\n;;\n\n/* Tracks a drag's mouse movement, firing various handlers\n----------------------------------------------------------------------------------------------------------------------*/\n// TODO: use Emitter\n\nvar DragListener = FC.DragListener = Class.extend(ListenerMixin, MouseIgnorerMixin, {\n\n\toptions: null,\n\tsubjectEl: null,\n\n\t// coordinates of the initial mousedown\n\toriginX: null,\n\toriginY: null,\n\n\t// the wrapping element that scrolls, or MIGHT scroll if there's overflow.\n\t// TODO: do this for wrappers that have overflow:hidden as well.\n\tscrollEl: null,\n\n\tisInteracting: false,\n\tisDistanceSurpassed: false,\n\tisDelayEnded: false,\n\tisDragging: false,\n\tisTouch: false,\n\n\tdelay: null,\n\tdelayTimeoutId: null,\n\tminDistance: null,\n\n\thandleTouchScrollProxy: null, // calls handleTouchScroll, always bound to `this`\n\n\n\tconstructor: function(options) {\n\t\tthis.options = options || {};\n\t\tthis.handleTouchScrollProxy = proxy(this, 'handleTouchScroll');\n\t\tthis.initMouseIgnoring(500);\n\t},\n\n\n\t// Interaction (high-level)\n\t// -----------------------------------------------------------------------------------------------------------------\n\n\n\tstartInteraction: function(ev, extraOptions) {\n\t\tvar isTouch = getEvIsTouch(ev);\n\n\t\tif (ev.type === 'mousedown') {\n\t\t\tif (this.isIgnoringMouse) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if (!isPrimaryMouseButton(ev)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tev.preventDefault(); // prevents native selection in most browsers\n\t\t\t}\n\t\t}\n\n\t\tif (!this.isInteracting) {\n\n\t\t\t// process options\n\t\t\textraOptions = extraOptions || {};\n\t\t\tthis.delay = firstDefined(extraOptions.delay, this.options.delay, 0);\n\t\t\tthis.minDistance = firstDefined(extraOptions.distance, this.options.distance, 0);\n\t\t\tthis.subjectEl = this.options.subjectEl;\n\n\t\t\tthis.isInteracting = true;\n\t\t\tthis.isTouch = isTouch;\n\t\t\tthis.isDelayEnded = false;\n\t\t\tthis.isDistanceSurpassed = false;\n\n\t\t\tthis.originX = getEvX(ev);\n\t\t\tthis.originY = getEvY(ev);\n\t\t\tthis.scrollEl = getScrollParent($(ev.target));\n\n\t\t\tthis.bindHandlers();\n\t\t\tthis.initAutoScroll();\n\t\t\tthis.handleInteractionStart(ev);\n\t\t\tthis.startDelay(ev);\n\n\t\t\tif (!this.minDistance) {\n\t\t\t\tthis.handleDistanceSurpassed(ev);\n\t\t\t}\n\t\t}\n\t},\n\n\n\thandleInteractionStart: function(ev) {\n\t\tthis.trigger('interactionStart', ev);\n\t},\n\n\n\tendInteraction: function(ev, isCancelled) {\n\t\tif (this.isInteracting) {\n\t\t\tthis.endDrag(ev);\n\n\t\t\tif (this.delayTimeoutId) {\n\t\t\t\tclearTimeout(this.delayTimeoutId);\n\t\t\t\tthis.delayTimeoutId = null;\n\t\t\t}\n\n\t\t\tthis.destroyAutoScroll();\n\t\t\tthis.unbindHandlers();\n\n\t\t\tthis.isInteracting = false;\n\t\t\tthis.handleInteractionEnd(ev, isCancelled);\n\n\t\t\t// a touchstart+touchend on the same element will result in the following addition simulated events:\n\t\t\t// mouseover + mouseout + click\n\t\t\t// let's ignore these bogus events\n\t\t\tif (this.isTouch) {\n\t\t\t\tthis.tempIgnoreMouse();\n\t\t\t}\n\t\t}\n\t},\n\n\n\thandleInteractionEnd: function(ev, isCancelled) {\n\t\tthis.trigger('interactionEnd', ev, isCancelled || false);\n\t},\n\n\n\t// Binding To DOM\n\t// -----------------------------------------------------------------------------------------------------------------\n\n\n\tbindHandlers: function() {\n\t\tvar _this = this;\n\t\tvar touchStartIgnores = 1;\n\n\t\tif (this.isTouch) {\n\t\t\tthis.listenTo($(document), {\n\t\t\t\ttouchmove: this.handleTouchMove,\n\t\t\t\ttouchend: this.endInteraction,\n\t\t\t\ttouchcancel: this.endInteraction,\n\n\t\t\t\t// Sometimes touchend doesn't fire\n\t\t\t\t// (can't figure out why. touchcancel doesn't fire either. has to do with scrolling?)\n\t\t\t\t// If another touchstart happens, we know it's bogus, so cancel the drag.\n\t\t\t\t// touchend will continue to be broken until user does a shorttap/scroll, but this is best we can do.\n\t\t\t\ttouchstart: function(ev) {\n\t\t\t\t\tif (touchStartIgnores) { // bindHandlers is called from within a touchstart,\n\t\t\t\t\t\ttouchStartIgnores--; // and we don't want this to fire immediately, so ignore.\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t_this.endInteraction(ev, true); // isCancelled=true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// listen to ALL scroll actions on the page\n\t\t\tif (\n\t\t\t\t!bindAnyScroll(this.handleTouchScrollProxy) && // hopefully this works and short-circuits the rest\n\t\t\t\tthis.scrollEl // otherwise, attach a single handler to this\n\t\t\t) {\n\t\t\t\tthis.listenTo(this.scrollEl, 'scroll', this.handleTouchScroll);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthis.listenTo($(document), {\n\t\t\t\tmousemove: this.handleMouseMove,\n\t\t\t\tmouseup: this.endInteraction\n\t\t\t});\n\t\t}\n\n\t\tthis.listenTo($(document), {\n\t\t\tselectstart: preventDefault, // don't allow selection while dragging\n\t\t\tcontextmenu: preventDefault // long taps would open menu on Chrome dev tools\n\t\t});\n\t},\n\n\n\tunbindHandlers: function() {\n\t\tthis.stopListeningTo($(document));\n\n\t\t// unbind scroll listening\n\t\tunbindAnyScroll(this.handleTouchScrollProxy);\n\t\tif (this.scrollEl) {\n\t\t\tthis.stopListeningTo(this.scrollEl, 'scroll');\n\t\t}\n\t},\n\n\n\t// Drag (high-level)\n\t// -----------------------------------------------------------------------------------------------------------------\n\n\n\t// extraOptions ignored if drag already started\n\tstartDrag: function(ev, extraOptions) {\n\t\tthis.startInteraction(ev, extraOptions); // ensure interaction began\n\n\t\tif (!this.isDragging) {\n\t\t\tthis.isDragging = true;\n\t\t\tthis.handleDragStart(ev);\n\t\t}\n\t},\n\n\n\thandleDragStart: function(ev) {\n\t\tthis.trigger('dragStart', ev);\n\t},\n\n\n\thandleMove: function(ev) {\n\t\tvar dx = getEvX(ev) - this.originX;\n\t\tvar dy = getEvY(ev) - this.originY;\n\t\tvar minDistance = this.minDistance;\n\t\tvar distanceSq; // current distance from the origin, squared\n\n\t\tif (!this.isDistanceSurpassed) {\n\t\t\tdistanceSq = dx * dx + dy * dy;\n\t\t\tif (distanceSq >= minDistance * minDistance) { // use pythagorean theorem\n\t\t\t\tthis.handleDistanceSurpassed(ev);\n\t\t\t}\n\t\t}\n\n\t\tif (this.isDragging) {\n\t\t\tthis.handleDrag(dx, dy, ev);\n\t\t}\n\t},\n\n\n\t// Called while the mouse is being moved and when we know a legitimate drag is taking place\n\thandleDrag: function(dx, dy, ev) {\n\t\tthis.trigger('drag', dx, dy, ev);\n\t\tthis.updateAutoScroll(ev); // will possibly cause scrolling\n\t},\n\n\n\tendDrag: function(ev) {\n\t\tif (this.isDragging) {\n\t\t\tthis.isDragging = false;\n\t\t\tthis.handleDragEnd(ev);\n\t\t}\n\t},\n\n\n\thandleDragEnd: function(ev) {\n\t\tthis.trigger('dragEnd', ev);\n\t},\n\n\n\t// Delay\n\t// -----------------------------------------------------------------------------------------------------------------\n\n\n\tstartDelay: function(initialEv) {\n\t\tvar _this = this;\n\n\t\tif (this.delay) {\n\t\t\tthis.delayTimeoutId = setTimeout(function() {\n\t\t\t\t_this.handleDelayEnd(initialEv);\n\t\t\t}, this.delay);\n\t\t}\n\t\telse {\n\t\t\tthis.handleDelayEnd(initialEv);\n\t\t}\n\t},\n\n\n\thandleDelayEnd: function(initialEv) {\n\t\tthis.isDelayEnded = true;\n\n\t\tif (this.isDistanceSurpassed) {\n\t\t\tthis.startDrag(initialEv);\n\t\t}\n\t},\n\n\n\t// Distance\n\t// -----------------------------------------------------------------------------------------------------------------\n\n\n\thandleDistanceSurpassed: function(ev) {\n\t\tthis.isDistanceSurpassed = true;\n\n\t\tif (this.isDelayEnded) {\n\t\t\tthis.startDrag(ev);\n\t\t}\n\t},\n\n\n\t// Mouse / Touch\n\t// -----------------------------------------------------------------------------------------------------------------\n\n\n\thandleTouchMove: function(ev) {\n\t\t// prevent inertia and touchmove-scrolling while dragging\n\t\tif (this.isDragging) {\n\t\t\tev.preventDefault();\n\t\t}\n\n\t\tthis.handleMove(ev);\n\t},\n\n\n\thandleMouseMove: function(ev) {\n\t\tthis.handleMove(ev);\n\t},\n\n\n\t// Scrolling (unrelated to auto-scroll)\n\t// -----------------------------------------------------------------------------------------------------------------\n\n\n\thandleTouchScroll: function(ev) {\n\t\t// if the drag is being initiated by touch, but a scroll happens before\n\t\t// the drag-initiating delay is over, cancel the drag\n\t\tif (!this.isDragging) {\n\t\t\tthis.endInteraction(ev, true); // isCancelled=true\n\t\t}\n\t},\n\n\n\t// Utils\n\t// -----------------------------------------------------------------------------------------------------------------\n\n\n\t// Triggers a callback. Calls a function in the option hash of the same name.\n\t// Arguments beyond the first `name` are forwarded on.\n\ttrigger: function(name) {\n\t\tif (this.options[name]) {\n\t\t\tthis.options[name].apply(this, Array.prototype.slice.call(arguments, 1));\n\t\t}\n\t\t// makes _methods callable by event name. TODO: kill this\n\t\tif (this['_' + name]) {\n\t\t\tthis['_' + name].apply(this, Array.prototype.slice.call(arguments, 1));\n\t\t}\n\t}\n\n\n});\n\n;;\n/*\nthis.scrollEl is set in DragListener\n*/\nDragListener.mixin({\n\n\tisAutoScroll: false,\n\n\tscrollBounds: null, // { top, bottom, left, right }\n\tscrollTopVel: null, // pixels per second\n\tscrollLeftVel: null, // pixels per second\n\tscrollIntervalId: null, // ID of setTimeout for scrolling animation loop\n\n\t// defaults\n\tscrollSensitivity: 30, // pixels from edge for scrolling to start\n\tscrollSpeed: 200, // pixels per second, at maximum speed\n\tscrollIntervalMs: 50, // millisecond wait between scroll increment\n\n\n\tinitAutoScroll: function() {\n\t\tvar scrollEl = this.scrollEl;\n\n\t\tthis.isAutoScroll =\n\t\t\tthis.options.scroll &&\n\t\t\tscrollEl &&\n\t\t\t!scrollEl.is(window) &&\n\t\t\t!scrollEl.is(document);\n\n\t\tif (this.isAutoScroll) {\n\t\t\t// debounce makes sure rapid calls don't happen\n\t\t\tthis.listenTo(scrollEl, 'scroll', debounce(this.handleDebouncedScroll, 100));\n\t\t}\n\t},\n\n\n\tdestroyAutoScroll: function() {\n\t\tthis.endAutoScroll(); // kill any animation loop\n\n\t\t// remove the scroll handler if there is a scrollEl\n\t\tif (this.isAutoScroll) {\n\t\t\tthis.stopListeningTo(this.scrollEl, 'scroll'); // will probably get removed by unbindHandlers too :(\n\t\t}\n\t},\n\n\n\t// Computes and stores the bounding rectangle of scrollEl\n\tcomputeScrollBounds: function() {\n\t\tif (this.isAutoScroll) {\n\t\t\tthis.scrollBounds = getOuterRect(this.scrollEl);\n\t\t\t// TODO: use getClientRect in future. but prevents auto scrolling when on top of scrollbars\n\t\t}\n\t},\n\n\n\t// Called when the dragging is in progress and scrolling should be updated\n\tupdateAutoScroll: function(ev) {\n\t\tvar sensitivity = this.scrollSensitivity;\n\t\tvar bounds = this.scrollBounds;\n\t\tvar topCloseness, bottomCloseness;\n\t\tvar leftCloseness, rightCloseness;\n\t\tvar topVel = 0;\n\t\tvar leftVel = 0;\n\n\t\tif (bounds) { // only scroll if scrollEl exists\n\n\t\t\t// compute closeness to edges. valid range is from 0.0 - 1.0\n\t\t\ttopCloseness = (sensitivity - (getEvY(ev) - bounds.top)) / sensitivity;\n\t\t\tbottomCloseness = (sensitivity - (bounds.bottom - getEvY(ev))) / sensitivity;\n\t\t\tleftCloseness = (sensitivity - (getEvX(ev) - bounds.left)) / sensitivity;\n\t\t\trightCloseness = (sensitivity - (bounds.right - getEvX(ev))) / sensitivity;\n\n\t\t\t// translate vertical closeness into velocity.\n\t\t\t// mouse must be completely in bounds for velocity to happen.\n\t\t\tif (topCloseness >= 0 && topCloseness <= 1) {\n\t\t\t\ttopVel = topCloseness * this.scrollSpeed * -1; // negative. for scrolling up\n\t\t\t}\n\t\t\telse if (bottomCloseness >= 0 && bottomCloseness <= 1) {\n\t\t\t\ttopVel = bottomCloseness * this.scrollSpeed;\n\t\t\t}\n\n\t\t\t// translate horizontal closeness into velocity\n\t\t\tif (leftCloseness >= 0 && leftCloseness <= 1) {\n\t\t\t\tleftVel = leftCloseness * this.scrollSpeed * -1; // negative. for scrolling left\n\t\t\t}\n\t\t\telse if (rightCloseness >= 0 && rightCloseness <= 1) {\n\t\t\t\tleftVel = rightCloseness * this.scrollSpeed;\n\t\t\t}\n\t\t}\n\n\t\tthis.setScrollVel(topVel, leftVel);\n\t},\n\n\n\t// Sets the speed-of-scrolling for the scrollEl\n\tsetScrollVel: function(topVel, leftVel) {\n\n\t\tthis.scrollTopVel = topVel;\n\t\tthis.scrollLeftVel = leftVel;\n\n\t\tthis.constrainScrollVel(); // massages into realistic values\n\n\t\t// if there is non-zero velocity, and an animation loop hasn't already started, then START\n\t\tif ((this.scrollTopVel || this.scrollLeftVel) && !this.scrollIntervalId) {\n\t\t\tthis.scrollIntervalId = setInterval(\n\t\t\t\tproxy(this, 'scrollIntervalFunc'), // scope to `this`\n\t\t\t\tthis.scrollIntervalMs\n\t\t\t);\n\t\t}\n\t},\n\n\n\t// Forces scrollTopVel and scrollLeftVel to be zero if scrolling has already gone all the way\n\tconstrainScrollVel: function() {\n\t\tvar el = this.scrollEl;\n\n\t\tif (this.scrollTopVel < 0) { // scrolling up?\n\t\t\tif (el.scrollTop() <= 0) { // already scrolled all the way up?\n\t\t\t\tthis.scrollTopVel = 0;\n\t\t\t}\n\t\t}\n\t\telse if (this.scrollTopVel > 0) { // scrolling down?\n\t\t\tif (el.scrollTop() + el[0].clientHeight >= el[0].scrollHeight) { // already scrolled all the way down?\n\t\t\t\tthis.scrollTopVel = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (this.scrollLeftVel < 0) { // scrolling left?\n\t\t\tif (el.scrollLeft() <= 0) { // already scrolled all the left?\n\t\t\t\tthis.scrollLeftVel = 0;\n\t\t\t}\n\t\t}\n\t\telse if (this.scrollLeftVel > 0) { // scrolling right?\n\t\t\tif (el.scrollLeft() + el[0].clientWidth >= el[0].scrollWidth) { // already scrolled all the way right?\n\t\t\t\tthis.scrollLeftVel = 0;\n\t\t\t}\n\t\t}\n\t},\n\n\n\t// This function gets called during every iteration of the scrolling animation loop\n\tscrollIntervalFunc: function() {\n\t\tvar el = this.scrollEl;\n\t\tvar frac = this.scrollIntervalMs / 1000; // considering animation frequency, what the vel should be mult'd by\n\n\t\t// change the value of scrollEl's scroll\n\t\tif (this.scrollTopVel) {\n\t\t\tel.scrollTop(el.scrollTop() + this.scrollTopVel * frac);\n\t\t}\n\t\tif (this.scrollLeftVel) {\n\t\t\tel.scrollLeft(el.scrollLeft() + this.scrollLeftVel * frac);\n\t\t}\n\n\t\tthis.constrainScrollVel(); // since the scroll values changed, recompute the velocities\n\n\t\t// if scrolled all the way, which causes the vels to be zero, stop the animation loop\n\t\tif (!this.scrollTopVel && !this.scrollLeftVel) {\n\t\t\tthis.endAutoScroll();\n\t\t}\n\t},\n\n\n\t// Kills any existing scrolling animation loop\n\tendAutoScroll: function() {\n\t\tif (this.scrollIntervalId) {\n\t\t\tclearInterval(this.scrollIntervalId);\n\t\t\tthis.scrollIntervalId = null;\n\n\t\t\tthis.handleScrollEnd();\n\t\t}\n\t},\n\n\n\t// Get called when the scrollEl is scrolled (NOTE: this is delayed via debounce)\n\thandleDebouncedScroll: function() {\n\t\t// recompute all coordinates, but *only* if this is *not* part of our scrolling animation\n\t\tif (!this.scrollIntervalId) {\n\t\t\tthis.handleScrollEnd();\n\t\t}\n\t},\n\n\n\t// Called when scrolling has stopped, whether through auto scroll, or the user scrolling\n\thandleScrollEnd: function() {\n\t}\n\n});\n;;\n\n/* Tracks mouse movements over a component and raises events about which hit the mouse is over.\n------------------------------------------------------------------------------------------------------------------------\noptions:\n- subjectEl\n- subjectCenter\n*/\n\nvar HitDragListener = DragListener.extend({\n\n\tcomponent: null, // converts coordinates to hits\n\t\t// methods: prepareHits, releaseHits, queryHit\n\n\torigHit: null, // the hit the mouse was over when listening started\n\thit: null, // the hit the mouse is over\n\tcoordAdjust: null, // delta that will be added to the mouse coordinates when computing collisions\n\n\n\tconstructor: function(component, options) {\n\t\tDragListener.call(this, options); // call the super-constructor\n\n\t\tthis.component = component;\n\t},\n\n\n\t// Called when drag listening starts (but a real drag has not necessarily began).\n\t// ev might be undefined if dragging was started manually.\n\thandleInteractionStart: function(ev) {\n\t\tvar subjectEl = this.subjectEl;\n\t\tvar subjectRect;\n\t\tvar origPoint;\n\t\tvar point;\n\n\t\tthis.computeCoords();\n\n\t\tif (ev) {\n\t\t\torigPoint = { left: getEvX(ev), top: getEvY(ev) };\n\t\t\tpoint = origPoint;\n\n\t\t\t// constrain the point to bounds of the element being dragged\n\t\t\tif (subjectEl) {\n\t\t\t\tsubjectRect = getOuterRect(subjectEl); // used for centering as well\n\t\t\t\tpoint = constrainPoint(point, subjectRect);\n\t\t\t}\n\n\t\t\tthis.origHit = this.queryHit(point.left, point.top);\n\n\t\t\t// treat the center of the subject as the collision point?\n\t\t\tif (subjectEl && this.options.subjectCenter) {\n\n\t\t\t\t// only consider the area the subject overlaps the hit. best for large subjects.\n\t\t\t\t// TODO: skip this if hit didn't supply left/right/top/bottom\n\t\t\t\tif (this.origHit) {\n\t\t\t\t\tsubjectRect = intersectRects(this.origHit, subjectRect) ||\n\t\t\t\t\t\tsubjectRect; // in case there is no intersection\n\t\t\t\t}\n\n\t\t\t\tpoint = getRectCenter(subjectRect);\n\t\t\t}\n\n\t\t\tthis.coordAdjust = diffPoints(point, origPoint); // point - origPoint\n\t\t}\n\t\telse {\n\t\t\tthis.origHit = null;\n\t\t\tthis.coordAdjust = null;\n\t\t}\n\n\t\t// call the super-method. do it after origHit has been computed\n\t\tDragListener.prototype.handleInteractionStart.apply(this, arguments);\n\t},\n\n\n\t// Recomputes the drag-critical positions of elements\n\tcomputeCoords: function() {\n\t\tthis.component.prepareHits();\n\t\tthis.computeScrollBounds(); // why is this here??????\n\t},\n\n\n\t// Called when the actual drag has started\n\thandleDragStart: function(ev) {\n\t\tvar hit;\n\n\t\tDragListener.prototype.handleDragStart.apply(this, arguments); // call the super-method\n\n\t\t// might be different from this.origHit if the min-distance is large\n\t\thit = this.queryHit(getEvX(ev), getEvY(ev));\n\n\t\t// report the initial hit the mouse is over\n\t\t// especially important if no min-distance and drag starts immediately\n\t\tif (hit) {\n\t\t\tthis.handleHitOver(hit);\n\t\t}\n\t},\n\n\n\t// Called when the drag moves\n\thandleDrag: function(dx, dy, ev) {\n\t\tvar hit;\n\n\t\tDragListener.prototype.handleDrag.apply(this, arguments); // call the super-method\n\n\t\thit = this.queryHit(getEvX(ev), getEvY(ev));\n\n\t\tif (!isHitsEqual(hit, this.hit)) { // a different hit than before?\n\t\t\tif (this.hit) {\n\t\t\t\tthis.handleHitOut();\n\t\t\t}\n\t\t\tif (hit) {\n\t\t\t\tthis.handleHitOver(hit);\n\t\t\t}\n\t\t}\n\t},\n\n\n\t// Called when dragging has been stopped\n\thandleDragEnd: function() {\n\t\tthis.handleHitDone();\n\t\tDragListener.prototype.handleDragEnd.apply(this, arguments); // call the super-method\n\t},\n\n\n\t// Called when a the mouse has just moved over a new hit\n\thandleHitOver: function(hit) {\n\t\tvar isOrig = isHitsEqual(hit, this.origHit);\n\n\t\tthis.hit = hit;\n\n\t\tthis.trigger('hitOver', this.hit, isOrig, this.origHit);\n\t},\n\n\n\t// Called when the mouse has just moved out of a hit\n\thandleHitOut: function() {\n\t\tif (this.hit) {\n\t\t\tthis.trigger('hitOut', this.hit);\n\t\t\tthis.handleHitDone();\n\t\t\tthis.hit = null;\n\t\t}\n\t},\n\n\n\t// Called after a hitOut. Also called before a dragStop\n\thandleHitDone: function() {\n\t\tif (this.hit) {\n\t\t\tthis.trigger('hitDone', this.hit);\n\t\t}\n\t},\n\n\n\t// Called when the interaction ends, whether there was a real drag or not\n\thandleInteractionEnd: function() {\n\t\tDragListener.prototype.handleInteractionEnd.apply(this, arguments); // call the super-method\n\n\t\tthis.origHit = null;\n\t\tthis.hit = null;\n\n\t\tthis.component.releaseHits();\n\t},\n\n\n\t// Called when scrolling has stopped, whether through auto scroll, or the user scrolling\n\thandleScrollEnd: function() {\n\t\tDragListener.prototype.handleScrollEnd.apply(this, arguments); // call the super-method\n\n\t\tthis.computeCoords(); // hits' absolute positions will be in new places. recompute\n\t},\n\n\n\t// Gets the hit underneath the coordinates for the given mouse event\n\tqueryHit: function(left, top) {\n\n\t\tif (this.coordAdjust) {\n\t\t\tleft += this.coordAdjust.left;\n\t\t\ttop += this.coordAdjust.top;\n\t\t}\n\n\t\treturn this.component.queryHit(left, top);\n\t}\n\n});\n\n\n// Returns `true` if the hits are identically equal. `false` otherwise. Must be from the same component.\n// Two null values will be considered equal, as two \"out of the component\" states are the same.\nfunction isHitsEqual(hit0, hit1) {\n\n\tif (!hit0 && !hit1) {\n\t\treturn true;\n\t}\n\n\tif (hit0 && hit1) {\n\t\treturn hit0.component === hit1.component &&\n\t\t\tisHitPropsWithin(hit0, hit1) &&\n\t\t\tisHitPropsWithin(hit1, hit0); // ensures all props are identical\n\t}\n\n\treturn false;\n}\n\n\n// Returns true if all of subHit's non-standard properties are within superHit\nfunction isHitPropsWithin(subHit, superHit) {\n\tfor (var propName in subHit) {\n\t\tif (!/^(component|left|right|top|bottom)$/.test(propName)) {\n\t\t\tif (subHit[propName] !== superHit[propName]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\n;;\n\n/* Creates a clone of an element and lets it track the mouse as it moves\n----------------------------------------------------------------------------------------------------------------------*/\n\nvar MouseFollower = Class.extend(ListenerMixin, {\n\n\toptions: null,\n\n\tsourceEl: null, // the element that will be cloned and made to look like it is dragging\n\tel: null, // the clone of `sourceEl` that will track the mouse\n\tparentEl: null, // the element that `el` (the clone) will be attached to\n\n\t// the initial position of el, relative to the offset parent. made to match the initial offset of sourceEl\n\ttop0: null,\n\tleft0: null,\n\n\t// the absolute coordinates of the initiating touch/mouse action\n\ty0: null,\n\tx0: null,\n\n\t// the number of pixels the mouse has moved from its initial position\n\ttopDelta: null,\n\tleftDelta: null,\n\n\tisFollowing: false,\n\tisHidden: false,\n\tisAnimating: false, // doing the revert animation?\n\n\tconstructor: function(sourceEl, options) {\n\t\tthis.options = options = options || {};\n\t\tthis.sourceEl = sourceEl;\n\t\tthis.parentEl = options.parentEl ? $(options.parentEl) : sourceEl.parent(); // default to sourceEl's parent\n\t},\n\n\n\t// Causes the element to start following the mouse\n\tstart: function(ev) {\n\t\tif (!this.isFollowing) {\n\t\t\tthis.isFollowing = true;\n\n\t\t\tthis.y0 = getEvY(ev);\n\t\t\tthis.x0 = getEvX(ev);\n\t\t\tthis.topDelta = 0;\n\t\t\tthis.leftDelta = 0;\n\n\t\t\tif (!this.isHidden) {\n\t\t\t\tthis.updatePosition();\n\t\t\t}\n\n\t\t\tif (getEvIsTouch(ev)) {\n\t\t\t\tthis.listenTo($(document), 'touchmove', this.handleMove);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.listenTo($(document), 'mousemove', this.handleMove);\n\t\t\t}\n\t\t}\n\t},\n\n\n\t// Causes the element to stop following the mouse. If shouldRevert is true, will animate back to original position.\n\t// `callback` gets invoked when the animation is complete. If no animation, it is invoked immediately.\n\tstop: function(shouldRevert, callback) {\n\t\tvar _this = this;\n\t\tvar revertDuration = this.options.revertDuration;\n\n\t\tfunction complete() { // might be called by .animate(), which might change `this` context\n\t\t\t_this.isAnimating = false;\n\t\t\t_this.removeElement();\n\n\t\t\t_this.top0 = _this.left0 = null; // reset state for future updatePosition calls\n\n\t\t\tif (callback) {\n\t\t\t\tcallback();\n\t\t\t}\n\t\t}\n\n\t\tif (this.isFollowing && !this.isAnimating) { // disallow more than one stop animation at a time\n\t\t\tthis.isFollowing = false;\n\n\t\t\tthis.stopListeningTo($(document));\n\n\t\t\tif (shouldRevert && revertDuration && !this.isHidden) { // do a revert animation?\n\t\t\t\tthis.isAnimating = true;\n\t\t\t\tthis.el.animate({\n\t\t\t\t\ttop: this.top0,\n\t\t\t\t\tleft: this.left0\n\t\t\t\t}, {\n\t\t\t\t\tduration: revertDuration,\n\t\t\t\t\tcomplete: complete\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcomplete();\n\t\t\t}\n\t\t}\n\t},\n\n\n\t// Gets the tracking element. Create it if necessary\n\tgetEl: function() {\n\t\tvar el = this.el;\n\n\t\tif (!el) {\n\t\t\tel = this.el = this.sourceEl.clone()\n\t\t\t\t.addClass(this.options.additionalClass || '')\n\t\t\t\t.css({\n\t\t\t\t\tposition: 'absolute',\n\t\t\t\t\tvisibility: '', // in case original element was hidden (commonly through hideEvents())\n\t\t\t\t\tdisplay: this.isHidden ? 'none' : '', // for when initially hidden\n\t\t\t\t\tmargin: 0,\n\t\t\t\t\tright: 'auto', // erase and set width instead\n\t\t\t\t\tbottom: 'auto', // erase and set height instead\n\t\t\t\t\twidth: this.sourceEl.width(), // explicit height in case there was a 'right' value\n\t\t\t\t\theight: this.sourceEl.height(), // explicit width in case there was a 'bottom' value\n\t\t\t\t\topacity: this.options.opacity || '',\n\t\t\t\t\tzIndex: this.options.zIndex\n\t\t\t\t});\n\n\t\t\t// we don't want long taps or any mouse interaction causing selection/menus.\n\t\t\t// would use preventSelection(), but that prevents selectstart, causing problems.\n\t\t\tel.addClass('fc-unselectable');\n\n\t\t\tel.appendTo(this.parentEl);\n\t\t}\n\n\t\treturn el;\n\t},\n\n\n\t// Removes the tracking element if it has already been created\n\tremoveElement: function() {\n\t\tif (this.el) {\n\t\t\tthis.el.remove();\n\t\t\tthis.el = null;\n\t\t}\n\t},\n\n\n\t// Update the CSS position of the tracking element\n\tupdatePosition: function() {\n\t\tvar sourceOffset;\n\t\tvar origin;\n\n\t\tthis.getEl(); // ensure this.el\n\n\t\t// make sure origin info was computed\n\t\tif (this.top0 === null) {\n\t\t\tsourceOffset = this.sourceEl.offset();\n\t\t\torigin = this.el.offsetParent().offset();\n\t\t\tthis.top0 = sourceOffset.top - origin.top;\n\t\t\tthis.left0 = sourceOffset.left - origin.left;\n\t\t}\n\n\t\tthis.el.css({\n\t\t\ttop: this.top0 + this.topDelta,\n\t\t\tleft: this.left0 + this.leftDelta\n\t\t});\n\t},\n\n\n\t// Gets called when the user moves the mouse\n\thandleMove: function(ev) {\n\t\tthis.topDelta = getEvY(ev) - this.y0;\n\t\tthis.leftDelta = getEvX(ev) - this.x0;\n\n\t\tif (!this.isHidden) {\n\t\t\tthis.updatePosition();\n\t\t}\n\t},\n\n\n\t// Temporarily makes the tracking element invisible. Can be called before following starts\n\thide: function() {\n\t\tif (!this.isHidden) {\n\t\t\tthis.isHidden = true;\n\t\t\tif (this.el) {\n\t\t\t\tthis.el.hide();\n\t\t\t}\n\t\t}\n\t},\n\n\n\t// Show the tracking element after it has been temporarily hidden\n\tshow: function() {\n\t\tif (this.isHidden) {\n\t\t\tthis.isHidden = false;\n\t\t\tthis.updatePosition();\n\t\t\tthis.getEl().show();\n\t\t}\n\t}\n\n});\n\n;;\n\n/* An abstract class comprised of a \"grid\" of areas that each represent a specific datetime\n----------------------------------------------------------------------------------------------------------------------*/\n\nvar Grid = FC.Grid = Class.extend(ListenerMixin, MouseIgnorerMixin, {\n\n\t// self-config, overridable by subclasses\n\thasDayInteractions: true, // can user click/select ranges of time?\n\n\tview: null, // a View object\n\tisRTL: null, // shortcut to the view's isRTL option\n\n\tstart: null,\n\tend: null,\n\n\tel: null, // the containing element\n\telsByFill: null, // a hash of jQuery element sets used for rendering each fill. Keyed by fill name.\n\n\t// derived from options\n\teventTimeFormat: null,\n\tdisplayEventTime: null,\n\tdisplayEventEnd: null,\n\n\tminResizeDuration: null, // TODO: hack. set by subclasses. minumum event resize duration\n\n\t// if defined, holds the unit identified (ex: \"year\" or \"month\") that determines the level of granularity\n\t// of the date areas. if not defined, assumes to be day and time granularity.\n\t// TODO: port isTimeScale into same system?\n\tlargeUnit: null,\n\n\tdayDragListener: null,\n\tsegDragListener: null,\n\tsegResizeListener: null,\n\texternalDragListener: null,\n\n\n\tconstructor: function(view) {\n\t\tthis.view = view;\n\t\tthis.isRTL = view.opt('isRTL');\n\t\tthis.elsByFill = {};\n\n\t\tthis.dayDragListener = this.buildDayDragListener();\n\t\tthis.initMouseIgnoring();\n\t},\n\n\n\t/* Options\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Generates the format string used for event time text, if not explicitly defined by 'timeFormat'\n\tcomputeEventTimeFormat: function() {\n\t\treturn this.view.opt('smallTimeFormat');\n\t},\n\n\n\t// Determines whether events should have their end times displayed, if not explicitly defined by 'displayEventTime'.\n\t// Only applies to non-all-day events.\n\tcomputeDisplayEventTime: function() {\n\t\treturn true;\n\t},\n\n\n\t// Determines whether events should have their end times displayed, if not explicitly defined by 'displayEventEnd'\n\tcomputeDisplayEventEnd: function() {\n\t\treturn true;\n\t},\n\n\n\t/* Dates\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Tells the grid about what period of time to display.\n\t// Any date-related internal data should be generated.\n\tsetRange: function(range) {\n\t\tthis.start = range.start.clone();\n\t\tthis.end = range.end.clone();\n\n\t\tthis.rangeUpdated();\n\t\tthis.processRangeOptions();\n\t},\n\n\n\t// Called when internal variables that rely on the range should be updated\n\trangeUpdated: function() {\n\t},\n\n\n\t// Updates values that rely on options and also relate to range\n\tprocessRangeOptions: function() {\n\t\tvar view = this.view;\n\t\tvar displayEventTime;\n\t\tvar displayEventEnd;\n\n\t\tthis.eventTimeFormat =\n\t\t\tview.opt('eventTimeFormat') ||\n\t\t\tview.opt('timeFormat') || // deprecated\n\t\t\tthis.computeEventTimeFormat();\n\n\t\tdisplayEventTime = view.opt('displayEventTime');\n\t\tif (displayEventTime == null) {\n\t\t\tdisplayEventTime = this.computeDisplayEventTime(); // might be based off of range\n\t\t}\n\n\t\tdisplayEventEnd = view.opt('displayEventEnd');\n\t\tif (displayEventEnd == null) {\n\t\t\tdisplayEventEnd = this.computeDisplayEventEnd(); // might be based off of range\n\t\t}\n\n\t\tthis.displayEventTime = displayEventTime;\n\t\tthis.displayEventEnd = displayEventEnd;\n\t},\n\n\n\t// Converts a span (has unzoned start/end and any other grid-specific location information)\n\t// into an array of segments (pieces of events whose format is decided by the grid).\n\tspanToSegs: function(span) {\n\t\t// subclasses must implement\n\t},\n\n\n\t// Diffs the two dates, returning a duration, based on granularity of the grid\n\t// TODO: port isTimeScale into this system?\n\tdiffDates: function(a, b) {\n\t\tif (this.largeUnit) {\n\t\t\treturn diffByUnit(a, b, this.largeUnit);\n\t\t}\n\t\telse {\n\t\t\treturn diffDayTime(a, b);\n\t\t}\n\t},\n\n\n\t/* Hit Area\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Called before one or more queryHit calls might happen. Should prepare any cached coordinates for queryHit\n\tprepareHits: function() {\n\t},\n\n\n\t// Called when queryHit calls have subsided. Good place to clear any coordinate caches.\n\treleaseHits: function() {\n\t},\n\n\n\t// Given coordinates from the topleft of the document, return data about the date-related area underneath.\n\t// Can return an object with arbitrary properties (although top/right/left/bottom are encouraged).\n\t// Must have a `grid` property, a reference to this current grid. TODO: avoid this\n\t// The returned object will be processed by getHitSpan and getHitEl.\n\tqueryHit: function(leftOffset, topOffset) {\n\t},\n\n\n\t// Given position-level information about a date-related area within the grid,\n\t// should return an object with at least a start/end date. Can provide other information as well.\n\tgetHitSpan: function(hit) {\n\t},\n\n\n\t// Given position-level information about a date-related area within the grid,\n\t// should return a jQuery element that best represents it. passed to dayClick callback.\n\tgetHitEl: function(hit) {\n\t},\n\n\n\t/* Rendering\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Sets the container element that the grid should render inside of.\n\t// Does other DOM-related initializations.\n\tsetElement: function(el) {\n\t\tthis.el = el;\n\n\t\tif (this.hasDayInteractions) {\n\t\t\tpreventSelection(el);\n\n\t\t\tthis.bindDayHandler('touchstart', this.dayTouchStart);\n\t\t\tthis.bindDayHandler('mousedown', this.dayMousedown);\n\t\t}\n\n\t\t// attach event-element-related handlers. in Grid.events\n\t\t// same garbage collection note as above.\n\t\tthis.bindSegHandlers();\n\n\t\tthis.bindGlobalHandlers();\n\t},\n\n\n\tbindDayHandler: function(name, handler) {\n\t\tvar _this = this;\n\n\t\t// attach a handler to the grid's root element.\n\t\t// jQuery will take care of unregistering them when removeElement gets called.\n\t\tthis.el.on(name, function(ev) {\n\t\t\tif (\n\t\t\t\t!$(ev.target).is(\n\t\t\t\t\t_this.segSelector + ',' + // directly on an event element\n\t\t\t\t\t_this.segSelector + ' *,' + // within an event element\n\t\t\t\t\t'.fc-more,' + // a \"more..\" link\n\t\t\t\t\t'a[data-goto]' // a clickable nav link\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\treturn handler.call(_this, ev);\n\t\t\t}\n\t\t});\n\t},\n\n\n\t// Removes the grid's container element from the DOM. Undoes any other DOM-related attachments.\n\t// DOES NOT remove any content beforehand (doesn't clear events or call unrenderDates), unlike View\n\tremoveElement: function() {\n\t\tthis.unbindGlobalHandlers();\n\t\tthis.clearDragListeners();\n\n\t\tthis.el.remove();\n\n\t\t// NOTE: we don't null-out this.el for the same reasons we don't do it within View::removeElement\n\t},\n\n\n\t// Renders the basic structure of grid view before any content is rendered\n\trenderSkeleton: function() {\n\t\t// subclasses should implement\n\t},\n\n\n\t// Renders the grid's date-related content (like areas that represent days/times).\n\t// Assumes setRange has already been called and the skeleton has already been rendered.\n\trenderDates: function() {\n\t\t// subclasses should implement\n\t},\n\n\n\t// Unrenders the grid's date-related content\n\tunrenderDates: function() {\n\t\t// subclasses should implement\n\t},\n\n\n\t/* Handlers\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Binds DOM handlers to elements that reside outside the grid, such as the document\n\tbindGlobalHandlers: function() {\n\t\tthis.listenTo($(document), {\n\t\t\tdragstart: this.externalDragStart, // jqui\n\t\t\tsortstart: this.externalDragStart // jqui\n\t\t});\n\t},\n\n\n\t// Unbinds DOM handlers from elements that reside outside the grid\n\tunbindGlobalHandlers: function() {\n\t\tthis.stopListeningTo($(document));\n\t},\n\n\n\t// Process a mousedown on an element that represents a day. For day clicking and selecting.\n\tdayMousedown: function(ev) {\n\t\tif (!this.isIgnoringMouse) {\n\t\t\tthis.dayDragListener.startInteraction(ev, {\n\t\t\t\t//distance: 5, // needs more work if we want dayClick to fire correctly\n\t\t\t});\n\t\t}\n\t},\n\n\n\tdayTouchStart: function(ev) {\n\t\tvar view = this.view;\n\n\t\t// HACK to prevent a user's clickaway for unselecting a range or an event\n\t\t// from causing a dayClick.\n\t\tif (view.isSelected || view.selectedEvent) {\n\t\t\tthis.tempIgnoreMouse();\n\t\t}\n\n\t\tthis.dayDragListener.startInteraction(ev, {\n\t\t\tdelay: this.view.opt('longPressDelay')\n\t\t});\n\t},\n\n\n\t// Creates a listener that tracks the user's drag across day elements.\n\t// For day clicking and selecting.\n\tbuildDayDragListener: function() {\n\t\tvar _this = this;\n\t\tvar view = this.view;\n\t\tvar isSelectable = view.opt('selectable');\n\t\tvar dayClickHit; // null if invalid dayClick\n\t\tvar selectionSpan; // null if invalid selection\n\n\t\t// this listener tracks a mousedown on a day element, and a subsequent drag.\n\t\t// if the drag ends on the same day, it is a 'dayClick'.\n\t\t// if 'selectable' is enabled, this listener also detects selections.\n\t\tvar dragListener = new HitDragListener(this, {\n\t\t\tscroll: view.opt('dragScroll'),\n\t\t\tinteractionStart: function() {\n\t\t\t\tdayClickHit = dragListener.origHit; // for dayClick, where no dragging happens\n\t\t\t\tselectionSpan = null;\n\t\t\t},\n\t\t\tdragStart: function() {\n\t\t\t\tview.unselect(); // since we could be rendering a new selection, we want to clear any old one\n\t\t\t},\n\t\t\thitOver: function(hit, isOrig, origHit) {\n\t\t\t\tif (origHit) { // click needs to have started on a hit\n\n\t\t\t\t\t// if user dragged to another cell at any point, it can no longer be a dayClick\n\t\t\t\t\tif (!isOrig) {\n\t\t\t\t\t\tdayClickHit = null;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isSelectable) {\n\t\t\t\t\t\tselectionSpan = _this.computeSelection(\n\t\t\t\t\t\t\t_this.getHitSpan(origHit),\n\t\t\t\t\t\t\t_this.getHitSpan(hit)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (selectionSpan) {\n\t\t\t\t\t\t\t_this.renderSelection(selectionSpan);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (selectionSpan === false) {\n\t\t\t\t\t\t\tdisableCursor();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\thitOut: function() { // called before mouse moves to a different hit OR moved out of all hits\n\t\t\t\tdayClickHit = null;\n\t\t\t\tselectionSpan = null;\n\t\t\t\t_this.unrenderSelection();\n\t\t\t},\n\t\t\thitDone: function() { // called after a hitOut OR before a dragEnd\n\t\t\t\tenableCursor();\n\t\t\t},\n\t\t\tinteractionEnd: function(ev, isCancelled) {\n\t\t\t\tif (!isCancelled) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tdayClickHit &&\n\t\t\t\t\t\t!_this.isIgnoringMouse // see hack in dayTouchStart\n\t\t\t\t\t) {\n\t\t\t\t\t\tview.triggerDayClick(\n\t\t\t\t\t\t\t_this.getHitSpan(dayClickHit),\n\t\t\t\t\t\t\t_this.getHitEl(dayClickHit),\n\t\t\t\t\t\t\tev\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tif (selectionSpan) {\n\t\t\t\t\t\t// the selection will already have been rendered. just report it\n\t\t\t\t\t\tview.reportSelection(selectionSpan, ev);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn dragListener;\n\t},\n\n\n\t// Kills all in-progress dragging.\n\t// Useful for when public API methods that result in re-rendering are invoked during a drag.\n\t// Also useful for when touch devices misbehave and don't fire their touchend.\n\tclearDragListeners: function() {\n\t\tthis.dayDragListener.endInteraction();\n\n\t\tif (this.segDragListener) {\n\t\t\tthis.segDragListener.endInteraction(); // will clear this.segDragListener\n\t\t}\n\t\tif (this.segResizeListener) {\n\t\t\tthis.segResizeListener.endInteraction(); // will clear this.segResizeListener\n\t\t}\n\t\tif (this.externalDragListener) {\n\t\t\tthis.externalDragListener.endInteraction(); // will clear this.externalDragListener\n\t\t}\n\t},\n\n\n\t/* Event Helper\n\t------------------------------------------------------------------------------------------------------------------*/\n\t// TODO: should probably move this to Grid.events, like we did event dragging / resizing\n\n\n\t// Renders a mock event at the given event location, which contains zoned start/end properties.\n\t// Returns all mock event elements.\n\trenderEventLocationHelper: function(eventLocation, sourceSeg) {\n\t\tvar fakeEvent = this.fabricateHelperEvent(eventLocation, sourceSeg);\n\n\t\treturn this.renderHelper(fakeEvent, sourceSeg); // do the actual rendering\n\t},\n\n\n\t// Builds a fake event given zoned event date properties and a segment is should be inspired from.\n\t// The range's end can be null, in which case the mock event that is rendered will have a null end time.\n\t// `sourceSeg` is the internal segment object involved in the drag. If null, something external is dragging.\n\tfabricateHelperEvent: function(eventLocation, sourceSeg) {\n\t\tvar fakeEvent = sourceSeg ? createObject(sourceSeg.event) : {}; // mask the original event object if possible\n\n\t\tfakeEvent.start = eventLocation.start.clone();\n\t\tfakeEvent.end = eventLocation.end ? eventLocation.end.clone() : null;\n\t\tfakeEvent.allDay = null; // force it to be freshly computed by normalizeEventDates\n\t\tthis.view.calendar.normalizeEventDates(fakeEvent);\n\n\t\t// this extra className will be useful for differentiating real events from mock events in CSS\n\t\tfakeEvent.className = (fakeEvent.className || []).concat('fc-helper');\n\n\t\t// if something external is being dragged in, don't render a resizer\n\t\tif (!sourceSeg) {\n\t\t\tfakeEvent.editable = false;\n\t\t}\n\n\t\treturn fakeEvent;\n\t},\n\n\n\t// Renders a mock event. Given zoned event date properties.\n\t// Must return all mock event elements.\n\trenderHelper: function(eventLocation, sourceSeg) {\n\t\t// subclasses must implement\n\t},\n\n\n\t// Unrenders a mock event\n\tunrenderHelper: function() {\n\t\t// subclasses must implement\n\t},\n\n\n\t/* Selection\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Renders a visual indication of a selection. Will highlight by default but can be overridden by subclasses.\n\t// Given a span (unzoned start/end and other misc data)\n\trenderSelection: function(span) {\n\t\tthis.renderHighlight(span);\n\t},\n\n\n\t// Unrenders any visual indications of a selection. Will unrender a highlight by default.\n\tunrenderSelection: function() {\n\t\tthis.unrenderHighlight();\n\t},\n\n\n\t// Given the first and last date-spans of a selection, returns another date-span object.\n\t// Subclasses can override and provide additional data in the span object. Will be passed to renderSelection().\n\t// Will return false if the selection is invalid and this should be indicated to the user.\n\t// Will return null/undefined if a selection invalid but no error should be reported.\n\tcomputeSelection: function(span0, span1) {\n\t\tvar span = this.computeSelectionSpan(span0, span1);\n\n\t\tif (span && !this.view.calendar.isSelectionSpanAllowed(span)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn span;\n\t},\n\n\n\t// Given two spans, must return the combination of the two.\n\t// TODO: do this separation of concerns (combining VS validation) for event dnd/resize too.\n\tcomputeSelectionSpan: function(span0, span1) {\n\t\tvar dates = [ span0.start, span0.end, span1.start, span1.end ];\n\n\t\tdates.sort(compareNumbers); // sorts chronologically. works with Moments\n\n\t\treturn { start: dates[0].clone(), end: dates[3].clone() };\n\t},\n\n\n\t/* Highlight\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Renders an emphasis on the given date range. Given a span (unzoned start/end and other misc data)\n\trenderHighlight: function(span) {\n\t\tthis.renderFill('highlight', this.spanToSegs(span));\n\t},\n\n\n\t// Unrenders the emphasis on a date range\n\tunrenderHighlight: function() {\n\t\tthis.unrenderFill('highlight');\n\t},\n\n\n\t// Generates an array of classNames for rendering the highlight. Used by the fill system.\n\thighlightSegClasses: function() {\n\t\treturn [ 'fc-highlight' ];\n\t},\n\n\n\t/* Business Hours\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\trenderBusinessHours: function() {\n\t},\n\n\n\tunrenderBusinessHours: function() {\n\t},\n\n\n\t/* Now Indicator\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\tgetNowIndicatorUnit: function() {\n\t},\n\n\n\trenderNowIndicator: function(date) {\n\t},\n\n\n\tunrenderNowIndicator: function() {\n\t},\n\n\n\t/* Fill System (highlight, background events, business hours)\n\t--------------------------------------------------------------------------------------------------------------------\n\tTODO: remove this system. like we did in TimeGrid\n\t*/\n\n\n\t// Renders a set of rectangles over the given segments of time.\n\t// MUST RETURN a subset of segs, the segs that were actually rendered.\n\t// Responsible for populating this.elsByFill. TODO: better API for expressing this requirement\n\trenderFill: function(type, segs) {\n\t\t// subclasses must implement\n\t},\n\n\n\t// Unrenders a specific type of fill that is currently rendered on the grid\n\tunrenderFill: function(type) {\n\t\tvar el = this.elsByFill[type];\n\n\t\tif (el) {\n\t\t\tel.remove();\n\t\t\tdelete this.elsByFill[type];\n\t\t}\n\t},\n\n\n\t// Renders and assigns an `el` property for each fill segment. Generic enough to work with different types.\n\t// Only returns segments that successfully rendered.\n\t// To be harnessed by renderFill (implemented by subclasses).\n\t// Analagous to renderFgSegEls.\n\trenderFillSegEls: function(type, segs) {\n\t\tvar _this = this;\n\t\tvar segElMethod = this[type + 'SegEl'];\n\t\tvar html = '';\n\t\tvar renderedSegs = [];\n\t\tvar i;\n\n\t\tif (segs.length) {\n\n\t\t\t// build a large concatenation of segment HTML\n\t\t\tfor (i = 0; i < segs.length; i++) {\n\t\t\t\thtml += this.fillSegHtml(type, segs[i]);\n\t\t\t}\n\n\t\t\t// Grab individual elements from the combined HTML string. Use each as the default rendering.\n\t\t\t// Then, compute the 'el' for each segment.\n\t\t\t$(html).each(function(i, node) {\n\t\t\t\tvar seg = segs[i];\n\t\t\t\tvar el = $(node);\n\n\t\t\t\t// allow custom filter methods per-type\n\t\t\t\tif (segElMethod) {\n\t\t\t\t\tel = segElMethod.call(_this, seg, el);\n\t\t\t\t}\n\n\t\t\t\tif (el) { // custom filters did not cancel the render\n\t\t\t\t\tel = $(el); // allow custom filter to return raw DOM node\n\n\t\t\t\t\t// correct element type? (would be bad if a non-TD were inserted into a table for example)\n\t\t\t\t\tif (el.is(_this.fillSegTag)) {\n\t\t\t\t\t\tseg.el = el;\n\t\t\t\t\t\trenderedSegs.push(seg);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn renderedSegs;\n\t},\n\n\n\tfillSegTag: 'div', // subclasses can override\n\n\n\t// Builds the HTML needed for one fill segment. Generic enough to work with different types.\n\tfillSegHtml: function(type, seg) {\n\n\t\t// custom hooks per-type\n\t\tvar classesMethod = this[type + 'SegClasses'];\n\t\tvar cssMethod = this[type + 'SegCss'];\n\n\t\tvar classes = classesMethod ? classesMethod.call(this, seg) : [];\n\t\tvar css = cssToStr(cssMethod ? cssMethod.call(this, seg) : {});\n\n\t\treturn '<' + this.fillSegTag +\n\t\t\t(classes.length ? ' class=\"' + classes.join(' ') + '\"' : '') +\n\t\t\t(css ? ' style=\"' + css + '\"' : '') +\n\t\t\t' />';\n\t},\n\n\n\n\t/* Generic rendering utilities for subclasses\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Computes HTML classNames for a single-day element\n\tgetDayClasses: function(date) {\n\t\tvar view = this.view;\n\t\tvar today = view.calendar.getNow();\n\t\tvar classes = [ 'fc-' + dayIDs[date.day()] ];\n\n\t\tif (\n\t\t\tview.intervalDuration.as('months') == 1 &&\n\t\t\tdate.month() != view.intervalStart.month()\n\t\t) {\n\t\t\tclasses.push('fc-other-month');\n\t\t}\n\n\t\tif (date.isSame(today, 'day')) {\n\t\t\tclasses.push(\n\t\t\t\t'fc-today',\n\t\t\t\tview.highlightStateClass\n\t\t\t);\n\t\t}\n\t\telse if (date < today) {\n\t\t\tclasses.push('fc-past');\n\t\t}\n\t\telse {\n\t\t\tclasses.push('fc-future');\n\t\t}\n\n\t\treturn classes;\n\t}\n\n});\n\n;;\n\n/* Event-rendering and event-interaction methods for the abstract Grid class\n----------------------------------------------------------------------------------------------------------------------*/\n\nGrid.mixin({\n\n\t// self-config, overridable by subclasses\n\tsegSelector: '.fc-event-container > *', // what constitutes an event element?\n\n\tmousedOverSeg: null, // the segment object the user's mouse is over. null if over nothing\n\tisDraggingSeg: false, // is a segment being dragged? boolean\n\tisResizingSeg: false, // is a segment being resized? boolean\n\tisDraggingExternal: false, // jqui-dragging an external element? boolean\n\tsegs: null, // the *event* segments currently rendered in the grid. TODO: rename to `eventSegs`\n\n\n\t// Renders the given events onto the grid\n\trenderEvents: function(events) {\n\t\tvar bgEvents = [];\n\t\tvar fgEvents = [];\n\t\tvar i;\n\n\t\tfor (i = 0; i < events.length; i++) {\n\t\t\t(isBgEvent(events[i]) ? bgEvents : fgEvents).push(events[i]);\n\t\t}\n\n\t\tthis.segs = [].concat( // record all segs\n\t\t\tthis.renderBgEvents(bgEvents),\n\t\t\tthis.renderFgEvents(fgEvents)\n\t\t);\n\t},\n\n\n\trenderBgEvents: function(events) {\n\t\tvar segs = this.eventsToSegs(events);\n\n\t\t// renderBgSegs might return a subset of segs, segs that were actually rendered\n\t\treturn this.renderBgSegs(segs) || segs;\n\t},\n\n\n\trenderFgEvents: function(events) {\n\t\tvar segs = this.eventsToSegs(events);\n\n\t\t// renderFgSegs might return a subset of segs, segs that were actually rendered\n\t\treturn this.renderFgSegs(segs) || segs;\n\t},\n\n\n\t// Unrenders all events currently rendered on the grid\n\tunrenderEvents: function() {\n\t\tthis.handleSegMouseout(); // trigger an eventMouseout if user's mouse is over an event\n\t\tthis.clearDragListeners();\n\n\t\tthis.unrenderFgSegs();\n\t\tthis.unrenderBgSegs();\n\n\t\tthis.segs = null;\n\t},\n\n\n\t// Retrieves all rendered segment objects currently rendered on the grid\n\tgetEventSegs: function() {\n\t\treturn this.segs || [];\n\t},\n\n\n\t/* Foreground Segment Rendering\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Renders foreground event segments onto the grid. May return a subset of segs that were rendered.\n\trenderFgSegs: function(segs) {\n\t\t// subclasses must implement\n\t},\n\n\n\t// Unrenders all currently rendered foreground segments\n\tunrenderFgSegs: function() {\n\t\t// subclasses must implement\n\t},\n\n\n\t// Renders and assigns an `el` property for each foreground event segment.\n\t// Only returns segments that successfully rendered.\n\t// A utility that subclasses may use.\n\trenderFgSegEls: function(segs, disableResizing) {\n\t\tvar view = this.view;\n\t\tvar html = '';\n\t\tvar renderedSegs = [];\n\t\tvar i;\n\n\t\tif (segs.length) { // don't build an empty html string\n\n\t\t\t// build a large concatenation of event segment HTML\n\t\t\tfor (i = 0; i < segs.length; i++) {\n\t\t\t\thtml += this.fgSegHtml(segs[i], disableResizing);\n\t\t\t}\n\n\t\t\t// Grab individual elements from the combined HTML string. Use each as the default rendering.\n\t\t\t// Then, compute the 'el' for each segment. An el might be null if the eventRender callback returned false.\n\t\t\t$(html).each(function(i, node) {\n\t\t\t\tvar seg = segs[i];\n\t\t\t\tvar el = view.resolveEventEl(seg.event, $(node));\n\n\t\t\t\tif (el) {\n\t\t\t\t\tel.data('fc-seg', seg); // used by handlers\n\t\t\t\t\tseg.el = el;\n\t\t\t\t\trenderedSegs.push(seg);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn renderedSegs;\n\t},\n\n\n\t// Generates the HTML for the default rendering of a foreground event segment. Used by renderFgSegEls()\n\tfgSegHtml: function(seg, disableResizing) {\n\t\t// subclasses should implement\n\t},\n\n\n\t/* Background Segment Rendering\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Renders the given background event segments onto the grid.\n\t// Returns a subset of the segs that were actually rendered.\n\trenderBgSegs: function(segs) {\n\t\treturn this.renderFill('bgEvent', segs);\n\t},\n\n\n\t// Unrenders all the currently rendered background event segments\n\tunrenderBgSegs: function() {\n\t\tthis.unrenderFill('bgEvent');\n\t},\n\n\n\t// Renders a background event element, given the default rendering. Called by the fill system.\n\tbgEventSegEl: function(seg, el) {\n\t\treturn this.view.resolveEventEl(seg.event, el); // will filter through eventRender\n\t},\n\n\n\t// Generates an array of classNames to be used for the default rendering of a background event.\n\t// Called by fillSegHtml.\n\tbgEventSegClasses: function(seg) {\n\t\tvar event = seg.event;\n\t\tvar source = event.source || {};\n\n\t\treturn [ 'fc-bgevent' ].concat(\n\t\t\tevent.className,\n\t\t\tsource.className || []\n\t\t);\n\t},\n\n\n\t// Generates a semicolon-separated CSS string to be used for the default rendering of a background event.\n\t// Called by fillSegHtml.\n\tbgEventSegCss: function(seg) {\n\t\treturn {\n\t\t\t'background-color': this.getSegSkinCss(seg)['background-color']\n\t\t};\n\t},\n\n\n\t// Generates an array of classNames to be used for the rendering business hours overlay. Called by the fill system.\n\t// Called by fillSegHtml.\n\tbusinessHoursSegClasses: function(seg) {\n\t\treturn [ 'fc-nonbusiness', 'fc-bgevent' ];\n\t},\n\n\n\t/* Business Hours\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Compute business hour segs for the grid's current date range.\n\t// Caller must ask if whole-day business hours are needed.\n\tbuildBusinessHourSegs: function(wholeDay) {\n\t\tvar events = this.view.calendar.getCurrentBusinessHourEvents(wholeDay);\n\n\t\t// HACK. Eventually refactor business hours \"events\" system.\n\t\t// If no events are given, but businessHours is activated, this means the entire visible range should be\n\t\t// marked as *not* business-hours, via inverse-background rendering.\n\t\tif (\n\t\t\t!events.length &&\n\t\t\tthis.view.calendar.options.businessHours // don't access view option. doesn't update with dynamic options\n\t\t) {\n\t\t\tevents = [\n\t\t\t\t$.extend({}, BUSINESS_HOUR_EVENT_DEFAULTS, {\n\t\t\t\t\tstart: this.view.end, // guaranteed out-of-range\n\t\t\t\t\tend: this.view.end,   // \"\n\t\t\t\t\tdow: null\n\t\t\t\t})\n\t\t\t];\n\t\t}\n\n\t\treturn this.eventsToSegs(events);\n\t},\n\n\n\t/* Handlers\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Attaches event-element-related handlers for *all* rendered event segments of the view.\n\tbindSegHandlers: function() {\n\t\tthis.bindSegHandlersToEl(this.el);\n\t},\n\n\n\t// Attaches event-element-related handlers to an arbitrary container element. leverages bubbling.\n\tbindSegHandlersToEl: function(el) {\n\t\tthis.bindSegHandlerToEl(el, 'touchstart', this.handleSegTouchStart);\n\t\tthis.bindSegHandlerToEl(el, 'touchend', this.handleSegTouchEnd);\n\t\tthis.bindSegHandlerToEl(el, 'mouseenter', this.handleSegMouseover);\n\t\tthis.bindSegHandlerToEl(el, 'mouseleave', this.handleSegMouseout);\n\t\tthis.bindSegHandlerToEl(el, 'mousedown', this.handleSegMousedown);\n\t\tthis.bindSegHandlerToEl(el, 'click', this.handleSegClick);\n\t},\n\n\n\t// Executes a handler for any a user-interaction on a segment.\n\t// Handler gets called with (seg, ev), and with the `this` context of the Grid\n\tbindSegHandlerToEl: function(el, name, handler) {\n\t\tvar _this = this;\n\n\t\tel.on(name, this.segSelector, function(ev) {\n\t\t\tvar seg = $(this).data('fc-seg'); // grab segment data. put there by View::renderEvents\n\n\t\t\t// only call the handlers if there is not a drag/resize in progress\n\t\t\tif (seg && !_this.isDraggingSeg && !_this.isResizingSeg) {\n\t\t\t\treturn handler.call(_this, seg, ev); // context will be the Grid\n\t\t\t}\n\t\t});\n\t},\n\n\n\thandleSegClick: function(seg, ev) {\n\t\tvar res = this.view.trigger('eventClick', seg.el[0], seg.event, ev); // can return `false` to cancel\n\t\tif (res === false) {\n\t\t\tev.preventDefault();\n\t\t}\n\t},\n\n\n\t// Updates internal state and triggers handlers for when an event element is moused over\n\thandleSegMouseover: function(seg, ev) {\n\t\tif (\n\t\t\t!this.isIgnoringMouse &&\n\t\t\t!this.mousedOverSeg\n\t\t) {\n\t\t\tthis.mousedOverSeg = seg;\n\t\t\tif (this.view.isEventResizable(seg.event)) {\n\t\t\t\tseg.el.addClass('fc-allow-mouse-resize');\n\t\t\t}\n\t\t\tthis.view.trigger('eventMouseover', seg.el[0], seg.event, ev);\n\t\t}\n\t},\n\n\n\t// Updates internal state and triggers handlers for when an event element is moused out.\n\t// Can be given no arguments, in which case it will mouseout the segment that was previously moused over.\n\thandleSegMouseout: function(seg, ev) {\n\t\tev = ev || {}; // if given no args, make a mock mouse event\n\n\t\tif (this.mousedOverSeg) {\n\t\t\tseg = seg || this.mousedOverSeg; // if given no args, use the currently moused-over segment\n\t\t\tthis.mousedOverSeg = null;\n\t\t\tif (this.view.isEventResizable(seg.event)) {\n\t\t\t\tseg.el.removeClass('fc-allow-mouse-resize');\n\t\t\t}\n\t\t\tthis.view.trigger('eventMouseout', seg.el[0], seg.event, ev);\n\t\t}\n\t},\n\n\n\thandleSegMousedown: function(seg, ev) {\n\t\tvar isResizing = this.startSegResize(seg, ev, { distance: 5 });\n\n\t\tif (!isResizing && this.view.isEventDraggable(seg.event)) {\n\t\t\tthis.buildSegDragListener(seg)\n\t\t\t\t.startInteraction(ev, {\n\t\t\t\t\tdistance: 5\n\t\t\t\t});\n\t\t}\n\t},\n\n\n\thandleSegTouchStart: function(seg, ev) {\n\t\tvar view = this.view;\n\t\tvar event = seg.event;\n\t\tvar isSelected = view.isEventSelected(event);\n\t\tvar isDraggable = view.isEventDraggable(event);\n\t\tvar isResizable = view.isEventResizable(event);\n\t\tvar isResizing = false;\n\t\tvar dragListener;\n\n\t\tif (isSelected && isResizable) {\n\t\t\t// only allow resizing of the event is selected\n\t\t\tisResizing = this.startSegResize(seg, ev);\n\t\t}\n\n\t\tif (!isResizing && (isDraggable || isResizable)) { // allowed to be selected?\n\n\t\t\tdragListener = isDraggable ?\n\t\t\t\tthis.buildSegDragListener(seg) :\n\t\t\t\tthis.buildSegSelectListener(seg); // seg isn't draggable, but still needs to be selected\n\n\t\t\tdragListener.startInteraction(ev, { // won't start if already started\n\t\t\t\tdelay: isSelected ? 0 : this.view.opt('longPressDelay') // do delay if not already selected\n\t\t\t});\n\t\t}\n\n\t\t// a long tap simulates a mouseover. ignore this bogus mouseover.\n\t\tthis.tempIgnoreMouse();\n\t},\n\n\n\thandleSegTouchEnd: function(seg, ev) {\n\t\t// touchstart+touchend = click, which simulates a mouseover.\n\t\t// ignore this bogus mouseover.\n\t\tthis.tempIgnoreMouse();\n\t},\n\n\n\t// returns boolean whether resizing actually started or not.\n\t// assumes the seg allows resizing.\n\t// `dragOptions` are optional.\n\tstartSegResize: function(seg, ev, dragOptions) {\n\t\tif ($(ev.target).is('.fc-resizer')) {\n\t\t\tthis.buildSegResizeListener(seg, $(ev.target).is('.fc-start-resizer'))\n\t\t\t\t.startInteraction(ev, dragOptions);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\n\n\t/* Event Dragging\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Builds a listener that will track user-dragging on an event segment.\n\t// Generic enough to work with any type of Grid.\n\t// Has side effect of setting/unsetting `segDragListener`\n\tbuildSegDragListener: function(seg) {\n\t\tvar _this = this;\n\t\tvar view = this.view;\n\t\tvar calendar = view.calendar;\n\t\tvar el = seg.el;\n\t\tvar event = seg.event;\n\t\tvar isDragging;\n\t\tvar mouseFollower; // A clone of the original element that will move with the mouse\n\t\tvar dropLocation; // zoned event date properties\n\n\t\tif (this.segDragListener) {\n\t\t\treturn this.segDragListener;\n\t\t}\n\n\t\t// Tracks mouse movement over the *view's* coordinate map. Allows dragging and dropping between subcomponents\n\t\t// of the view.\n\t\tvar dragListener = this.segDragListener = new HitDragListener(view, {\n\t\t\tscroll: view.opt('dragScroll'),\n\t\t\tsubjectEl: el,\n\t\t\tsubjectCenter: true,\n\t\t\tinteractionStart: function(ev) {\n\t\t\t\tseg.component = _this; // for renderDrag\n\t\t\t\tisDragging = false;\n\t\t\t\tmouseFollower = new MouseFollower(seg.el, {\n\t\t\t\t\tadditionalClass: 'fc-dragging',\n\t\t\t\t\tparentEl: view.el,\n\t\t\t\t\topacity: dragListener.isTouch ? null : view.opt('dragOpacity'),\n\t\t\t\t\trevertDuration: view.opt('dragRevertDuration'),\n\t\t\t\t\tzIndex: 2 // one above the .fc-view\n\t\t\t\t});\n\t\t\t\tmouseFollower.hide(); // don't show until we know this is a real drag\n\t\t\t\tmouseFollower.start(ev);\n\t\t\t},\n\t\t\tdragStart: function(ev) {\n\t\t\t\tif (dragListener.isTouch && !view.isEventSelected(event)) {\n\t\t\t\t\t// if not previously selected, will fire after a delay. then, select the event\n\t\t\t\t\tview.selectEvent(event);\n\t\t\t\t}\n\t\t\t\tisDragging = true;\n\t\t\t\t_this.handleSegMouseout(seg, ev); // ensure a mouseout on the manipulated event has been reported\n\t\t\t\t_this.segDragStart(seg, ev);\n\t\t\t\tview.hideEvent(event); // hide all event segments. our mouseFollower will take over\n\t\t\t},\n\t\t\thitOver: function(hit, isOrig, origHit) {\n\t\t\t\tvar dragHelperEls;\n\n\t\t\t\t// starting hit could be forced (DayGrid.limit)\n\t\t\t\tif (seg.hit) {\n\t\t\t\t\torigHit = seg.hit;\n\t\t\t\t}\n\n\t\t\t\t// since we are querying the parent view, might not belong to this grid\n\t\t\t\tdropLocation = _this.computeEventDrop(\n\t\t\t\t\torigHit.component.getHitSpan(origHit),\n\t\t\t\t\thit.component.getHitSpan(hit),\n\t\t\t\t\tevent\n\t\t\t\t);\n\n\t\t\t\tif (dropLocation && !calendar.isEventSpanAllowed(_this.eventToSpan(dropLocation), event)) {\n\t\t\t\t\tdisableCursor();\n\t\t\t\t\tdropLocation = null;\n\t\t\t\t}\n\n\t\t\t\t// if a valid drop location, have the subclass render a visual indication\n\t\t\t\tif (dropLocation && (dragHelperEls = view.renderDrag(dropLocation, seg))) {\n\n\t\t\t\t\tdragHelperEls.addClass('fc-dragging');\n\t\t\t\t\tif (!dragListener.isTouch) {\n\t\t\t\t\t\t_this.applyDragOpacity(dragHelperEls);\n\t\t\t\t\t}\n\n\t\t\t\t\tmouseFollower.hide(); // if the subclass is already using a mock event \"helper\", hide our own\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmouseFollower.show(); // otherwise, have the helper follow the mouse (no snapping)\n\t\t\t\t}\n\n\t\t\t\tif (isOrig) {\n\t\t\t\t\tdropLocation = null; // needs to have moved hits to be a valid drop\n\t\t\t\t}\n\t\t\t},\n\t\t\thitOut: function() { // called before mouse moves to a different hit OR moved out of all hits\n\t\t\t\tview.unrenderDrag(); // unrender whatever was done in renderDrag\n\t\t\t\tmouseFollower.show(); // show in case we are moving out of all hits\n\t\t\t\tdropLocation = null;\n\t\t\t},\n\t\t\thitDone: function() { // Called after a hitOut OR before a dragEnd\n\t\t\t\tenableCursor();\n\t\t\t},\n\t\t\tinteractionEnd: function(ev) {\n\t\t\t\tdelete seg.component; // prevent side effects\n\n\t\t\t\t// do revert animation if hasn't changed. calls a callback when finished (whether animation or not)\n\t\t\t\tmouseFollower.stop(!dropLocation, function() {\n\t\t\t\t\tif (isDragging) {\n\t\t\t\t\t\tview.unrenderDrag();\n\t\t\t\t\t\tview.showEvent(event);\n\t\t\t\t\t\t_this.segDragStop(seg, ev);\n\t\t\t\t\t}\n\t\t\t\t\tif (dropLocation) {\n\t\t\t\t\t\tview.reportEventDrop(event, dropLocation, this.largeUnit, el, ev);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t_this.segDragListener = null;\n\t\t\t}\n\t\t});\n\n\t\treturn dragListener;\n\t},\n\n\n\t// seg isn't draggable, but let's use a generic DragListener\n\t// simply for the delay, so it can be selected.\n\t// Has side effect of setting/unsetting `segDragListener`\n\tbuildSegSelectListener: function(seg) {\n\t\tvar _this = this;\n\t\tvar view = this.view;\n\t\tvar event = seg.event;\n\n\t\tif (this.segDragListener) {\n\t\t\treturn this.segDragListener;\n\t\t}\n\n\t\tvar dragListener = this.segDragListener = new DragListener({\n\t\t\tdragStart: function(ev) {\n\t\t\t\tif (dragListener.isTouch && !view.isEventSelected(event)) {\n\t\t\t\t\t// if not previously selected, will fire after a delay. then, select the event\n\t\t\t\t\tview.selectEvent(event);\n\t\t\t\t}\n\t\t\t},\n\t\t\tinteractionEnd: function(ev) {\n\t\t\t\t_this.segDragListener = null;\n\t\t\t}\n\t\t});\n\n\t\treturn dragListener;\n\t},\n\n\n\t// Called before event segment dragging starts\n\tsegDragStart: function(seg, ev) {\n\t\tthis.isDraggingSeg = true;\n\t\tthis.view.trigger('eventDragStart', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy\n\t},\n\n\n\t// Called after event segment dragging stops\n\tsegDragStop: function(seg, ev) {\n\t\tthis.isDraggingSeg = false;\n\t\tthis.view.trigger('eventDragStop', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy\n\t},\n\n\n\t// Given the spans an event drag began, and the span event was dropped, calculates the new zoned start/end/allDay\n\t// values for the event. Subclasses may override and set additional properties to be used by renderDrag.\n\t// A falsy returned value indicates an invalid drop.\n\t// DOES NOT consider overlap/constraint.\n\tcomputeEventDrop: function(startSpan, endSpan, event) {\n\t\tvar calendar = this.view.calendar;\n\t\tvar dragStart = startSpan.start;\n\t\tvar dragEnd = endSpan.start;\n\t\tvar delta;\n\t\tvar dropLocation; // zoned event date properties\n\n\t\tif (dragStart.hasTime() === dragEnd.hasTime()) {\n\t\t\tdelta = this.diffDates(dragEnd, dragStart);\n\n\t\t\t// if an all-day event was in a timed area and it was dragged to a different time,\n\t\t\t// guarantee an end and adjust start/end to have times\n\t\t\tif (event.allDay && durationHasTime(delta)) {\n\t\t\t\tdropLocation = {\n\t\t\t\t\tstart: event.start.clone(),\n\t\t\t\t\tend: calendar.getEventEnd(event), // will be an ambig day\n\t\t\t\t\tallDay: false // for normalizeEventTimes\n\t\t\t\t};\n\t\t\t\tcalendar.normalizeEventTimes(dropLocation);\n\t\t\t}\n\t\t\t// othewise, work off existing values\n\t\t\telse {\n\t\t\t\tdropLocation = pluckEventDateProps(event);\n\t\t\t}\n\n\t\t\tdropLocation.start.add(delta);\n\t\t\tif (dropLocation.end) {\n\t\t\t\tdropLocation.end.add(delta);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// if switching from day <-> timed, start should be reset to the dropped date, and the end cleared\n\t\t\tdropLocation = {\n\t\t\t\tstart: dragEnd.clone(),\n\t\t\t\tend: null, // end should be cleared\n\t\t\t\tallDay: !dragEnd.hasTime()\n\t\t\t};\n\t\t}\n\n\t\treturn dropLocation;\n\t},\n\n\n\t// Utility for apply dragOpacity to a jQuery set\n\tapplyDragOpacity: function(els) {\n\t\tvar opacity = this.view.opt('dragOpacity');\n\n\t\tif (opacity != null) {\n\t\t\tels.css('opacity', opacity);\n\t\t}\n\t},\n\n\n\t/* External Element Dragging\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Called when a jQuery UI drag is initiated anywhere in the DOM\n\texternalDragStart: function(ev, ui) {\n\t\tvar view = this.view;\n\t\tvar el;\n\t\tvar accept;\n\n\t\tif (view.opt('droppable')) { // only listen if this setting is on\n\t\t\tel = $((ui ? ui.item : null) || ev.target);\n\n\t\t\t// Test that the dragged element passes the dropAccept selector or filter function.\n\t\t\t// FYI, the default is \"*\" (matches all)\n\t\t\taccept = view.opt('dropAccept');\n\t\t\tif ($.isFunction(accept) ? accept.call(el[0], el) : el.is(accept)) {\n\t\t\t\tif (!this.isDraggingExternal) { // prevent double-listening if fired twice\n\t\t\t\t\tthis.listenToExternalDrag(el, ev, ui);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\n\t// Called when a jQuery UI drag starts and it needs to be monitored for dropping\n\tlistenToExternalDrag: function(el, ev, ui) {\n\t\tvar _this = this;\n\t\tvar calendar = this.view.calendar;\n\t\tvar meta = getDraggedElMeta(el); // extra data about event drop, including possible event to create\n\t\tvar dropLocation; // a null value signals an unsuccessful drag\n\n\t\t// listener that tracks mouse movement over date-associated pixel regions\n\t\tvar dragListener = _this.externalDragListener = new HitDragListener(this, {\n\t\t\tinteractionStart: function() {\n\t\t\t\t_this.isDraggingExternal = true;\n\t\t\t},\n\t\t\thitOver: function(hit) {\n\t\t\t\tdropLocation = _this.computeExternalDrop(\n\t\t\t\t\thit.component.getHitSpan(hit), // since we are querying the parent view, might not belong to this grid\n\t\t\t\t\tmeta\n\t\t\t\t);\n\n\t\t\t\tif ( // invalid hit?\n\t\t\t\t\tdropLocation &&\n\t\t\t\t\t!calendar.isExternalSpanAllowed(_this.eventToSpan(dropLocation), dropLocation, meta.eventProps)\n\t\t\t\t) {\n\t\t\t\t\tdisableCursor();\n\t\t\t\t\tdropLocation = null;\n\t\t\t\t}\n\n\t\t\t\tif (dropLocation) {\n\t\t\t\t\t_this.renderDrag(dropLocation); // called without a seg parameter\n\t\t\t\t}\n\t\t\t},\n\t\t\thitOut: function() {\n\t\t\t\tdropLocation = null; // signal unsuccessful\n\t\t\t},\n\t\t\thitDone: function() { // Called after a hitOut OR before a dragEnd\n\t\t\t\tenableCursor();\n\t\t\t\t_this.unrenderDrag();\n\t\t\t},\n\t\t\tinteractionEnd: function(ev) {\n\t\t\t\tif (dropLocation) { // element was dropped on a valid hit\n\t\t\t\t\t_this.view.reportExternalDrop(meta, dropLocation, el, ev, ui);\n\t\t\t\t}\n\t\t\t\t_this.isDraggingExternal = false;\n\t\t\t\t_this.externalDragListener = null;\n\t\t\t}\n\t\t});\n\n\t\tdragListener.startDrag(ev); // start listening immediately\n\t},\n\n\n\t// Given a hit to be dropped upon, and misc data associated with the jqui drag (guaranteed to be a plain object),\n\t// returns the zoned start/end dates for the event that would result from the hypothetical drop. end might be null.\n\t// Returning a null value signals an invalid drop hit.\n\t// DOES NOT consider overlap/constraint.\n\tcomputeExternalDrop: function(span, meta) {\n\t\tvar calendar = this.view.calendar;\n\t\tvar dropLocation = {\n\t\t\tstart: calendar.applyTimezone(span.start), // simulate a zoned event start date\n\t\t\tend: null\n\t\t};\n\n\t\t// if dropped on an all-day span, and element's metadata specified a time, set it\n\t\tif (meta.startTime && !dropLocation.start.hasTime()) {\n\t\t\tdropLocation.start.time(meta.startTime);\n\t\t}\n\n\t\tif (meta.duration) {\n\t\t\tdropLocation.end = dropLocation.start.clone().add(meta.duration);\n\t\t}\n\n\t\treturn dropLocation;\n\t},\n\n\n\n\t/* Drag Rendering (for both events and an external elements)\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Renders a visual indication of an event or external element being dragged.\n\t// `dropLocation` contains hypothetical start/end/allDay values the event would have if dropped. end can be null.\n\t// `seg` is the internal segment object that is being dragged. If dragging an external element, `seg` is null.\n\t// A truthy returned value indicates this method has rendered a helper element.\n\t// Must return elements used for any mock events.\n\trenderDrag: function(dropLocation, seg) {\n\t\t// subclasses must implement\n\t},\n\n\n\t// Unrenders a visual indication of an event or external element being dragged\n\tunrenderDrag: function() {\n\t\t// subclasses must implement\n\t},\n\n\n\t/* Resizing\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Creates a listener that tracks the user as they resize an event segment.\n\t// Generic enough to work with any type of Grid.\n\tbuildSegResizeListener: function(seg, isStart) {\n\t\tvar _this = this;\n\t\tvar view = this.view;\n\t\tvar calendar = view.calendar;\n\t\tvar el = seg.el;\n\t\tvar event = seg.event;\n\t\tvar eventEnd = calendar.getEventEnd(event);\n\t\tvar isDragging;\n\t\tvar resizeLocation; // zoned event date properties. falsy if invalid resize\n\n\t\t// Tracks mouse movement over the *grid's* coordinate map\n\t\tvar dragListener = this.segResizeListener = new HitDragListener(this, {\n\t\t\tscroll: view.opt('dragScroll'),\n\t\t\tsubjectEl: el,\n\t\t\tinteractionStart: function() {\n\t\t\t\tisDragging = false;\n\t\t\t},\n\t\t\tdragStart: function(ev) {\n\t\t\t\tisDragging = true;\n\t\t\t\t_this.handleSegMouseout(seg, ev); // ensure a mouseout on the manipulated event has been reported\n\t\t\t\t_this.segResizeStart(seg, ev);\n\t\t\t},\n\t\t\thitOver: function(hit, isOrig, origHit) {\n\t\t\t\tvar origHitSpan = _this.getHitSpan(origHit);\n\t\t\t\tvar hitSpan = _this.getHitSpan(hit);\n\n\t\t\t\tresizeLocation = isStart ?\n\t\t\t\t\t_this.computeEventStartResize(origHitSpan, hitSpan, event) :\n\t\t\t\t\t_this.computeEventEndResize(origHitSpan, hitSpan, event);\n\n\t\t\t\tif (resizeLocation) {\n\t\t\t\t\tif (!calendar.isEventSpanAllowed(_this.eventToSpan(resizeLocation), event)) {\n\t\t\t\t\t\tdisableCursor();\n\t\t\t\t\t\tresizeLocation = null;\n\t\t\t\t\t}\n\t\t\t\t\t// no change? (FYI, event dates might have zones)\n\t\t\t\t\telse if (\n\t\t\t\t\t\tresizeLocation.start.isSame(event.start.clone().stripZone()) &&\n\t\t\t\t\t\tresizeLocation.end.isSame(eventEnd.clone().stripZone())\n\t\t\t\t\t) {\n\t\t\t\t\t\tresizeLocation = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (resizeLocation) {\n\t\t\t\t\tview.hideEvent(event);\n\t\t\t\t\t_this.renderEventResize(resizeLocation, seg);\n\t\t\t\t}\n\t\t\t},\n\t\t\thitOut: function() { // called before mouse moves to a different hit OR moved out of all hits\n\t\t\t\tresizeLocation = null;\n\t\t\t},\n\t\t\thitDone: function() { // resets the rendering to show the original event\n\t\t\t\t_this.unrenderEventResize();\n\t\t\t\tview.showEvent(event);\n\t\t\t\tenableCursor();\n\t\t\t},\n\t\t\tinteractionEnd: function(ev) {\n\t\t\t\tif (isDragging) {\n\t\t\t\t\t_this.segResizeStop(seg, ev);\n\t\t\t\t}\n\t\t\t\tif (resizeLocation) { // valid date to resize to?\n\t\t\t\t\tview.reportEventResize(event, resizeLocation, this.largeUnit, el, ev);\n\t\t\t\t}\n\t\t\t\t_this.segResizeListener = null;\n\t\t\t}\n\t\t});\n\n\t\treturn dragListener;\n\t},\n\n\n\t// Called before event segment resizing starts\n\tsegResizeStart: function(seg, ev) {\n\t\tthis.isResizingSeg = true;\n\t\tthis.view.trigger('eventResizeStart', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy\n\t},\n\n\n\t// Called after event segment resizing stops\n\tsegResizeStop: function(seg, ev) {\n\t\tthis.isResizingSeg = false;\n\t\tthis.view.trigger('eventResizeStop', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy\n\t},\n\n\n\t// Returns new date-information for an event segment being resized from its start\n\tcomputeEventStartResize: function(startSpan, endSpan, event) {\n\t\treturn this.computeEventResize('start', startSpan, endSpan, event);\n\t},\n\n\n\t// Returns new date-information for an event segment being resized from its end\n\tcomputeEventEndResize: function(startSpan, endSpan, event) {\n\t\treturn this.computeEventResize('end', startSpan, endSpan, event);\n\t},\n\n\n\t// Returns new zoned date information for an event segment being resized from its start OR end\n\t// `type` is either 'start' or 'end'.\n\t// DOES NOT consider overlap/constraint.\n\tcomputeEventResize: function(type, startSpan, endSpan, event) {\n\t\tvar calendar = this.view.calendar;\n\t\tvar delta = this.diffDates(endSpan[type], startSpan[type]);\n\t\tvar resizeLocation; // zoned event date properties\n\t\tvar defaultDuration;\n\n\t\t// build original values to work from, guaranteeing a start and end\n\t\tresizeLocation = {\n\t\t\tstart: event.start.clone(),\n\t\t\tend: calendar.getEventEnd(event),\n\t\t\tallDay: event.allDay\n\t\t};\n\n\t\t// if an all-day event was in a timed area and was resized to a time, adjust start/end to have times\n\t\tif (resizeLocation.allDay && durationHasTime(delta)) {\n\t\t\tresizeLocation.allDay = false;\n\t\t\tcalendar.normalizeEventTimes(resizeLocation);\n\t\t}\n\n\t\tresizeLocation[type].add(delta); // apply delta to start or end\n\n\t\t// if the event was compressed too small, find a new reasonable duration for it\n\t\tif (!resizeLocation.start.isBefore(resizeLocation.end)) {\n\n\t\t\tdefaultDuration =\n\t\t\t\tthis.minResizeDuration || // TODO: hack\n\t\t\t\t(event.allDay ?\n\t\t\t\t\tcalendar.defaultAllDayEventDuration :\n\t\t\t\t\tcalendar.defaultTimedEventDuration);\n\n\t\t\tif (type == 'start') { // resizing the start?\n\t\t\t\tresizeLocation.start = resizeLocation.end.clone().subtract(defaultDuration);\n\t\t\t}\n\t\t\telse { // resizing the end?\n\t\t\t\tresizeLocation.end = resizeLocation.start.clone().add(defaultDuration);\n\t\t\t}\n\t\t}\n\n\t\treturn resizeLocation;\n\t},\n\n\n\t// Renders a visual indication of an event being resized.\n\t// `range` has the updated dates of the event. `seg` is the original segment object involved in the drag.\n\t// Must return elements used for any mock events.\n\trenderEventResize: function(range, seg) {\n\t\t// subclasses must implement\n\t},\n\n\n\t// Unrenders a visual indication of an event being resized.\n\tunrenderEventResize: function() {\n\t\t// subclasses must implement\n\t},\n\n\n\t/* Rendering Utils\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Compute the text that should be displayed on an event's element.\n\t// `range` can be the Event object itself, or something range-like, with at least a `start`.\n\t// If event times are disabled, or the event has no time, will return a blank string.\n\t// If not specified, formatStr will default to the eventTimeFormat setting,\n\t// and displayEnd will default to the displayEventEnd setting.\n\tgetEventTimeText: function(range, formatStr, displayEnd) {\n\n\t\tif (formatStr == null) {\n\t\t\tformatStr = this.eventTimeFormat;\n\t\t}\n\n\t\tif (displayEnd == null) {\n\t\t\tdisplayEnd = this.displayEventEnd;\n\t\t}\n\n\t\tif (this.displayEventTime && range.start.hasTime()) {\n\t\t\tif (displayEnd && range.end) {\n\t\t\t\treturn this.view.formatRange(range, formatStr);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn range.start.format(formatStr);\n\t\t\t}\n\t\t}\n\n\t\treturn '';\n\t},\n\n\n\t// Generic utility for generating the HTML classNames for an event segment's element\n\tgetSegClasses: function(seg, isDraggable, isResizable) {\n\t\tvar view = this.view;\n\t\tvar classes = [\n\t\t\t'fc-event',\n\t\t\tseg.isStart ? 'fc-start' : 'fc-not-start',\n\t\t\tseg.isEnd ? 'fc-end' : 'fc-not-end'\n\t\t].concat(this.getSegCustomClasses(seg));\n\n\t\tif (isDraggable) {\n\t\t\tclasses.push('fc-draggable');\n\t\t}\n\t\tif (isResizable) {\n\t\t\tclasses.push('fc-resizable');\n\t\t}\n\n\t\t// event is currently selected? attach a className.\n\t\tif (view.isEventSelected(seg.event)) {\n\t\t\tclasses.push('fc-selected');\n\t\t}\n\n\t\treturn classes;\n\t},\n\n\n\t// List of classes that were defined by the caller of the API in some way\n\tgetSegCustomClasses: function(seg) {\n\t\tvar event = seg.event;\n\n\t\treturn [].concat(\n\t\t\tevent.className, // guaranteed to be an array\n\t\t\tevent.source ? event.source.className : []\n\t\t);\n\t},\n\n\n\t// Utility for generating event skin-related CSS properties\n\tgetSegSkinCss: function(seg) {\n\t\treturn {\n\t\t\t'background-color': this.getSegBackgroundColor(seg),\n\t\t\t'border-color': this.getSegBorderColor(seg),\n\t\t\tcolor: this.getSegTextColor(seg)\n\t\t};\n\t},\n\n\n\t// Queries for caller-specified color, then falls back to default\n\tgetSegBackgroundColor: function(seg) {\n\t\treturn seg.event.backgroundColor ||\n\t\t\tseg.event.color ||\n\t\t\tthis.getSegDefaultBackgroundColor(seg);\n\t},\n\n\n\tgetSegDefaultBackgroundColor: function(seg) {\n\t\tvar source = seg.event.source || {};\n\n\t\treturn source.backgroundColor ||\n\t\t\tsource.color ||\n\t\t\tthis.view.opt('eventBackgroundColor') ||\n\t\t\tthis.view.opt('eventColor');\n\t},\n\n\n\t// Queries for caller-specified color, then falls back to default\n\tgetSegBorderColor: function(seg) {\n\t\treturn seg.event.borderColor ||\n\t\t\tseg.event.color ||\n\t\t\tthis.getSegDefaultBorderColor(seg);\n\t},\n\n\n\tgetSegDefaultBorderColor: function(seg) {\n\t\tvar source = seg.event.source || {};\n\n\t\treturn source.borderColor ||\n\t\t\tsource.color ||\n\t\t\tthis.view.opt('eventBorderColor') ||\n\t\t\tthis.view.opt('eventColor');\n\t},\n\n\n\t// Queries for caller-specified color, then falls back to default\n\tgetSegTextColor: function(seg) {\n\t\treturn seg.event.textColor ||\n\t\t\tthis.getSegDefaultTextColor(seg);\n\t},\n\n\n\tgetSegDefaultTextColor: function(seg) {\n\t\tvar source = seg.event.source || {};\n\n\t\treturn source.textColor ||\n\t\t\tthis.view.opt('eventTextColor');\n\t},\n\n\n\t/* Converting events -> eventRange -> eventSpan -> eventSegs\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Generates an array of segments for the given single event\n\t// Can accept an event \"location\" as well (which only has start/end and no allDay)\n\teventToSegs: function(event) {\n\t\treturn this.eventsToSegs([ event ]);\n\t},\n\n\n\teventToSpan: function(event) {\n\t\treturn this.eventToSpans(event)[0];\n\t},\n\n\n\t// Generates spans (always unzoned) for the given event.\n\t// Does not do any inverting for inverse-background events.\n\t// Can accept an event \"location\" as well (which only has start/end and no allDay)\n\teventToSpans: function(event) {\n\t\tvar range = this.eventToRange(event);\n\t\treturn this.eventRangeToSpans(range, event);\n\t},\n\n\n\n\t// Converts an array of event objects into an array of event segment objects.\n\t// A custom `segSliceFunc` may be given for arbitrarily slicing up events.\n\t// Doesn't guarantee an order for the resulting array.\n\teventsToSegs: function(allEvents, segSliceFunc) {\n\t\tvar _this = this;\n\t\tvar eventsById = groupEventsById(allEvents);\n\t\tvar segs = [];\n\n\t\t$.each(eventsById, function(id, events) {\n\t\t\tvar ranges = [];\n\t\t\tvar i;\n\n\t\t\tfor (i = 0; i < events.length; i++) {\n\t\t\t\tranges.push(_this.eventToRange(events[i]));\n\t\t\t}\n\n\t\t\t// inverse-background events (utilize only the first event in calculations)\n\t\t\tif (isInverseBgEvent(events[0])) {\n\t\t\t\tranges = _this.invertRanges(ranges);\n\n\t\t\t\tfor (i = 0; i < ranges.length; i++) {\n\t\t\t\t\tsegs.push.apply(segs, // append to\n\t\t\t\t\t\t_this.eventRangeToSegs(ranges[i], events[0], segSliceFunc));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// normal event ranges\n\t\t\telse {\n\t\t\t\tfor (i = 0; i < ranges.length; i++) {\n\t\t\t\t\tsegs.push.apply(segs, // append to\n\t\t\t\t\t\t_this.eventRangeToSegs(ranges[i], events[i], segSliceFunc));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn segs;\n\t},\n\n\n\t// Generates the unzoned start/end dates an event appears to occupy\n\t// Can accept an event \"location\" as well (which only has start/end and no allDay)\n\teventToRange: function(event) {\n\t\tvar calendar = this.view.calendar;\n\t\tvar start = event.start.clone().stripZone();\n\t\tvar end = (\n\t\t\t\tevent.end ?\n\t\t\t\t\tevent.end.clone() :\n\t\t\t\t\t// derive the end from the start and allDay. compute allDay if necessary\n\t\t\t\t\tcalendar.getDefaultEventEnd(\n\t\t\t\t\t\tevent.allDay != null ?\n\t\t\t\t\t\t\tevent.allDay :\n\t\t\t\t\t\t\t!event.start.hasTime(),\n\t\t\t\t\t\tevent.start\n\t\t\t\t\t)\n\t\t\t).stripZone();\n\n\t\t// hack: dynamic locale change forgets to upate stored event localed\n\t\tcalendar.localizeMoment(start);\n\t\tcalendar.localizeMoment(end);\n\n\t\treturn { start: start, end: end };\n\t},\n\n\n\t// Given an event's range (unzoned start/end), and the event itself,\n\t// slice into segments (using the segSliceFunc function if specified)\n\teventRangeToSegs: function(range, event, segSliceFunc) {\n\t\tvar spans = this.eventRangeToSpans(range, event);\n\t\tvar segs = [];\n\t\tvar i;\n\n\t\tfor (i = 0; i < spans.length; i++) {\n\t\t\tsegs.push.apply(segs, // append to\n\t\t\t\tthis.eventSpanToSegs(spans[i], event, segSliceFunc));\n\t\t}\n\n\t\treturn segs;\n\t},\n\n\n\t// Given an event's unzoned date range, return an array of \"span\" objects.\n\t// Subclasses can override.\n\teventRangeToSpans: function(range, event) {\n\t\treturn [ $.extend({}, range) ]; // copy into a single-item array\n\t},\n\n\n\t// Given an event's span (unzoned start/end and other misc data), and the event itself,\n\t// slices into segments and attaches event-derived properties to them.\n\teventSpanToSegs: function(span, event, segSliceFunc) {\n\t\tvar segs = segSliceFunc ? segSliceFunc(span) : this.spanToSegs(span);\n\t\tvar i, seg;\n\n\t\tfor (i = 0; i < segs.length; i++) {\n\t\t\tseg = segs[i];\n\t\t\tseg.event = event;\n\t\t\tseg.eventStartMS = +span.start; // TODO: not the best name after making spans unzoned\n\t\t\tseg.eventDurationMS = span.end - span.start;\n\t\t}\n\n\t\treturn segs;\n\t},\n\n\n\t// Produces a new array of range objects that will cover all the time NOT covered by the given ranges.\n\t// SIDE EFFECT: will mutate the given array and will use its date references.\n\tinvertRanges: function(ranges) {\n\t\tvar view = this.view;\n\t\tvar viewStart = view.start.clone(); // need a copy\n\t\tvar viewEnd = view.end.clone(); // need a copy\n\t\tvar inverseRanges = [];\n\t\tvar start = viewStart; // the end of the previous range. the start of the new range\n\t\tvar i, range;\n\n\t\t// ranges need to be in order. required for our date-walking algorithm\n\t\tranges.sort(compareRanges);\n\n\t\tfor (i = 0; i < ranges.length; i++) {\n\t\t\trange = ranges[i];\n\n\t\t\t// add the span of time before the event (if there is any)\n\t\t\tif (range.start > start) { // compare millisecond time (skip any ambig logic)\n\t\t\t\tinverseRanges.push({\n\t\t\t\t\tstart: start,\n\t\t\t\t\tend: range.start\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tstart = range.end;\n\t\t}\n\n\t\t// add the span of time after the last event (if there is any)\n\t\tif (start < viewEnd) { // compare millisecond time (skip any ambig logic)\n\t\t\tinverseRanges.push({\n\t\t\t\tstart: start,\n\t\t\t\tend: viewEnd\n\t\t\t});\n\t\t}\n\n\t\treturn inverseRanges;\n\t},\n\n\n\tsortEventSegs: function(segs) {\n\t\tsegs.sort(proxy(this, 'compareEventSegs'));\n\t},\n\n\n\t// A cmp function for determining which segments should take visual priority\n\tcompareEventSegs: function(seg1, seg2) {\n\t\treturn seg1.eventStartMS - seg2.eventStartMS || // earlier events go first\n\t\t\tseg2.eventDurationMS - seg1.eventDurationMS || // tie? longer events go first\n\t\t\tseg2.event.allDay - seg1.event.allDay || // tie? put all-day events first (booleans cast to 0/1)\n\t\t\tcompareByFieldSpecs(seg1.event, seg2.event, this.view.eventOrderSpecs);\n\t}\n\n});\n\n\n/* Utilities\n----------------------------------------------------------------------------------------------------------------------*/\n\n\nfunction pluckEventDateProps(event) {\n\treturn {\n\t\tstart: event.start.clone(),\n\t\tend: event.end ? event.end.clone() : null,\n\t\tallDay: event.allDay // keep it the same\n\t};\n}\nFC.pluckEventDateProps = pluckEventDateProps;\n\n\nfunction isBgEvent(event) { // returns true if background OR inverse-background\n\tvar rendering = getEventRendering(event);\n\treturn rendering === 'background' || rendering === 'inverse-background';\n}\nFC.isBgEvent = isBgEvent; // export\n\n\nfunction isInverseBgEvent(event) {\n\treturn getEventRendering(event) === 'inverse-background';\n}\n\n\nfunction getEventRendering(event) {\n\treturn firstDefined((event.source || {}).rendering, event.rendering);\n}\n\n\nfunction groupEventsById(events) {\n\tvar eventsById = {};\n\tvar i, event;\n\n\tfor (i = 0; i < events.length; i++) {\n\t\tevent = events[i];\n\t\t(eventsById[event._id] || (eventsById[event._id] = [])).push(event);\n\t}\n\n\treturn eventsById;\n}\n\n\n// A cmp function for determining which non-inverted \"ranges\" (see above) happen earlier\nfunction compareRanges(range1, range2) {\n\treturn range1.start - range2.start; // earlier ranges go first\n}\n\n\n/* External-Dragging-Element Data\n----------------------------------------------------------------------------------------------------------------------*/\n\n// Require all HTML5 data-* attributes used by FullCalendar to have this prefix.\n// A value of '' will query attributes like data-event. A value of 'fc' will query attributes like data-fc-event.\nFC.dataAttrPrefix = '';\n\n// Given a jQuery element that might represent a dragged FullCalendar event, returns an intermediate data structure\n// to be used for Event Object creation.\n// A defined `.eventProps`, even when empty, indicates that an event should be created.\nfunction getDraggedElMeta(el) {\n\tvar prefix = FC.dataAttrPrefix;\n\tvar eventProps; // properties for creating the event, not related to date/time\n\tvar startTime; // a Duration\n\tvar duration;\n\tvar stick;\n\n\tif (prefix) { prefix += '-'; }\n\teventProps = el.data(prefix + 'event') || null;\n\n\tif (eventProps) {\n\t\tif (typeof eventProps === 'object') {\n\t\t\teventProps = $.extend({}, eventProps); // make a copy\n\t\t}\n\t\telse { // something like 1 or true. still signal event creation\n\t\t\teventProps = {};\n\t\t}\n\n\t\t// pluck special-cased date/time properties\n\t\tstartTime = eventProps.start;\n\t\tif (startTime == null) { startTime = eventProps.time; } // accept 'time' as well\n\t\tduration = eventProps.duration;\n\t\tstick = eventProps.stick;\n\t\tdelete eventProps.start;\n\t\tdelete eventProps.time;\n\t\tdelete eventProps.duration;\n\t\tdelete eventProps.stick;\n\t}\n\n\t// fallback to standalone attribute values for each of the date/time properties\n\tif (startTime == null) { startTime = el.data(prefix + 'start'); }\n\tif (startTime == null) { startTime = el.data(prefix + 'time'); } // accept 'time' as well\n\tif (duration == null) { duration = el.data(prefix + 'duration'); }\n\tif (stick == null) { stick = el.data(prefix + 'stick'); }\n\n\t// massage into correct data types\n\tstartTime = startTime != null ? moment.duration(startTime) : null;\n\tduration = duration != null ? moment.duration(duration) : null;\n\tstick = Boolean(stick);\n\n\treturn { eventProps: eventProps, startTime: startTime, duration: duration, stick: stick };\n}\n\n\n;;\n\n/*\nA set of rendering and date-related methods for a visual component comprised of one or more rows of day columns.\nPrerequisite: the object being mixed into needs to be a *Grid*\n*/\nvar DayTableMixin = FC.DayTableMixin = {\n\n\tbreakOnWeeks: false, // should create a new row for each week?\n\tdayDates: null, // whole-day dates for each column. left to right\n\tdayIndices: null, // for each day from start, the offset\n\tdaysPerRow: null,\n\trowCnt: null,\n\tcolCnt: null,\n\tcolHeadFormat: null,\n\n\n\t// Populates internal variables used for date calculation and rendering\n\tupdateDayTable: function() {\n\t\tvar view = this.view;\n\t\tvar date = this.start.clone();\n\t\tvar dayIndex = -1;\n\t\tvar dayIndices = [];\n\t\tvar dayDates = [];\n\t\tvar daysPerRow;\n\t\tvar firstDay;\n\t\tvar rowCnt;\n\n\t\twhile (date.isBefore(this.end)) { // loop each day from start to end\n\t\t\tif (view.isHiddenDay(date)) {\n\t\t\t\tdayIndices.push(dayIndex + 0.5); // mark that it's between indices\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdayIndex++;\n\t\t\t\tdayIndices.push(dayIndex);\n\t\t\t\tdayDates.push(date.clone());\n\t\t\t}\n\t\t\tdate.add(1, 'days');\n\t\t}\n\n\t\tif (this.breakOnWeeks) {\n\t\t\t// count columns until the day-of-week repeats\n\t\t\tfirstDay = dayDates[0].day();\n\t\t\tfor (daysPerRow = 1; daysPerRow < dayDates.length; daysPerRow++) {\n\t\t\t\tif (dayDates[daysPerRow].day() == firstDay) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\trowCnt = Math.ceil(dayDates.length / daysPerRow);\n\t\t}\n\t\telse {\n\t\t\trowCnt = 1;\n\t\t\tdaysPerRow = dayDates.length;\n\t\t}\n\n\t\tthis.dayDates = dayDates;\n\t\tthis.dayIndices = dayIndices;\n\t\tthis.daysPerRow = daysPerRow;\n\t\tthis.rowCnt = rowCnt;\n\t\t\n\t\tthis.updateDayTableCols();\n\t},\n\n\n\t// Computes and assigned the colCnt property and updates any options that may be computed from it\n\tupdateDayTableCols: function() {\n\t\tthis.colCnt = this.computeColCnt();\n\t\tthis.colHeadFormat = this.view.opt('columnFormat') || this.computeColHeadFormat();\n\t},\n\n\n\t// Determines how many columns there should be in the table\n\tcomputeColCnt: function() {\n\t\treturn this.daysPerRow;\n\t},\n\n\n\t// Computes the ambiguously-timed moment for the given cell\n\tgetCellDate: function(row, col) {\n\t\treturn this.dayDates[\n\t\t\t\tthis.getCellDayIndex(row, col)\n\t\t\t].clone();\n\t},\n\n\n\t// Computes the ambiguously-timed date range for the given cell\n\tgetCellRange: function(row, col) {\n\t\tvar start = this.getCellDate(row, col);\n\t\tvar end = start.clone().add(1, 'days');\n\n\t\treturn { start: start, end: end };\n\t},\n\n\n\t// Returns the number of day cells, chronologically, from the first of the grid (0-based)\n\tgetCellDayIndex: function(row, col) {\n\t\treturn row * this.daysPerRow + this.getColDayIndex(col);\n\t},\n\n\n\t// Returns the numner of day cells, chronologically, from the first cell in *any given row*\n\tgetColDayIndex: function(col) {\n\t\tif (this.isRTL) {\n\t\t\treturn this.colCnt - 1 - col;\n\t\t}\n\t\telse {\n\t\t\treturn col;\n\t\t}\n\t},\n\n\n\t// Given a date, returns its chronolocial cell-index from the first cell of the grid.\n\t// If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.\n\t// If before the first offset, returns a negative number.\n\t// If after the last offset, returns an offset past the last cell offset.\n\t// Only works for *start* dates of cells. Will not work for exclusive end dates for cells.\n\tgetDateDayIndex: function(date) {\n\t\tvar dayIndices = this.dayIndices;\n\t\tvar dayOffset = date.diff(this.start, 'days');\n\n\t\tif (dayOffset < 0) {\n\t\t\treturn dayIndices[0] - 1;\n\t\t}\n\t\telse if (dayOffset >= dayIndices.length) {\n\t\t\treturn dayIndices[dayIndices.length - 1] + 1;\n\t\t}\n\t\telse {\n\t\t\treturn dayIndices[dayOffset];\n\t\t}\n\t},\n\n\n\t/* Options\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Computes a default column header formatting string if `colFormat` is not explicitly defined\n\tcomputeColHeadFormat: function() {\n\t\t// if more than one week row, or if there are a lot of columns with not much space,\n\t\t// put just the day numbers will be in each cell\n\t\tif (this.rowCnt > 1 || this.colCnt > 10) {\n\t\t\treturn 'ddd'; // \"Sat\"\n\t\t}\n\t\t// multiple days, so full single date string WON'T be in title text\n\t\telse if (this.colCnt > 1) {\n\t\t\treturn this.view.opt('dayOfMonthFormat'); // \"Sat 12/10\"\n\t\t}\n\t\t// single day, so full single date string will probably be in title text\n\t\telse {\n\t\t\treturn 'dddd'; // \"Saturday\"\n\t\t}\n\t},\n\n\n\t/* Slicing\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Slices up a date range into a segment for every week-row it intersects with\n\tsliceRangeByRow: function(range) {\n\t\tvar daysPerRow = this.daysPerRow;\n\t\tvar normalRange = this.view.computeDayRange(range); // make whole-day range, considering nextDayThreshold\n\t\tvar rangeFirst = this.getDateDayIndex(normalRange.start); // inclusive first index\n\t\tvar rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, 'days')); // inclusive last index\n\t\tvar segs = [];\n\t\tvar row;\n\t\tvar rowFirst, rowLast; // inclusive day-index range for current row\n\t\tvar segFirst, segLast; // inclusive day-index range for segment\n\n\t\tfor (row = 0; row < this.rowCnt; row++) {\n\t\t\trowFirst = row * daysPerRow;\n\t\t\trowLast = rowFirst + daysPerRow - 1;\n\n\t\t\t// intersect segment's offset range with the row's\n\t\t\tsegFirst = Math.max(rangeFirst, rowFirst);\n\t\t\tsegLast = Math.min(rangeLast, rowLast);\n\n\t\t\t// deal with in-between indices\n\t\t\tsegFirst = Math.ceil(segFirst); // in-between starts round to next cell\n\t\t\tsegLast = Math.floor(segLast); // in-between ends round to prev cell\n\n\t\t\tif (segFirst <= segLast) { // was there any intersection with the current row?\n\t\t\t\tsegs.push({\n\t\t\t\t\trow: row,\n\n\t\t\t\t\t// normalize to start of row\n\t\t\t\t\tfirstRowDayIndex: segFirst - rowFirst,\n\t\t\t\t\tlastRowDayIndex: segLast - rowFirst,\n\n\t\t\t\t\t// must be matching integers to be the segment's start/end\n\t\t\t\t\tisStart: segFirst === rangeFirst,\n\t\t\t\t\tisEnd: segLast === rangeLast\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn segs;\n\t},\n\n\n\t// Slices up a date range into a segment for every day-cell it intersects with.\n\t// TODO: make more DRY with sliceRangeByRow somehow.\n\tsliceRangeByDay: function(range) {\n\t\tvar daysPerRow = this.daysPerRow;\n\t\tvar normalRange = this.view.computeDayRange(range); // make whole-day range, considering nextDayThreshold\n\t\tvar rangeFirst = this.getDateDayIndex(normalRange.start); // inclusive first index\n\t\tvar rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, 'days')); // inclusive last index\n\t\tvar segs = [];\n\t\tvar row;\n\t\tvar rowFirst, rowLast; // inclusive day-index range for current row\n\t\tvar i;\n\t\tvar segFirst, segLast; // inclusive day-index range for segment\n\n\t\tfor (row = 0; row < this.rowCnt; row++) {\n\t\t\trowFirst = row * daysPerRow;\n\t\t\trowLast = rowFirst + daysPerRow - 1;\n\n\t\t\tfor (i = rowFirst; i <= rowLast; i++) {\n\n\t\t\t\t// intersect segment's offset range with the row's\n\t\t\t\tsegFirst = Math.max(rangeFirst, i);\n\t\t\t\tsegLast = Math.min(rangeLast, i);\n\n\t\t\t\t// deal with in-between indices\n\t\t\t\tsegFirst = Math.ceil(segFirst); // in-between starts round to next cell\n\t\t\t\tsegLast = Math.floor(segLast); // in-between ends round to prev cell\n\n\t\t\t\tif (segFirst <= segLast) { // was there any intersection with the current row?\n\t\t\t\t\tsegs.push({\n\t\t\t\t\t\trow: row,\n\n\t\t\t\t\t\t// normalize to start of row\n\t\t\t\t\t\tfirstRowDayIndex: segFirst - rowFirst,\n\t\t\t\t\t\tlastRowDayIndex: segLast - rowFirst,\n\n\t\t\t\t\t\t// must be matching integers to be the segment's start/end\n\t\t\t\t\t\tisStart: segFirst === rangeFirst,\n\t\t\t\t\t\tisEnd: segLast === rangeLast\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn segs;\n\t},\n\n\n\t/* Header Rendering\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\trenderHeadHtml: function() {\n\t\tvar view = this.view;\n\n\t\treturn '' +\n\t\t\t'<div class=\"fc-row ' + view.widgetHeaderClass + '\">' +\n\t\t\t\t'<table>' +\n\t\t\t\t\t'<thead>' +\n\t\t\t\t\t\tthis.renderHeadTrHtml() +\n\t\t\t\t\t'</thead>' +\n\t\t\t\t'</table>' +\n\t\t\t'</div>';\n\t},\n\n\n\trenderHeadIntroHtml: function() {\n\t\treturn this.renderIntroHtml(); // fall back to generic\n\t},\n\n\n\trenderHeadTrHtml: function() {\n\t\treturn '' +\n\t\t\t'<tr>' +\n\t\t\t\t(this.isRTL ? '' : this.renderHeadIntroHtml()) +\n\t\t\t\tthis.renderHeadDateCellsHtml() +\n\t\t\t\t(this.isRTL ? this.renderHeadIntroHtml() : '') +\n\t\t\t'</tr>';\n\t},\n\n\n\trenderHeadDateCellsHtml: function() {\n\t\tvar htmls = [];\n\t\tvar col, date;\n\n\t\tfor (col = 0; col < this.colCnt; col++) {\n\t\t\tdate = this.getCellDate(0, col);\n\t\t\thtmls.push(this.renderHeadDateCellHtml(date));\n\t\t}\n\n\t\treturn htmls.join('');\n\t},\n\n\n\t// TODO: when internalApiVersion, accept an object for HTML attributes\n\t// (colspan should be no different)\n\trenderHeadDateCellHtml: function(date, colspan, otherAttrs) {\n\t\tvar view = this.view;\n\n\t\treturn '' +\n\t\t\t'<th class=\"fc-day-header ' + view.widgetHeaderClass + ' fc-' + dayIDs[date.day()] + '\"' +\n\t\t\t\t(this.rowCnt === 1 ?\n\t\t\t\t\t' data-date=\"' + date.format('YYYY-MM-DD') + '\"' :\n\t\t\t\t\t'') +\n\t\t\t\t(colspan > 1 ?\n\t\t\t\t\t' colspan=\"' + colspan + '\"' :\n\t\t\t\t\t'') +\n\t\t\t\t(otherAttrs ?\n\t\t\t\t\t' ' + otherAttrs :\n\t\t\t\t\t'') +\n\t\t\t\t'>' +\n\t\t\t\t// don't make a link if the heading could represent multiple days, or if there's only one day (forceOff)\n\t\t\t\tview.buildGotoAnchorHtml(\n\t\t\t\t\t{ date: date, forceOff: this.rowCnt > 1 || this.colCnt === 1 },\n\t\t\t\t\thtmlEscape(date.format(this.colHeadFormat)) // inner HTML\n\t\t\t\t) +\n\t\t\t'</th>';\n\t},\n\n\n\t/* Background Rendering\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\trenderBgTrHtml: function(row) {\n\t\treturn '' +\n\t\t\t'<tr>' +\n\t\t\t\t(this.isRTL ? '' : this.renderBgIntroHtml(row)) +\n\t\t\t\tthis.renderBgCellsHtml(row) +\n\t\t\t\t(this.isRTL ? this.renderBgIntroHtml(row) : '') +\n\t\t\t'</tr>';\n\t},\n\n\n\trenderBgIntroHtml: function(row) {\n\t\treturn this.renderIntroHtml(); // fall back to generic\n\t},\n\n\n\trenderBgCellsHtml: function(row) {\n\t\tvar htmls = [];\n\t\tvar col, date;\n\n\t\tfor (col = 0; col < this.colCnt; col++) {\n\t\t\tdate = this.getCellDate(row, col);\n\t\t\thtmls.push(this.renderBgCellHtml(date));\n\t\t}\n\n\t\treturn htmls.join('');\n\t},\n\n\n\trenderBgCellHtml: function(date, otherAttrs) {\n\t\tvar view = this.view;\n\t\tvar classes = this.getDayClasses(date);\n\n\t\tclasses.unshift('fc-day', view.widgetContentClass);\n\n\t\treturn '<td class=\"' + classes.join(' ') + '\"' +\n\t\t\t' data-date=\"' + date.format('YYYY-MM-DD') + '\"' + // if date has a time, won't format it\n\t\t\t(otherAttrs ?\n\t\t\t\t' ' + otherAttrs :\n\t\t\t\t'') +\n\t\t\t'></td>';\n\t},\n\n\n\t/* Generic\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Generates the default HTML intro for any row. User classes should override\n\trenderIntroHtml: function() {\n\t},\n\n\n\t// TODO: a generic method for dealing with <tr>, RTL, intro\n\t// when increment internalApiVersion\n\t// wrapTr (scheduler)\n\n\n\t/* Utils\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Applies the generic \"intro\" and \"outro\" HTML to the given cells.\n\t// Intro means the leftmost cell when the calendar is LTR and the rightmost cell when RTL. Vice-versa for outro.\n\tbookendCells: function(trEl) {\n\t\tvar introHtml = this.renderIntroHtml();\n\n\t\tif (introHtml) {\n\t\t\tif (this.isRTL) {\n\t\t\t\ttrEl.append(introHtml);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttrEl.prepend(introHtml);\n\t\t\t}\n\t\t}\n\t}\n\n};\n\n;;\n\n/* A component that renders a grid of whole-days that runs horizontally. There can be multiple rows, one per week.\n----------------------------------------------------------------------------------------------------------------------*/\n\nvar DayGrid = FC.DayGrid = Grid.extend(DayTableMixin, {\n\n\tnumbersVisible: false, // should render a row for day/week numbers? set by outside view. TODO: make internal\n\tbottomCoordPadding: 0, // hack for extending the hit area for the last row of the coordinate grid\n\n\trowEls: null, // set of fake row elements\n\tcellEls: null, // set of whole-day elements comprising the row's background\n\thelperEls: null, // set of cell skeleton elements for rendering the mock event \"helper\"\n\n\trowCoordCache: null,\n\tcolCoordCache: null,\n\n\n\t// Renders the rows and columns into the component's `this.el`, which should already be assigned.\n\t// isRigid determins whether the individual rows should ignore the contents and be a constant height.\n\t// Relies on the view's colCnt and rowCnt. In the future, this component should probably be self-sufficient.\n\trenderDates: function(isRigid) {\n\t\tvar view = this.view;\n\t\tvar rowCnt = this.rowCnt;\n\t\tvar colCnt = this.colCnt;\n\t\tvar html = '';\n\t\tvar row;\n\t\tvar col;\n\n\t\tfor (row = 0; row < rowCnt; row++) {\n\t\t\thtml += this.renderDayRowHtml(row, isRigid);\n\t\t}\n\t\tthis.el.html(html);\n\n\t\tthis.rowEls = this.el.find('.fc-row');\n\t\tthis.cellEls = this.el.find('.fc-day');\n\n\t\tthis.rowCoordCache = new CoordCache({\n\t\t\tels: this.rowEls,\n\t\t\tisVertical: true\n\t\t});\n\t\tthis.colCoordCache = new CoordCache({\n\t\t\tels: this.cellEls.slice(0, this.colCnt), // only the first row\n\t\t\tisHorizontal: true\n\t\t});\n\n\t\t// trigger dayRender with each cell's element\n\t\tfor (row = 0; row < rowCnt; row++) {\n\t\t\tfor (col = 0; col < colCnt; col++) {\n\t\t\t\tview.trigger(\n\t\t\t\t\t'dayRender',\n\t\t\t\t\tnull,\n\t\t\t\t\tthis.getCellDate(row, col),\n\t\t\t\t\tthis.getCellEl(row, col)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t},\n\n\n\tunrenderDates: function() {\n\t\tthis.removeSegPopover();\n\t},\n\n\n\trenderBusinessHours: function() {\n\t\tvar segs = this.buildBusinessHourSegs(true); // wholeDay=true\n\t\tthis.renderFill('businessHours', segs, 'bgevent');\n\t},\n\n\n\tunrenderBusinessHours: function() {\n\t\tthis.unrenderFill('businessHours');\n\t},\n\n\n\t// Generates the HTML for a single row, which is a div that wraps a table.\n\t// `row` is the row number.\n\trenderDayRowHtml: function(row, isRigid) {\n\t\tvar view = this.view;\n\t\tvar classes = [ 'fc-row', 'fc-week', view.widgetContentClass ];\n\n\t\tif (isRigid) {\n\t\t\tclasses.push('fc-rigid');\n\t\t}\n\n\t\treturn '' +\n\t\t\t'<div class=\"' + classes.join(' ') + '\">' +\n\t\t\t\t'<div class=\"fc-bg\">' +\n\t\t\t\t\t'<table>' +\n\t\t\t\t\t\tthis.renderBgTrHtml(row) +\n\t\t\t\t\t'</table>' +\n\t\t\t\t'</div>' +\n\t\t\t\t'<div class=\"fc-content-skeleton\">' +\n\t\t\t\t\t'<table>' +\n\t\t\t\t\t\t(this.numbersVisible ?\n\t\t\t\t\t\t\t'<thead>' +\n\t\t\t\t\t\t\t\tthis.renderNumberTrHtml(row) +\n\t\t\t\t\t\t\t'</thead>' :\n\t\t\t\t\t\t\t''\n\t\t\t\t\t\t\t) +\n\t\t\t\t\t'</table>' +\n\t\t\t\t'</div>' +\n\t\t\t'</div>';\n\t},\n\n\n\t/* Grid Number Rendering\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\trenderNumberTrHtml: function(row) {\n\t\treturn '' +\n\t\t\t'<tr>' +\n\t\t\t\t(this.isRTL ? '' : this.renderNumberIntroHtml(row)) +\n\t\t\t\tthis.renderNumberCellsHtml(row) +\n\t\t\t\t(this.isRTL ? this.renderNumberIntroHtml(row) : '') +\n\t\t\t'</tr>';\n\t},\n\n\n\trenderNumberIntroHtml: function(row) {\n\t\treturn this.renderIntroHtml();\n\t},\n\n\n\trenderNumberCellsHtml: function(row) {\n\t\tvar htmls = [];\n\t\tvar col, date;\n\n\t\tfor (col = 0; col < this.colCnt; col++) {\n\t\t\tdate = this.getCellDate(row, col);\n\t\t\thtmls.push(this.renderNumberCellHtml(date));\n\t\t}\n\n\t\treturn htmls.join('');\n\t},\n\n\n\t// Generates the HTML for the <td>s of the \"number\" row in the DayGrid's content skeleton.\n\t// The number row will only exist if either day numbers or week numbers are turned on.\n\trenderNumberCellHtml: function(date) {\n\t\tvar html = '';\n\t\tvar classes;\n\t\tvar weekCalcFirstDoW;\n\n\t\tif (!this.view.dayNumbersVisible && !this.view.cellWeekNumbersVisible) {\n\t\t\t// no numbers in day cell (week number must be along the side)\n\t\t\treturn '<td/>'; //  will create an empty space above events :(\n\t\t}\n\n\t\tclasses = this.getDayClasses(date);\n\t\tclasses.unshift('fc-day-top');\n\n\t\tif (this.view.cellWeekNumbersVisible) {\n\t\t\t// To determine the day of week number change under ISO, we cannot\n\t\t\t// rely on moment.js methods such as firstDayOfWeek() or weekday(),\n\t\t\t// because they rely on the locale's dow (possibly overridden by\n\t\t\t// our firstDay option), which may not be Monday. We cannot change\n\t\t\t// dow, because that would affect the calendar start day as well.\n\t\t\tif (date._locale._fullCalendar_weekCalc === 'ISO') {\n\t\t\t\tweekCalcFirstDoW = 1;  // Monday by ISO 8601 definition\n\t\t\t}\n\t\t\telse {\n\t\t\t\tweekCalcFirstDoW = date._locale.firstDayOfWeek();\n\t\t\t}\n\t\t}\n\n\t\thtml += '<td class=\"' + classes.join(' ') + '\" data-date=\"' + date.format() + '\">';\n\n\t\tif (this.view.cellWeekNumbersVisible && (date.day() == weekCalcFirstDoW)) {\n\t\t\thtml += this.view.buildGotoAnchorHtml(\n\t\t\t\t{ date: date, type: 'week' },\n\t\t\t\t{ 'class': 'fc-week-number' },\n\t\t\t\tdate.format('w') // inner HTML\n\t\t\t);\n\t\t}\n\n\t\tif (this.view.dayNumbersVisible) {\n\t\t\thtml += this.view.buildGotoAnchorHtml(\n\t\t\t\tdate,\n\t\t\t\t{ 'class': 'fc-day-number' },\n\t\t\t\tdate.date() // inner HTML\n\t\t\t);\n\t\t}\n\n\t\thtml += '</td>';\n\n\t\treturn html;\n\t},\n\n\n\t/* Options\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Computes a default event time formatting string if `timeFormat` is not explicitly defined\n\tcomputeEventTimeFormat: function() {\n\t\treturn this.view.opt('extraSmallTimeFormat'); // like \"6p\" or \"6:30p\"\n\t},\n\n\n\t// Computes a default `displayEventEnd` value if one is not expliclty defined\n\tcomputeDisplayEventEnd: function() {\n\t\treturn this.colCnt == 1; // we'll likely have space if there's only one day\n\t},\n\n\n\t/* Dates\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\trangeUpdated: function() {\n\t\tthis.updateDayTable();\n\t},\n\n\n\t// Slices up the given span (unzoned start/end with other misc data) into an array of segments\n\tspanToSegs: function(span) {\n\t\tvar segs = this.sliceRangeByRow(span);\n\t\tvar i, seg;\n\n\t\tfor (i = 0; i < segs.length; i++) {\n\t\t\tseg = segs[i];\n\t\t\tif (this.isRTL) {\n\t\t\t\tseg.leftCol = this.daysPerRow - 1 - seg.lastRowDayIndex;\n\t\t\t\tseg.rightCol = this.daysPerRow - 1 - seg.firstRowDayIndex;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tseg.leftCol = seg.firstRowDayIndex;\n\t\t\t\tseg.rightCol = seg.lastRowDayIndex;\n\t\t\t}\n\t\t}\n\n\t\treturn segs;\n\t},\n\n\n\t/* Hit System\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\tprepareHits: function() {\n\t\tthis.colCoordCache.build();\n\t\tthis.rowCoordCache.build();\n\t\tthis.rowCoordCache.bottoms[this.rowCnt - 1] += this.bottomCoordPadding; // hack\n\t},\n\n\n\treleaseHits: function() {\n\t\tthis.colCoordCache.clear();\n\t\tthis.rowCoordCache.clear();\n\t},\n\n\n\tqueryHit: function(leftOffset, topOffset) {\n\t\tif (this.colCoordCache.isLeftInBounds(leftOffset) && this.rowCoordCache.isTopInBounds(topOffset)) {\n\t\t\tvar col = this.colCoordCache.getHorizontalIndex(leftOffset);\n\t\t\tvar row = this.rowCoordCache.getVerticalIndex(topOffset);\n\n\t\t\tif (row != null && col != null) {\n\t\t\t\treturn this.getCellHit(row, col);\n\t\t\t}\n\t\t}\n\t},\n\n\n\tgetHitSpan: function(hit) {\n\t\treturn this.getCellRange(hit.row, hit.col);\n\t},\n\n\n\tgetHitEl: function(hit) {\n\t\treturn this.getCellEl(hit.row, hit.col);\n\t},\n\n\n\t/* Cell System\n\t------------------------------------------------------------------------------------------------------------------*/\n\t// FYI: the first column is the leftmost column, regardless of date\n\n\n\tgetCellHit: function(row, col) {\n\t\treturn {\n\t\t\trow: row,\n\t\t\tcol: col,\n\t\t\tcomponent: this, // needed unfortunately :(\n\t\t\tleft: this.colCoordCache.getLeftOffset(col),\n\t\t\tright: this.colCoordCache.getRightOffset(col),\n\t\t\ttop: this.rowCoordCache.getTopOffset(row),\n\t\t\tbottom: this.rowCoordCache.getBottomOffset(row)\n\t\t};\n\t},\n\n\n\tgetCellEl: function(row, col) {\n\t\treturn this.cellEls.eq(row * this.colCnt + col);\n\t},\n\n\n\t/* Event Drag Visualization\n\t------------------------------------------------------------------------------------------------------------------*/\n\t// TODO: move to DayGrid.event, similar to what we did with Grid's drag methods\n\n\n\t// Renders a visual indication of an event or external element being dragged.\n\t// `eventLocation` has zoned start and end (optional)\n\trenderDrag: function(eventLocation, seg) {\n\n\t\t// always render a highlight underneath\n\t\tthis.renderHighlight(this.eventToSpan(eventLocation));\n\n\t\t// if a segment from the same calendar but another component is being dragged, render a helper event\n\t\tif (seg && seg.component !== this) {\n\t\t\treturn this.renderEventLocationHelper(eventLocation, seg); // returns mock event elements\n\t\t}\n\t},\n\n\n\t// Unrenders any visual indication of a hovering event\n\tunrenderDrag: function() {\n\t\tthis.unrenderHighlight();\n\t\tthis.unrenderHelper();\n\t},\n\n\n\t/* Event Resize Visualization\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Renders a visual indication of an event being resized\n\trenderEventResize: function(eventLocation, seg) {\n\t\tthis.renderHighlight(this.eventToSpan(eventLocation));\n\t\treturn this.renderEventLocationHelper(eventLocation, seg); // returns mock event elements\n\t},\n\n\n\t// Unrenders a visual indication of an event being resized\n\tunrenderEventResize: function() {\n\t\tthis.unrenderHighlight();\n\t\tthis.unrenderHelper();\n\t},\n\n\n\t/* Event Helper\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Renders a mock \"helper\" event. `sourceSeg` is the associated internal segment object. It can be null.\n\trenderHelper: function(event, sourceSeg) {\n\t\tvar helperNodes = [];\n\t\tvar segs = this.eventToSegs(event);\n\t\tvar rowStructs;\n\n\t\tsegs = this.renderFgSegEls(segs); // assigns each seg's el and returns a subset of segs that were rendered\n\t\trowStructs = this.renderSegRows(segs);\n\n\t\t// inject each new event skeleton into each associated row\n\t\tthis.rowEls.each(function(row, rowNode) {\n\t\t\tvar rowEl = $(rowNode); // the .fc-row\n\t\t\tvar skeletonEl = $('<div class=\"fc-helper-skeleton\"><table/></div>'); // will be absolutely positioned\n\t\t\tvar skeletonTop;\n\n\t\t\t// If there is an original segment, match the top position. Otherwise, put it at the row's top level\n\t\t\tif (sourceSeg && sourceSeg.row === row) {\n\t\t\t\tskeletonTop = sourceSeg.el.position().top;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tskeletonTop = rowEl.find('.fc-content-skeleton tbody').position().top;\n\t\t\t}\n\n\t\t\tskeletonEl.css('top', skeletonTop)\n\t\t\t\t.find('table')\n\t\t\t\t\t.append(rowStructs[row].tbodyEl);\n\n\t\t\trowEl.append(skeletonEl);\n\t\t\thelperNodes.push(skeletonEl[0]);\n\t\t});\n\n\t\treturn ( // must return the elements rendered\n\t\t\tthis.helperEls = $(helperNodes) // array -> jQuery set\n\t\t);\n\t},\n\n\n\t// Unrenders any visual indication of a mock helper event\n\tunrenderHelper: function() {\n\t\tif (this.helperEls) {\n\t\t\tthis.helperEls.remove();\n\t\t\tthis.helperEls = null;\n\t\t}\n\t},\n\n\n\t/* Fill System (highlight, background events, business hours)\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\tfillSegTag: 'td', // override the default tag name\n\n\n\t// Renders a set of rectangles over the given segments of days.\n\t// Only returns segments that successfully rendered.\n\trenderFill: function(type, segs, className) {\n\t\tvar nodes = [];\n\t\tvar i, seg;\n\t\tvar skeletonEl;\n\n\t\tsegs = this.renderFillSegEls(type, segs); // assignes `.el` to each seg. returns successfully rendered segs\n\n\t\tfor (i = 0; i < segs.length; i++) {\n\t\t\tseg = segs[i];\n\t\t\tskeletonEl = this.renderFillRow(type, seg, className);\n\t\t\tthis.rowEls.eq(seg.row).append(skeletonEl);\n\t\t\tnodes.push(skeletonEl[0]);\n\t\t}\n\n\t\tthis.elsByFill[type] = $(nodes);\n\n\t\treturn segs;\n\t},\n\n\n\t// Generates the HTML needed for one row of a fill. Requires the seg's el to be rendered.\n\trenderFillRow: function(type, seg, className) {\n\t\tvar colCnt = this.colCnt;\n\t\tvar startCol = seg.leftCol;\n\t\tvar endCol = seg.rightCol + 1;\n\t\tvar skeletonEl;\n\t\tvar trEl;\n\n\t\tclassName = className || type.toLowerCase();\n\n\t\tskeletonEl = $(\n\t\t\t'<div class=\"fc-' + className + '-skeleton\">' +\n\t\t\t\t'<table><tr/></table>' +\n\t\t\t'</div>'\n\t\t);\n\t\ttrEl = skeletonEl.find('tr');\n\n\t\tif (startCol > 0) {\n\t\t\ttrEl.append('<td colspan=\"' + startCol + '\"/>');\n\t\t}\n\n\t\ttrEl.append(\n\t\t\tseg.el.attr('colspan', endCol - startCol)\n\t\t);\n\n\t\tif (endCol < colCnt) {\n\t\t\ttrEl.append('<td colspan=\"' + (colCnt - endCol) + '\"/>');\n\t\t}\n\n\t\tthis.bookendCells(trEl);\n\n\t\treturn skeletonEl;\n\t}\n\n});\n\n;;\n\n/* Event-rendering methods for the DayGrid class\n----------------------------------------------------------------------------------------------------------------------*/\n\nDayGrid.mixin({\n\n\trowStructs: null, // an array of objects, each holding information about a row's foreground event-rendering\n\n\n\t// Unrenders all events currently rendered on the grid\n\tunrenderEvents: function() {\n\t\tthis.removeSegPopover(); // removes the \"more..\" events popover\n\t\tGrid.prototype.unrenderEvents.apply(this, arguments); // calls the super-method\n\t},\n\n\n\t// Retrieves all rendered segment objects currently rendered on the grid\n\tgetEventSegs: function() {\n\t\treturn Grid.prototype.getEventSegs.call(this) // get the segments from the super-method\n\t\t\t.concat(this.popoverSegs || []); // append the segments from the \"more...\" popover\n\t},\n\n\n\t// Renders the given background event segments onto the grid\n\trenderBgSegs: function(segs) {\n\n\t\t// don't render timed background events\n\t\tvar allDaySegs = $.grep(segs, function(seg) {\n\t\t\treturn seg.event.allDay;\n\t\t});\n\n\t\treturn Grid.prototype.renderBgSegs.call(this, allDaySegs); // call the super-method\n\t},\n\n\n\t// Renders the given foreground event segments onto the grid\n\trenderFgSegs: function(segs) {\n\t\tvar rowStructs;\n\n\t\t// render an `.el` on each seg\n\t\t// returns a subset of the segs. segs that were actually rendered\n\t\tsegs = this.renderFgSegEls(segs);\n\n\t\trowStructs = this.rowStructs = this.renderSegRows(segs);\n\n\t\t// append to each row's content skeleton\n\t\tthis.rowEls.each(function(i, rowNode) {\n\t\t\t$(rowNode).find('.fc-content-skeleton > table').append(\n\t\t\t\trowStructs[i].tbodyEl\n\t\t\t);\n\t\t});\n\n\t\treturn segs; // return only the segs that were actually rendered\n\t},\n\n\n\t// Unrenders all currently rendered foreground event segments\n\tunrenderFgSegs: function() {\n\t\tvar rowStructs = this.rowStructs || [];\n\t\tvar rowStruct;\n\n\t\twhile ((rowStruct = rowStructs.pop())) {\n\t\t\trowStruct.tbodyEl.remove();\n\t\t}\n\n\t\tthis.rowStructs = null;\n\t},\n\n\n\t// Uses the given events array to generate <tbody> elements that should be appended to each row's content skeleton.\n\t// Returns an array of rowStruct objects (see the bottom of `renderSegRow`).\n\t// PRECONDITION: each segment shoud already have a rendered and assigned `.el`\n\trenderSegRows: function(segs) {\n\t\tvar rowStructs = [];\n\t\tvar segRows;\n\t\tvar row;\n\n\t\tsegRows = this.groupSegRows(segs); // group into nested arrays\n\n\t\t// iterate each row of segment groupings\n\t\tfor (row = 0; row < segRows.length; row++) {\n\t\t\trowStructs.push(\n\t\t\t\tthis.renderSegRow(row, segRows[row])\n\t\t\t);\n\t\t}\n\n\t\treturn rowStructs;\n\t},\n\n\n\t// Builds the HTML to be used for the default element for an individual segment\n\tfgSegHtml: function(seg, disableResizing) {\n\t\tvar view = this.view;\n\t\tvar event = seg.event;\n\t\tvar isDraggable = view.isEventDraggable(event);\n\t\tvar isResizableFromStart = !disableResizing && event.allDay &&\n\t\t\tseg.isStart && view.isEventResizableFromStart(event);\n\t\tvar isResizableFromEnd = !disableResizing && event.allDay &&\n\t\t\tseg.isEnd && view.isEventResizableFromEnd(event);\n\t\tvar classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);\n\t\tvar skinCss = cssToStr(this.getSegSkinCss(seg));\n\t\tvar timeHtml = '';\n\t\tvar timeText;\n\t\tvar titleHtml;\n\n\t\tclasses.unshift('fc-day-grid-event', 'fc-h-event');\n\n\t\t// Only display a timed events time if it is the starting segment\n\t\tif (seg.isStart) {\n\t\t\ttimeText = this.getEventTimeText(event);\n\t\t\tif (timeText) {\n\t\t\t\ttimeHtml = '<span class=\"fc-time\">' + htmlEscape(timeText) + '</span>';\n\t\t\t}\n\t\t}\n\n\t\ttitleHtml =\n\t\t\t'<span class=\"fc-title\">' +\n\t\t\t\t(htmlEscape(event.title || '') || '&nbsp;') + // we always want one line of height\n\t\t\t'</span>';\n\t\t\n\t\treturn '<a class=\"' + classes.join(' ') + '\"' +\n\t\t\t\t(event.url ?\n\t\t\t\t\t' href=\"' + htmlEscape(event.url) + '\"' :\n\t\t\t\t\t''\n\t\t\t\t\t) +\n\t\t\t\t(skinCss ?\n\t\t\t\t\t' style=\"' + skinCss + '\"' :\n\t\t\t\t\t''\n\t\t\t\t\t) +\n\t\t\t'>' +\n\t\t\t\t'<div class=\"fc-content\">' +\n\t\t\t\t\t(this.isRTL ?\n\t\t\t\t\t\ttitleHtml + ' ' + timeHtml : // put a natural space in between\n\t\t\t\t\t\ttimeHtml + ' ' + titleHtml   //\n\t\t\t\t\t\t) +\n\t\t\t\t'</div>' +\n\t\t\t\t(isResizableFromStart ?\n\t\t\t\t\t'<div class=\"fc-resizer fc-start-resizer\" />' :\n\t\t\t\t\t''\n\t\t\t\t\t) +\n\t\t\t\t(isResizableFromEnd ?\n\t\t\t\t\t'<div class=\"fc-resizer fc-end-resizer\" />' :\n\t\t\t\t\t''\n\t\t\t\t\t) +\n\t\t\t'</a>';\n\t},\n\n\n\t// Given a row # and an array of segments all in the same row, render a <tbody> element, a skeleton that contains\n\t// the segments. Returns object with a bunch of internal data about how the render was calculated.\n\t// NOTE: modifies rowSegs\n\trenderSegRow: function(row, rowSegs) {\n\t\tvar colCnt = this.colCnt;\n\t\tvar segLevels = this.buildSegLevels(rowSegs); // group into sub-arrays of levels\n\t\tvar levelCnt = Math.max(1, segLevels.length); // ensure at least one level\n\t\tvar tbody = $('<tbody/>');\n\t\tvar segMatrix = []; // lookup for which segments are rendered into which level+col cells\n\t\tvar cellMatrix = []; // lookup for all <td> elements of the level+col matrix\n\t\tvar loneCellMatrix = []; // lookup for <td> elements that only take up a single column\n\t\tvar i, levelSegs;\n\t\tvar col;\n\t\tvar tr;\n\t\tvar j, seg;\n\t\tvar td;\n\n\t\t// populates empty cells from the current column (`col`) to `endCol`\n\t\tfunction emptyCellsUntil(endCol) {\n\t\t\twhile (col < endCol) {\n\t\t\t\t// try to grab a cell from the level above and extend its rowspan. otherwise, create a fresh cell\n\t\t\t\ttd = (loneCellMatrix[i - 1] || [])[col];\n\t\t\t\tif (td) {\n\t\t\t\t\ttd.attr(\n\t\t\t\t\t\t'rowspan',\n\t\t\t\t\t\tparseInt(td.attr('rowspan') || 1, 10) + 1\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttd = $('<td/>');\n\t\t\t\t\ttr.append(td);\n\t\t\t\t}\n\t\t\t\tcellMatrix[i][col] = td;\n\t\t\t\tloneCellMatrix[i][col] = td;\n\t\t\t\tcol++;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < levelCnt; i++) { // iterate through all levels\n\t\t\tlevelSegs = segLevels[i];\n\t\t\tcol = 0;\n\t\t\ttr = $('<tr/>');\n\n\t\t\tsegMatrix.push([]);\n\t\t\tcellMatrix.push([]);\n\t\t\tloneCellMatrix.push([]);\n\n\t\t\t// levelCnt might be 1 even though there are no actual levels. protect against this.\n\t\t\t// this single empty row is useful for styling.\n\t\t\tif (levelSegs) {\n\t\t\t\tfor (j = 0; j < levelSegs.length; j++) { // iterate through segments in level\n\t\t\t\t\tseg = levelSegs[j];\n\n\t\t\t\t\temptyCellsUntil(seg.leftCol);\n\n\t\t\t\t\t// create a container that occupies or more columns. append the event element.\n\t\t\t\t\ttd = $('<td class=\"fc-event-container\"/>').append(seg.el);\n\t\t\t\t\tif (seg.leftCol != seg.rightCol) {\n\t\t\t\t\t\ttd.attr('colspan', seg.rightCol - seg.leftCol + 1);\n\t\t\t\t\t}\n\t\t\t\t\telse { // a single-column segment\n\t\t\t\t\t\tloneCellMatrix[i][col] = td;\n\t\t\t\t\t}\n\n\t\t\t\t\twhile (col <= seg.rightCol) {\n\t\t\t\t\t\tcellMatrix[i][col] = td;\n\t\t\t\t\t\tsegMatrix[i][col] = seg;\n\t\t\t\t\t\tcol++;\n\t\t\t\t\t}\n\n\t\t\t\t\ttr.append(td);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\temptyCellsUntil(colCnt); // finish off the row\n\t\t\tthis.bookendCells(tr);\n\t\t\ttbody.append(tr);\n\t\t}\n\n\t\treturn { // a \"rowStruct\"\n\t\t\trow: row, // the row number\n\t\t\ttbodyEl: tbody,\n\t\t\tcellMatrix: cellMatrix,\n\t\t\tsegMatrix: segMatrix,\n\t\t\tsegLevels: segLevels,\n\t\t\tsegs: rowSegs\n\t\t};\n\t},\n\n\n\t// Stacks a flat array of segments, which are all assumed to be in the same row, into subarrays of vertical levels.\n\t// NOTE: modifies segs\n\tbuildSegLevels: function(segs) {\n\t\tvar levels = [];\n\t\tvar i, seg;\n\t\tvar j;\n\n\t\t// Give preference to elements with certain criteria, so they have\n\t\t// a chance to be closer to the top.\n\t\tthis.sortEventSegs(segs);\n\t\t\n\t\tfor (i = 0; i < segs.length; i++) {\n\t\t\tseg = segs[i];\n\n\t\t\t// loop through levels, starting with the topmost, until the segment doesn't collide with other segments\n\t\t\tfor (j = 0; j < levels.length; j++) {\n\t\t\t\tif (!isDaySegCollision(seg, levels[j])) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// `j` now holds the desired subrow index\n\t\t\tseg.level = j;\n\n\t\t\t// create new level array if needed and append segment\n\t\t\t(levels[j] || (levels[j] = [])).push(seg);\n\t\t}\n\n\t\t// order segments left-to-right. very important if calendar is RTL\n\t\tfor (j = 0; j < levels.length; j++) {\n\t\t\tlevels[j].sort(compareDaySegCols);\n\t\t}\n\n\t\treturn levels;\n\t},\n\n\n\t// Given a flat array of segments, return an array of sub-arrays, grouped by each segment's row\n\tgroupSegRows: function(segs) {\n\t\tvar segRows = [];\n\t\tvar i;\n\n\t\tfor (i = 0; i < this.rowCnt; i++) {\n\t\t\tsegRows.push([]);\n\t\t}\n\n\t\tfor (i = 0; i < segs.length; i++) {\n\t\t\tsegRows[segs[i].row].push(segs[i]);\n\t\t}\n\n\t\treturn segRows;\n\t}\n\n});\n\n\n// Computes whether two segments' columns collide. They are assumed to be in the same row.\nfunction isDaySegCollision(seg, otherSegs) {\n\tvar i, otherSeg;\n\n\tfor (i = 0; i < otherSegs.length; i++) {\n\t\totherSeg = otherSegs[i];\n\n\t\tif (\n\t\t\totherSeg.leftCol <= seg.rightCol &&\n\t\t\totherSeg.rightCol >= seg.leftCol\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n\n// A cmp function for determining the leftmost event\nfunction compareDaySegCols(a, b) {\n\treturn a.leftCol - b.leftCol;\n}\n\n;;\n\n/* Methods relate to limiting the number events for a given day on a DayGrid\n----------------------------------------------------------------------------------------------------------------------*/\n// NOTE: all the segs being passed around in here are foreground segs\n\nDayGrid.mixin({\n\n\tsegPopover: null, // the Popover that holds events that can't fit in a cell. null when not visible\n\tpopoverSegs: null, // an array of segment objects that the segPopover holds. null when not visible\n\n\n\tremoveSegPopover: function() {\n\t\tif (this.segPopover) {\n\t\t\tthis.segPopover.hide(); // in handler, will call segPopover's removeElement\n\t\t}\n\t},\n\n\n\t// Limits the number of \"levels\" (vertically stacking layers of events) for each row of the grid.\n\t// `levelLimit` can be false (don't limit), a number, or true (should be computed).\n\tlimitRows: function(levelLimit) {\n\t\tvar rowStructs = this.rowStructs || [];\n\t\tvar row; // row #\n\t\tvar rowLevelLimit;\n\n\t\tfor (row = 0; row < rowStructs.length; row++) {\n\t\t\tthis.unlimitRow(row);\n\n\t\t\tif (!levelLimit) {\n\t\t\t\trowLevelLimit = false;\n\t\t\t}\n\t\t\telse if (typeof levelLimit === 'number') {\n\t\t\t\trowLevelLimit = levelLimit;\n\t\t\t}\n\t\t\telse {\n\t\t\t\trowLevelLimit = this.computeRowLevelLimit(row);\n\t\t\t}\n\n\t\t\tif (rowLevelLimit !== false) {\n\t\t\t\tthis.limitRow(row, rowLevelLimit);\n\t\t\t}\n\t\t}\n\t},\n\n\n\t// Computes the number of levels a row will accomodate without going outside its bounds.\n\t// Assumes the row is \"rigid\" (maintains a constant height regardless of what is inside).\n\t// `row` is the row number.\n\tcomputeRowLevelLimit: function(row) {\n\t\tvar rowEl = this.rowEls.eq(row); // the containing \"fake\" row div\n\t\tvar rowHeight = rowEl.height(); // TODO: cache somehow?\n\t\tvar trEls = this.rowStructs[row].tbodyEl.children();\n\t\tvar i, trEl;\n\t\tvar trHeight;\n\n\t\tfunction iterInnerHeights(i, childNode) {\n\t\t\ttrHeight = Math.max(trHeight, $(childNode).outerHeight());\n\t\t}\n\n\t\t// Reveal one level <tr> at a time and stop when we find one out of bounds\n\t\tfor (i = 0; i < trEls.length; i++) {\n\t\t\ttrEl = trEls.eq(i).removeClass('fc-limited'); // reset to original state (reveal)\n\n\t\t\t// with rowspans>1 and IE8, trEl.outerHeight() would return the height of the largest cell,\n\t\t\t// so instead, find the tallest inner content element.\n\t\t\ttrHeight = 0;\n\t\t\ttrEl.find('> td > :first-child').each(iterInnerHeights);\n\n\t\t\tif (trEl.position().top + trHeight > rowHeight) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\treturn false; // should not limit at all\n\t},\n\n\n\t// Limits the given grid row to the maximum number of levels and injects \"more\" links if necessary.\n\t// `row` is the row number.\n\t// `levelLimit` is a number for the maximum (inclusive) number of levels allowed.\n\tlimitRow: function(row, levelLimit) {\n\t\tvar _this = this;\n\t\tvar rowStruct = this.rowStructs[row];\n\t\tvar moreNodes = []; // array of \"more\" <a> links and <td> DOM nodes\n\t\tvar col = 0; // col #, left-to-right (not chronologically)\n\t\tvar levelSegs; // array of segment objects in the last allowable level, ordered left-to-right\n\t\tvar cellMatrix; // a matrix (by level, then column) of all <td> jQuery elements in the row\n\t\tvar limitedNodes; // array of temporarily hidden level <tr> and segment <td> DOM nodes\n\t\tvar i, seg;\n\t\tvar segsBelow; // array of segment objects below `seg` in the current `col`\n\t\tvar totalSegsBelow; // total number of segments below `seg` in any of the columns `seg` occupies\n\t\tvar colSegsBelow; // array of segment arrays, below seg, one for each column (offset from segs's first column)\n\t\tvar td, rowspan;\n\t\tvar segMoreNodes; // array of \"more\" <td> cells that will stand-in for the current seg's cell\n\t\tvar j;\n\t\tvar moreTd, moreWrap, moreLink;\n\n\t\t// Iterates through empty level cells and places \"more\" links inside if need be\n\t\tfunction emptyCellsUntil(endCol) { // goes from current `col` to `endCol`\n\t\t\twhile (col < endCol) {\n\t\t\t\tsegsBelow = _this.getCellSegs(row, col, levelLimit);\n\t\t\t\tif (segsBelow.length) {\n\t\t\t\t\ttd = cellMatrix[levelLimit - 1][col];\n\t\t\t\t\tmoreLink = _this.renderMoreLink(row, col, segsBelow);\n\t\t\t\t\tmoreWrap = $('<div/>').append(moreLink);\n\t\t\t\t\ttd.append(moreWrap);\n\t\t\t\t\tmoreNodes.push(moreWrap[0]);\n\t\t\t\t}\n\t\t\t\tcol++;\n\t\t\t}\n\t\t}\n\n\t\tif (levelLimit && levelLimit < rowStruct.segLevels.length) { // is it actually over the limit?\n\t\t\tlevelSegs = rowStruct.segLevels[levelLimit - 1];\n\t\t\tcellMatrix = rowStruct.cellMatrix;\n\n\t\t\tlimitedNodes = rowStruct.tbodyEl.children().slice(levelLimit) // get level <tr> elements past the limit\n\t\t\t\t.addClass('fc-limited').get(); // hide elements and get a simple DOM-nodes array\n\n\t\t\t// iterate though segments in the last allowable level\n\t\t\tfor (i = 0; i < levelSegs.length; i++) {\n\t\t\t\tseg = levelSegs[i];\n\t\t\t\temptyCellsUntil(seg.leftCol); // process empty cells before the segment\n\n\t\t\t\t// determine *all* segments below `seg` that occupy the same columns\n\t\t\t\tcolSegsBelow = [];\n\t\t\t\ttotalSegsBelow = 0;\n\t\t\t\twhile (col <= seg.rightCol) {\n\t\t\t\t\tsegsBelow = this.getCellSegs(row, col, levelLimit);\n\t\t\t\t\tcolSegsBelow.push(segsBelow);\n\t\t\t\t\ttotalSegsBelow += segsBelow.length;\n\t\t\t\t\tcol++;\n\t\t\t\t}\n\n\t\t\t\tif (totalSegsBelow) { // do we need to replace this segment with one or many \"more\" links?\n\t\t\t\t\ttd = cellMatrix[levelLimit - 1][seg.leftCol]; // the segment's parent cell\n\t\t\t\t\trowspan = td.attr('rowspan') || 1;\n\t\t\t\t\tsegMoreNodes = [];\n\n\t\t\t\t\t// make a replacement <td> for each column the segment occupies. will be one for each colspan\n\t\t\t\t\tfor (j = 0; j < colSegsBelow.length; j++) {\n\t\t\t\t\t\tmoreTd = $('<td class=\"fc-more-cell\"/>').attr('rowspan', rowspan);\n\t\t\t\t\t\tsegsBelow = colSegsBelow[j];\n\t\t\t\t\t\tmoreLink = this.renderMoreLink(\n\t\t\t\t\t\t\trow,\n\t\t\t\t\t\t\tseg.leftCol + j,\n\t\t\t\t\t\t\t[ seg ].concat(segsBelow) // count seg as hidden too\n\t\t\t\t\t\t);\n\t\t\t\t\t\tmoreWrap = $('<div/>').append(moreLink);\n\t\t\t\t\t\tmoreTd.append(moreWrap);\n\t\t\t\t\t\tsegMoreNodes.push(moreTd[0]);\n\t\t\t\t\t\tmoreNodes.push(moreTd[0]);\n\t\t\t\t\t}\n\n\t\t\t\t\ttd.addClass('fc-limited').after($(segMoreNodes)); // hide original <td> and inject replacements\n\t\t\t\t\tlimitedNodes.push(td[0]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\temptyCellsUntil(this.colCnt); // finish off the level\n\t\t\trowStruct.moreEls = $(moreNodes); // for easy undoing later\n\t\t\trowStruct.limitedEls = $(limitedNodes); // for easy undoing later\n\t\t}\n\t},\n\n\n\t// Reveals all levels and removes all \"more\"-related elements for a grid's row.\n\t// `row` is a row number.\n\tunlimitRow: function(row) {\n\t\tvar rowStruct = this.rowStructs[row];\n\n\t\tif (rowStruct.moreEls) {\n\t\t\trowStruct.moreEls.remove();\n\t\t\trowStruct.moreEls = null;\n\t\t}\n\n\t\tif (rowStruct.limitedEls) {\n\t\t\trowStruct.limitedEls.removeClass('fc-limited');\n\t\t\trowStruct.limitedEls = null;\n\t\t}\n\t},\n\n\n\t// Renders an <a> element that represents hidden event element for a cell.\n\t// Responsible for attaching click handler as well.\n\trenderMoreLink: function(row, col, hiddenSegs) {\n\t\tvar _this = this;\n\t\tvar view = this.view;\n\n\t\treturn $('<a class=\"fc-more\"/>')\n\t\t\t.text(\n\t\t\t\tthis.getMoreLinkText(hiddenSegs.length)\n\t\t\t)\n\t\t\t.on('click', function(ev) {\n\t\t\t\tvar clickOption = view.opt('eventLimitClick');\n\t\t\t\tvar date = _this.getCellDate(row, col);\n\t\t\t\tvar moreEl = $(this);\n\t\t\t\tvar dayEl = _this.getCellEl(row, col);\n\t\t\t\tvar allSegs = _this.getCellSegs(row, col);\n\n\t\t\t\t// rescope the segments to be within the cell's date\n\t\t\t\tvar reslicedAllSegs = _this.resliceDaySegs(allSegs, date);\n\t\t\t\tvar reslicedHiddenSegs = _this.resliceDaySegs(hiddenSegs, date);\n\n\t\t\t\tif (typeof clickOption === 'function') {\n\t\t\t\t\t// the returned value can be an atomic option\n\t\t\t\t\tclickOption = view.trigger('eventLimitClick', null, {\n\t\t\t\t\t\tdate: date,\n\t\t\t\t\t\tdayEl: dayEl,\n\t\t\t\t\t\tmoreEl: moreEl,\n\t\t\t\t\t\tsegs: reslicedAllSegs,\n\t\t\t\t\t\thiddenSegs: reslicedHiddenSegs\n\t\t\t\t\t}, ev);\n\t\t\t\t}\n\n\t\t\t\tif (clickOption === 'popover') {\n\t\t\t\t\t_this.showSegPopover(row, col, moreEl, reslicedAllSegs);\n\t\t\t\t}\n\t\t\t\telse if (typeof clickOption === 'string') { // a view name\n\t\t\t\t\tview.calendar.zoomTo(date, clickOption);\n\t\t\t\t}\n\t\t\t});\n\t},\n\n\n\t// Reveals the popover that displays all events within a cell\n\tshowSegPopover: function(row, col, moreLink, segs) {\n\t\tvar _this = this;\n\t\tvar view = this.view;\n\t\tvar moreWrap = moreLink.parent(); // the <div> wrapper around the <a>\n\t\tvar topEl; // the element we want to match the top coordinate of\n\t\tvar options;\n\n\t\tif (this.rowCnt == 1) {\n\t\t\ttopEl = view.el; // will cause the popover to cover any sort of header\n\t\t}\n\t\telse {\n\t\t\ttopEl = this.rowEls.eq(row); // will align with top of row\n\t\t}\n\n\t\toptions = {\n\t\t\tclassName: 'fc-more-popover',\n\t\t\tcontent: this.renderSegPopoverContent(row, col, segs),\n\t\t\tparentEl: this.view.el, // attach to root of view. guarantees outside of scrollbars.\n\t\t\ttop: topEl.offset().top,\n\t\t\tautoHide: true, // when the user clicks elsewhere, hide the popover\n\t\t\tviewportConstrain: view.opt('popoverViewportConstrain'),\n\t\t\thide: function() {\n\t\t\t\t// kill everything when the popover is hidden\n\t\t\t\t_this.segPopover.removeElement();\n\t\t\t\t_this.segPopover = null;\n\t\t\t\t_this.popoverSegs = null;\n\t\t\t}\n\t\t};\n\n\t\t// Determine horizontal coordinate.\n\t\t// We use the moreWrap instead of the <td> to avoid border confusion.\n\t\tif (this.isRTL) {\n\t\t\toptions.right = moreWrap.offset().left + moreWrap.outerWidth() + 1; // +1 to be over cell border\n\t\t}\n\t\telse {\n\t\t\toptions.left = moreWrap.offset().left - 1; // -1 to be over cell border\n\t\t}\n\n\t\tthis.segPopover = new Popover(options);\n\t\tthis.segPopover.show();\n\n\t\t// the popover doesn't live within the grid's container element, and thus won't get the event\n\t\t// delegated-handlers for free. attach event-related handlers to the popover.\n\t\tthis.bindSegHandlersToEl(this.segPopover.el);\n\t},\n\n\n\t// Builds the inner DOM contents of the segment popover\n\trenderSegPopoverContent: function(row, col, segs) {\n\t\tvar view = this.view;\n\t\tvar isTheme = view.opt('theme');\n\t\tvar title = this.getCellDate(row, col).format(view.opt('dayPopoverFormat'));\n\t\tvar content = $(\n\t\t\t'<div class=\"fc-header ' + view.widgetHeaderClass + '\">' +\n\t\t\t\t'<span class=\"fc-close ' +\n\t\t\t\t\t(isTheme ? 'ui-icon ui-icon-closethick' : 'fc-icon fc-icon-x') +\n\t\t\t\t'\"></span>' +\n\t\t\t\t'<span class=\"fc-title\">' +\n\t\t\t\t\thtmlEscape(title) +\n\t\t\t\t'</span>' +\n\t\t\t\t'<div class=\"fc-clear\"/>' +\n\t\t\t'</div>' +\n\t\t\t'<div class=\"fc-body ' + view.widgetContentClass + '\">' +\n\t\t\t\t'<div class=\"fc-event-container\"></div>' +\n\t\t\t'</div>'\n\t\t);\n\t\tvar segContainer = content.find('.fc-event-container');\n\t\tvar i;\n\n\t\t// render each seg's `el` and only return the visible segs\n\t\tsegs = this.renderFgSegEls(segs, true); // disableResizing=true\n\t\tthis.popoverSegs = segs;\n\n\t\tfor (i = 0; i < segs.length; i++) {\n\n\t\t\t// because segments in the popover are not part of a grid coordinate system, provide a hint to any\n\t\t\t// grids that want to do drag-n-drop about which cell it came from\n\t\t\tthis.prepareHits();\n\t\t\tsegs[i].hit = this.getCellHit(row, col);\n\t\t\tthis.releaseHits();\n\n\t\t\tsegContainer.append(segs[i].el);\n\t\t}\n\n\t\treturn content;\n\t},\n\n\n\t// Given the events within an array of segment objects, reslice them to be in a single day\n\tresliceDaySegs: function(segs, dayDate) {\n\n\t\t// build an array of the original events\n\t\tvar events = $.map(segs, function(seg) {\n\t\t\treturn seg.event;\n\t\t});\n\n\t\tvar dayStart = dayDate.clone();\n\t\tvar dayEnd = dayStart.clone().add(1, 'days');\n\t\tvar dayRange = { start: dayStart, end: dayEnd };\n\n\t\t// slice the events with a custom slicing function\n\t\tsegs = this.eventsToSegs(\n\t\t\tevents,\n\t\t\tfunction(range) {\n\t\t\t\tvar seg = intersectRanges(range, dayRange); // undefind if no intersection\n\t\t\t\treturn seg ? [ seg ] : []; // must return an array of segments\n\t\t\t}\n\t\t);\n\n\t\t// force an order because eventsToSegs doesn't guarantee one\n\t\tthis.sortEventSegs(segs);\n\n\t\treturn segs;\n\t},\n\n\n\t// Generates the text that should be inside a \"more\" link, given the number of events it represents\n\tgetMoreLinkText: function(num) {\n\t\tvar opt = this.view.opt('eventLimitText');\n\n\t\tif (typeof opt === 'function') {\n\t\t\treturn opt(num);\n\t\t}\n\t\telse {\n\t\t\treturn '+' + num + ' ' + opt;\n\t\t}\n\t},\n\n\n\t// Returns segments within a given cell.\n\t// If `startLevel` is specified, returns only events including and below that level. Otherwise returns all segs.\n\tgetCellSegs: function(row, col, startLevel) {\n\t\tvar segMatrix = this.rowStructs[row].segMatrix;\n\t\tvar level = startLevel || 0;\n\t\tvar segs = [];\n\t\tvar seg;\n\n\t\twhile (level < segMatrix.length) {\n\t\t\tseg = segMatrix[level][col];\n\t\t\tif (seg) {\n\t\t\t\tsegs.push(seg);\n\t\t\t}\n\t\t\tlevel++;\n\t\t}\n\n\t\treturn segs;\n\t}\n\n});\n\n;;\n\n/* A component that renders one or more columns of vertical time slots\n----------------------------------------------------------------------------------------------------------------------*/\n// We mixin DayTable, even though there is only a single row of days\n\nvar TimeGrid = FC.TimeGrid = Grid.extend(DayTableMixin, {\n\n\tslotDuration: null, // duration of a \"slot\", a distinct time segment on given day, visualized by lines\n\tsnapDuration: null, // granularity of time for dragging and selecting\n\tsnapsPerSlot: null,\n\tminTime: null, // Duration object that denotes the first visible time of any given day\n\tmaxTime: null, // Duration object that denotes the exclusive visible end time of any given day\n\tlabelFormat: null, // formatting string for times running along vertical axis\n\tlabelInterval: null, // duration of how often a label should be displayed for a slot\n\n\tcolEls: null, // cells elements in the day-row background\n\tslatContainerEl: null, // div that wraps all the slat rows\n\tslatEls: null, // elements running horizontally across all columns\n\tnowIndicatorEls: null,\n\n\tcolCoordCache: null,\n\tslatCoordCache: null,\n\n\n\tconstructor: function() {\n\t\tGrid.apply(this, arguments); // call the super-constructor\n\n\t\tthis.processOptions();\n\t},\n\n\n\t// Renders the time grid into `this.el`, which should already be assigned.\n\t// Relies on the view's colCnt. In the future, this component should probably be self-sufficient.\n\trenderDates: function() {\n\t\tthis.el.html(this.renderHtml());\n\t\tthis.colEls = this.el.find('.fc-day');\n\t\tthis.slatContainerEl = this.el.find('.fc-slats');\n\t\tthis.slatEls = this.slatContainerEl.find('tr');\n\n\t\tthis.colCoordCache = new CoordCache({\n\t\t\tels: this.colEls,\n\t\t\tisHorizontal: true\n\t\t});\n\t\tthis.slatCoordCache = new CoordCache({\n\t\t\tels: this.slatEls,\n\t\t\tisVertical: true\n\t\t});\n\n\t\tthis.renderContentSkeleton();\n\t},\n\n\n\t// Renders the basic HTML skeleton for the grid\n\trenderHtml: function() {\n\t\treturn '' +\n\t\t\t'<div class=\"fc-bg\">' +\n\t\t\t\t'<table>' +\n\t\t\t\t\tthis.renderBgTrHtml(0) + // row=0\n\t\t\t\t'</table>' +\n\t\t\t'</div>' +\n\t\t\t'<div class=\"fc-slats\">' +\n\t\t\t\t'<table>' +\n\t\t\t\t\tthis.renderSlatRowHtml() +\n\t\t\t\t'</table>' +\n\t\t\t'</div>';\n\t},\n\n\n\t// Generates the HTML for the horizontal \"slats\" that run width-wise. Has a time axis on a side. Depends on RTL.\n\trenderSlatRowHtml: function() {\n\t\tvar view = this.view;\n\t\tvar isRTL = this.isRTL;\n\t\tvar html = '';\n\t\tvar slotTime = moment.duration(+this.minTime); // wish there was .clone() for durations\n\t\tvar slotDate; // will be on the view's first day, but we only care about its time\n\t\tvar isLabeled;\n\t\tvar axisHtml;\n\n\t\t// Calculate the time for each slot\n\t\twhile (slotTime < this.maxTime) {\n\t\t\tslotDate = this.start.clone().time(slotTime);\n\t\t\tisLabeled = isInt(divideDurationByDuration(slotTime, this.labelInterval));\n\n\t\t\taxisHtml =\n\t\t\t\t'<td class=\"fc-axis fc-time ' + view.widgetContentClass + '\" ' + view.axisStyleAttr() + '>' +\n\t\t\t\t\t(isLabeled ?\n\t\t\t\t\t\t'<span>' + // for matchCellWidths\n\t\t\t\t\t\t\thtmlEscape(slotDate.format(this.labelFormat)) +\n\t\t\t\t\t\t'</span>' :\n\t\t\t\t\t\t''\n\t\t\t\t\t\t) +\n\t\t\t\t'</td>';\n\n\t\t\thtml +=\n\t\t\t\t'<tr data-time=\"' + slotDate.format('HH:mm:ss') + '\"' +\n\t\t\t\t\t(isLabeled ? '' : ' class=\"fc-minor\"') +\n\t\t\t\t\t'>' +\n\t\t\t\t\t(!isRTL ? axisHtml : '') +\n\t\t\t\t\t'<td class=\"' + view.widgetContentClass + '\"/>' +\n\t\t\t\t\t(isRTL ? axisHtml : '') +\n\t\t\t\t\"</tr>\";\n\n\t\t\tslotTime.add(this.slotDuration);\n\t\t}\n\n\t\treturn html;\n\t},\n\n\n\t/* Options\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Parses various options into properties of this object\n\tprocessOptions: function() {\n\t\tvar view = this.view;\n\t\tvar slotDuration = view.opt('slotDuration');\n\t\tvar snapDuration = view.opt('snapDuration');\n\t\tvar input;\n\n\t\tslotDuration = moment.duration(slotDuration);\n\t\tsnapDuration = snapDuration ? moment.duration(snapDuration) : slotDuration;\n\n\t\tthis.slotDuration = slotDuration;\n\t\tthis.snapDuration = snapDuration;\n\t\tthis.snapsPerSlot = slotDuration / snapDuration; // TODO: ensure an integer multiple?\n\n\t\tthis.minResizeDuration = snapDuration; // hack\n\n\t\tthis.minTime = moment.duration(view.opt('minTime'));\n\t\tthis.maxTime = moment.duration(view.opt('maxTime'));\n\n\t\t// might be an array value (for TimelineView).\n\t\t// if so, getting the most granular entry (the last one probably).\n\t\tinput = view.opt('slotLabelFormat');\n\t\tif ($.isArray(input)) {\n\t\t\tinput = input[input.length - 1];\n\t\t}\n\n\t\tthis.labelFormat =\n\t\t\tinput ||\n\t\t\tview.opt('smallTimeFormat'); // the computed default\n\n\t\tinput = view.opt('slotLabelInterval');\n\t\tthis.labelInterval = input ?\n\t\t\tmoment.duration(input) :\n\t\t\tthis.computeLabelInterval(slotDuration);\n\t},\n\n\n\t// Computes an automatic value for slotLabelInterval\n\tcomputeLabelInterval: function(slotDuration) {\n\t\tvar i;\n\t\tvar labelInterval;\n\t\tvar slotsPerLabel;\n\n\t\t// find the smallest stock label interval that results in more than one slots-per-label\n\t\tfor (i = AGENDA_STOCK_SUB_DURATIONS.length - 1; i >= 0; i--) {\n\t\t\tlabelInterval = moment.duration(AGENDA_STOCK_SUB_DURATIONS[i]);\n\t\t\tslotsPerLabel = divideDurationByDuration(labelInterval, slotDuration);\n\t\t\tif (isInt(slotsPerLabel) && slotsPerLabel > 1) {\n\t\t\t\treturn labelInterval;\n\t\t\t}\n\t\t}\n\n\t\treturn moment.duration(slotDuration); // fall back. clone\n\t},\n\n\n\t// Computes a default event time formatting string if `timeFormat` is not explicitly defined\n\tcomputeEventTimeFormat: function() {\n\t\treturn this.view.opt('noMeridiemTimeFormat'); // like \"6:30\" (no AM/PM)\n\t},\n\n\n\t// Computes a default `displayEventEnd` value if one is not expliclty defined\n\tcomputeDisplayEventEnd: function() {\n\t\treturn true;\n\t},\n\n\n\t/* Hit System\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\tprepareHits: function() {\n\t\tthis.colCoordCache.build();\n\t\tthis.slatCoordCache.build();\n\t},\n\n\n\treleaseHits: function() {\n\t\tthis.colCoordCache.clear();\n\t\t// NOTE: don't clear slatCoordCache because we rely on it for computeTimeTop\n\t},\n\n\n\tqueryHit: function(leftOffset, topOffset) {\n\t\tvar snapsPerSlot = this.snapsPerSlot;\n\t\tvar colCoordCache = this.colCoordCache;\n\t\tvar slatCoordCache = this.slatCoordCache;\n\n\t\tif (colCoordCache.isLeftInBounds(leftOffset) && slatCoordCache.isTopInBounds(topOffset)) {\n\t\t\tvar colIndex = colCoordCache.getHorizontalIndex(leftOffset);\n\t\t\tvar slatIndex = slatCoordCache.getVerticalIndex(topOffset);\n\n\t\t\tif (colIndex != null && slatIndex != null) {\n\t\t\t\tvar slatTop = slatCoordCache.getTopOffset(slatIndex);\n\t\t\t\tvar slatHeight = slatCoordCache.getHeight(slatIndex);\n\t\t\t\tvar partial = (topOffset - slatTop) / slatHeight; // floating point number between 0 and 1\n\t\t\t\tvar localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat\n\t\t\t\tvar snapIndex = slatIndex * snapsPerSlot + localSnapIndex;\n\t\t\t\tvar snapTop = slatTop + (localSnapIndex / snapsPerSlot) * slatHeight;\n\t\t\t\tvar snapBottom = slatTop + ((localSnapIndex + 1) / snapsPerSlot) * slatHeight;\n\n\t\t\t\treturn {\n\t\t\t\t\tcol: colIndex,\n\t\t\t\t\tsnap: snapIndex,\n\t\t\t\t\tcomponent: this, // needed unfortunately :(\n\t\t\t\t\tleft: colCoordCache.getLeftOffset(colIndex),\n\t\t\t\t\tright: colCoordCache.getRightOffset(colIndex),\n\t\t\t\t\ttop: snapTop,\n\t\t\t\t\tbottom: snapBottom\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t},\n\n\n\tgetHitSpan: function(hit) {\n\t\tvar start = this.getCellDate(0, hit.col); // row=0\n\t\tvar time = this.computeSnapTime(hit.snap); // pass in the snap-index\n\t\tvar end;\n\n\t\tstart.time(time);\n\t\tend = start.clone().add(this.snapDuration);\n\n\t\treturn { start: start, end: end };\n\t},\n\n\n\tgetHitEl: function(hit) {\n\t\treturn this.colEls.eq(hit.col);\n\t},\n\n\n\t/* Dates\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\trangeUpdated: function() {\n\t\tthis.updateDayTable();\n\t},\n\n\n\t// Given a row number of the grid, representing a \"snap\", returns a time (Duration) from its start-of-day\n\tcomputeSnapTime: function(snapIndex) {\n\t\treturn moment.duration(this.minTime + this.snapDuration * snapIndex);\n\t},\n\n\n\t// Slices up the given span (unzoned start/end with other misc data) into an array of segments\n\tspanToSegs: function(span) {\n\t\tvar segs = this.sliceRangeByTimes(span);\n\t\tvar i;\n\n\t\tfor (i = 0; i < segs.length; i++) {\n\t\t\tif (this.isRTL) {\n\t\t\t\tsegs[i].col = this.daysPerRow - 1 - segs[i].dayIndex;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsegs[i].col = segs[i].dayIndex;\n\t\t\t}\n\t\t}\n\n\t\treturn segs;\n\t},\n\n\n\tsliceRangeByTimes: function(range) {\n\t\tvar segs = [];\n\t\tvar seg;\n\t\tvar dayIndex;\n\t\tvar dayDate;\n\t\tvar dayRange;\n\n\t\tfor (dayIndex = 0; dayIndex < this.daysPerRow; dayIndex++) {\n\t\t\tdayDate = this.dayDates[dayIndex].clone(); // TODO: better API for this?\n\t\t\tdayRange = {\n\t\t\t\tstart: dayDate.clone().time(this.minTime),\n\t\t\t\tend: dayDate.clone().time(this.maxTime)\n\t\t\t};\n\t\t\tseg = intersectRanges(range, dayRange); // both will be ambig timezone\n\t\t\tif (seg) {\n\t\t\t\tseg.dayIndex = dayIndex;\n\t\t\t\tsegs.push(seg);\n\t\t\t}\n\t\t}\n\n\t\treturn segs;\n\t},\n\n\n\t/* Coordinates\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\tupdateSize: function(isResize) { // NOT a standard Grid method\n\t\tthis.slatCoordCache.build();\n\n\t\tif (isResize) {\n\t\t\tthis.updateSegVerticals(\n\t\t\t\t[].concat(this.fgSegs || [], this.bgSegs || [], this.businessSegs || [])\n\t\t\t);\n\t\t}\n\t},\n\n\n\tgetTotalSlatHeight: function() {\n\t\treturn this.slatContainerEl.outerHeight();\n\t},\n\n\n\t// Computes the top coordinate, relative to the bounds of the grid, of the given date.\n\t// A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.\n\tcomputeDateTop: function(date, startOfDayDate) {\n\t\treturn this.computeTimeTop(\n\t\t\tmoment.duration(\n\t\t\t\tdate - startOfDayDate.clone().stripTime()\n\t\t\t)\n\t\t);\n\t},\n\n\n\t// Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).\n\tcomputeTimeTop: function(time) {\n\t\tvar len = this.slatEls.length;\n\t\tvar slatCoverage = (time - this.minTime) / this.slotDuration; // floating-point value of # of slots covered\n\t\tvar slatIndex;\n\t\tvar slatRemainder;\n\n\t\t// compute a floating-point number for how many slats should be progressed through.\n\t\t// from 0 to number of slats (inclusive)\n\t\t// constrained because minTime/maxTime might be customized.\n\t\tslatCoverage = Math.max(0, slatCoverage);\n\t\tslatCoverage = Math.min(len, slatCoverage);\n\n\t\t// an integer index of the furthest whole slat\n\t\t// from 0 to number slats (*exclusive*, so len-1)\n\t\tslatIndex = Math.floor(slatCoverage);\n\t\tslatIndex = Math.min(slatIndex, len - 1);\n\n\t\t// how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.\n\t\t// could be 1.0 if slatCoverage is covering *all* the slots\n\t\tslatRemainder = slatCoverage - slatIndex;\n\n\t\treturn this.slatCoordCache.getTopPosition(slatIndex) +\n\t\t\tthis.slatCoordCache.getHeight(slatIndex) * slatRemainder;\n\t},\n\n\n\n\t/* Event Drag Visualization\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Renders a visual indication of an event being dragged over the specified date(s).\n\t// A returned value of `true` signals that a mock \"helper\" event has been rendered.\n\trenderDrag: function(eventLocation, seg) {\n\n\t\tif (seg) { // if there is event information for this drag, render a helper event\n\n\t\t\t// returns mock event elements\n\t\t\t// signal that a helper has been rendered\n\t\t\treturn this.renderEventLocationHelper(eventLocation, seg);\n\t\t}\n\t\telse {\n\t\t\t// otherwise, just render a highlight\n\t\t\tthis.renderHighlight(this.eventToSpan(eventLocation));\n\t\t}\n\t},\n\n\n\t// Unrenders any visual indication of an event being dragged\n\tunrenderDrag: function() {\n\t\tthis.unrenderHelper();\n\t\tthis.unrenderHighlight();\n\t},\n\n\n\t/* Event Resize Visualization\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Renders a visual indication of an event being resized\n\trenderEventResize: function(eventLocation, seg) {\n\t\treturn this.renderEventLocationHelper(eventLocation, seg); // returns mock event elements\n\t},\n\n\n\t// Unrenders any visual indication of an event being resized\n\tunrenderEventResize: function() {\n\t\tthis.unrenderHelper();\n\t},\n\n\n\t/* Event Helper\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Renders a mock \"helper\" event. `sourceSeg` is the original segment object and might be null (an external drag)\n\trenderHelper: function(event, sourceSeg) {\n\t\treturn this.renderHelperSegs(this.eventToSegs(event), sourceSeg); // returns mock event elements\n\t},\n\n\n\t// Unrenders any mock helper event\n\tunrenderHelper: function() {\n\t\tthis.unrenderHelperSegs();\n\t},\n\n\n\t/* Business Hours\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\trenderBusinessHours: function() {\n\t\tthis.renderBusinessSegs(\n\t\t\tthis.buildBusinessHourSegs()\n\t\t);\n\t},\n\n\n\tunrenderBusinessHours: function() {\n\t\tthis.unrenderBusinessSegs();\n\t},\n\n\n\t/* Now Indicator\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\tgetNowIndicatorUnit: function() {\n\t\treturn 'minute'; // will refresh on the minute\n\t},\n\n\n\trenderNowIndicator: function(date) {\n\t\t// seg system might be overkill, but it handles scenario where line needs to be rendered\n\t\t//  more than once because of columns with the same date (resources columns for example)\n\t\tvar segs = this.spanToSegs({ start: date, end: date });\n\t\tvar top = this.computeDateTop(date, date);\n\t\tvar nodes = [];\n\t\tvar i;\n\n\t\t// render lines within the columns\n\t\tfor (i = 0; i < segs.length; i++) {\n\t\t\tnodes.push($('<div class=\"fc-now-indicator fc-now-indicator-line\"></div>')\n\t\t\t\t.css('top', top)\n\t\t\t\t.appendTo(this.colContainerEls.eq(segs[i].col))[0]);\n\t\t}\n\n\t\t// render an arrow over the axis\n\t\tif (segs.length > 0) { // is the current time in view?\n\t\t\tnodes.push($('<div class=\"fc-now-indicator fc-now-indicator-arrow\"></div>')\n\t\t\t\t.css('top', top)\n\t\t\t\t.appendTo(this.el.find('.fc-content-skeleton'))[0]);\n\t\t}\n\n\t\tthis.nowIndicatorEls = $(nodes);\n\t},\n\n\n\tunrenderNowIndicator: function() {\n\t\tif (this.nowIndicatorEls) {\n\t\t\tthis.nowIndicatorEls.remove();\n\t\t\tthis.nowIndicatorEls = null;\n\t\t}\n\t},\n\n\n\t/* Selection\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Renders a visual indication of a selection. Overrides the default, which was to simply render a highlight.\n\trenderSelection: function(span) {\n\t\tif (this.view.opt('selectHelper')) { // this setting signals that a mock helper event should be rendered\n\n\t\t\t// normally acceps an eventLocation, span has a start/end, which is good enough\n\t\t\tthis.renderEventLocationHelper(span);\n\t\t}\n\t\telse {\n\t\t\tthis.renderHighlight(span);\n\t\t}\n\t},\n\n\n\t// Unrenders any visual indication of a selection\n\tunrenderSelection: function() {\n\t\tthis.unrenderHelper();\n\t\tthis.unrenderHighlight();\n\t},\n\n\n\t/* Highlight\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\trenderHighlight: function(span) {\n\t\tthis.renderHighlightSegs(this.spanToSegs(span));\n\t},\n\n\n\tunrenderHighlight: function() {\n\t\tthis.unrenderHighlightSegs();\n\t}\n\n});\n\n;;\n\n/* Methods for rendering SEGMENTS, pieces of content that live on the view\n ( this file is no longer just for events )\n----------------------------------------------------------------------------------------------------------------------*/\n\nTimeGrid.mixin({\n\n\tcolContainerEls: null, // containers for each column\n\n\t// inner-containers for each column where different types of segs live\n\tfgContainerEls: null,\n\tbgContainerEls: null,\n\thelperContainerEls: null,\n\thighlightContainerEls: null,\n\tbusinessContainerEls: null,\n\n\t// arrays of different types of displayed segments\n\tfgSegs: null,\n\tbgSegs: null,\n\thelperSegs: null,\n\thighlightSegs: null,\n\tbusinessSegs: null,\n\n\n\t// Renders the DOM that the view's content will live in\n\trenderContentSkeleton: function() {\n\t\tvar cellHtml = '';\n\t\tvar i;\n\t\tvar skeletonEl;\n\n\t\tfor (i = 0; i < this.colCnt; i++) {\n\t\t\tcellHtml +=\n\t\t\t\t'<td>' +\n\t\t\t\t\t'<div class=\"fc-content-col\">' +\n\t\t\t\t\t\t'<div class=\"fc-event-container fc-helper-container\"></div>' +\n\t\t\t\t\t\t'<div class=\"fc-event-container\"></div>' +\n\t\t\t\t\t\t'<div class=\"fc-highlight-container\"></div>' +\n\t\t\t\t\t\t'<div class=\"fc-bgevent-container\"></div>' +\n\t\t\t\t\t\t'<div class=\"fc-business-container\"></div>' +\n\t\t\t\t\t'</div>' +\n\t\t\t\t'</td>';\n\t\t}\n\n\t\tskeletonEl = $(\n\t\t\t'<div class=\"fc-content-skeleton\">' +\n\t\t\t\t'<table>' +\n\t\t\t\t\t'<tr>' + cellHtml + '</tr>' +\n\t\t\t\t'</table>' +\n\t\t\t'</div>'\n\t\t);\n\n\t\tthis.colContainerEls = skeletonEl.find('.fc-content-col');\n\t\tthis.helperContainerEls = skeletonEl.find('.fc-helper-container');\n\t\tthis.fgContainerEls = skeletonEl.find('.fc-event-container:not(.fc-helper-container)');\n\t\tthis.bgContainerEls = skeletonEl.find('.fc-bgevent-container');\n\t\tthis.highlightContainerEls = skeletonEl.find('.fc-highlight-container');\n\t\tthis.businessContainerEls = skeletonEl.find('.fc-business-container');\n\n\t\tthis.bookendCells(skeletonEl.find('tr')); // TODO: do this on string level\n\t\tthis.el.append(skeletonEl);\n\t},\n\n\n\t/* Foreground Events\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\trenderFgSegs: function(segs) {\n\t\tsegs = this.renderFgSegsIntoContainers(segs, this.fgContainerEls);\n\t\tthis.fgSegs = segs;\n\t\treturn segs; // needed for Grid::renderEvents\n\t},\n\n\n\tunrenderFgSegs: function() {\n\t\tthis.unrenderNamedSegs('fgSegs');\n\t},\n\n\n\t/* Foreground Helper Events\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\trenderHelperSegs: function(segs, sourceSeg) {\n\t\tvar helperEls = [];\n\t\tvar i, seg;\n\t\tvar sourceEl;\n\n\t\tsegs = this.renderFgSegsIntoContainers(segs, this.helperContainerEls);\n\n\t\t// Try to make the segment that is in the same row as sourceSeg look the same\n\t\tfor (i = 0; i < segs.length; i++) {\n\t\t\tseg = segs[i];\n\t\t\tif (sourceSeg && sourceSeg.col === seg.col) {\n\t\t\t\tsourceEl = sourceSeg.el;\n\t\t\t\tseg.el.css({\n\t\t\t\t\tleft: sourceEl.css('left'),\n\t\t\t\t\tright: sourceEl.css('right'),\n\t\t\t\t\t'margin-left': sourceEl.css('margin-left'),\n\t\t\t\t\t'margin-right': sourceEl.css('margin-right')\n\t\t\t\t});\n\t\t\t}\n\t\t\thelperEls.push(seg.el[0]);\n\t\t}\n\n\t\tthis.helperSegs = segs;\n\n\t\treturn $(helperEls); // must return rendered helpers\n\t},\n\n\n\tunrenderHelperSegs: function() {\n\t\tthis.unrenderNamedSegs('helperSegs');\n\t},\n\n\n\t/* Background Events\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\trenderBgSegs: function(segs) {\n\t\tsegs = this.renderFillSegEls('bgEvent', segs); // TODO: old fill system\n\t\tthis.updateSegVerticals(segs);\n\t\tthis.attachSegsByCol(this.groupSegsByCol(segs), this.bgContainerEls);\n\t\tthis.bgSegs = segs;\n\t\treturn segs; // needed for Grid::renderEvents\n\t},\n\n\n\tunrenderBgSegs: function() {\n\t\tthis.unrenderNamedSegs('bgSegs');\n\t},\n\n\n\t/* Highlight\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\trenderHighlightSegs: function(segs) {\n\t\tsegs = this.renderFillSegEls('highlight', segs); // TODO: old fill system\n\t\tthis.updateSegVerticals(segs);\n\t\tthis.attachSegsByCol(this.groupSegsByCol(segs), this.highlightContainerEls);\n\t\tthis.highlightSegs = segs;\n\t},\n\n\n\tunrenderHighlightSegs: function() {\n\t\tthis.unrenderNamedSegs('highlightSegs');\n\t},\n\n\n\t/* Business Hours\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\trenderBusinessSegs: function(segs) {\n\t\tsegs = this.renderFillSegEls('businessHours', segs); // TODO: old fill system\n\t\tthis.updateSegVerticals(segs);\n\t\tthis.attachSegsByCol(this.groupSegsByCol(segs), this.businessContainerEls);\n\t\tthis.businessSegs = segs;\n\t},\n\n\n\tunrenderBusinessSegs: function() {\n\t\tthis.unrenderNamedSegs('businessSegs');\n\t},\n\n\n\t/* Seg Rendering Utils\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Given a flat array of segments, return an array of sub-arrays, grouped by each segment's col\n\tgroupSegsByCol: function(segs) {\n\t\tvar segsByCol = [];\n\t\tvar i;\n\n\t\tfor (i = 0; i < this.colCnt; i++) {\n\t\t\tsegsByCol.push([]);\n\t\t}\n\n\t\tfor (i = 0; i < segs.length; i++) {\n\t\t\tsegsByCol[segs[i].col].push(segs[i]);\n\t\t}\n\n\t\treturn segsByCol;\n\t},\n\n\n\t// Given segments grouped by column, insert the segments' elements into a parallel array of container\n\t// elements, each living within a column.\n\tattachSegsByCol: function(segsByCol, containerEls) {\n\t\tvar col;\n\t\tvar segs;\n\t\tvar i;\n\n\t\tfor (col = 0; col < this.colCnt; col++) { // iterate each column grouping\n\t\t\tsegs = segsByCol[col];\n\n\t\t\tfor (i = 0; i < segs.length; i++) {\n\t\t\t\tcontainerEls.eq(col).append(segs[i].el);\n\t\t\t}\n\t\t}\n\t},\n\n\n\t// Given the name of a property of `this` object, assumed to be an array of segments,\n\t// loops through each segment and removes from DOM. Will null-out the property afterwards.\n\tunrenderNamedSegs: function(propName) {\n\t\tvar segs = this[propName];\n\t\tvar i;\n\n\t\tif (segs) {\n\t\t\tfor (i = 0; i < segs.length; i++) {\n\t\t\t\tsegs[i].el.remove();\n\t\t\t}\n\t\t\tthis[propName] = null;\n\t\t}\n\t},\n\n\n\n\t/* Foreground Event Rendering Utils\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Given an array of foreground segments, render a DOM element for each, computes position,\n\t// and attaches to the column inner-container elements.\n\trenderFgSegsIntoContainers: function(segs, containerEls) {\n\t\tvar segsByCol;\n\t\tvar col;\n\n\t\tsegs = this.renderFgSegEls(segs); // will call fgSegHtml\n\t\tsegsByCol = this.groupSegsByCol(segs);\n\n\t\tfor (col = 0; col < this.colCnt; col++) {\n\t\t\tthis.updateFgSegCoords(segsByCol[col]);\n\t\t}\n\n\t\tthis.attachSegsByCol(segsByCol, containerEls);\n\n\t\treturn segs;\n\t},\n\n\n\t// Renders the HTML for a single event segment's default rendering\n\tfgSegHtml: function(seg, disableResizing) {\n\t\tvar view = this.view;\n\t\tvar event = seg.event;\n\t\tvar isDraggable = view.isEventDraggable(event);\n\t\tvar isResizableFromStart = !disableResizing && seg.isStart && view.isEventResizableFromStart(event);\n\t\tvar isResizableFromEnd = !disableResizing && seg.isEnd && view.isEventResizableFromEnd(event);\n\t\tvar classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);\n\t\tvar skinCss = cssToStr(this.getSegSkinCss(seg));\n\t\tvar timeText;\n\t\tvar fullTimeText; // more verbose time text. for the print stylesheet\n\t\tvar startTimeText; // just the start time text\n\n\t\tclasses.unshift('fc-time-grid-event', 'fc-v-event');\n\n\t\tif (view.isMultiDayEvent(event)) { // if the event appears to span more than one day...\n\t\t\t// Don't display time text on segments that run entirely through a day.\n\t\t\t// That would appear as midnight-midnight and would look dumb.\n\t\t\t// Otherwise, display the time text for the *segment's* times (like 6pm-midnight or midnight-10am)\n\t\t\tif (seg.isStart || seg.isEnd) {\n\t\t\t\ttimeText = this.getEventTimeText(seg);\n\t\t\t\tfullTimeText = this.getEventTimeText(seg, 'LT');\n\t\t\t\tstartTimeText = this.getEventTimeText(seg, null, false); // displayEnd=false\n\t\t\t}\n\t\t} else {\n\t\t\t// Display the normal time text for the *event's* times\n\t\t\ttimeText = this.getEventTimeText(event);\n\t\t\tfullTimeText = this.getEventTimeText(event, 'LT');\n\t\t\tstartTimeText = this.getEventTimeText(event, null, false); // displayEnd=false\n\t\t}\n\n\t\treturn '<a class=\"' + classes.join(' ') + '\"' +\n\t\t\t(event.url ?\n\t\t\t\t' href=\"' + htmlEscape(event.url) + '\"' :\n\t\t\t\t''\n\t\t\t\t) +\n\t\t\t(skinCss ?\n\t\t\t\t' style=\"' + skinCss + '\"' :\n\t\t\t\t''\n\t\t\t\t) +\n\t\t\t'>' +\n\t\t\t\t'<div class=\"fc-content\">' +\n\t\t\t\t\t(timeText ?\n\t\t\t\t\t\t'<div class=\"fc-time\"' +\n\t\t\t\t\t\t' data-start=\"' + htmlEscape(startTimeText) + '\"' +\n\t\t\t\t\t\t' data-full=\"' + htmlEscape(fullTimeText) + '\"' +\n\t\t\t\t\t\t'>' +\n\t\t\t\t\t\t\t'<span>' + htmlEscape(timeText) + '</span>' +\n\t\t\t\t\t\t'</div>' :\n\t\t\t\t\t\t''\n\t\t\t\t\t\t) +\n\t\t\t\t\t(event.title ?\n\t\t\t\t\t\t'<div class=\"fc-title\">' +\n\t\t\t\t\t\t\thtmlEscape(event.title) +\n\t\t\t\t\t\t'</div>' :\n\t\t\t\t\t\t''\n\t\t\t\t\t\t) +\n\t\t\t\t'</div>' +\n\t\t\t\t'<div class=\"fc-bg\"/>' +\n\t\t\t\t/* TODO: write CSS for this\n\t\t\t\t(isResizableFromStart ?\n\t\t\t\t\t'<div class=\"fc-resizer fc-start-resizer\" />' :\n\t\t\t\t\t''\n\t\t\t\t\t) +\n\t\t\t\t*/\n\t\t\t\t(isResizableFromEnd ?\n\t\t\t\t\t'<div class=\"fc-resizer fc-end-resizer\" />' :\n\t\t\t\t\t''\n\t\t\t\t\t) +\n\t\t\t'</a>';\n\t},\n\n\n\t/* Seg Position Utils\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Refreshes the CSS top/bottom coordinates for each segment element.\n\t// Works when called after initial render, after a window resize/zoom for example.\n\tupdateSegVerticals: function(segs) {\n\t\tthis.computeSegVerticals(segs);\n\t\tthis.assignSegVerticals(segs);\n\t},\n\n\n\t// For each segment in an array, computes and assigns its top and bottom properties\n\tcomputeSegVerticals: function(segs) {\n\t\tvar i, seg;\n\n\t\tfor (i = 0; i < segs.length; i++) {\n\t\t\tseg = segs[i];\n\t\t\tseg.top = this.computeDateTop(seg.start, seg.start);\n\t\t\tseg.bottom = this.computeDateTop(seg.end, seg.start);\n\t\t}\n\t},\n\n\n\t// Given segments that already have their top/bottom properties computed, applies those values to\n\t// the segments' elements.\n\tassignSegVerticals: function(segs) {\n\t\tvar i, seg;\n\n\t\tfor (i = 0; i < segs.length; i++) {\n\t\t\tseg = segs[i];\n\t\t\tseg.el.css(this.generateSegVerticalCss(seg));\n\t\t}\n\t},\n\n\n\t// Generates an object with CSS properties for the top/bottom coordinates of a segment element\n\tgenerateSegVerticalCss: function(seg) {\n\t\treturn {\n\t\t\ttop: seg.top,\n\t\t\tbottom: -seg.bottom // flipped because needs to be space beyond bottom edge of event container\n\t\t};\n\t},\n\n\n\t/* Foreground Event Positioning Utils\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Given segments that are assumed to all live in the *same column*,\n\t// compute their verical/horizontal coordinates and assign to their elements.\n\tupdateFgSegCoords: function(segs) {\n\t\tthis.computeSegVerticals(segs); // horizontals relies on this\n\t\tthis.computeFgSegHorizontals(segs); // compute horizontal coordinates, z-index's, and reorder the array\n\t\tthis.assignSegVerticals(segs);\n\t\tthis.assignFgSegHorizontals(segs);\n\t},\n\n\n\t// Given an array of segments that are all in the same column, sets the backwardCoord and forwardCoord on each.\n\t// NOTE: Also reorders the given array by date!\n\tcomputeFgSegHorizontals: function(segs) {\n\t\tvar levels;\n\t\tvar level0;\n\t\tvar i;\n\n\t\tthis.sortEventSegs(segs); // order by certain criteria\n\t\tlevels = buildSlotSegLevels(segs);\n\t\tcomputeForwardSlotSegs(levels);\n\n\t\tif ((level0 = levels[0])) {\n\n\t\t\tfor (i = 0; i < level0.length; i++) {\n\t\t\t\tcomputeSlotSegPressures(level0[i]);\n\t\t\t}\n\n\t\t\tfor (i = 0; i < level0.length; i++) {\n\t\t\t\tthis.computeFgSegForwardBack(level0[i], 0, 0);\n\t\t\t}\n\t\t}\n\t},\n\n\n\t// Calculate seg.forwardCoord and seg.backwardCoord for the segment, where both values range\n\t// from 0 to 1. If the calendar is left-to-right, the seg.backwardCoord maps to \"left\" and\n\t// seg.forwardCoord maps to \"right\" (via percentage). Vice-versa if the calendar is right-to-left.\n\t//\n\t// The segment might be part of a \"series\", which means consecutive segments with the same pressure\n\t// who's width is unknown until an edge has been hit. `seriesBackwardPressure` is the number of\n\t// segments behind this one in the current series, and `seriesBackwardCoord` is the starting\n\t// coordinate of the first segment in the series.\n\tcomputeFgSegForwardBack: function(seg, seriesBackwardPressure, seriesBackwardCoord) {\n\t\tvar forwardSegs = seg.forwardSegs;\n\t\tvar i;\n\n\t\tif (seg.forwardCoord === undefined) { // not already computed\n\n\t\t\tif (!forwardSegs.length) {\n\n\t\t\t\t// if there are no forward segments, this segment should butt up against the edge\n\t\t\t\tseg.forwardCoord = 1;\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\t// sort highest pressure first\n\t\t\t\tthis.sortForwardSegs(forwardSegs);\n\n\t\t\t\t// this segment's forwardCoord will be calculated from the backwardCoord of the\n\t\t\t\t// highest-pressure forward segment.\n\t\t\t\tthis.computeFgSegForwardBack(forwardSegs[0], seriesBackwardPressure + 1, seriesBackwardCoord);\n\t\t\t\tseg.forwardCoord = forwardSegs[0].backwardCoord;\n\t\t\t}\n\n\t\t\t// calculate the backwardCoord from the forwardCoord. consider the series\n\t\t\tseg.backwardCoord = seg.forwardCoord -\n\t\t\t\t(seg.forwardCoord - seriesBackwardCoord) / // available width for series\n\t\t\t\t(seriesBackwardPressure + 1); // # of segments in the series\n\n\t\t\t// use this segment's coordinates to computed the coordinates of the less-pressurized\n\t\t\t// forward segments\n\t\t\tfor (i=0; i<forwardSegs.length; i++) {\n\t\t\t\tthis.computeFgSegForwardBack(forwardSegs[i], 0, seg.forwardCoord);\n\t\t\t}\n\t\t}\n\t},\n\n\n\tsortForwardSegs: function(forwardSegs) {\n\t\tforwardSegs.sort(proxy(this, 'compareForwardSegs'));\n\t},\n\n\n\t// A cmp function for determining which forward segment to rely on more when computing coordinates.\n\tcompareForwardSegs: function(seg1, seg2) {\n\t\t// put higher-pressure first\n\t\treturn seg2.forwardPressure - seg1.forwardPressure ||\n\t\t\t// put segments that are closer to initial edge first (and favor ones with no coords yet)\n\t\t\t(seg1.backwardCoord || 0) - (seg2.backwardCoord || 0) ||\n\t\t\t// do normal sorting...\n\t\t\tthis.compareEventSegs(seg1, seg2);\n\t},\n\n\n\t// Given foreground event segments that have already had their position coordinates computed,\n\t// assigns position-related CSS values to their elements.\n\tassignFgSegHorizontals: function(segs) {\n\t\tvar i, seg;\n\n\t\tfor (i = 0; i < segs.length; i++) {\n\t\t\tseg = segs[i];\n\t\t\tseg.el.css(this.generateFgSegHorizontalCss(seg));\n\n\t\t\t// if the height is short, add a className for alternate styling\n\t\t\tif (seg.bottom - seg.top < 30) {\n\t\t\t\tseg.el.addClass('fc-short');\n\t\t\t}\n\t\t}\n\t},\n\n\n\t// Generates an object with CSS properties/values that should be applied to an event segment element.\n\t// Contains important positioning-related properties that should be applied to any event element, customized or not.\n\tgenerateFgSegHorizontalCss: function(seg) {\n\t\tvar shouldOverlap = this.view.opt('slotEventOverlap');\n\t\tvar backwardCoord = seg.backwardCoord; // the left side if LTR. the right side if RTL. floating-point\n\t\tvar forwardCoord = seg.forwardCoord; // the right side if LTR. the left side if RTL. floating-point\n\t\tvar props = this.generateSegVerticalCss(seg); // get top/bottom first\n\t\tvar left; // amount of space from left edge, a fraction of the total width\n\t\tvar right; // amount of space from right edge, a fraction of the total width\n\n\t\tif (shouldOverlap) {\n\t\t\t// double the width, but don't go beyond the maximum forward coordinate (1.0)\n\t\t\tforwardCoord = Math.min(1, backwardCoord + (forwardCoord - backwardCoord) * 2);\n\t\t}\n\n\t\tif (this.isRTL) {\n\t\t\tleft = 1 - forwardCoord;\n\t\t\tright = backwardCoord;\n\t\t}\n\t\telse {\n\t\t\tleft = backwardCoord;\n\t\t\tright = 1 - forwardCoord;\n\t\t}\n\n\t\tprops.zIndex = seg.level + 1; // convert from 0-base to 1-based\n\t\tprops.left = left * 100 + '%';\n\t\tprops.right = right * 100 + '%';\n\n\t\tif (shouldOverlap && seg.forwardPressure) {\n\t\t\t// add padding to the edge so that forward stacked events don't cover the resizer's icon\n\t\t\tprops[this.isRTL ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width\n\t\t}\n\n\t\treturn props;\n\t}\n\n});\n\n\n// Builds an array of segments \"levels\". The first level will be the leftmost tier of segments if the calendar is\n// left-to-right, or the rightmost if the calendar is right-to-left. Assumes the segments are already ordered by date.\nfunction buildSlotSegLevels(segs) {\n\tvar levels = [];\n\tvar i, seg;\n\tvar j;\n\n\tfor (i=0; i<segs.length; i++) {\n\t\tseg = segs[i];\n\n\t\t// go through all the levels and stop on the first level where there are no collisions\n\t\tfor (j=0; j<levels.length; j++) {\n\t\t\tif (!computeSlotSegCollisions(seg, levels[j]).length) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tseg.level = j;\n\n\t\t(levels[j] || (levels[j] = [])).push(seg);\n\t}\n\n\treturn levels;\n}\n\n\n// For every segment, figure out the other segments that are in subsequent\n// levels that also occupy the same vertical space. Accumulate in seg.forwardSegs\nfunction computeForwardSlotSegs(levels) {\n\tvar i, level;\n\tvar j, seg;\n\tvar k;\n\n\tfor (i=0; i<levels.length; i++) {\n\t\tlevel = levels[i];\n\n\t\tfor (j=0; j<level.length; j++) {\n\t\t\tseg = level[j];\n\n\t\t\tseg.forwardSegs = [];\n\t\t\tfor (k=i+1; k<levels.length; k++) {\n\t\t\t\tcomputeSlotSegCollisions(seg, levels[k], seg.forwardSegs);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// Figure out which path forward (via seg.forwardSegs) results in the longest path until\n// the furthest edge is reached. The number of segments in this path will be seg.forwardPressure\nfunction computeSlotSegPressures(seg) {\n\tvar forwardSegs = seg.forwardSegs;\n\tvar forwardPressure = 0;\n\tvar i, forwardSeg;\n\n\tif (seg.forwardPressure === undefined) { // not already computed\n\n\t\tfor (i=0; i<forwardSegs.length; i++) {\n\t\t\tforwardSeg = forwardSegs[i];\n\n\t\t\t// figure out the child's maximum forward path\n\t\t\tcomputeSlotSegPressures(forwardSeg);\n\n\t\t\t// either use the existing maximum, or use the child's forward pressure\n\t\t\t// plus one (for the forwardSeg itself)\n\t\t\tforwardPressure = Math.max(\n\t\t\t\tforwardPressure,\n\t\t\t\t1 + forwardSeg.forwardPressure\n\t\t\t);\n\t\t}\n\n\t\tseg.forwardPressure = forwardPressure;\n\t}\n}\n\n\n// Find all the segments in `otherSegs` that vertically collide with `seg`.\n// Append into an optionally-supplied `results` array and return.\nfunction computeSlotSegCollisions(seg, otherSegs, results) {\n\tresults = results || [];\n\n\tfor (var i=0; i<otherSegs.length; i++) {\n\t\tif (isSlotSegCollision(seg, otherSegs[i])) {\n\t\t\tresults.push(otherSegs[i]);\n\t\t}\n\t}\n\n\treturn results;\n}\n\n\n// Do these segments occupy the same vertical space?\nfunction isSlotSegCollision(seg1, seg2) {\n\treturn seg1.bottom > seg2.top && seg1.top < seg2.bottom;\n}\n\n;;\n\n/* An abstract class from which other views inherit from\n----------------------------------------------------------------------------------------------------------------------*/\n\nvar View = FC.View = Class.extend(EmitterMixin, ListenerMixin, {\n\n\ttype: null, // subclass' view name (string)\n\tname: null, // deprecated. use `type` instead\n\ttitle: null, // the text that will be displayed in the header's title\n\n\tcalendar: null, // owner Calendar object\n\toptions: null, // hash containing all options. already merged with view-specific-options\n\tel: null, // the view's containing element. set by Calendar\n\n\tdisplaying: null, // a promise representing the state of rendering. null if no render requested\n\tisSkeletonRendered: false,\n\tisEventsRendered: false,\n\n\t// range the view is actually displaying (moments)\n\tstart: null,\n\tend: null, // exclusive\n\n\t// range the view is formally responsible for (moments)\n\t// may be different from start/end. for example, a month view might have 1st-31st, excluding padded dates\n\tintervalStart: null,\n\tintervalEnd: null, // exclusive\n\tintervalDuration: null,\n\tintervalUnit: null, // name of largest unit being displayed, like \"month\" or \"week\"\n\n\tisRTL: false,\n\tisSelected: false, // boolean whether a range of time is user-selected or not\n\tselectedEvent: null,\n\n\teventOrderSpecs: null, // criteria for ordering events when they have same date/time\n\n\t// classNames styled by jqui themes\n\twidgetHeaderClass: null,\n\twidgetContentClass: null,\n\thighlightStateClass: null,\n\n\t// for date utils, computed from options\n\tnextDayThreshold: null,\n\tisHiddenDayHash: null,\n\n\t// now indicator\n\tisNowIndicatorRendered: null,\n\tinitialNowDate: null, // result first getNow call\n\tinitialNowQueriedMs: null, // ms time the getNow was called\n\tnowIndicatorTimeoutID: null, // for refresh timing of now indicator\n\tnowIndicatorIntervalID: null, // \"\n\n\n\tconstructor: function(calendar, type, options, intervalDuration) {\n\n\t\tthis.calendar = calendar;\n\t\tthis.type = this.name = type; // .name is deprecated\n\t\tthis.options = options;\n\t\tthis.intervalDuration = intervalDuration || moment.duration(1, 'day');\n\n\t\tthis.nextDayThreshold = moment.duration(this.opt('nextDayThreshold'));\n\t\tthis.initThemingProps();\n\t\tthis.initHiddenDays();\n\t\tthis.isRTL = this.opt('isRTL');\n\n\t\tthis.eventOrderSpecs = parseFieldSpecs(this.opt('eventOrder'));\n\n\t\tthis.initialize();\n\t},\n\n\n\t// A good place for subclasses to initialize member variables\n\tinitialize: function() {\n\t\t// subclasses can implement\n\t},\n\n\n\t// Retrieves an option with the given name\n\topt: function(name) {\n\t\treturn this.options[name];\n\t},\n\n\n\t// Triggers handlers that are view-related. Modifies args before passing to calendar.\n\ttrigger: function(name, thisObj) { // arguments beyond thisObj are passed along\n\t\tvar calendar = this.calendar;\n\n\t\treturn calendar.trigger.apply(\n\t\t\tcalendar,\n\t\t\t[name, thisObj || this].concat(\n\t\t\t\tArray.prototype.slice.call(arguments, 2), // arguments beyond thisObj\n\t\t\t\t[ this ] // always make the last argument a reference to the view. TODO: deprecate\n\t\t\t)\n\t\t);\n\t},\n\n\n\t/* Dates\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Updates all internal dates to center around the given current unzoned date.\n\tsetDate: function(date) {\n\t\tthis.setRange(this.computeRange(date));\n\t},\n\n\n\t// Updates all internal dates for displaying the given unzoned range.\n\tsetRange: function(range) {\n\t\t$.extend(this, range); // assigns every property to this object's member variables\n\t\tthis.updateTitle();\n\t},\n\n\n\t// Given a single current unzoned date, produce information about what range to display.\n\t// Subclasses can override. Must return all properties.\n\tcomputeRange: function(date) {\n\t\tvar intervalUnit = computeIntervalUnit(this.intervalDuration);\n\t\tvar intervalStart = date.clone().startOf(intervalUnit);\n\t\tvar intervalEnd = intervalStart.clone().add(this.intervalDuration);\n\t\tvar start, end;\n\n\t\t// normalize the range's time-ambiguity\n\t\tif (/year|month|week|day/.test(intervalUnit)) { // whole-days?\n\t\t\tintervalStart.stripTime();\n\t\t\tintervalEnd.stripTime();\n\t\t}\n\t\telse { // needs to have a time?\n\t\t\tif (!intervalStart.hasTime()) {\n\t\t\t\tintervalStart = this.calendar.time(0); // give 00:00 time\n\t\t\t}\n\t\t\tif (!intervalEnd.hasTime()) {\n\t\t\t\tintervalEnd = this.calendar.time(0); // give 00:00 time\n\t\t\t}\n\t\t}\n\n\t\tstart = intervalStart.clone();\n\t\tstart = this.skipHiddenDays(start);\n\t\tend = intervalEnd.clone();\n\t\tend = this.skipHiddenDays(end, -1, true); // exclusively move backwards\n\n\t\treturn {\n\t\t\tintervalUnit: intervalUnit,\n\t\t\tintervalStart: intervalStart,\n\t\t\tintervalEnd: intervalEnd,\n\t\t\tstart: start,\n\t\t\tend: end\n\t\t};\n\t},\n\n\n\t// Computes the new date when the user hits the prev button, given the current date\n\tcomputePrevDate: function(date) {\n\t\treturn this.massageCurrentDate(\n\t\t\tdate.clone().startOf(this.intervalUnit).subtract(this.intervalDuration), -1\n\t\t);\n\t},\n\n\n\t// Computes the new date when the user hits the next button, given the current date\n\tcomputeNextDate: function(date) {\n\t\treturn this.massageCurrentDate(\n\t\t\tdate.clone().startOf(this.intervalUnit).add(this.intervalDuration)\n\t\t);\n\t},\n\n\n\t// Given an arbitrarily calculated current date of the calendar, returns a date that is ensured to be completely\n\t// visible. `direction` is optional and indicates which direction the current date was being\n\t// incremented or decremented (1 or -1).\n\tmassageCurrentDate: function(date, direction) {\n\t\tif (this.intervalDuration.as('days') <= 1) { // if the view displays a single day or smaller\n\t\t\tif (this.isHiddenDay(date)) {\n\t\t\t\tdate = this.skipHiddenDays(date, direction);\n\t\t\t\tdate.startOf('day');\n\t\t\t}\n\t\t}\n\n\t\treturn date;\n\t},\n\n\n\t/* Title and Date Formatting\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Sets the view's title property to the most updated computed value\n\tupdateTitle: function() {\n\t\tthis.title = this.computeTitle();\n\t},\n\n\n\t// Computes what the title at the top of the calendar should be for this view\n\tcomputeTitle: function() {\n\t\treturn this.formatRange(\n\t\t\t{\n\t\t\t\t// in case intervalStart/End has a time, make sure timezone is correct\n\t\t\t\tstart: this.calendar.applyTimezone(this.intervalStart),\n\t\t\t\tend: this.calendar.applyTimezone(this.intervalEnd)\n\t\t\t},\n\t\t\tthis.opt('titleFormat') || this.computeTitleFormat(),\n\t\t\tthis.opt('titleRangeSeparator')\n\t\t);\n\t},\n\n\n\t// Generates the format string that should be used to generate the title for the current date range.\n\t// Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.\n\tcomputeTitleFormat: function() {\n\t\tif (this.intervalUnit == 'year') {\n\t\t\treturn 'YYYY';\n\t\t}\n\t\telse if (this.intervalUnit == 'month') {\n\t\t\treturn this.opt('monthYearFormat'); // like \"September 2014\"\n\t\t}\n\t\telse if (this.intervalDuration.as('days') > 1) {\n\t\t\treturn 'll'; // multi-day range. shorter, like \"Sep 9 - 10 2014\"\n\t\t}\n\t\telse {\n\t\t\treturn 'LL'; // one day. longer, like \"September 9 2014\"\n\t\t}\n\t},\n\n\n\t// Utility for formatting a range. Accepts a range object, formatting string, and optional separator.\n\t// Displays all-day ranges naturally, with an inclusive end. Takes the current isRTL into account.\n\t// The timezones of the dates within `range` will be respected.\n\tformatRange: function(range, formatStr, separator) {\n\t\tvar end = range.end;\n\n\t\tif (!end.hasTime()) { // all-day?\n\t\t\tend = end.clone().subtract(1); // convert to inclusive. last ms of previous day\n\t\t}\n\n\t\treturn formatRange(range.start, end, formatStr, separator, this.opt('isRTL'));\n\t},\n\n\n\tgetAllDayHtml: function() {\n\t\treturn this.opt('allDayHtml') || htmlEscape(this.opt('allDayText'));\n\t},\n\n\n\t/* Navigation\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Generates HTML for an anchor to another view into the calendar.\n\t// Will either generate an <a> tag or a non-clickable <span> tag, depending on enabled settings.\n\t// `gotoOptions` can either be a moment input, or an object with the form:\n\t// { date, type, forceOff }\n\t// `type` is a view-type like \"day\" or \"week\". default value is \"day\".\n\t// `attrs` and `innerHtml` are use to generate the rest of the HTML tag.\n\tbuildGotoAnchorHtml: function(gotoOptions, attrs, innerHtml) {\n\t\tvar date, type, forceOff;\n\t\tvar finalOptions;\n\n\t\tif ($.isPlainObject(gotoOptions)) {\n\t\t\tdate = gotoOptions.date;\n\t\t\ttype = gotoOptions.type;\n\t\t\tforceOff = gotoOptions.forceOff;\n\t\t}\n\t\telse {\n\t\t\tdate = gotoOptions; // a single moment input\n\t\t}\n\t\tdate = FC.moment(date); // if a string, parse it\n\n\t\tfinalOptions = { // for serialization into the link\n\t\t\tdate: date.format('YYYY-MM-DD'),\n\t\t\ttype: type || 'day'\n\t\t};\n\n\t\tif (typeof attrs === 'string') {\n\t\t\tinnerHtml = attrs;\n\t\t\tattrs = null;\n\t\t}\n\n\t\tattrs = attrs ? ' ' + attrsToStr(attrs) : ''; // will have a leading space\n\t\tinnerHtml = innerHtml || '';\n\n\t\tif (!forceOff && this.opt('navLinks')) {\n\t\t\treturn '<a' + attrs +\n\t\t\t\t' data-goto=\"' + htmlEscape(JSON.stringify(finalOptions)) + '\">' +\n\t\t\t\tinnerHtml +\n\t\t\t\t'</a>';\n\t\t}\n\t\telse {\n\t\t\treturn '<span' + attrs + '>' +\n\t\t\t\tinnerHtml +\n\t\t\t\t'</span>';\n\t\t}\n\t},\n\n\n\t/* Rendering\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Sets the container element that the view should render inside of.\n\t// Does other DOM-related initializations.\n\tsetElement: function(el) {\n\t\tthis.el = el;\n\t\tthis.bindGlobalHandlers();\n\t},\n\n\n\t// Removes the view's container element from the DOM, clearing any content beforehand.\n\t// Undoes any other DOM-related attachments.\n\tremoveElement: function() {\n\t\tthis.clear(); // clears all content\n\n\t\t// clean up the skeleton\n\t\tif (this.isSkeletonRendered) {\n\t\t\tthis.unrenderSkeleton();\n\t\t\tthis.isSkeletonRendered = false;\n\t\t}\n\n\t\tthis.unbindGlobalHandlers();\n\n\t\tthis.el.remove();\n\n\t\t// NOTE: don't null-out this.el in case the View was destroyed within an API callback.\n\t\t// We don't null-out the View's other jQuery element references upon destroy,\n\t\t//  so we shouldn't kill this.el either.\n\t},\n\n\n\t// Does everything necessary to display the view centered around the given unzoned date.\n\t// Does every type of rendering EXCEPT rendering events.\n\t// Is asychronous and returns a promise.\n\tdisplay: function(date, explicitScrollState) {\n\t\tvar _this = this;\n\t\tvar prevScrollState = null;\n\n\t\tif (explicitScrollState != null && this.displaying) { // don't need prevScrollState if explicitScrollState\n\t\t\tprevScrollState = this.queryScroll();\n\t\t}\n\n\t\tthis.calendar.freezeContentHeight();\n\n\t\treturn syncThen(this.clear(), function() { // clear the content first\n\t\t\treturn (\n\t\t\t\t_this.displaying =\n\t\t\t\t\tsyncThen(_this.displayView(date), function() { // displayView might return a promise\n\n\t\t\t\t\t\t// caller of display() wants a specific scroll state?\n\t\t\t\t\t\tif (explicitScrollState != null) {\n\t\t\t\t\t\t\t// we make an assumption that this is NOT the initial render,\n\t\t\t\t\t\t\t// and thus don't need forceScroll (is inconveniently asynchronous)\n\t\t\t\t\t\t\t_this.setScroll(explicitScrollState);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t_this.forceScroll(_this.computeInitialScroll(prevScrollState));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_this.calendar.unfreezeContentHeight();\n\t\t\t\t\t\t_this.triggerRender();\n\t\t\t\t\t})\n\t\t\t);\n\t\t});\n\t},\n\n\n\t// Does everything necessary to clear the content of the view.\n\t// Clears dates and events. Does not clear the skeleton.\n\t// Is asychronous and returns a promise.\n\tclear: function() {\n\t\tvar _this = this;\n\t\tvar displaying = this.displaying;\n\n\t\tif (displaying) { // previously displayed, or in the process of being displayed?\n\t\t\treturn syncThen(displaying, function() { // wait for the display to finish\n\t\t\t\t_this.displaying = null;\n\t\t\t\t_this.clearEvents();\n\t\t\t\treturn _this.clearView(); // might return a promise. chain it\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\treturn $.when(); // an immediately-resolved promise\n\t\t}\n\t},\n\n\n\t// Displays the view's non-event content, such as date-related content or anything required by events.\n\t// Renders the view's non-content skeleton if necessary.\n\t// Can be asynchronous and return a promise.\n\tdisplayView: function(date) {\n\t\tif (!this.isSkeletonRendered) {\n\t\t\tthis.renderSkeleton();\n\t\t\tthis.isSkeletonRendered = true;\n\t\t}\n\t\tif (date) {\n\t\t\tthis.setDate(date);\n\t\t}\n\t\tif (this.render) {\n\t\t\tthis.render(); // TODO: deprecate\n\t\t}\n\t\tthis.renderDates();\n\t\tthis.updateSize();\n\t\tthis.renderBusinessHours(); // might need coordinates, so should go after updateSize()\n\t\tthis.startNowIndicator();\n\t},\n\n\n\t// Unrenders the view content that was rendered in displayView.\n\t// Can be asynchronous and return a promise.\n\tclearView: function() {\n\t\tthis.unselect();\n\t\tthis.stopNowIndicator();\n\t\tthis.triggerUnrender();\n\t\tthis.unrenderBusinessHours();\n\t\tthis.unrenderDates();\n\t\tif (this.destroy) {\n\t\t\tthis.destroy(); // TODO: deprecate\n\t\t}\n\t},\n\n\n\t// Renders the basic structure of the view before any content is rendered\n\trenderSkeleton: function() {\n\t\t// subclasses should implement\n\t},\n\n\n\t// Unrenders the basic structure of the view\n\tunrenderSkeleton: function() {\n\t\t// subclasses should implement\n\t},\n\n\n\t// Renders the view's date-related content.\n\t// Assumes setRange has already been called and the skeleton has already been rendered.\n\trenderDates: function() {\n\t\t// subclasses should implement\n\t},\n\n\n\t// Unrenders the view's date-related content\n\tunrenderDates: function() {\n\t\t// subclasses should override\n\t},\n\n\n\t// Signals that the view's content has been rendered\n\ttriggerRender: function() {\n\t\tthis.trigger('viewRender', this, this, this.el);\n\t},\n\n\n\t// Signals that the view's content is about to be unrendered\n\ttriggerUnrender: function() {\n\t\tthis.trigger('viewDestroy', this, this, this.el);\n\t},\n\n\n\t// Binds DOM handlers to elements that reside outside the view container, such as the document\n\tbindGlobalHandlers: function() {\n\t\tthis.listenTo($(document), 'mousedown', this.handleDocumentMousedown);\n\t\tthis.listenTo($(document), 'touchstart', this.processUnselect);\n\t},\n\n\n\t// Unbinds DOM handlers from elements that reside outside the view container\n\tunbindGlobalHandlers: function() {\n\t\tthis.stopListeningTo($(document));\n\t},\n\n\n\t// Initializes internal variables related to theming\n\tinitThemingProps: function() {\n\t\tvar tm = this.opt('theme') ? 'ui' : 'fc';\n\n\t\tthis.widgetHeaderClass = tm + '-widget-header';\n\t\tthis.widgetContentClass = tm + '-widget-content';\n\t\tthis.highlightStateClass = tm + '-state-highlight';\n\t},\n\n\n\t/* Business Hours\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Renders business-hours onto the view. Assumes updateSize has already been called.\n\trenderBusinessHours: function() {\n\t\t// subclasses should implement\n\t},\n\n\n\t// Unrenders previously-rendered business-hours\n\tunrenderBusinessHours: function() {\n\t\t// subclasses should implement\n\t},\n\n\n\t/* Now Indicator\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Immediately render the current time indicator and begins re-rendering it at an interval,\n\t// which is defined by this.getNowIndicatorUnit().\n\t// TODO: somehow do this for the current whole day's background too\n\tstartNowIndicator: function() {\n\t\tvar _this = this;\n\t\tvar unit;\n\t\tvar update;\n\t\tvar delay; // ms wait value\n\n\t\tif (this.opt('nowIndicator')) {\n\t\t\tunit = this.getNowIndicatorUnit();\n\t\t\tif (unit) {\n\t\t\t\tupdate = proxy(this, 'updateNowIndicator'); // bind to `this`\n\n\t\t\t\tthis.initialNowDate = this.calendar.getNow();\n\t\t\t\tthis.initialNowQueriedMs = +new Date();\n\t\t\t\tthis.renderNowIndicator(this.initialNowDate);\n\t\t\t\tthis.isNowIndicatorRendered = true;\n\n\t\t\t\t// wait until the beginning of the next interval\n\t\t\t\tdelay = this.initialNowDate.clone().startOf(unit).add(1, unit) - this.initialNowDate;\n\t\t\t\tthis.nowIndicatorTimeoutID = setTimeout(function() {\n\t\t\t\t\t_this.nowIndicatorTimeoutID = null;\n\t\t\t\t\tupdate();\n\t\t\t\t\tdelay = +moment.duration(1, unit);\n\t\t\t\t\tdelay = Math.max(100, delay); // prevent too frequent\n\t\t\t\t\t_this.nowIndicatorIntervalID = setInterval(update, delay); // update every interval\n\t\t\t\t}, delay);\n\t\t\t}\n\t\t}\n\t},\n\n\n\t// rerenders the now indicator, computing the new current time from the amount of time that has passed\n\t// since the initial getNow call.\n\tupdateNowIndicator: function() {\n\t\tif (this.isNowIndicatorRendered) {\n\t\t\tthis.unrenderNowIndicator();\n\t\t\tthis.renderNowIndicator(\n\t\t\t\tthis.initialNowDate.clone().add(new Date() - this.initialNowQueriedMs) // add ms\n\t\t\t);\n\t\t}\n\t},\n\n\n\t// Immediately unrenders the view's current time indicator and stops any re-rendering timers.\n\t// Won't cause side effects if indicator isn't rendered.\n\tstopNowIndicator: function() {\n\t\tif (this.isNowIndicatorRendered) {\n\n\t\t\tif (this.nowIndicatorTimeoutID) {\n\t\t\t\tclearTimeout(this.nowIndicatorTimeoutID);\n\t\t\t\tthis.nowIndicatorTimeoutID = null;\n\t\t\t}\n\t\t\tif (this.nowIndicatorIntervalID) {\n\t\t\t\tclearTimeout(this.nowIndicatorIntervalID);\n\t\t\t\tthis.nowIndicatorIntervalID = null;\n\t\t\t}\n\n\t\t\tthis.unrenderNowIndicator();\n\t\t\tthis.isNowIndicatorRendered = false;\n\t\t}\n\t},\n\n\n\t// Returns a string unit, like 'second' or 'minute' that defined how often the current time indicator\n\t// should be refreshed. If something falsy is returned, no time indicator is rendered at all.\n\tgetNowIndicatorUnit: function() {\n\t\t// subclasses should implement\n\t},\n\n\n\t// Renders a current time indicator at the given datetime\n\trenderNowIndicator: function(date) {\n\t\t// subclasses should implement\n\t},\n\n\n\t// Undoes the rendering actions from renderNowIndicator\n\tunrenderNowIndicator: function() {\n\t\t// subclasses should implement\n\t},\n\n\n\t/* Dimensions\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Refreshes anything dependant upon sizing of the container element of the grid\n\tupdateSize: function(isResize) {\n\t\tvar scrollState;\n\n\t\tif (isResize) {\n\t\t\tscrollState = this.queryScroll();\n\t\t}\n\n\t\tthis.updateHeight(isResize);\n\t\tthis.updateWidth(isResize);\n\t\tthis.updateNowIndicator();\n\n\t\tif (isResize) {\n\t\t\tthis.setScroll(scrollState);\n\t\t}\n\t},\n\n\n\t// Refreshes the horizontal dimensions of the calendar\n\tupdateWidth: function(isResize) {\n\t\t// subclasses should implement\n\t},\n\n\n\t// Refreshes the vertical dimensions of the calendar\n\tupdateHeight: function(isResize) {\n\t\tvar calendar = this.calendar; // we poll the calendar for height information\n\n\t\tthis.setHeight(\n\t\t\tcalendar.getSuggestedViewHeight(),\n\t\t\tcalendar.isHeightAuto()\n\t\t);\n\t},\n\n\n\t// Updates the vertical dimensions of the calendar to the specified height.\n\t// if `isAuto` is set to true, height becomes merely a suggestion and the view should use its \"natural\" height.\n\tsetHeight: function(height, isAuto) {\n\t\t// subclasses should implement\n\t},\n\n\n\t/* Scroller\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Computes the initial pre-configured scroll state prior to allowing the user to change it.\n\t// Given the scroll state from the previous rendering. If first time rendering, given null.\n\tcomputeInitialScroll: function(previousScrollState) {\n\t\treturn 0;\n\t},\n\n\n\t// Retrieves the view's current natural scroll state. Can return an arbitrary format.\n\tqueryScroll: function() {\n\t\t// subclasses must implement\n\t},\n\n\n\t// Sets the view's scroll state. Will accept the same format computeInitialScroll and queryScroll produce.\n\tsetScroll: function(scrollState) {\n\t\t// subclasses must implement\n\t},\n\n\n\t// Sets the scroll state, making sure to overcome any predefined scroll value the browser has in mind\n\tforceScroll: function(scrollState) {\n\t\tvar _this = this;\n\n\t\tthis.setScroll(scrollState);\n\t\tsetTimeout(function() {\n\t\t\t_this.setScroll(scrollState);\n\t\t}, 0);\n\t},\n\n\n\t/* Event Elements / Segments\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Does everything necessary to display the given events onto the current view\n\tdisplayEvents: function(events) {\n\t\tvar scrollState = this.queryScroll();\n\n\t\tthis.clearEvents();\n\t\tthis.renderEvents(events);\n\t\tthis.isEventsRendered = true;\n\t\tthis.setScroll(scrollState);\n\t\tthis.triggerEventRender();\n\t},\n\n\n\t// Does everything necessary to clear the view's currently-rendered events\n\tclearEvents: function() {\n\t\tvar scrollState;\n\n\t\tif (this.isEventsRendered) {\n\n\t\t\t// TODO: optimize: if we know this is part of a displayEvents call, don't queryScroll/setScroll\n\t\t\tscrollState = this.queryScroll();\n\n\t\t\tthis.triggerEventUnrender();\n\t\t\tif (this.destroyEvents) {\n\t\t\t\tthis.destroyEvents(); // TODO: deprecate\n\t\t\t}\n\t\t\tthis.unrenderEvents();\n\t\t\tthis.setScroll(scrollState);\n\t\t\tthis.isEventsRendered = false;\n\t\t}\n\t},\n\n\n\t// Renders the events onto the view.\n\trenderEvents: function(events) {\n\t\t// subclasses should implement\n\t},\n\n\n\t// Removes event elements from the view.\n\tunrenderEvents: function() {\n\t\t// subclasses should implement\n\t},\n\n\n\t// Signals that all events have been rendered\n\ttriggerEventRender: function() {\n\t\tthis.renderedEventSegEach(function(seg) {\n\t\t\tthis.trigger('eventAfterRender', seg.event, seg.event, seg.el);\n\t\t});\n\t\tthis.trigger('eventAfterAllRender');\n\t},\n\n\n\t// Signals that all event elements are about to be removed\n\ttriggerEventUnrender: function() {\n\t\tthis.renderedEventSegEach(function(seg) {\n\t\t\tthis.trigger('eventDestroy', seg.event, seg.event, seg.el);\n\t\t});\n\t},\n\n\n\t// Given an event and the default element used for rendering, returns the element that should actually be used.\n\t// Basically runs events and elements through the eventRender hook.\n\tresolveEventEl: function(event, el) {\n\t\tvar custom = this.trigger('eventRender', event, event, el);\n\n\t\tif (custom === false) { // means don't render at all\n\t\t\tel = null;\n\t\t}\n\t\telse if (custom && custom !== true) {\n\t\t\tel = $(custom);\n\t\t}\n\n\t\treturn el;\n\t},\n\n\n\t// Hides all rendered event segments linked to the given event\n\tshowEvent: function(event) {\n\t\tthis.renderedEventSegEach(function(seg) {\n\t\t\tseg.el.css('visibility', '');\n\t\t}, event);\n\t},\n\n\n\t// Shows all rendered event segments linked to the given event\n\thideEvent: function(event) {\n\t\tthis.renderedEventSegEach(function(seg) {\n\t\t\tseg.el.css('visibility', 'hidden');\n\t\t}, event);\n\t},\n\n\n\t// Iterates through event segments that have been rendered (have an el). Goes through all by default.\n\t// If the optional `event` argument is specified, only iterates through segments linked to that event.\n\t// The `this` value of the callback function will be the view.\n\trenderedEventSegEach: function(func, event) {\n\t\tvar segs = this.getEventSegs();\n\t\tvar i;\n\n\t\tfor (i = 0; i < segs.length; i++) {\n\t\t\tif (!event || segs[i].event._id === event._id) {\n\t\t\t\tif (segs[i].el) {\n\t\t\t\t\tfunc.call(this, segs[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\n\t// Retrieves all the rendered segment objects for the view\n\tgetEventSegs: function() {\n\t\t// subclasses must implement\n\t\treturn [];\n\t},\n\n\n\t/* Event Drag-n-Drop\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Computes if the given event is allowed to be dragged by the user\n\tisEventDraggable: function(event) {\n\t\treturn this.isEventStartEditable(event);\n\t},\n\n\n\tisEventStartEditable: function(event) {\n\t\treturn firstDefined(\n\t\t\tevent.startEditable,\n\t\t\t(event.source || {}).startEditable,\n\t\t\tthis.opt('eventStartEditable'),\n\t\t\tthis.isEventGenerallyEditable(event)\n\t\t);\n\t},\n\n\n\tisEventGenerallyEditable: function(event) {\n\t\treturn firstDefined(\n\t\t\tevent.editable,\n\t\t\t(event.source || {}).editable,\n\t\t\tthis.opt('editable')\n\t\t);\n\t},\n\n\n\t// Must be called when an event in the view is dropped onto new location.\n\t// `dropLocation` is an object that contains the new zoned start/end/allDay values for the event.\n\treportEventDrop: function(event, dropLocation, largeUnit, el, ev) {\n\t\tvar calendar = this.calendar;\n\t\tvar mutateResult = calendar.mutateEvent(event, dropLocation, largeUnit);\n\t\tvar undoFunc = function() {\n\t\t\tmutateResult.undo();\n\t\t\tcalendar.reportEventChange();\n\t\t};\n\n\t\tthis.triggerEventDrop(event, mutateResult.dateDelta, undoFunc, el, ev);\n\t\tcalendar.reportEventChange(); // will rerender events\n\t},\n\n\n\t// Triggers event-drop handlers that have subscribed via the API\n\ttriggerEventDrop: function(event, dateDelta, undoFunc, el, ev) {\n\t\tthis.trigger('eventDrop', el[0], event, dateDelta, undoFunc, ev, {}); // {} = jqui dummy\n\t},\n\n\n\t/* External Element Drag-n-Drop\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Must be called when an external element, via jQuery UI, has been dropped onto the calendar.\n\t// `meta` is the parsed data that has been embedded into the dragging event.\n\t// `dropLocation` is an object that contains the new zoned start/end/allDay values for the event.\n\treportExternalDrop: function(meta, dropLocation, el, ev, ui) {\n\t\tvar eventProps = meta.eventProps;\n\t\tvar eventInput;\n\t\tvar event;\n\n\t\t// Try to build an event object and render it. TODO: decouple the two\n\t\tif (eventProps) {\n\t\t\teventInput = $.extend({}, eventProps, dropLocation);\n\t\t\tevent = this.calendar.renderEvent(eventInput, meta.stick)[0]; // renderEvent returns an array\n\t\t}\n\n\t\tthis.triggerExternalDrop(event, dropLocation, el, ev, ui);\n\t},\n\n\n\t// Triggers external-drop handlers that have subscribed via the API\n\ttriggerExternalDrop: function(event, dropLocation, el, ev, ui) {\n\n\t\t// trigger 'drop' regardless of whether element represents an event\n\t\tthis.trigger('drop', el[0], dropLocation.start, ev, ui);\n\n\t\tif (event) {\n\t\t\tthis.trigger('eventReceive', null, event); // signal an external event landed\n\t\t}\n\t},\n\n\n\t/* Drag-n-Drop Rendering (for both events and external elements)\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Renders a visual indication of a event or external-element drag over the given drop zone.\n\t// If an external-element, seg will be `null`.\n\t// Must return elements used for any mock events.\n\trenderDrag: function(dropLocation, seg) {\n\t\t// subclasses must implement\n\t},\n\n\n\t// Unrenders a visual indication of an event or external-element being dragged.\n\tunrenderDrag: function() {\n\t\t// subclasses must implement\n\t},\n\n\n\t/* Event Resizing\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Computes if the given event is allowed to be resized from its starting edge\n\tisEventResizableFromStart: function(event) {\n\t\treturn this.opt('eventResizableFromStart') && this.isEventResizable(event);\n\t},\n\n\n\t// Computes if the given event is allowed to be resized from its ending edge\n\tisEventResizableFromEnd: function(event) {\n\t\treturn this.isEventResizable(event);\n\t},\n\n\n\t// Computes if the given event is allowed to be resized by the user at all\n\tisEventResizable: function(event) {\n\t\tvar source = event.source || {};\n\n\t\treturn firstDefined(\n\t\t\tevent.durationEditable,\n\t\t\tsource.durationEditable,\n\t\t\tthis.opt('eventDurationEditable'),\n\t\t\tevent.editable,\n\t\t\tsource.editable,\n\t\t\tthis.opt('editable')\n\t\t);\n\t},\n\n\n\t// Must be called when an event in the view has been resized to a new length\n\treportEventResize: function(event, resizeLocation, largeUnit, el, ev) {\n\t\tvar calendar = this.calendar;\n\t\tvar mutateResult = calendar.mutateEvent(event, resizeLocation, largeUnit);\n\t\tvar undoFunc = function() {\n\t\t\tmutateResult.undo();\n\t\t\tcalendar.reportEventChange();\n\t\t};\n\n\t\tthis.triggerEventResize(event, mutateResult.durationDelta, undoFunc, el, ev);\n\t\tcalendar.reportEventChange(); // will rerender events\n\t},\n\n\n\t// Triggers event-resize handlers that have subscribed via the API\n\ttriggerEventResize: function(event, durationDelta, undoFunc, el, ev) {\n\t\tthis.trigger('eventResize', el[0], event, durationDelta, undoFunc, ev, {}); // {} = jqui dummy\n\t},\n\n\n\t/* Selection (time range)\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Selects a date span on the view. `start` and `end` are both Moments.\n\t// `ev` is the native mouse event that begin the interaction.\n\tselect: function(span, ev) {\n\t\tthis.unselect(ev);\n\t\tthis.renderSelection(span);\n\t\tthis.reportSelection(span, ev);\n\t},\n\n\n\t// Renders a visual indication of the selection\n\trenderSelection: function(span) {\n\t\t// subclasses should implement\n\t},\n\n\n\t// Called when a new selection is made. Updates internal state and triggers handlers.\n\treportSelection: function(span, ev) {\n\t\tthis.isSelected = true;\n\t\tthis.triggerSelect(span, ev);\n\t},\n\n\n\t// Triggers handlers to 'select'\n\ttriggerSelect: function(span, ev) {\n\t\tthis.trigger(\n\t\t\t'select',\n\t\t\tnull,\n\t\t\tthis.calendar.applyTimezone(span.start), // convert to calendar's tz for external API\n\t\t\tthis.calendar.applyTimezone(span.end), // \"\n\t\t\tev\n\t\t);\n\t},\n\n\n\t// Undoes a selection. updates in the internal state and triggers handlers.\n\t// `ev` is the native mouse event that began the interaction.\n\tunselect: function(ev) {\n\t\tif (this.isSelected) {\n\t\t\tthis.isSelected = false;\n\t\t\tif (this.destroySelection) {\n\t\t\t\tthis.destroySelection(); // TODO: deprecate\n\t\t\t}\n\t\t\tthis.unrenderSelection();\n\t\t\tthis.trigger('unselect', null, ev);\n\t\t}\n\t},\n\n\n\t// Unrenders a visual indication of selection\n\tunrenderSelection: function() {\n\t\t// subclasses should implement\n\t},\n\n\n\t/* Event Selection\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\tselectEvent: function(event) {\n\t\tif (!this.selectedEvent || this.selectedEvent !== event) {\n\t\t\tthis.unselectEvent();\n\t\t\tthis.renderedEventSegEach(function(seg) {\n\t\t\t\tseg.el.addClass('fc-selected');\n\t\t\t}, event);\n\t\t\tthis.selectedEvent = event;\n\t\t}\n\t},\n\n\n\tunselectEvent: function() {\n\t\tif (this.selectedEvent) {\n\t\t\tthis.renderedEventSegEach(function(seg) {\n\t\t\t\tseg.el.removeClass('fc-selected');\n\t\t\t}, this.selectedEvent);\n\t\t\tthis.selectedEvent = null;\n\t\t}\n\t},\n\n\n\tisEventSelected: function(event) {\n\t\t// event references might change on refetchEvents(), while selectedEvent doesn't,\n\t\t// so compare IDs\n\t\treturn this.selectedEvent && this.selectedEvent._id === event._id;\n\t},\n\n\n\t/* Mouse / Touch Unselecting (time range & event unselection)\n\t------------------------------------------------------------------------------------------------------------------*/\n\t// TODO: move consistently to down/start or up/end?\n\t// TODO: don't kill previous selection if touch scrolling\n\n\n\thandleDocumentMousedown: function(ev) {\n\t\tif (isPrimaryMouseButton(ev)) {\n\t\t\tthis.processUnselect(ev);\n\t\t}\n\t},\n\n\n\tprocessUnselect: function(ev) {\n\t\tthis.processRangeUnselect(ev);\n\t\tthis.processEventUnselect(ev);\n\t},\n\n\n\tprocessRangeUnselect: function(ev) {\n\t\tvar ignore;\n\n\t\t// is there a time-range selection?\n\t\tif (this.isSelected && this.opt('unselectAuto')) {\n\t\t\t// only unselect if the clicked element is not identical to or inside of an 'unselectCancel' element\n\t\t\tignore = this.opt('unselectCancel');\n\t\t\tif (!ignore || !$(ev.target).closest(ignore).length) {\n\t\t\t\tthis.unselect(ev);\n\t\t\t}\n\t\t}\n\t},\n\n\n\tprocessEventUnselect: function(ev) {\n\t\tif (this.selectedEvent) {\n\t\t\tif (!$(ev.target).closest('.fc-selected').length) {\n\t\t\t\tthis.unselectEvent();\n\t\t\t}\n\t\t}\n\t},\n\n\n\t/* Day Click\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Triggers handlers to 'dayClick'\n\t// Span has start/end of the clicked area. Only the start is useful.\n\ttriggerDayClick: function(span, dayEl, ev) {\n\t\tthis.trigger(\n\t\t\t'dayClick',\n\t\t\tdayEl,\n\t\t\tthis.calendar.applyTimezone(span.start), // convert to calendar's timezone for external API\n\t\t\tev\n\t\t);\n\t},\n\n\n\t/* Date Utils\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Initializes internal variables related to calculating hidden days-of-week\n\tinitHiddenDays: function() {\n\t\tvar hiddenDays = this.opt('hiddenDays') || []; // array of day-of-week indices that are hidden\n\t\tvar isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)\n\t\tvar dayCnt = 0;\n\t\tvar i;\n\n\t\tif (this.opt('weekends') === false) {\n\t\t\thiddenDays.push(0, 6); // 0=sunday, 6=saturday\n\t\t}\n\n\t\tfor (i = 0; i < 7; i++) {\n\t\t\tif (\n\t\t\t\t!(isHiddenDayHash[i] = $.inArray(i, hiddenDays) !== -1)\n\t\t\t) {\n\t\t\t\tdayCnt++;\n\t\t\t}\n\t\t}\n\n\t\tif (!dayCnt) {\n\t\t\tthrow 'invalid hiddenDays'; // all days were hidden? bad.\n\t\t}\n\n\t\tthis.isHiddenDayHash = isHiddenDayHash;\n\t},\n\n\n\t// Is the current day hidden?\n\t// `day` is a day-of-week index (0-6), or a Moment\n\tisHiddenDay: function(day) {\n\t\tif (moment.isMoment(day)) {\n\t\t\tday = day.day();\n\t\t}\n\t\treturn this.isHiddenDayHash[day];\n\t},\n\n\n\t// Incrementing the current day until it is no longer a hidden day, returning a copy.\n\t// If the initial value of `date` is not a hidden day, don't do anything.\n\t// Pass `isExclusive` as `true` if you are dealing with an end date.\n\t// `inc` defaults to `1` (increment one day forward each time)\n\tskipHiddenDays: function(date, inc, isExclusive) {\n\t\tvar out = date.clone();\n\t\tinc = inc || 1;\n\t\twhile (\n\t\t\tthis.isHiddenDayHash[(out.day() + (isExclusive ? inc : 0) + 7) % 7]\n\t\t) {\n\t\t\tout.add(inc, 'days');\n\t\t}\n\t\treturn out;\n\t},\n\n\n\t// Returns the date range of the full days the given range visually appears to occupy.\n\t// Returns a new range object.\n\tcomputeDayRange: function(range) {\n\t\tvar startDay = range.start.clone().stripTime(); // the beginning of the day the range starts\n\t\tvar end = range.end;\n\t\tvar endDay = null;\n\t\tvar endTimeMS;\n\n\t\tif (end) {\n\t\t\tendDay = end.clone().stripTime(); // the beginning of the day the range exclusively ends\n\t\t\tendTimeMS = +end.time(); // # of milliseconds into `endDay`\n\n\t\t\t// If the end time is actually inclusively part of the next day and is equal to or\n\t\t\t// beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.\n\t\t\t// Otherwise, leaving it as inclusive will cause it to exclude `endDay`.\n\t\t\tif (endTimeMS && endTimeMS >= this.nextDayThreshold) {\n\t\t\t\tendDay.add(1, 'days');\n\t\t\t}\n\t\t}\n\n\t\t// If no end was specified, or if it is within `startDay` but not past nextDayThreshold,\n\t\t// assign the default duration of one day.\n\t\tif (!end || endDay <= startDay) {\n\t\t\tendDay = startDay.clone().add(1, 'days');\n\t\t}\n\n\t\treturn { start: startDay, end: endDay };\n\t},\n\n\n\t// Does the given event visually appear to occupy more than one day?\n\tisMultiDayEvent: function(event) {\n\t\tvar range = this.computeDayRange(event); // event is range-ish\n\n\t\treturn range.end.diff(range.start, 'days') > 1;\n\t}\n\n});\n\n;;\n\n/*\nEmbodies a div that has potential scrollbars\n*/\nvar Scroller = FC.Scroller = Class.extend({\n\n\tel: null, // the guaranteed outer element\n\tscrollEl: null, // the element with the scrollbars\n\toverflowX: null,\n\toverflowY: null,\n\n\n\tconstructor: function(options) {\n\t\toptions = options || {};\n\t\tthis.overflowX = options.overflowX || options.overflow || 'auto';\n\t\tthis.overflowY = options.overflowY || options.overflow || 'auto';\n\t},\n\n\n\trender: function() {\n\t\tthis.el = this.renderEl();\n\t\tthis.applyOverflow();\n\t},\n\n\n\trenderEl: function() {\n\t\treturn (this.scrollEl = $('<div class=\"fc-scroller\"></div>'));\n\t},\n\n\n\t// sets to natural height, unlocks overflow\n\tclear: function() {\n\t\tthis.setHeight('auto');\n\t\tthis.applyOverflow();\n\t},\n\n\n\tdestroy: function() {\n\t\tthis.el.remove();\n\t},\n\n\n\t// Overflow\n\t// -----------------------------------------------------------------------------------------------------------------\n\n\n\tapplyOverflow: function() {\n\t\tthis.scrollEl.css({\n\t\t\t'overflow-x': this.overflowX,\n\t\t\t'overflow-y': this.overflowY\n\t\t});\n\t},\n\n\n\t// Causes any 'auto' overflow values to resolves to 'scroll' or 'hidden'.\n\t// Useful for preserving scrollbar widths regardless of future resizes.\n\t// Can pass in scrollbarWidths for optimization.\n\tlockOverflow: function(scrollbarWidths) {\n\t\tvar overflowX = this.overflowX;\n\t\tvar overflowY = this.overflowY;\n\n\t\tscrollbarWidths = scrollbarWidths || this.getScrollbarWidths();\n\n\t\tif (overflowX === 'auto') {\n\t\t\toverflowX = (\n\t\t\t\t\tscrollbarWidths.top || scrollbarWidths.bottom || // horizontal scrollbars?\n\t\t\t\t\t// OR scrolling pane with massless scrollbars?\n\t\t\t\t\tthis.scrollEl[0].scrollWidth - 1 > this.scrollEl[0].clientWidth\n\t\t\t\t\t\t// subtract 1 because of IE off-by-one issue\n\t\t\t\t) ? 'scroll' : 'hidden';\n\t\t}\n\n\t\tif (overflowY === 'auto') {\n\t\t\toverflowY = (\n\t\t\t\t\tscrollbarWidths.left || scrollbarWidths.right || // vertical scrollbars?\n\t\t\t\t\t// OR scrolling pane with massless scrollbars?\n\t\t\t\t\tthis.scrollEl[0].scrollHeight - 1 > this.scrollEl[0].clientHeight\n\t\t\t\t\t\t// subtract 1 because of IE off-by-one issue\n\t\t\t\t) ? 'scroll' : 'hidden';\n\t\t}\n\n\t\tthis.scrollEl.css({ 'overflow-x': overflowX, 'overflow-y': overflowY });\n\t},\n\n\n\t// Getters / Setters\n\t// -----------------------------------------------------------------------------------------------------------------\n\n\n\tsetHeight: function(height) {\n\t\tthis.scrollEl.height(height);\n\t},\n\n\n\tgetScrollTop: function() {\n\t\treturn this.scrollEl.scrollTop();\n\t},\n\n\n\tsetScrollTop: function(top) {\n\t\tthis.scrollEl.scrollTop(top);\n\t},\n\n\n\tgetClientWidth: function() {\n\t\treturn this.scrollEl[0].clientWidth;\n\t},\n\n\n\tgetClientHeight: function() {\n\t\treturn this.scrollEl[0].clientHeight;\n\t},\n\n\n\tgetScrollbarWidths: function() {\n\t\treturn getScrollbarWidths(this.scrollEl);\n\t}\n\n});\n\n;;\n\nvar Calendar = FC.Calendar = Class.extend({\n\n\tdirDefaults: null, // option defaults related to LTR or RTL\n\tlocaleDefaults: null, // option defaults related to current locale\n\toverrides: null, // option overrides given to the fullCalendar constructor\n\tdynamicOverrides: null, // options set with dynamic setter method. higher precedence than view overrides.\n\toptions: null, // all defaults combined with overrides\n\tviewSpecCache: null, // cache of view definitions\n\tview: null, // current View object\n\theader: null,\n\tloadingLevel: 0, // number of simultaneous loading tasks\n\n\n\t// a lot of this class' OOP logic is scoped within this constructor function,\n\t// but in the future, write individual methods on the prototype.\n\tconstructor: Calendar_constructor,\n\n\n\t// Subclasses can override this for initialization logic after the constructor has been called\n\tinitialize: function() {\n\t},\n\n\n\t// Computes the flattened options hash for the calendar and assigns to `this.options`.\n\t// Assumes this.overrides and this.dynamicOverrides have already been initialized.\n\tpopulateOptionsHash: function() {\n\t\tvar locale, localeDefaults;\n\t\tvar isRTL, dirDefaults;\n\n\t\tlocale = firstDefined( // explicit locale option given?\n\t\t\tthis.dynamicOverrides.locale,\n\t\t\tthis.overrides.locale\n\t\t);\n\t\tlocaleDefaults = localeOptionHash[locale];\n\t\tif (!localeDefaults) { // explicit locale option not given or invalid?\n\t\t\tlocale = Calendar.defaults.locale;\n\t\t\tlocaleDefaults = localeOptionHash[locale] || {};\n\t\t}\n\n\t\tisRTL = firstDefined( // based on options computed so far, is direction RTL?\n\t\t\tthis.dynamicOverrides.isRTL,\n\t\t\tthis.overrides.isRTL,\n\t\t\tlocaleDefaults.isRTL,\n\t\t\tCalendar.defaults.isRTL\n\t\t);\n\t\tdirDefaults = isRTL ? Calendar.rtlDefaults : {};\n\n\t\tthis.dirDefaults = dirDefaults;\n\t\tthis.localeDefaults = localeDefaults;\n\t\tthis.options = mergeOptions([ // merge defaults and overrides. lowest to highest precedence\n\t\t\tCalendar.defaults, // global defaults\n\t\t\tdirDefaults,\n\t\t\tlocaleDefaults,\n\t\t\tthis.overrides,\n\t\t\tthis.dynamicOverrides\n\t\t]);\n\t\tpopulateInstanceComputableOptions(this.options); // fill in gaps with computed options\n\t},\n\n\n\t// Gets information about how to create a view. Will use a cache.\n\tgetViewSpec: function(viewType) {\n\t\tvar cache = this.viewSpecCache;\n\n\t\treturn cache[viewType] || (cache[viewType] = this.buildViewSpec(viewType));\n\t},\n\n\n\t// Given a duration singular unit, like \"week\" or \"day\", finds a matching view spec.\n\t// Preference is given to views that have corresponding buttons.\n\tgetUnitViewSpec: function(unit) {\n\t\tvar viewTypes;\n\t\tvar i;\n\t\tvar spec;\n\n\t\tif ($.inArray(unit, intervalUnits) != -1) {\n\n\t\t\t// put views that have buttons first. there will be duplicates, but oh well\n\t\t\tviewTypes = this.header.getViewsWithButtons();\n\t\t\t$.each(FC.views, function(viewType) { // all views\n\t\t\t\tviewTypes.push(viewType);\n\t\t\t});\n\n\t\t\tfor (i = 0; i < viewTypes.length; i++) {\n\t\t\t\tspec = this.getViewSpec(viewTypes[i]);\n\t\t\t\tif (spec) {\n\t\t\t\t\tif (spec.singleUnit == unit) {\n\t\t\t\t\t\treturn spec;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\n\t// Builds an object with information on how to create a given view\n\tbuildViewSpec: function(requestedViewType) {\n\t\tvar viewOverrides = this.overrides.views || {};\n\t\tvar specChain = []; // for the view. lowest to highest priority\n\t\tvar defaultsChain = []; // for the view. lowest to highest priority\n\t\tvar overridesChain = []; // for the view. lowest to highest priority\n\t\tvar viewType = requestedViewType;\n\t\tvar spec; // for the view\n\t\tvar overrides; // for the view\n\t\tvar duration;\n\t\tvar unit;\n\n\t\t// iterate from the specific view definition to a more general one until we hit an actual View class\n\t\twhile (viewType) {\n\t\t\tspec = fcViews[viewType];\n\t\t\toverrides = viewOverrides[viewType];\n\t\t\tviewType = null; // clear. might repopulate for another iteration\n\n\t\t\tif (typeof spec === 'function') { // TODO: deprecate\n\t\t\t\tspec = { 'class': spec };\n\t\t\t}\n\n\t\t\tif (spec) {\n\t\t\t\tspecChain.unshift(spec);\n\t\t\t\tdefaultsChain.unshift(spec.defaults || {});\n\t\t\t\tduration = duration || spec.duration;\n\t\t\t\tviewType = viewType || spec.type;\n\t\t\t}\n\n\t\t\tif (overrides) {\n\t\t\t\toverridesChain.unshift(overrides); // view-specific option hashes have options at zero-level\n\t\t\t\tduration = duration || overrides.duration;\n\t\t\t\tviewType = viewType || overrides.type;\n\t\t\t}\n\t\t}\n\n\t\tspec = mergeProps(specChain);\n\t\tspec.type = requestedViewType;\n\t\tif (!spec['class']) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (duration) {\n\t\t\tduration = moment.duration(duration);\n\t\t\tif (duration.valueOf()) { // valid?\n\t\t\t\tspec.duration = duration;\n\t\t\t\tunit = computeIntervalUnit(duration);\n\n\t\t\t\t// view is a single-unit duration, like \"week\" or \"day\"\n\t\t\t\t// incorporate options for this. lowest priority\n\t\t\t\tif (duration.as(unit) === 1) {\n\t\t\t\t\tspec.singleUnit = unit;\n\t\t\t\t\toverridesChain.unshift(viewOverrides[unit] || {});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tspec.defaults = mergeOptions(defaultsChain);\n\t\tspec.overrides = mergeOptions(overridesChain);\n\n\t\tthis.buildViewSpecOptions(spec);\n\t\tthis.buildViewSpecButtonText(spec, requestedViewType);\n\n\t\treturn spec;\n\t},\n\n\n\t// Builds and assigns a view spec's options object from its already-assigned defaults and overrides\n\tbuildViewSpecOptions: function(spec) {\n\t\tspec.options = mergeOptions([ // lowest to highest priority\n\t\t\tCalendar.defaults, // global defaults\n\t\t\tspec.defaults, // view's defaults (from ViewSubclass.defaults)\n\t\t\tthis.dirDefaults,\n\t\t\tthis.localeDefaults, // locale and dir take precedence over view's defaults!\n\t\t\tthis.overrides, // calendar's overrides (options given to constructor)\n\t\t\tspec.overrides, // view's overrides (view-specific options)\n\t\t\tthis.dynamicOverrides // dynamically set via setter. highest precedence\n\t\t]);\n\t\tpopulateInstanceComputableOptions(spec.options);\n\t},\n\n\n\t// Computes and assigns a view spec's buttonText-related options\n\tbuildViewSpecButtonText: function(spec, requestedViewType) {\n\n\t\t// given an options object with a possible `buttonText` hash, lookup the buttonText for the\n\t\t// requested view, falling back to a generic unit entry like \"week\" or \"day\"\n\t\tfunction queryButtonText(options) {\n\t\t\tvar buttonText = options.buttonText || {};\n\t\t\treturn buttonText[requestedViewType] ||\n\t\t\t\t// view can decide to look up a certain key\n\t\t\t\t(spec.buttonTextKey ? buttonText[spec.buttonTextKey] : null) ||\n\t\t\t\t// a key like \"month\"\n\t\t\t\t(spec.singleUnit ? buttonText[spec.singleUnit] : null);\n\t\t}\n\n\t\t// highest to lowest priority\n\t\tspec.buttonTextOverride =\n\t\t\tqueryButtonText(this.dynamicOverrides) ||\n\t\t\tqueryButtonText(this.overrides) || // constructor-specified buttonText lookup hash takes precedence\n\t\t\tspec.overrides.buttonText; // `buttonText` for view-specific options is a string\n\n\t\t// highest to lowest priority. mirrors buildViewSpecOptions\n\t\tspec.buttonTextDefault =\n\t\t\tqueryButtonText(this.localeDefaults) ||\n\t\t\tqueryButtonText(this.dirDefaults) ||\n\t\t\tspec.defaults.buttonText || // a single string. from ViewSubclass.defaults\n\t\t\tqueryButtonText(Calendar.defaults) ||\n\t\t\t(spec.duration ? this.humanizeDuration(spec.duration) : null) || // like \"3 days\"\n\t\t\trequestedViewType; // fall back to given view name\n\t},\n\n\n\t// Given a view name for a custom view or a standard view, creates a ready-to-go View object\n\tinstantiateView: function(viewType) {\n\t\tvar spec = this.getViewSpec(viewType);\n\n\t\treturn new spec['class'](this, viewType, spec.options, spec.duration);\n\t},\n\n\n\t// Returns a boolean about whether the view is okay to instantiate at some point\n\tisValidViewType: function(viewType) {\n\t\treturn Boolean(this.getViewSpec(viewType));\n\t},\n\n\n\t// Should be called when any type of async data fetching begins\n\tpushLoading: function() {\n\t\tif (!(this.loadingLevel++)) {\n\t\t\tthis.trigger('loading', null, true, this.view);\n\t\t}\n\t},\n\n\n\t// Should be called when any type of async data fetching completes\n\tpopLoading: function() {\n\t\tif (!(--this.loadingLevel)) {\n\t\t\tthis.trigger('loading', null, false, this.view);\n\t\t}\n\t},\n\n\n\t// Given arguments to the select method in the API, returns a span (unzoned start/end and other info)\n\tbuildSelectSpan: function(zonedStartInput, zonedEndInput) {\n\t\tvar start = this.moment(zonedStartInput).stripZone();\n\t\tvar end;\n\n\t\tif (zonedEndInput) {\n\t\t\tend = this.moment(zonedEndInput).stripZone();\n\t\t}\n\t\telse if (start.hasTime()) {\n\t\t\tend = start.clone().add(this.defaultTimedEventDuration);\n\t\t}\n\t\telse {\n\t\t\tend = start.clone().add(this.defaultAllDayEventDuration);\n\t\t}\n\n\t\treturn { start: start, end: end };\n\t}\n\n});\n\n\nCalendar.mixin(EmitterMixin);\n\n\nfunction Calendar_constructor(element, overrides) {\n\tvar t = this;\n\n\n\t// Exports\n\t// -----------------------------------------------------------------------------------\n\n\tt.render = render;\n\tt.destroy = destroy;\n\tt.refetchEvents = refetchEvents;\n\tt.refetchEventSources = refetchEventSources;\n\tt.reportEvents = reportEvents;\n\tt.reportEventChange = reportEventChange;\n\tt.rerenderEvents = renderEvents; // `renderEvents` serves as a rerender. an API method\n\tt.changeView = renderView; // `renderView` will switch to another view\n\tt.select = select;\n\tt.unselect = unselect;\n\tt.prev = prev;\n\tt.next = next;\n\tt.prevYear = prevYear;\n\tt.nextYear = nextYear;\n\tt.today = today;\n\tt.gotoDate = gotoDate;\n\tt.incrementDate = incrementDate;\n\tt.zoomTo = zoomTo;\n\tt.getDate = getDate;\n\tt.getCalendar = getCalendar;\n\tt.getView = getView;\n\tt.option = option; // getter/setter method\n\tt.trigger = trigger;\n\n\n\t// Options\n\t// -----------------------------------------------------------------------------------\n\n\tt.dynamicOverrides = {};\n\tt.viewSpecCache = {};\n\tt.optionHandlers = {}; // for Calendar.options.js\n\tt.overrides = $.extend({}, overrides); // make a copy\n\n\tt.populateOptionsHash(); // sets this.options\n\n\n\n\t// Locale-data Internals\n\t// -----------------------------------------------------------------------------------\n\t// Apply overrides to the current locale's data\n\n\tvar localeData;\n\n\t// Called immediately, and when any of the options change.\n\t// Happens before any internal objects rebuild or rerender, because this is very core.\n\tt.bindOptions([\n\t\t'locale', 'monthNames', 'monthNamesShort', 'dayNames', 'dayNamesShort', 'firstDay', 'weekNumberCalculation'\n\t], function(locale, monthNames, monthNamesShort, dayNames, dayNamesShort, firstDay, weekNumberCalculation) {\n\n\t\t// normalize\n\t\tif (weekNumberCalculation === 'iso') {\n\t\t\tweekNumberCalculation = 'ISO'; // normalize\n\t\t}\n\n\t\tlocaleData = createObject( // make a cheap copy\n\t\t\tgetMomentLocaleData(locale) // will fall back to en\n\t\t);\n\n\t\tif (monthNames) {\n\t\t\tlocaleData._months = monthNames;\n\t\t}\n\t\tif (monthNamesShort) {\n\t\t\tlocaleData._monthsShort = monthNamesShort;\n\t\t}\n\t\tif (dayNames) {\n\t\t\tlocaleData._weekdays = dayNames;\n\t\t}\n\t\tif (dayNamesShort) {\n\t\t\tlocaleData._weekdaysShort = dayNamesShort;\n\t\t}\n\n\t\tif (firstDay == null && weekNumberCalculation === 'ISO') {\n\t\t\tfirstDay = 1;\n\t\t}\n\t\tif (firstDay != null) {\n\t\t\tvar _week = createObject(localeData._week); // _week: { dow: # }\n\t\t\t_week.dow = firstDay;\n\t\t\tlocaleData._week = _week;\n\t\t}\n\n\t\tif ( // whitelist certain kinds of input\n\t\t\tweekNumberCalculation === 'ISO' ||\n\t\t\tweekNumberCalculation === 'local' ||\n\t\t\ttypeof weekNumberCalculation === 'function'\n\t\t) {\n\t\t\tlocaleData._fullCalendar_weekCalc = weekNumberCalculation; // moment-ext will know what to do with it\n\t\t}\n\n\t\t// If the internal current date object already exists, move to new locale.\n\t\t// We do NOT need to do this technique for event dates, because this happens when converting to \"segments\".\n\t\tif (date) {\n\t\t\tlocalizeMoment(date); // sets to localeData\n\t\t}\n\t});\n\n\n\t// Calendar-specific Date Utilities\n\t// -----------------------------------------------------------------------------------\n\n\n\tt.defaultAllDayEventDuration = moment.duration(t.options.defaultAllDayEventDuration);\n\tt.defaultTimedEventDuration = moment.duration(t.options.defaultTimedEventDuration);\n\n\n\t// Builds a moment using the settings of the current calendar: timezone and locale.\n\t// Accepts anything the vanilla moment() constructor accepts.\n\tt.moment = function() {\n\t\tvar mom;\n\n\t\tif (t.options.timezone === 'local') {\n\t\t\tmom = FC.moment.apply(null, arguments);\n\n\t\t\t// Force the moment to be local, because FC.moment doesn't guarantee it.\n\t\t\tif (mom.hasTime()) { // don't give ambiguously-timed moments a local zone\n\t\t\t\tmom.local();\n\t\t\t}\n\t\t}\n\t\telse if (t.options.timezone === 'UTC') {\n\t\t\tmom = FC.moment.utc.apply(null, arguments); // process as UTC\n\t\t}\n\t\telse {\n\t\t\tmom = FC.moment.parseZone.apply(null, arguments); // let the input decide the zone\n\t\t}\n\n\t\tlocalizeMoment(mom);\n\n\t\treturn mom;\n\t};\n\n\n\t// Updates the given moment's locale settings to the current calendar locale settings.\n\tfunction localizeMoment(mom) {\n\t\tmom._locale = localeData;\n\t}\n\tt.localizeMoment = localizeMoment;\n\n\n\t// Returns a boolean about whether or not the calendar knows how to calculate\n\t// the timezone offset of arbitrary dates in the current timezone.\n\tt.getIsAmbigTimezone = function() {\n\t\treturn t.options.timezone !== 'local' && t.options.timezone !== 'UTC';\n\t};\n\n\n\t// Returns a copy of the given date in the current timezone. Has no effect on dates without times.\n\tt.applyTimezone = function(date) {\n\t\tif (!date.hasTime()) {\n\t\t\treturn date.clone();\n\t\t}\n\n\t\tvar zonedDate = t.moment(date.toArray());\n\t\tvar timeAdjust = date.time() - zonedDate.time();\n\t\tvar adjustedZonedDate;\n\n\t\t// Safari sometimes has problems with this coersion when near DST. Adjust if necessary. (bug #2396)\n\t\tif (timeAdjust) { // is the time result different than expected?\n\t\t\tadjustedZonedDate = zonedDate.clone().add(timeAdjust); // add milliseconds\n\t\t\tif (date.time() - adjustedZonedDate.time() === 0) { // does it match perfectly now?\n\t\t\t\tzonedDate = adjustedZonedDate;\n\t\t\t}\n\t\t}\n\n\t\treturn zonedDate;\n\t};\n\n\n\t// Returns a moment for the current date, as defined by the client's computer or from the `now` option.\n\t// Will return an moment with an ambiguous timezone.\n\tt.getNow = function() {\n\t\tvar now = t.options.now;\n\t\tif (typeof now === 'function') {\n\t\t\tnow = now();\n\t\t}\n\t\treturn t.moment(now).stripZone();\n\t};\n\n\n\t// Get an event's normalized end date. If not present, calculate it from the defaults.\n\tt.getEventEnd = function(event) {\n\t\tif (event.end) {\n\t\t\treturn event.end.clone();\n\t\t}\n\t\telse {\n\t\t\treturn t.getDefaultEventEnd(event.allDay, event.start);\n\t\t}\n\t};\n\n\n\t// Given an event's allDay status and start date, return what its fallback end date should be.\n\t// TODO: rename to computeDefaultEventEnd\n\tt.getDefaultEventEnd = function(allDay, zonedStart) {\n\t\tvar end = zonedStart.clone();\n\n\t\tif (allDay) {\n\t\t\tend.stripTime().add(t.defaultAllDayEventDuration);\n\t\t}\n\t\telse {\n\t\t\tend.add(t.defaultTimedEventDuration);\n\t\t}\n\n\t\tif (t.getIsAmbigTimezone()) {\n\t\t\tend.stripZone(); // we don't know what the tzo should be\n\t\t}\n\n\t\treturn end;\n\t};\n\n\n\t// Produces a human-readable string for the given duration.\n\t// Side-effect: changes the locale of the given duration.\n\tt.humanizeDuration = function(duration) {\n\t\treturn duration.locale(t.options.locale).humanize();\n\t};\n\n\n\t\n\t// Imports\n\t// -----------------------------------------------------------------------------------\n\n\n\tEventManager.call(t);\n\tvar isFetchNeeded = t.isFetchNeeded;\n\tvar fetchEvents = t.fetchEvents;\n\tvar fetchEventSources = t.fetchEventSources;\n\n\n\n\t// Locals\n\t// -----------------------------------------------------------------------------------\n\n\n\tvar _element = element[0];\n\tvar header;\n\tvar content;\n\tvar tm; // for making theme classes\n\tvar currentView; // NOTE: keep this in sync with this.view\n\tvar viewsByType = {}; // holds all instantiated view instances, current or not\n\tvar suggestedViewHeight;\n\tvar windowResizeProxy; // wraps the windowResize function\n\tvar ignoreWindowResize = 0;\n\tvar events = [];\n\tvar date; // unzoned\n\t\n\t\n\t\n\t// Main Rendering\n\t// -----------------------------------------------------------------------------------\n\n\n\t// compute the initial ambig-timezone date\n\tif (t.options.defaultDate != null) {\n\t\tdate = t.moment(t.options.defaultDate).stripZone();\n\t}\n\telse {\n\t\tdate = t.getNow(); // getNow already returns unzoned\n\t}\n\t\n\t\n\tfunction render() {\n\t\tif (!content) {\n\t\t\tinitialRender();\n\t\t}\n\t\telse if (elementVisible()) {\n\t\t\t// mainly for the public API\n\t\t\tcalcSize();\n\t\t\trenderView();\n\t\t}\n\t}\n\t\n\t\n\tfunction initialRender() {\n\t\telement.addClass('fc');\n\n\t\t// event delegation for nav links\n\t\telement.on('click.fc', 'a[data-goto]', function(ev) {\n\t\t\tvar anchorEl = $(this);\n\t\t\tvar gotoOptions = anchorEl.data('goto'); // will automatically parse JSON\n\t\t\tvar date = t.moment(gotoOptions.date);\n\t\t\tvar viewType = gotoOptions.type;\n\n\t\t\t// property like \"navLinkDayClick\". might be a string or a function\n\t\t\tvar customAction = currentView.opt('navLink' + capitaliseFirstLetter(viewType) + 'Click');\n\n\t\t\tif (typeof customAction === 'function') {\n\t\t\t\tcustomAction(date, ev);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (typeof customAction === 'string') {\n\t\t\t\t\tviewType = customAction;\n\t\t\t\t}\n\t\t\t\tzoomTo(date, viewType);\n\t\t\t}\n\t\t});\n\n\t\t// called immediately, and upon option change\n\t\tt.bindOption('theme', function(theme) {\n\t\t\ttm = theme ? 'ui' : 'fc'; // affects a larger scope\n\t\t\telement.toggleClass('ui-widget', theme);\n\t\t\telement.toggleClass('fc-unthemed', !theme);\n\t\t});\n\n\t\t// called immediately, and upon option change.\n\t\t// HACK: locale often affects isRTL, so we explicitly listen to that too.\n\t\tt.bindOptions([ 'isRTL', 'locale' ], function(isRTL) {\n\t\t\telement.toggleClass('fc-ltr', !isRTL);\n\t\t\telement.toggleClass('fc-rtl', isRTL);\n\t\t});\n\n\t\tcontent = $(\"<div class='fc-view-container'/>\").prependTo(element);\n\n\t\theader = t.header = new Header(t);\n\t\trenderHeader();\n\n\t\trenderView(t.options.defaultView);\n\n\t\tif (t.options.handleWindowResize) {\n\t\t\twindowResizeProxy = debounce(windowResize, t.options.windowResizeDelay); // prevents rapid calls\n\t\t\t$(window).resize(windowResizeProxy);\n\t\t}\n\t}\n\n\n\t// can be called repeatedly and Header will rerender\n\tfunction renderHeader() {\n\t\theader.render();\n\t\tif (header.el) {\n\t\t\telement.prepend(header.el);\n\t\t}\n\t}\n\t\n\t\n\tfunction destroy() {\n\n\t\tif (currentView) {\n\t\t\tcurrentView.removeElement();\n\n\t\t\t// NOTE: don't null-out currentView/t.view in case API methods are called after destroy.\n\t\t\t// It is still the \"current\" view, just not rendered.\n\t\t}\n\n\t\theader.removeElement();\n\t\tcontent.remove();\n\t\telement.removeClass('fc fc-ltr fc-rtl fc-unthemed ui-widget');\n\n\t\telement.off('.fc'); // unbind nav link handlers\n\n\t\tif (windowResizeProxy) {\n\t\t\t$(window).unbind('resize', windowResizeProxy);\n\t\t}\n\t}\n\t\n\t\n\tfunction elementVisible() {\n\t\treturn element.is(':visible');\n\t}\n\t\n\t\n\n\t// View Rendering\n\t// -----------------------------------------------------------------------------------\n\n\n\t// Renders a view because of a date change, view-type change, or for the first time.\n\t// If not given a viewType, keep the current view but render different dates.\n\t// Accepts an optional scroll state to restore to.\n\tfunction renderView(viewType, explicitScrollState) {\n\t\tignoreWindowResize++;\n\n\t\t// if viewType is changing, remove the old view's rendering\n\t\tif (currentView && viewType && currentView.type !== viewType) {\n\t\t\tfreezeContentHeight(); // prevent a scroll jump when view element is removed\n\t\t\tclearView();\n\t\t}\n\n\t\t// if viewType changed, or the view was never created, create a fresh view\n\t\tif (!currentView && viewType) {\n\t\t\tcurrentView = t.view =\n\t\t\t\tviewsByType[viewType] ||\n\t\t\t\t(viewsByType[viewType] = t.instantiateView(viewType));\n\n\t\t\tcurrentView.setElement(\n\t\t\t\t$(\"<div class='fc-view fc-\" + viewType + \"-view' />\").appendTo(content)\n\t\t\t);\n\t\t\theader.activateButton(viewType);\n\t\t}\n\n\t\tif (currentView) {\n\n\t\t\t// in case the view should render a period of time that is completely hidden\n\t\t\tdate = currentView.massageCurrentDate(date);\n\n\t\t\t// render or rerender the view\n\t\t\tif (\n\t\t\t\t!currentView.displaying ||\n\t\t\t\t!( // NOT within interval range signals an implicit date window change\n\t\t\t\t\tdate >= currentView.intervalStart &&\n\t\t\t\t\tdate < currentView.intervalEnd\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tif (elementVisible()) {\n\n\t\t\t\t\tcurrentView.display(date, explicitScrollState); // will call freezeContentHeight\n\t\t\t\t\tunfreezeContentHeight(); // immediately unfreeze regardless of whether display is async\n\n\t\t\t\t\t// need to do this after View::render, so dates are calculated\n\t\t\t\t\tupdateHeaderTitle();\n\t\t\t\t\tupdateTodayButton();\n\n\t\t\t\t\tgetAndRenderEvents();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tunfreezeContentHeight(); // undo any lone freezeContentHeight calls\n\t\tignoreWindowResize--;\n\t}\n\n\n\t// Unrenders the current view and reflects this change in the Header.\n\t// Unregsiters the `currentView`, but does not remove from viewByType hash.\n\tfunction clearView() {\n\t\theader.deactivateButton(currentView.type);\n\t\tcurrentView.removeElement();\n\t\tcurrentView = t.view = null;\n\t}\n\n\n\t// Destroys the view, including the view object. Then, re-instantiates it and renders it.\n\t// Maintains the same scroll state.\n\t// TODO: maintain any other user-manipulated state.\n\tfunction reinitView() {\n\t\tignoreWindowResize++;\n\t\tfreezeContentHeight();\n\n\t\tvar viewType = currentView.type;\n\t\tvar scrollState = currentView.queryScroll();\n\t\tclearView();\n\t\trenderView(viewType, scrollState);\n\n\t\tunfreezeContentHeight();\n\t\tignoreWindowResize--;\n\t}\n\n\t\n\n\t// Resizing\n\t// -----------------------------------------------------------------------------------\n\n\n\tt.getSuggestedViewHeight = function() {\n\t\tif (suggestedViewHeight === undefined) {\n\t\t\tcalcSize();\n\t\t}\n\t\treturn suggestedViewHeight;\n\t};\n\n\n\tt.isHeightAuto = function() {\n\t\treturn t.options.contentHeight === 'auto' || t.options.height === 'auto';\n\t};\n\t\n\t\n\tfunction updateSize(shouldRecalc) {\n\t\tif (elementVisible()) {\n\n\t\t\tif (shouldRecalc) {\n\t\t\t\t_calcSize();\n\t\t\t}\n\n\t\t\tignoreWindowResize++;\n\t\t\tcurrentView.updateSize(true); // isResize=true. will poll getSuggestedViewHeight() and isHeightAuto()\n\t\t\tignoreWindowResize--;\n\n\t\t\treturn true; // signal success\n\t\t}\n\t}\n\n\n\tfunction calcSize() {\n\t\tif (elementVisible()) {\n\t\t\t_calcSize();\n\t\t}\n\t}\n\t\n\t\n\tfunction _calcSize() { // assumes elementVisible\n\t\tvar contentHeightInput = t.options.contentHeight;\n\t\tvar heightInput = t.options.height;\n\n\t\tif (typeof contentHeightInput === 'number') { // exists and not 'auto'\n\t\t\tsuggestedViewHeight = contentHeightInput;\n\t\t}\n\t\telse if (typeof contentHeightInput === 'function') { // exists and is a function\n\t\t\tsuggestedViewHeight = contentHeightInput();\n\t\t}\n\t\telse if (typeof heightInput === 'number') { // exists and not 'auto'\n\t\t\tsuggestedViewHeight = heightInput - queryHeaderHeight();\n\t\t}\n\t\telse if (typeof heightInput === 'function') { // exists and is a function\n\t\t\tsuggestedViewHeight = heightInput() - queryHeaderHeight();\n\t\t}\n\t\telse if (heightInput === 'parent') { // set to height of parent element\n\t\t\tsuggestedViewHeight = element.parent().height() - queryHeaderHeight();\n\t\t}\n\t\telse {\n\t\t\tsuggestedViewHeight = Math.round(content.width() / Math.max(t.options.aspectRatio, .5));\n\t\t}\n\t}\n\n\n\tfunction queryHeaderHeight() {\n\t\treturn header.el ? header.el.outerHeight(true) : 0; // includes margin\n\t}\n\t\n\t\n\tfunction windowResize(ev) {\n\t\tif (\n\t\t\t!ignoreWindowResize &&\n\t\t\tev.target === window && // so we don't process jqui \"resize\" events that have bubbled up\n\t\t\tcurrentView.start // view has already been rendered\n\t\t) {\n\t\t\tif (updateSize(true)) {\n\t\t\t\tcurrentView.trigger('windowResize', _element);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t\n\t/* Event Fetching/Rendering\n\t-----------------------------------------------------------------------------*/\n\t// TODO: going forward, most of this stuff should be directly handled by the view\n\n\n\tfunction refetchEvents() { // can be called as an API method\n\t\tfetchAndRenderEvents();\n\t}\n\n\n\t// TODO: move this into EventManager?\n\tfunction refetchEventSources(matchInputs) {\n\t\tfetchEventSources(t.getEventSourcesByMatchArray(matchInputs));\n\t}\n\n\n\tfunction renderEvents() { // destroys old events if previously rendered\n\t\tif (elementVisible()) {\n\t\t\tfreezeContentHeight();\n\t\t\tcurrentView.displayEvents(events);\n\t\t\tunfreezeContentHeight();\n\t\t}\n\t}\n\t\n\n\tfunction getAndRenderEvents() {\n\t\tif (!t.options.lazyFetching || isFetchNeeded(currentView.start, currentView.end)) {\n\t\t\tfetchAndRenderEvents();\n\t\t}\n\t\telse {\n\t\t\trenderEvents();\n\t\t}\n\t}\n\n\n\tfunction fetchAndRenderEvents() {\n\t\tfetchEvents(currentView.start, currentView.end);\n\t\t\t// ... will call reportEvents\n\t\t\t// ... which will call renderEvents\n\t}\n\n\t\n\t// called when event data arrives\n\tfunction reportEvents(_events) {\n\t\tevents = _events;\n\t\trenderEvents();\n\t}\n\n\n\t// called when a single event's data has been changed\n\tfunction reportEventChange() {\n\t\trenderEvents();\n\t}\n\n\n\n\t/* Header Updating\n\t-----------------------------------------------------------------------------*/\n\n\n\tfunction updateHeaderTitle() {\n\t\theader.updateTitle(currentView.title);\n\t}\n\n\n\tfunction updateTodayButton() {\n\t\tvar now = t.getNow();\n\n\t\tif (now >= currentView.intervalStart && now < currentView.intervalEnd) {\n\t\t\theader.disableButton('today');\n\t\t}\n\t\telse {\n\t\t\theader.enableButton('today');\n\t\t}\n\t}\n\t\n\n\n\t/* Selection\n\t-----------------------------------------------------------------------------*/\n\t\n\n\t// this public method receives start/end dates in any format, with any timezone\n\tfunction select(zonedStartInput, zonedEndInput) {\n\t\tcurrentView.select(\n\t\t\tt.buildSelectSpan.apply(t, arguments)\n\t\t);\n\t}\n\t\n\n\tfunction unselect() { // safe to be called before renderView\n\t\tif (currentView) {\n\t\t\tcurrentView.unselect();\n\t\t}\n\t}\n\t\n\t\n\t\n\t/* Date\n\t-----------------------------------------------------------------------------*/\n\t\n\t\n\tfunction prev() {\n\t\tdate = currentView.computePrevDate(date);\n\t\trenderView();\n\t}\n\t\n\t\n\tfunction next() {\n\t\tdate = currentView.computeNextDate(date);\n\t\trenderView();\n\t}\n\t\n\t\n\tfunction prevYear() {\n\t\tdate.add(-1, 'years');\n\t\trenderView();\n\t}\n\t\n\t\n\tfunction nextYear() {\n\t\tdate.add(1, 'years');\n\t\trenderView();\n\t}\n\t\n\t\n\tfunction today() {\n\t\tdate = t.getNow();\n\t\trenderView();\n\t}\n\t\n\t\n\tfunction gotoDate(zonedDateInput) {\n\t\tdate = t.moment(zonedDateInput).stripZone();\n\t\trenderView();\n\t}\n\t\n\t\n\tfunction incrementDate(delta) {\n\t\tdate.add(moment.duration(delta));\n\t\trenderView();\n\t}\n\n\n\t// Forces navigation to a view for the given date.\n\t// `viewType` can be a specific view name or a generic one like \"week\" or \"day\".\n\tfunction zoomTo(newDate, viewType) {\n\t\tvar spec;\n\n\t\tviewType = viewType || 'day'; // day is default zoom\n\t\tspec = t.getViewSpec(viewType) || t.getUnitViewSpec(viewType);\n\n\t\tdate = newDate.clone();\n\t\trenderView(spec ? spec.type : null);\n\t}\n\t\n\t\n\t// for external API\n\tfunction getDate() {\n\t\treturn t.applyTimezone(date); // infuse the calendar's timezone\n\t}\n\n\n\n\t/* Height \"Freezing\"\n\t-----------------------------------------------------------------------------*/\n\t// TODO: move this into the view\n\n\tt.freezeContentHeight = freezeContentHeight;\n\tt.unfreezeContentHeight = unfreezeContentHeight;\n\n\n\tfunction freezeContentHeight() {\n\t\tcontent.css({\n\t\t\twidth: '100%',\n\t\t\theight: content.height(),\n\t\t\toverflow: 'hidden'\n\t\t});\n\t}\n\n\n\tfunction unfreezeContentHeight() {\n\t\tcontent.css({\n\t\t\twidth: '',\n\t\t\theight: '',\n\t\t\toverflow: ''\n\t\t});\n\t}\n\t\n\t\n\t\n\t/* Misc\n\t-----------------------------------------------------------------------------*/\n\t\n\n\tfunction getCalendar() {\n\t\treturn t;\n\t}\n\n\t\n\tfunction getView() {\n\t\treturn currentView;\n\t}\n\t\n\t\n\tfunction option(name, value) {\n\t\tvar newOptionHash;\n\n\t\tif (typeof name === 'string') {\n\t\t\tif (value === undefined) { // getter\n\t\t\t\treturn t.options[name];\n\t\t\t}\n\t\t\telse { // setter for individual option\n\t\t\t\tnewOptionHash = {};\n\t\t\t\tnewOptionHash[name] = value;\n\t\t\t\tsetOptions(newOptionHash);\n\t\t\t}\n\t\t}\n\t\telse if (typeof name === 'object') { // compound setter with object input\n\t\t\tsetOptions(name);\n\t\t}\n\t}\n\n\n\tfunction setOptions(newOptionHash) {\n\t\tvar optionCnt = 0;\n\t\tvar optionName;\n\n\t\tfor (optionName in newOptionHash) {\n\t\t\tt.dynamicOverrides[optionName] = newOptionHash[optionName];\n\t\t}\n\n\t\tt.viewSpecCache = {}; // the dynamic override invalidates the options in this cache, so just clear it\n\t\tt.populateOptionsHash(); // this.options needs to be recomputed after the dynamic override\n\n\t\t// trigger handlers after this.options has been updated\n\t\tfor (optionName in newOptionHash) {\n\t\t\tt.triggerOptionHandlers(optionName); // recall bindOption/bindOptions\n\t\t\toptionCnt++;\n\t\t}\n\n\t\t// special-case handling of single option change.\n\t\t// if only one option change, `optionName` will be its name.\n\t\tif (optionCnt === 1) {\n\t\t\tif (optionName === 'height' || optionName === 'contentHeight' || optionName === 'aspectRatio') {\n\t\t\t\tupdateSize(true); // true = allow recalculation of height\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if (optionName === 'defaultDate') {\n\t\t\t\treturn; // can't change date this way. use gotoDate instead\n\t\t\t}\n\t\t\telse if (optionName === 'businessHours') {\n\t\t\t\tif (currentView) {\n\t\t\t\t\tcurrentView.unrenderBusinessHours();\n\t\t\t\t\tcurrentView.renderBusinessHours();\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if (optionName === 'timezone') {\n\t\t\t\tt.rezoneArrayEventSources();\n\t\t\t\trefetchEvents();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// catch-all. rerender the header and rebuild/rerender the current view\n\t\trenderHeader();\n\t\tviewsByType = {}; // even non-current views will be affected by this option change. do before rerender\n\t\treinitView();\n\t}\n\t\n\t\n\tfunction trigger(name, thisObj) { // overrides the Emitter's trigger method :(\n\t\tvar args = Array.prototype.slice.call(arguments, 2);\n\n\t\tthisObj = thisObj || _element;\n\t\tthis.triggerWith(name, thisObj, args); // Emitter's method\n\n\t\tif (t.options[name]) {\n\t\t\treturn t.options[name].apply(thisObj, args);\n\t\t}\n\t}\n\n\tt.initialize();\n}\n\n;;\n/*\nOptions binding/triggering system.\n*/\nCalendar.mixin({\n\n\t// A map of option names to arrays of handler objects. Initialized to {} in Calendar.\n\t// Format for a handler object:\n\t// {\n\t//   func // callback function to be called upon change\n\t//   names // option names whose values should be given to func\n\t// }\n\toptionHandlers: null, \n\n\t// Calls handlerFunc immediately, and when the given option has changed.\n\t// handlerFunc will be given the option value.\n\tbindOption: function(optionName, handlerFunc) {\n\t\tthis.bindOptions([ optionName ], handlerFunc);\n\t},\n\n\t// Calls handlerFunc immediately, and when any of the given options change.\n\t// handlerFunc will be given each option value as ordered function arguments.\n\tbindOptions: function(optionNames, handlerFunc) {\n\t\tvar handlerObj = { func: handlerFunc, names: optionNames };\n\t\tvar i;\n\n\t\tfor (i = 0; i < optionNames.length; i++) {\n\t\t\tthis.registerOptionHandlerObj(optionNames[i], handlerObj);\n\t\t}\n\n\t\tthis.triggerOptionHandlerObj(handlerObj);\n\t},\n\n\t// Puts the given handler object into the internal hash\n\tregisterOptionHandlerObj: function(optionName, handlerObj) {\n\t\t(this.optionHandlers[optionName] || (this.optionHandlers[optionName] = []))\n\t\t\t.push(handlerObj);\n\t},\n\n\t// Reports that the given option has changed, and calls all appropriate handlers.\n\ttriggerOptionHandlers: function(optionName) {\n\t\tvar handlerObjs = this.optionHandlers[optionName] || [];\n\t\tvar i;\n\n\t\tfor (i = 0; i < handlerObjs.length; i++) {\n\t\t\tthis.triggerOptionHandlerObj(handlerObjs[i]);\n\t\t}\n\t},\n\n\t// Calls the callback for a specific handler object, passing in the appropriate arguments.\n\ttriggerOptionHandlerObj: function(handlerObj) {\n\t\tvar optionNames = handlerObj.names;\n\t\tvar optionValues = [];\n\t\tvar i;\n\n\t\tfor (i = 0; i < optionNames.length; i++) {\n\t\t\toptionValues.push(this.options[optionNames[i]]);\n\t\t}\n\n\t\thandlerObj.func.apply(this, optionValues); // maintain the Calendar's `this` context\n\t}\n\n});\n\n;;\n\nCalendar.defaults = {\n\n\ttitleRangeSeparator: ' \\u2013 ', // en dash\n\tmonthYearFormat: 'MMMM YYYY', // required for en. other locales rely on datepicker computable option\n\n\tdefaultTimedEventDuration: '02:00:00',\n\tdefaultAllDayEventDuration: { days: 1 },\n\tforceEventDuration: false,\n\tnextDayThreshold: '09:00:00', // 9am\n\n\t// display\n\tdefaultView: 'month',\n\taspectRatio: 1.35,\n\theader: {\n\t\tleft: 'title',\n\t\tcenter: '',\n\t\tright: 'today prev,next'\n\t},\n\tweekends: true,\n\tweekNumbers: false,\n\n\tweekNumberTitle: 'W',\n\tweekNumberCalculation: 'local',\n\t\n\t//editable: false,\n\n\t//nowIndicator: false,\n\n\tscrollTime: '06:00:00',\n\t\n\t// event ajax\n\tlazyFetching: true,\n\tstartParam: 'start',\n\tendParam: 'end',\n\ttimezoneParam: 'timezone',\n\n\ttimezone: false,\n\n\t//allDayDefault: undefined,\n\n\t// locale\n\tisRTL: false,\n\tbuttonText: {\n\t\tprev: \"prev\",\n\t\tnext: \"next\",\n\t\tprevYear: \"prev year\",\n\t\tnextYear: \"next year\",\n\t\tyear: 'year', // TODO: locale files need to specify this\n\t\ttoday: 'today',\n\t\tmonth: 'month',\n\t\tweek: 'week',\n\t\tday: 'day'\n\t},\n\n\tbuttonIcons: {\n\t\tprev: 'left-single-arrow',\n\t\tnext: 'right-single-arrow',\n\t\tprevYear: 'left-double-arrow',\n\t\tnextYear: 'right-double-arrow'\n\t},\n\n\tallDayText: 'all-day',\n\t\n\t// jquery-ui theming\n\ttheme: false,\n\tthemeButtonIcons: {\n\t\tprev: 'circle-triangle-w',\n\t\tnext: 'circle-triangle-e',\n\t\tprevYear: 'seek-prev',\n\t\tnextYear: 'seek-next'\n\t},\n\n\t//eventResizableFromStart: false,\n\tdragOpacity: .75,\n\tdragRevertDuration: 500,\n\tdragScroll: true,\n\t\n\t//selectable: false,\n\tunselectAuto: true,\n\t\n\tdropAccept: '*',\n\n\teventOrder: 'title',\n\n\teventLimit: false,\n\teventLimitText: 'more',\n\teventLimitClick: 'popover',\n\tdayPopoverFormat: 'LL',\n\t\n\thandleWindowResize: true,\n\twindowResizeDelay: 100, // milliseconds before an updateSize happens\n\n\tlongPressDelay: 1000\n\t\n};\n\n\nCalendar.englishDefaults = { // used by locale.js\n\tdayPopoverFormat: 'dddd, MMMM D'\n};\n\n\nCalendar.rtlDefaults = { // right-to-left defaults\n\theader: { // TODO: smarter solution (first/center/last ?)\n\t\tleft: 'next,prev today',\n\t\tcenter: '',\n\t\tright: 'title'\n\t},\n\tbuttonIcons: {\n\t\tprev: 'right-single-arrow',\n\t\tnext: 'left-single-arrow',\n\t\tprevYear: 'right-double-arrow',\n\t\tnextYear: 'left-double-arrow'\n\t},\n\tthemeButtonIcons: {\n\t\tprev: 'circle-triangle-e',\n\t\tnext: 'circle-triangle-w',\n\t\tnextYear: 'seek-prev',\n\t\tprevYear: 'seek-next'\n\t}\n};\n\n;;\n\nvar localeOptionHash = FC.locales = {}; // initialize and expose\n\n\n// TODO: document the structure and ordering of a FullCalendar locale file\n\n\n// Initialize jQuery UI datepicker translations while using some of the translations\n// Will set this as the default locales for datepicker.\nFC.datepickerLocale = function(localeCode, dpLocaleCode, dpOptions) {\n\n\t// get the FullCalendar internal option hash for this locale. create if necessary\n\tvar fcOptions = localeOptionHash[localeCode] || (localeOptionHash[localeCode] = {});\n\n\t// transfer some simple options from datepicker to fc\n\tfcOptions.isRTL = dpOptions.isRTL;\n\tfcOptions.weekNumberTitle = dpOptions.weekHeader;\n\n\t// compute some more complex options from datepicker\n\t$.each(dpComputableOptions, function(name, func) {\n\t\tfcOptions[name] = func(dpOptions);\n\t});\n\n\t// is jQuery UI Datepicker is on the page?\n\tif ($.datepicker) {\n\n\t\t// Register the locale data.\n\t\t// FullCalendar and MomentJS use locale codes like \"pt-br\" but Datepicker\n\t\t// does it like \"pt-BR\" or if it doesn't have the locale, maybe just \"pt\".\n\t\t// Make an alias so the locale can be referenced either way.\n\t\t$.datepicker.regional[dpLocaleCode] =\n\t\t\t$.datepicker.regional[localeCode] = // alias\n\t\t\t\tdpOptions;\n\n\t\t// Alias 'en' to the default locale data. Do this every time.\n\t\t$.datepicker.regional.en = $.datepicker.regional[''];\n\n\t\t// Set as Datepicker's global defaults.\n\t\t$.datepicker.setDefaults(dpOptions);\n\t}\n};\n\n\n// Sets FullCalendar-specific translations. Will set the locales as the global default.\nFC.locale = function(localeCode, newFcOptions) {\n\tvar fcOptions;\n\tvar momOptions;\n\n\t// get the FullCalendar internal option hash for this locale. create if necessary\n\tfcOptions = localeOptionHash[localeCode] || (localeOptionHash[localeCode] = {});\n\n\t// provided new options for this locales? merge them in\n\tif (newFcOptions) {\n\t\tfcOptions = localeOptionHash[localeCode] = mergeOptions([ fcOptions, newFcOptions ]);\n\t}\n\n\t// compute locale options that weren't defined.\n\t// always do this. newFcOptions can be undefined when initializing from i18n file,\n\t// so no way to tell if this is an initialization or a default-setting.\n\tmomOptions = getMomentLocaleData(localeCode); // will fall back to en\n\t$.each(momComputableOptions, function(name, func) {\n\t\tif (fcOptions[name] == null) {\n\t\t\tfcOptions[name] = func(momOptions, fcOptions);\n\t\t}\n\t});\n\n\t// set it as the default locale for FullCalendar\n\tCalendar.defaults.locale = localeCode;\n};\n\n\n// NOTE: can't guarantee any of these computations will run because not every locale has datepicker\n// configs, so make sure there are English fallbacks for these in the defaults file.\nvar dpComputableOptions = {\n\n\tbuttonText: function(dpOptions) {\n\t\treturn {\n\t\t\t// the translations sometimes wrongly contain HTML entities\n\t\t\tprev: stripHtmlEntities(dpOptions.prevText),\n\t\t\tnext: stripHtmlEntities(dpOptions.nextText),\n\t\t\ttoday: stripHtmlEntities(dpOptions.currentText)\n\t\t};\n\t},\n\n\t// Produces format strings like \"MMMM YYYY\" -> \"September 2014\"\n\tmonthYearFormat: function(dpOptions) {\n\t\treturn dpOptions.showMonthAfterYear ?\n\t\t\t'YYYY[' + dpOptions.yearSuffix + '] MMMM' :\n\t\t\t'MMMM YYYY[' + dpOptions.yearSuffix + ']';\n\t}\n\n};\n\nvar momComputableOptions = {\n\n\t// Produces format strings like \"ddd M/D\" -> \"Fri 9/15\"\n\tdayOfMonthFormat: function(momOptions, fcOptions) {\n\t\tvar format = momOptions.longDateFormat('l'); // for the format like \"M/D/YYYY\"\n\n\t\t// strip the year off the edge, as well as other misc non-whitespace chars\n\t\tformat = format.replace(/^Y+[^\\w\\s]*|[^\\w\\s]*Y+$/g, '');\n\n\t\tif (fcOptions.isRTL) {\n\t\t\tformat += ' ddd'; // for RTL, add day-of-week to end\n\t\t}\n\t\telse {\n\t\t\tformat = 'ddd ' + format; // for LTR, add day-of-week to beginning\n\t\t}\n\t\treturn format;\n\t},\n\n\t// Produces format strings like \"h:mma\" -> \"6:00pm\"\n\tmediumTimeFormat: function(momOptions) { // can't be called `timeFormat` because collides with option\n\t\treturn momOptions.longDateFormat('LT')\n\t\t\t.replace(/\\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand\n\t},\n\n\t// Produces format strings like \"h(:mm)a\" -> \"6pm\" / \"6:30pm\"\n\tsmallTimeFormat: function(momOptions) {\n\t\treturn momOptions.longDateFormat('LT')\n\t\t\t.replace(':mm', '(:mm)')\n\t\t\t.replace(/(\\Wmm)$/, '($1)') // like above, but for foreign locales\n\t\t\t.replace(/\\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand\n\t},\n\n\t// Produces format strings like \"h(:mm)t\" -> \"6p\" / \"6:30p\"\n\textraSmallTimeFormat: function(momOptions) {\n\t\treturn momOptions.longDateFormat('LT')\n\t\t\t.replace(':mm', '(:mm)')\n\t\t\t.replace(/(\\Wmm)$/, '($1)') // like above, but for foreign locales\n\t\t\t.replace(/\\s*a$/i, 't'); // convert to AM/PM/am/pm to lowercase one-letter. remove any spaces beforehand\n\t},\n\n\t// Produces format strings like \"ha\" / \"H\" -> \"6pm\" / \"18\"\n\thourFormat: function(momOptions) {\n\t\treturn momOptions.longDateFormat('LT')\n\t\t\t.replace(':mm', '')\n\t\t\t.replace(/(\\Wmm)$/, '') // like above, but for foreign locales\n\t\t\t.replace(/\\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand\n\t},\n\n\t// Produces format strings like \"h:mm\" -> \"6:30\" (with no AM/PM)\n\tnoMeridiemTimeFormat: function(momOptions) {\n\t\treturn momOptions.longDateFormat('LT')\n\t\t\t.replace(/\\s*a$/i, ''); // remove trailing AM/PM\n\t}\n\n};\n\n\n// options that should be computed off live calendar options (considers override options)\n// TODO: best place for this? related to locale?\n// TODO: flipping text based on isRTL is a bad idea because the CSS `direction` might want to handle it\nvar instanceComputableOptions = {\n\n\t// Produces format strings for results like \"Mo 16\"\n\tsmallDayDateFormat: function(options) {\n\t\treturn options.isRTL ?\n\t\t\t'D dd' :\n\t\t\t'dd D';\n\t},\n\n\t// Produces format strings for results like \"Wk 5\"\n\tweekFormat: function(options) {\n\t\treturn options.isRTL ?\n\t\t\t'w[ ' + options.weekNumberTitle + ']' :\n\t\t\t'[' + options.weekNumberTitle + ' ]w';\n\t},\n\n\t// Produces format strings for results like \"Wk5\"\n\tsmallWeekFormat: function(options) {\n\t\treturn options.isRTL ?\n\t\t\t'w[' + options.weekNumberTitle + ']' :\n\t\t\t'[' + options.weekNumberTitle + ']w';\n\t}\n\n};\n\nfunction populateInstanceComputableOptions(options) {\n\t$.each(instanceComputableOptions, function(name, func) {\n\t\tif (options[name] == null) {\n\t\t\toptions[name] = func(options);\n\t\t}\n\t});\n}\n\n\n// Returns moment's internal locale data. If doesn't exist, returns English.\nfunction getMomentLocaleData(localeCode) {\n\treturn moment.localeData(localeCode) || moment.localeData('en');\n}\n\n\n// Initialize English by forcing computation of moment-derived options.\n// Also, sets it as the default.\nFC.locale('en', Calendar.englishDefaults);\n\n;;\n\n/* Top toolbar area with buttons and title\n----------------------------------------------------------------------------------------------------------------------*/\n// TODO: rename all header-related things to \"toolbar\"\n\nfunction Header(calendar) {\n\tvar t = this;\n\t\n\t// exports\n\tt.render = render;\n\tt.removeElement = removeElement;\n\tt.updateTitle = updateTitle;\n\tt.activateButton = activateButton;\n\tt.deactivateButton = deactivateButton;\n\tt.disableButton = disableButton;\n\tt.enableButton = enableButton;\n\tt.getViewsWithButtons = getViewsWithButtons;\n\tt.el = null; // mirrors local `el`\n\t\n\t// locals\n\tvar el;\n\tvar viewsWithButtons = [];\n\tvar tm;\n\n\n\t// can be called repeatedly and will rerender\n\tfunction render() {\n\t\tvar options = calendar.options;\n\t\tvar sections = options.header;\n\n\t\ttm = options.theme ? 'ui' : 'fc';\n\n\t\tif (sections) {\n\t\t\tif (!el) {\n\t\t\t\tel = this.el = $(\"<div class='fc-toolbar'/>\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tel.empty();\n\t\t\t}\n\t\t\tel.append(renderSection('left'))\n\t\t\t\t.append(renderSection('right'))\n\t\t\t\t.append(renderSection('center'))\n\t\t\t\t.append('<div class=\"fc-clear\"/>');\n\t\t}\n\t\telse {\n\t\t\tremoveElement();\n\t\t}\n\t}\n\t\n\t\n\tfunction removeElement() {\n\t\tif (el) {\n\t\t\tel.remove();\n\t\t\tel = t.el = null;\n\t\t}\n\t}\n\t\n\t\n\tfunction renderSection(position) {\n\t\tvar sectionEl = $('<div class=\"fc-' + position + '\"/>');\n\t\tvar options = calendar.options;\n\t\tvar buttonStr = options.header[position];\n\n\t\tif (buttonStr) {\n\t\t\t$.each(buttonStr.split(' '), function(i) {\n\t\t\t\tvar groupChildren = $();\n\t\t\t\tvar isOnlyButtons = true;\n\t\t\t\tvar groupEl;\n\n\t\t\t\t$.each(this.split(','), function(j, buttonName) {\n\t\t\t\t\tvar customButtonProps;\n\t\t\t\t\tvar viewSpec;\n\t\t\t\t\tvar buttonClick;\n\t\t\t\t\tvar overrideText; // text explicitly set by calendar's constructor options. overcomes icons\n\t\t\t\t\tvar defaultText;\n\t\t\t\t\tvar themeIcon;\n\t\t\t\t\tvar normalIcon;\n\t\t\t\t\tvar innerHtml;\n\t\t\t\t\tvar classes;\n\t\t\t\t\tvar button; // the element\n\n\t\t\t\t\tif (buttonName == 'title') {\n\t\t\t\t\t\tgroupChildren = groupChildren.add($('<h2>&nbsp;</h2>')); // we always want it to take up height\n\t\t\t\t\t\tisOnlyButtons = false;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif ((customButtonProps = (options.customButtons || {})[buttonName])) {\n\t\t\t\t\t\t\tbuttonClick = function(ev) {\n\t\t\t\t\t\t\t\tif (customButtonProps.click) {\n\t\t\t\t\t\t\t\t\tcustomButtonProps.click.call(button[0], ev);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\toverrideText = ''; // icons will override text\n\t\t\t\t\t\t\tdefaultText = customButtonProps.text;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ((viewSpec = calendar.getViewSpec(buttonName))) {\n\t\t\t\t\t\t\tbuttonClick = function() {\n\t\t\t\t\t\t\t\tcalendar.changeView(buttonName);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tviewsWithButtons.push(buttonName);\n\t\t\t\t\t\t\toverrideText = viewSpec.buttonTextOverride;\n\t\t\t\t\t\t\tdefaultText = viewSpec.buttonTextDefault;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (calendar[buttonName]) { // a calendar method\n\t\t\t\t\t\t\tbuttonClick = function() {\n\t\t\t\t\t\t\t\tcalendar[buttonName]();\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\toverrideText = (calendar.overrides.buttonText || {})[buttonName];\n\t\t\t\t\t\t\tdefaultText = options.buttonText[buttonName]; // everything else is considered default\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (buttonClick) {\n\n\t\t\t\t\t\t\tthemeIcon =\n\t\t\t\t\t\t\t\tcustomButtonProps ?\n\t\t\t\t\t\t\t\t\tcustomButtonProps.themeIcon :\n\t\t\t\t\t\t\t\t\toptions.themeButtonIcons[buttonName];\n\n\t\t\t\t\t\t\tnormalIcon =\n\t\t\t\t\t\t\t\tcustomButtonProps ?\n\t\t\t\t\t\t\t\t\tcustomButtonProps.icon :\n\t\t\t\t\t\t\t\t\toptions.buttonIcons[buttonName];\n\n\t\t\t\t\t\t\tif (overrideText) {\n\t\t\t\t\t\t\t\tinnerHtml = htmlEscape(overrideText);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (themeIcon && options.theme) {\n\t\t\t\t\t\t\t\tinnerHtml = \"<span class='ui-icon ui-icon-\" + themeIcon + \"'></span>\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (normalIcon && !options.theme) {\n\t\t\t\t\t\t\t\tinnerHtml = \"<span class='fc-icon fc-icon-\" + normalIcon + \"'></span>\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tinnerHtml = htmlEscape(defaultText);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tclasses = [\n\t\t\t\t\t\t\t\t'fc-' + buttonName + '-button',\n\t\t\t\t\t\t\t\ttm + '-button',\n\t\t\t\t\t\t\t\ttm + '-state-default'\n\t\t\t\t\t\t\t];\n\n\t\t\t\t\t\t\tbutton = $( // type=\"button\" so that it doesn't submit a form\n\t\t\t\t\t\t\t\t'<button type=\"button\" class=\"' + classes.join(' ') + '\">' +\n\t\t\t\t\t\t\t\t\tinnerHtml +\n\t\t\t\t\t\t\t\t'</button>'\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t.click(function(ev) {\n\t\t\t\t\t\t\t\t\t// don't process clicks for disabled buttons\n\t\t\t\t\t\t\t\t\tif (!button.hasClass(tm + '-state-disabled')) {\n\n\t\t\t\t\t\t\t\t\t\tbuttonClick(ev);\n\n\t\t\t\t\t\t\t\t\t\t// after the click action, if the button becomes the \"active\" tab, or disabled,\n\t\t\t\t\t\t\t\t\t\t// it should never have a hover class, so remove it now.\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\tbutton.hasClass(tm + '-state-active') ||\n\t\t\t\t\t\t\t\t\t\t\tbutton.hasClass(tm + '-state-disabled')\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tbutton.removeClass(tm + '-state-hover');\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t.mousedown(function() {\n\t\t\t\t\t\t\t\t\t// the *down* effect (mouse pressed in).\n\t\t\t\t\t\t\t\t\t// only on buttons that are not the \"active\" tab, or disabled\n\t\t\t\t\t\t\t\t\tbutton\n\t\t\t\t\t\t\t\t\t\t.not('.' + tm + '-state-active')\n\t\t\t\t\t\t\t\t\t\t.not('.' + tm + '-state-disabled')\n\t\t\t\t\t\t\t\t\t\t.addClass(tm + '-state-down');\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t.mouseup(function() {\n\t\t\t\t\t\t\t\t\t// undo the *down* effect\n\t\t\t\t\t\t\t\t\tbutton.removeClass(tm + '-state-down');\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t.hover(\n\t\t\t\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t\t\t\t// the *hover* effect.\n\t\t\t\t\t\t\t\t\t\t// only on buttons that are not the \"active\" tab, or disabled\n\t\t\t\t\t\t\t\t\t\tbutton\n\t\t\t\t\t\t\t\t\t\t\t.not('.' + tm + '-state-active')\n\t\t\t\t\t\t\t\t\t\t\t.not('.' + tm + '-state-disabled')\n\t\t\t\t\t\t\t\t\t\t\t.addClass(tm + '-state-hover');\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t\t\t\t// undo the *hover* effect\n\t\t\t\t\t\t\t\t\t\tbutton\n\t\t\t\t\t\t\t\t\t\t\t.removeClass(tm + '-state-hover')\n\t\t\t\t\t\t\t\t\t\t\t.removeClass(tm + '-state-down'); // if mouseleave happens before mouseup\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tgroupChildren = groupChildren.add(button);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif (isOnlyButtons) {\n\t\t\t\t\tgroupChildren\n\t\t\t\t\t\t.first().addClass(tm + '-corner-left').end()\n\t\t\t\t\t\t.last().addClass(tm + '-corner-right').end();\n\t\t\t\t}\n\n\t\t\t\tif (groupChildren.length > 1) {\n\t\t\t\t\tgroupEl = $('<div/>');\n\t\t\t\t\tif (isOnlyButtons) {\n\t\t\t\t\t\tgroupEl.addClass('fc-button-group');\n\t\t\t\t\t}\n\t\t\t\t\tgroupEl.append(groupChildren);\n\t\t\t\t\tsectionEl.append(groupEl);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsectionEl.append(groupChildren); // 1 or 0 children\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn sectionEl;\n\t}\n\t\n\t\n\tfunction updateTitle(text) {\n\t\tif (el) {\n\t\t\tel.find('h2').text(text);\n\t\t}\n\t}\n\t\n\t\n\tfunction activateButton(buttonName) {\n\t\tif (el) {\n\t\t\tel.find('.fc-' + buttonName + '-button')\n\t\t\t\t.addClass(tm + '-state-active');\n\t\t}\n\t}\n\t\n\t\n\tfunction deactivateButton(buttonName) {\n\t\tif (el) {\n\t\t\tel.find('.fc-' + buttonName + '-button')\n\t\t\t\t.removeClass(tm + '-state-active');\n\t\t}\n\t}\n\t\n\t\n\tfunction disableButton(buttonName) {\n\t\tif (el) {\n\t\t\tel.find('.fc-' + buttonName + '-button')\n\t\t\t\t.prop('disabled', true)\n\t\t\t\t.addClass(tm + '-state-disabled');\n\t\t}\n\t}\n\t\n\t\n\tfunction enableButton(buttonName) {\n\t\tif (el) {\n\t\t\tel.find('.fc-' + buttonName + '-button')\n\t\t\t\t.prop('disabled', false)\n\t\t\t\t.removeClass(tm + '-state-disabled');\n\t\t}\n\t}\n\n\n\tfunction getViewsWithButtons() {\n\t\treturn viewsWithButtons;\n\t}\n\n}\n\n;;\n\nFC.sourceNormalizers = [];\nFC.sourceFetchers = [];\n\nvar ajaxDefaults = {\n\tdataType: 'json',\n\tcache: false\n};\n\nvar eventGUID = 1;\n\n\nfunction EventManager() { // assumed to be a calendar\n\tvar t = this;\n\t\n\t\n\t// exports\n\tt.isFetchNeeded = isFetchNeeded;\n\tt.fetchEvents = fetchEvents;\n\tt.fetchEventSources = fetchEventSources;\n\tt.getEventSources = getEventSources;\n\tt.getEventSourceById = getEventSourceById;\n\tt.getEventSourcesByMatchArray = getEventSourcesByMatchArray;\n\tt.getEventSourcesByMatch = getEventSourcesByMatch;\n\tt.addEventSource = addEventSource;\n\tt.removeEventSource = removeEventSource;\n\tt.removeEventSources = removeEventSources;\n\tt.updateEvent = updateEvent;\n\tt.renderEvent = renderEvent;\n\tt.removeEvents = removeEvents;\n\tt.clientEvents = clientEvents;\n\tt.mutateEvent = mutateEvent;\n\tt.normalizeEventDates = normalizeEventDates;\n\tt.normalizeEventTimes = normalizeEventTimes;\n\t\n\t\n\t// imports\n\tvar reportEvents = t.reportEvents;\n\t\n\t\n\t// locals\n\tvar stickySource = { events: [] };\n\tvar sources = [ stickySource ];\n\tvar rangeStart, rangeEnd;\n\tvar pendingSourceCnt = 0; // outstanding fetch requests, max one per source\n\tvar cache = []; // holds events that have already been expanded\n\n\n\t$.each(\n\t\t(t.options.events ? [ t.options.events ] : []).concat(t.options.eventSources || []),\n\t\tfunction(i, sourceInput) {\n\t\t\tvar source = buildEventSource(sourceInput);\n\t\t\tif (source) {\n\t\t\t\tsources.push(source);\n\t\t\t}\n\t\t}\n\t);\n\t\n\t\n\t\n\t/* Fetching\n\t-----------------------------------------------------------------------------*/\n\n\n\t// start and end are assumed to be unzoned\n\tfunction isFetchNeeded(start, end) {\n\t\treturn !rangeStart || // nothing has been fetched yet?\n\t\t\tstart < rangeStart || end > rangeEnd; // is part of the new range outside of the old range?\n\t}\n\t\n\t\n\tfunction fetchEvents(start, end) {\n\t\trangeStart = start;\n\t\trangeEnd = end;\n\t\tfetchEventSources(sources, 'reset');\n\t}\n\n\n\t// expects an array of event source objects (the originals, not copies)\n\t// `specialFetchType` is an optimization parameter that affects purging of the event cache.\n\tfunction fetchEventSources(specificSources, specialFetchType) {\n\t\tvar i, source;\n\n\t\tif (specialFetchType === 'reset') {\n\t\t\tcache = [];\n\t\t}\n\t\telse if (specialFetchType !== 'add') {\n\t\t\tcache = excludeEventsBySources(cache, specificSources);\n\t\t}\n\n\t\tfor (i = 0; i < specificSources.length; i++) {\n\t\t\tsource = specificSources[i];\n\n\t\t\t// already-pending sources have already been accounted for in pendingSourceCnt\n\t\t\tif (source._status !== 'pending') {\n\t\t\t\tpendingSourceCnt++;\n\t\t\t}\n\n\t\t\tsource._fetchId = (source._fetchId || 0) + 1;\n\t\t\tsource._status = 'pending';\n\t\t}\n\n\t\tfor (i = 0; i < specificSources.length; i++) {\n\t\t\tsource = specificSources[i];\n\n\t\t\ttryFetchEventSource(source, source._fetchId);\n\t\t}\n\t}\n\n\n\t// fetches an event source and processes its result ONLY if it is still the current fetch.\n\t// caller is responsible for incrementing pendingSourceCnt first.\n\tfunction tryFetchEventSource(source, fetchId) {\n\t\t_fetchEventSource(source, function(eventInputs) {\n\t\t\tvar isArraySource = $.isArray(source.events);\n\t\t\tvar i, eventInput;\n\t\t\tvar abstractEvent;\n\n\t\t\tif (\n\t\t\t\t// is this the source's most recent fetch?\n\t\t\t\t// if not, rely on an upcoming fetch of this source to decrement pendingSourceCnt\n\t\t\t\tfetchId === source._fetchId &&\n\t\t\t\t// event source no longer valid?\n\t\t\t\tsource._status !== 'rejected'\n\t\t\t) {\n\t\t\t\tsource._status = 'resolved';\n\n\t\t\t\tif (eventInputs) {\n\t\t\t\t\tfor (i = 0; i < eventInputs.length; i++) {\n\t\t\t\t\t\teventInput = eventInputs[i];\n\n\t\t\t\t\t\tif (isArraySource) { // array sources have already been convert to Event Objects\n\t\t\t\t\t\t\tabstractEvent = eventInput;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tabstractEvent = buildEventFromInput(eventInput, source);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (abstractEvent) { // not false (an invalid event)\n\t\t\t\t\t\t\tcache.push.apply(\n\t\t\t\t\t\t\t\tcache,\n\t\t\t\t\t\t\t\texpandEvent(abstractEvent) // add individual expanded events to the cache\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdecrementPendingSourceCnt();\n\t\t\t}\n\t\t});\n\t}\n\n\n\tfunction rejectEventSource(source) {\n\t\tvar wasPending = source._status === 'pending';\n\n\t\tsource._status = 'rejected';\n\n\t\tif (wasPending) {\n\t\t\tdecrementPendingSourceCnt();\n\t\t}\n\t}\n\n\n\tfunction decrementPendingSourceCnt() {\n\t\tpendingSourceCnt--;\n\t\tif (!pendingSourceCnt) {\n\t\t\treportEvents(cache);\n\t\t}\n\t}\n\t\n\t\n\tfunction _fetchEventSource(source, callback) {\n\t\tvar i;\n\t\tvar fetchers = FC.sourceFetchers;\n\t\tvar res;\n\n\t\tfor (i=0; i<fetchers.length; i++) {\n\t\t\tres = fetchers[i].call(\n\t\t\t\tt, // this, the Calendar object\n\t\t\t\tsource,\n\t\t\t\trangeStart.clone(),\n\t\t\t\trangeEnd.clone(),\n\t\t\t\tt.options.timezone,\n\t\t\t\tcallback\n\t\t\t);\n\n\t\t\tif (res === true) {\n\t\t\t\t// the fetcher is in charge. made its own async request\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if (typeof res == 'object') {\n\t\t\t\t// the fetcher returned a new source. process it\n\t\t\t\t_fetchEventSource(res, callback);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tvar events = source.events;\n\t\tif (events) {\n\t\t\tif ($.isFunction(events)) {\n\t\t\t\tt.pushLoading();\n\t\t\t\tevents.call(\n\t\t\t\t\tt, // this, the Calendar object\n\t\t\t\t\trangeStart.clone(),\n\t\t\t\t\trangeEnd.clone(),\n\t\t\t\t\tt.options.timezone,\n\t\t\t\t\tfunction(events) {\n\t\t\t\t\t\tcallback(events);\n\t\t\t\t\t\tt.popLoading();\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t\telse if ($.isArray(events)) {\n\t\t\t\tcallback(events);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcallback();\n\t\t\t}\n\t\t}else{\n\t\t\tvar url = source.url;\n\t\t\tif (url) {\n\t\t\t\tvar success = source.success;\n\t\t\t\tvar error = source.error;\n\t\t\t\tvar complete = source.complete;\n\n\t\t\t\t// retrieve any outbound GET/POST $.ajax data from the options\n\t\t\t\tvar customData;\n\t\t\t\tif ($.isFunction(source.data)) {\n\t\t\t\t\t// supplied as a function that returns a key/value object\n\t\t\t\t\tcustomData = source.data();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// supplied as a straight key/value object\n\t\t\t\t\tcustomData = source.data;\n\t\t\t\t}\n\n\t\t\t\t// use a copy of the custom data so we can modify the parameters\n\t\t\t\t// and not affect the passed-in object.\n\t\t\t\tvar data = $.extend({}, customData || {});\n\n\t\t\t\tvar startParam = firstDefined(source.startParam, t.options.startParam);\n\t\t\t\tvar endParam = firstDefined(source.endParam, t.options.endParam);\n\t\t\t\tvar timezoneParam = firstDefined(source.timezoneParam, t.options.timezoneParam);\n\n\t\t\t\tif (startParam) {\n\t\t\t\t\tdata[startParam] = rangeStart.format();\n\t\t\t\t}\n\t\t\t\tif (endParam) {\n\t\t\t\t\tdata[endParam] = rangeEnd.format();\n\t\t\t\t}\n\t\t\t\tif (t.options.timezone && t.options.timezone != 'local') {\n\t\t\t\t\tdata[timezoneParam] = t.options.timezone;\n\t\t\t\t}\n\n\t\t\t\tt.pushLoading();\n\t\t\t\t$.ajax($.extend({}, ajaxDefaults, source, {\n\t\t\t\t\tdata: data,\n\t\t\t\t\tsuccess: function(events) {\n\t\t\t\t\t\tevents = events || [];\n\t\t\t\t\t\tvar res = applyAll(success, this, arguments);\n\t\t\t\t\t\tif ($.isArray(res)) {\n\t\t\t\t\t\t\tevents = res;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcallback(events);\n\t\t\t\t\t},\n\t\t\t\t\terror: function() {\n\t\t\t\t\t\tapplyAll(error, this, arguments);\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t},\n\t\t\t\t\tcomplete: function() {\n\t\t\t\t\t\tapplyAll(complete, this, arguments);\n\t\t\t\t\t\tt.popLoading();\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t}else{\n\t\t\t\tcallback();\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t\n\t/* Sources\n\t-----------------------------------------------------------------------------*/\n\n\n\tfunction addEventSource(sourceInput) {\n\t\tvar source = buildEventSource(sourceInput);\n\t\tif (source) {\n\t\t\tsources.push(source);\n\t\t\tfetchEventSources([ source ], 'add'); // will eventually call reportEvents\n\t\t}\n\t}\n\n\n\tfunction buildEventSource(sourceInput) { // will return undefined if invalid source\n\t\tvar normalizers = FC.sourceNormalizers;\n\t\tvar source;\n\t\tvar i;\n\n\t\tif ($.isFunction(sourceInput) || $.isArray(sourceInput)) {\n\t\t\tsource = { events: sourceInput };\n\t\t}\n\t\telse if (typeof sourceInput === 'string') {\n\t\t\tsource = { url: sourceInput };\n\t\t}\n\t\telse if (typeof sourceInput === 'object') {\n\t\t\tsource = $.extend({}, sourceInput); // shallow copy\n\t\t}\n\n\t\tif (source) {\n\n\t\t\t// TODO: repeat code, same code for event classNames\n\t\t\tif (source.className) {\n\t\t\t\tif (typeof source.className === 'string') {\n\t\t\t\t\tsource.className = source.className.split(/\\s+/);\n\t\t\t\t}\n\t\t\t\t// otherwise, assumed to be an array\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsource.className = [];\n\t\t\t}\n\n\t\t\t// for array sources, we convert to standard Event Objects up front\n\t\t\tif ($.isArray(source.events)) {\n\t\t\t\tsource.origArray = source.events; // for removeEventSource\n\t\t\t\tsource.events = $.map(source.events, function(eventInput) {\n\t\t\t\t\treturn buildEventFromInput(eventInput, source);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfor (i=0; i<normalizers.length; i++) {\n\t\t\t\tnormalizers[i].call(t, source);\n\t\t\t}\n\n\t\t\treturn source;\n\t\t}\n\t}\n\n\n\tfunction removeEventSource(matchInput) {\n\t\tremoveSpecificEventSources(\n\t\t\tgetEventSourcesByMatch(matchInput)\n\t\t);\n\t}\n\n\n\t// if called with no arguments, removes all.\n\tfunction removeEventSources(matchInputs) {\n\t\tif (matchInputs == null) {\n\t\t\tremoveSpecificEventSources(sources, true); // isAll=true\n\t\t}\n\t\telse {\n\t\t\tremoveSpecificEventSources(\n\t\t\t\tgetEventSourcesByMatchArray(matchInputs)\n\t\t\t);\n\t\t}\n\t}\n\n\n\tfunction removeSpecificEventSources(targetSources, isAll) {\n\t\tvar i;\n\n\t\t// cancel pending requests\n\t\tfor (i = 0; i < targetSources.length; i++) {\n\t\t\trejectEventSource(targetSources[i]);\n\t\t}\n\n\t\tif (isAll) { // an optimization\n\t\t\tsources = [];\n\t\t\tcache = [];\n\t\t}\n\t\telse {\n\t\t\t// remove from persisted source list\n\t\t\tsources = $.grep(sources, function(source) {\n\t\t\t\tfor (i = 0; i < targetSources.length; i++) {\n\t\t\t\t\tif (source === targetSources[i]) {\n\t\t\t\t\t\treturn false; // exclude\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true; // include\n\t\t\t});\n\n\t\t\tcache = excludeEventsBySources(cache, targetSources);\n\t\t}\n\n\t\treportEvents(cache);\n\t}\n\n\n\tfunction getEventSources() {\n\t\treturn sources.slice(1); // returns a shallow copy of sources with stickySource removed\n\t}\n\n\n\tfunction getEventSourceById(id) {\n\t\treturn $.grep(sources, function(source) {\n\t\t\treturn source.id && source.id === id;\n\t\t})[0];\n\t}\n\n\n\t// like getEventSourcesByMatch, but accepts multple match criteria (like multiple IDs)\n\tfunction getEventSourcesByMatchArray(matchInputs) {\n\n\t\t// coerce into an array\n\t\tif (!matchInputs) {\n\t\t\tmatchInputs = [];\n\t\t}\n\t\telse if (!$.isArray(matchInputs)) {\n\t\t\tmatchInputs = [ matchInputs ];\n\t\t}\n\n\t\tvar matchingSources = [];\n\t\tvar i;\n\n\t\t// resolve raw inputs to real event source objects\n\t\tfor (i = 0; i < matchInputs.length; i++) {\n\t\t\tmatchingSources.push.apply( // append\n\t\t\t\tmatchingSources,\n\t\t\t\tgetEventSourcesByMatch(matchInputs[i])\n\t\t\t);\n\t\t}\n\n\t\treturn matchingSources;\n\t}\n\n\n\t// matchInput can either by a real event source object, an ID, or the function/URL for the source.\n\t// returns an array of matching source objects.\n\tfunction getEventSourcesByMatch(matchInput) {\n\t\tvar i, source;\n\n\t\t// given an proper event source object\n\t\tfor (i = 0; i < sources.length; i++) {\n\t\t\tsource = sources[i];\n\t\t\tif (source === matchInput) {\n\t\t\t\treturn [ source ];\n\t\t\t}\n\t\t}\n\n\t\t// an ID match\n\t\tsource = getEventSourceById(matchInput);\n\t\tif (source) {\n\t\t\treturn [ source ];\n\t\t}\n\n\t\treturn $.grep(sources, function(source) {\n\t\t\treturn isSourcesEquivalent(matchInput, source);\n\t\t});\n\t}\n\n\n\tfunction isSourcesEquivalent(source1, source2) {\n\t\treturn source1 && source2 && getSourcePrimitive(source1) == getSourcePrimitive(source2);\n\t}\n\n\n\tfunction getSourcePrimitive(source) {\n\t\treturn (\n\t\t\t(typeof source === 'object') ? // a normalized event source?\n\t\t\t\t(source.origArray || source.googleCalendarId || source.url || source.events) : // get the primitive\n\t\t\t\tnull\n\t\t) ||\n\t\tsource; // the given argument *is* the primitive\n\t}\n\n\n\t// util\n\t// returns a filtered array without events that are part of any of the given sources\n\tfunction excludeEventsBySources(specificEvents, specificSources) {\n\t\treturn $.grep(specificEvents, function(event) {\n\t\t\tfor (var i = 0; i < specificSources.length; i++) {\n\t\t\t\tif (event.source === specificSources[i]) {\n\t\t\t\t\treturn false; // exclude\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true; // keep\n\t\t});\n\t}\n\t\n\t\n\t\n\t/* Manipulation\n\t-----------------------------------------------------------------------------*/\n\n\n\t// Only ever called from the externally-facing API\n\tfunction updateEvent(event) {\n\n\t\t// massage start/end values, even if date string values\n\t\tevent.start = t.moment(event.start);\n\t\tif (event.end) {\n\t\t\tevent.end = t.moment(event.end);\n\t\t}\n\t\telse {\n\t\t\tevent.end = null;\n\t\t}\n\n\t\tmutateEvent(event, getMiscEventProps(event)); // will handle start/end/allDay normalization\n\t\treportEvents(cache); // reports event modifications (so we can redraw)\n\t}\n\n\n\t// Returns a hash of misc event properties that should be copied over to related events.\n\tfunction getMiscEventProps(event) {\n\t\tvar props = {};\n\n\t\t$.each(event, function(name, val) {\n\t\t\tif (isMiscEventPropName(name)) {\n\t\t\t\tif (val !== undefined && isAtomic(val)) { // a defined non-object\n\t\t\t\t\tprops[name] = val;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn props;\n\t}\n\n\t// non-date-related, non-id-related, non-secret\n\tfunction isMiscEventPropName(name) {\n\t\treturn !/^_|^(id|allDay|start|end)$/.test(name);\n\t}\n\n\t\n\t// returns the expanded events that were created\n\tfunction renderEvent(eventInput, stick) {\n\t\tvar abstractEvent = buildEventFromInput(eventInput);\n\t\tvar events;\n\t\tvar i, event;\n\n\t\tif (abstractEvent) { // not false (a valid input)\n\t\t\tevents = expandEvent(abstractEvent);\n\n\t\t\tfor (i = 0; i < events.length; i++) {\n\t\t\t\tevent = events[i];\n\n\t\t\t\tif (!event.source) {\n\t\t\t\t\tif (stick) {\n\t\t\t\t\t\tstickySource.events.push(event);\n\t\t\t\t\t\tevent.source = stickySource;\n\t\t\t\t\t}\n\t\t\t\t\tcache.push(event);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treportEvents(cache);\n\n\t\t\treturn events;\n\t\t}\n\n\t\treturn [];\n\t}\n\t\n\t\n\tfunction removeEvents(filter) {\n\t\tvar eventID;\n\t\tvar i;\n\n\t\tif (filter == null) { // null or undefined. remove all events\n\t\t\tfilter = function() { return true; }; // will always match\n\t\t}\n\t\telse if (!$.isFunction(filter)) { // an event ID\n\t\t\teventID = filter + '';\n\t\t\tfilter = function(event) {\n\t\t\t\treturn event._id == eventID;\n\t\t\t};\n\t\t}\n\n\t\t// Purge event(s) from our local cache\n\t\tcache = $.grep(cache, filter, true); // inverse=true\n\n\t\t// Remove events from array sources.\n\t\t// This works because they have been converted to official Event Objects up front.\n\t\t// (and as a result, event._id has been calculated).\n\t\tfor (i=0; i<sources.length; i++) {\n\t\t\tif ($.isArray(sources[i].events)) {\n\t\t\t\tsources[i].events = $.grep(sources[i].events, filter, true);\n\t\t\t}\n\t\t}\n\n\t\treportEvents(cache);\n\t}\n\n\t\n\tfunction clientEvents(filter) {\n\t\tif ($.isFunction(filter)) {\n\t\t\treturn $.grep(cache, filter);\n\t\t}\n\t\telse if (filter != null) { // not null, not undefined. an event ID\n\t\t\tfilter += '';\n\t\t\treturn $.grep(cache, function(e) {\n\t\t\t\treturn e._id == filter;\n\t\t\t});\n\t\t}\n\t\treturn cache; // else, return all\n\t}\n\n\n\t// Makes sure all array event sources have their internal event objects\n\t// converted over to the Calendar's current timezone.\n\tt.rezoneArrayEventSources = function() {\n\t\tvar i;\n\t\tvar events;\n\t\tvar j;\n\n\t\tfor (i = 0; i < sources.length; i++) {\n\t\t\tevents = sources[i].events;\n\t\t\tif ($.isArray(events)) {\n\n\t\t\t\tfor (j = 0; j < events.length; j++) {\n\t\t\t\t\trezoneEventDates(events[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tfunction rezoneEventDates(event) {\n\t\tevent.start = t.moment(event.start);\n\t\tif (event.end) {\n\t\t\tevent.end = t.moment(event.end);\n\t\t}\n\t\tbackupEventDates(event);\n\t}\n\t\n\t\n\t/* Event Normalization\n\t-----------------------------------------------------------------------------*/\n\n\n\t// Given a raw object with key/value properties, returns an \"abstract\" Event object.\n\t// An \"abstract\" event is an event that, if recurring, will not have been expanded yet.\n\t// Will return `false` when input is invalid.\n\t// `source` is optional\n\tfunction buildEventFromInput(input, source) {\n\t\tvar out = {};\n\t\tvar start, end;\n\t\tvar allDay;\n\n\t\tif (t.options.eventDataTransform) {\n\t\t\tinput = t.options.eventDataTransform(input);\n\t\t}\n\t\tif (source && source.eventDataTransform) {\n\t\t\tinput = source.eventDataTransform(input);\n\t\t}\n\n\t\t// Copy all properties over to the resulting object.\n\t\t// The special-case properties will be copied over afterwards.\n\t\t$.extend(out, input);\n\n\t\tif (source) {\n\t\t\tout.source = source;\n\t\t}\n\n\t\tout._id = input._id || (input.id === undefined ? '_fc' + eventGUID++ : input.id + '');\n\n\t\tif (input.className) {\n\t\t\tif (typeof input.className == 'string') {\n\t\t\t\tout.className = input.className.split(/\\s+/);\n\t\t\t}\n\t\t\telse { // assumed to be an array\n\t\t\t\tout.className = input.className;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tout.className = [];\n\t\t}\n\n\t\tstart = input.start || input.date; // \"date\" is an alias for \"start\"\n\t\tend = input.end;\n\n\t\t// parse as a time (Duration) if applicable\n\t\tif (isTimeString(start)) {\n\t\t\tstart = moment.duration(start);\n\t\t}\n\t\tif (isTimeString(end)) {\n\t\t\tend = moment.duration(end);\n\t\t}\n\n\t\tif (input.dow || moment.isDuration(start) || moment.isDuration(end)) {\n\n\t\t\t// the event is \"abstract\" (recurring) so don't calculate exact start/end dates just yet\n\t\t\tout.start = start ? moment.duration(start) : null; // will be a Duration or null\n\t\t\tout.end = end ? moment.duration(end) : null; // will be a Duration or null\n\t\t\tout._recurring = true; // our internal marker\n\t\t}\n\t\telse {\n\n\t\t\tif (start) {\n\t\t\t\tstart = t.moment(start);\n\t\t\t\tif (!start.isValid()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (end) {\n\t\t\t\tend = t.moment(end);\n\t\t\t\tif (!end.isValid()) {\n\t\t\t\t\tend = null; // let defaults take over\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tallDay = input.allDay;\n\t\t\tif (allDay === undefined) { // still undefined? fallback to default\n\t\t\t\tallDay = firstDefined(\n\t\t\t\t\tsource ? source.allDayDefault : undefined,\n\t\t\t\t\tt.options.allDayDefault\n\t\t\t\t);\n\t\t\t\t// still undefined? normalizeEventDates will calculate it\n\t\t\t}\n\n\t\t\tassignDatesToEvent(start, end, allDay, out);\n\t\t}\n\n\t\tt.normalizeEvent(out); // hook for external use. a prototype method\n\n\t\treturn out;\n\t}\n\tt.buildEventFromInput = buildEventFromInput;\n\n\n\t// Normalizes and assigns the given dates to the given partially-formed event object.\n\t// NOTE: mutates the given start/end moments. does not make a copy.\n\tfunction assignDatesToEvent(start, end, allDay, event) {\n\t\tevent.start = start;\n\t\tevent.end = end;\n\t\tevent.allDay = allDay;\n\t\tnormalizeEventDates(event);\n\t\tbackupEventDates(event);\n\t}\n\n\n\t// Ensures proper values for allDay/start/end. Accepts an Event object, or a plain object with event-ish properties.\n\t// NOTE: Will modify the given object.\n\tfunction normalizeEventDates(eventProps) {\n\n\t\tnormalizeEventTimes(eventProps);\n\n\t\tif (eventProps.end && !eventProps.end.isAfter(eventProps.start)) {\n\t\t\teventProps.end = null;\n\t\t}\n\n\t\tif (!eventProps.end) {\n\t\t\tif (t.options.forceEventDuration) {\n\t\t\t\teventProps.end = t.getDefaultEventEnd(eventProps.allDay, eventProps.start);\n\t\t\t}\n\t\t\telse {\n\t\t\t\teventProps.end = null;\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// Ensures the allDay property exists and the timeliness of the start/end dates are consistent\n\tfunction normalizeEventTimes(eventProps) {\n\t\tif (eventProps.allDay == null) {\n\t\t\teventProps.allDay = !(eventProps.start.hasTime() || (eventProps.end && eventProps.end.hasTime()));\n\t\t}\n\n\t\tif (eventProps.allDay) {\n\t\t\teventProps.start.stripTime();\n\t\t\tif (eventProps.end) {\n\t\t\t\t// TODO: consider nextDayThreshold here? If so, will require a lot of testing and adjustment\n\t\t\t\teventProps.end.stripTime();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (!eventProps.start.hasTime()) {\n\t\t\t\teventProps.start = t.applyTimezone(eventProps.start.time(0)); // will assign a 00:00 time\n\t\t\t}\n\t\t\tif (eventProps.end && !eventProps.end.hasTime()) {\n\t\t\t\teventProps.end = t.applyTimezone(eventProps.end.time(0)); // will assign a 00:00 time\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// If the given event is a recurring event, break it down into an array of individual instances.\n\t// If not a recurring event, return an array with the single original event.\n\t// If given a falsy input (probably because of a failed buildEventFromInput call), returns an empty array.\n\t// HACK: can override the recurring window by providing custom rangeStart/rangeEnd (for businessHours).\n\tfunction expandEvent(abstractEvent, _rangeStart, _rangeEnd) {\n\t\tvar events = [];\n\t\tvar dowHash;\n\t\tvar dow;\n\t\tvar i;\n\t\tvar date;\n\t\tvar startTime, endTime;\n\t\tvar start, end;\n\t\tvar event;\n\n\t\t_rangeStart = _rangeStart || rangeStart;\n\t\t_rangeEnd = _rangeEnd || rangeEnd;\n\n\t\tif (abstractEvent) {\n\t\t\tif (abstractEvent._recurring) {\n\n\t\t\t\t// make a boolean hash as to whether the event occurs on each day-of-week\n\t\t\t\tif ((dow = abstractEvent.dow)) {\n\t\t\t\t\tdowHash = {};\n\t\t\t\t\tfor (i = 0; i < dow.length; i++) {\n\t\t\t\t\t\tdowHash[dow[i]] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// iterate through every day in the current range\n\t\t\t\tdate = _rangeStart.clone().stripTime(); // holds the date of the current day\n\t\t\t\twhile (date.isBefore(_rangeEnd)) {\n\n\t\t\t\t\tif (!dowHash || dowHash[date.day()]) { // if everyday, or this particular day-of-week\n\n\t\t\t\t\t\tstartTime = abstractEvent.start; // the stored start and end properties are times (Durations)\n\t\t\t\t\t\tendTime = abstractEvent.end; // \"\n\t\t\t\t\t\tstart = date.clone();\n\t\t\t\t\t\tend = null;\n\n\t\t\t\t\t\tif (startTime) {\n\t\t\t\t\t\t\tstart = start.time(startTime);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (endTime) {\n\t\t\t\t\t\t\tend = date.clone().time(endTime);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tevent = $.extend({}, abstractEvent); // make a copy of the original\n\t\t\t\t\t\tassignDatesToEvent(\n\t\t\t\t\t\t\tstart, end,\n\t\t\t\t\t\t\t!startTime && !endTime, // allDay?\n\t\t\t\t\t\t\tevent\n\t\t\t\t\t\t);\n\t\t\t\t\t\tevents.push(event);\n\t\t\t\t\t}\n\n\t\t\t\t\tdate.add(1, 'days');\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tevents.push(abstractEvent); // return the original event. will be a one-item array\n\t\t\t}\n\t\t}\n\n\t\treturn events;\n\t}\n\tt.expandEvent = expandEvent;\n\n\n\n\t/* Event Modification Math\n\t-----------------------------------------------------------------------------------------*/\n\n\n\t// Modifies an event and all related events by applying the given properties.\n\t// Special date-diffing logic is used for manipulation of dates.\n\t// If `props` does not contain start/end dates, the updated values are assumed to be the event's current start/end.\n\t// All date comparisons are done against the event's pristine _start and _end dates.\n\t// Returns an object with delta information and a function to undo all operations.\n\t// For making computations in a granularity greater than day/time, specify largeUnit.\n\t// NOTE: The given `newProps` might be mutated for normalization purposes.\n\tfunction mutateEvent(event, newProps, largeUnit) {\n\t\tvar miscProps = {};\n\t\tvar oldProps;\n\t\tvar clearEnd;\n\t\tvar startDelta;\n\t\tvar endDelta;\n\t\tvar durationDelta;\n\t\tvar undoFunc;\n\n\t\t// diffs the dates in the appropriate way, returning a duration\n\t\tfunction diffDates(date1, date0) { // date1 - date0\n\t\t\tif (largeUnit) {\n\t\t\t\treturn diffByUnit(date1, date0, largeUnit);\n\t\t\t}\n\t\t\telse if (newProps.allDay) {\n\t\t\t\treturn diffDay(date1, date0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn diffDayTime(date1, date0);\n\t\t\t}\n\t\t}\n\n\t\tnewProps = newProps || {};\n\n\t\t// normalize new date-related properties\n\t\tif (!newProps.start) {\n\t\t\tnewProps.start = event.start.clone();\n\t\t}\n\t\tif (newProps.end === undefined) {\n\t\t\tnewProps.end = event.end ? event.end.clone() : null;\n\t\t}\n\t\tif (newProps.allDay == null) { // is null or undefined?\n\t\t\tnewProps.allDay = event.allDay;\n\t\t}\n\t\tnormalizeEventDates(newProps);\n\n\t\t// create normalized versions of the original props to compare against\n\t\t// need a real end value, for diffing\n\t\toldProps = {\n\t\t\tstart: event._start.clone(),\n\t\t\tend: event._end ? event._end.clone() : t.getDefaultEventEnd(event._allDay, event._start),\n\t\t\tallDay: newProps.allDay // normalize the dates in the same regard as the new properties\n\t\t};\n\t\tnormalizeEventDates(oldProps);\n\n\t\t// need to clear the end date if explicitly changed to null\n\t\tclearEnd = event._end !== null && newProps.end === null;\n\n\t\t// compute the delta for moving the start date\n\t\tstartDelta = diffDates(newProps.start, oldProps.start);\n\n\t\t// compute the delta for moving the end date\n\t\tif (newProps.end) {\n\t\t\tendDelta = diffDates(newProps.end, oldProps.end);\n\t\t\tdurationDelta = endDelta.subtract(startDelta);\n\t\t}\n\t\telse {\n\t\t\tdurationDelta = null;\n\t\t}\n\n\t\t// gather all non-date-related properties\n\t\t$.each(newProps, function(name, val) {\n\t\t\tif (isMiscEventPropName(name)) {\n\t\t\t\tif (val !== undefined) {\n\t\t\t\t\tmiscProps[name] = val;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// apply the operations to the event and all related events\n\t\tundoFunc = mutateEvents(\n\t\t\tclientEvents(event._id), // get events with this ID\n\t\t\tclearEnd,\n\t\t\tnewProps.allDay,\n\t\t\tstartDelta,\n\t\t\tdurationDelta,\n\t\t\tmiscProps\n\t\t);\n\n\t\treturn {\n\t\t\tdateDelta: startDelta,\n\t\t\tdurationDelta: durationDelta,\n\t\t\tundo: undoFunc\n\t\t};\n\t}\n\n\n\t// Modifies an array of events in the following ways (operations are in order):\n\t// - clear the event's `end`\n\t// - convert the event to allDay\n\t// - add `dateDelta` to the start and end\n\t// - add `durationDelta` to the event's duration\n\t// - assign `miscProps` to the event\n\t//\n\t// Returns a function that can be called to undo all the operations.\n\t//\n\t// TODO: don't use so many closures. possible memory issues when lots of events with same ID.\n\t//\n\tfunction mutateEvents(events, clearEnd, allDay, dateDelta, durationDelta, miscProps) {\n\t\tvar isAmbigTimezone = t.getIsAmbigTimezone();\n\t\tvar undoFunctions = [];\n\n\t\t// normalize zero-length deltas to be null\n\t\tif (dateDelta && !dateDelta.valueOf()) { dateDelta = null; }\n\t\tif (durationDelta && !durationDelta.valueOf()) { durationDelta = null; }\n\n\t\t$.each(events, function(i, event) {\n\t\t\tvar oldProps;\n\t\t\tvar newProps;\n\n\t\t\t// build an object holding all the old values, both date-related and misc.\n\t\t\t// for the undo function.\n\t\t\toldProps = {\n\t\t\t\tstart: event.start.clone(),\n\t\t\t\tend: event.end ? event.end.clone() : null,\n\t\t\t\tallDay: event.allDay\n\t\t\t};\n\t\t\t$.each(miscProps, function(name) {\n\t\t\t\toldProps[name] = event[name];\n\t\t\t});\n\n\t\t\t// new date-related properties. work off the original date snapshot.\n\t\t\t// ok to use references because they will be thrown away when backupEventDates is called.\n\t\t\tnewProps = {\n\t\t\t\tstart: event._start,\n\t\t\t\tend: event._end,\n\t\t\t\tallDay: allDay // normalize the dates in the same regard as the new properties\n\t\t\t};\n\t\t\tnormalizeEventDates(newProps); // massages start/end/allDay\n\n\t\t\t// strip or ensure the end date\n\t\t\tif (clearEnd) {\n\t\t\t\tnewProps.end = null;\n\t\t\t}\n\t\t\telse if (durationDelta && !newProps.end) { // the duration translation requires an end date\n\t\t\t\tnewProps.end = t.getDefaultEventEnd(newProps.allDay, newProps.start);\n\t\t\t}\n\n\t\t\tif (dateDelta) {\n\t\t\t\tnewProps.start.add(dateDelta);\n\t\t\t\tif (newProps.end) {\n\t\t\t\t\tnewProps.end.add(dateDelta);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (durationDelta) {\n\t\t\t\tnewProps.end.add(durationDelta); // end already ensured above\n\t\t\t}\n\n\t\t\t// if the dates have changed, and we know it is impossible to recompute the\n\t\t\t// timezone offsets, strip the zone.\n\t\t\tif (\n\t\t\t\tisAmbigTimezone &&\n\t\t\t\t!newProps.allDay &&\n\t\t\t\t(dateDelta || durationDelta)\n\t\t\t) {\n\t\t\t\tnewProps.start.stripZone();\n\t\t\t\tif (newProps.end) {\n\t\t\t\t\tnewProps.end.stripZone();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$.extend(event, miscProps, newProps); // copy over misc props, then date-related props\n\t\t\tbackupEventDates(event); // regenerate internal _start/_end/_allDay\n\n\t\t\tundoFunctions.push(function() {\n\t\t\t\t$.extend(event, oldProps);\n\t\t\t\tbackupEventDates(event); // regenerate internal _start/_end/_allDay\n\t\t\t});\n\t\t});\n\n\t\treturn function() {\n\t\t\tfor (var i = 0; i < undoFunctions.length; i++) {\n\t\t\t\tundoFunctions[i]();\n\t\t\t}\n\t\t};\n\t}\n\n\n\tt.getEventCache = function() {\n\t\treturn cache;\n\t};\n\n}\n\n\n// hook for external libs to manipulate event properties upon creation.\n// should manipulate the event in-place.\nCalendar.prototype.normalizeEvent = function(event) {\n};\n\n\n// Does the given span (start, end, and other location information)\n// fully contain the other?\nCalendar.prototype.spanContainsSpan = function(outerSpan, innerSpan) {\n\tvar eventStart = outerSpan.start.clone().stripZone();\n\tvar eventEnd = this.getEventEnd(outerSpan).stripZone();\n\n\treturn innerSpan.start >= eventStart && innerSpan.end <= eventEnd;\n};\n\n\n// Returns a list of events that the given event should be compared against when being considered for a move to\n// the specified span. Attached to the Calendar's prototype because EventManager is a mixin for a Calendar.\nCalendar.prototype.getPeerEvents = function(span, event) {\n\tvar cache = this.getEventCache();\n\tvar peerEvents = [];\n\tvar i, otherEvent;\n\n\tfor (i = 0; i < cache.length; i++) {\n\t\totherEvent = cache[i];\n\t\tif (\n\t\t\t!event ||\n\t\t\tevent._id !== otherEvent._id // don't compare the event to itself or other related [repeating] events\n\t\t) {\n\t\t\tpeerEvents.push(otherEvent);\n\t\t}\n\t}\n\n\treturn peerEvents;\n};\n\n\n// updates the \"backup\" properties, which are preserved in order to compute diffs later on.\nfunction backupEventDates(event) {\n\tevent._allDay = event.allDay;\n\tevent._start = event.start.clone();\n\tevent._end = event.end ? event.end.clone() : null;\n}\n\n\n/* Overlapping / Constraining\n-----------------------------------------------------------------------------------------*/\n\n\n// Determines if the given event can be relocated to the given span (unzoned start/end with other misc data)\nCalendar.prototype.isEventSpanAllowed = function(span, event) {\n\tvar source = event.source || {};\n\n\tvar constraint = firstDefined(\n\t\tevent.constraint,\n\t\tsource.constraint,\n\t\tthis.options.eventConstraint\n\t);\n\n\tvar overlap = firstDefined(\n\t\tevent.overlap,\n\t\tsource.overlap,\n\t\tthis.options.eventOverlap\n\t);\n\n\treturn this.isSpanAllowed(span, constraint, overlap, event) &&\n\t\t(!this.options.eventAllow || this.options.eventAllow(span, event) !== false);\n};\n\n\n// Determines if an external event can be relocated to the given span (unzoned start/end with other misc data)\nCalendar.prototype.isExternalSpanAllowed = function(eventSpan, eventLocation, eventProps) {\n\tvar eventInput;\n\tvar event;\n\n\t// note: very similar logic is in View's reportExternalDrop\n\tif (eventProps) {\n\t\teventInput = $.extend({}, eventProps, eventLocation);\n\t\tevent = this.expandEvent(\n\t\t\tthis.buildEventFromInput(eventInput)\n\t\t)[0];\n\t}\n\n\tif (event) {\n\t\treturn this.isEventSpanAllowed(eventSpan, event);\n\t}\n\telse { // treat it as a selection\n\n\t\treturn this.isSelectionSpanAllowed(eventSpan);\n\t}\n};\n\n\n// Determines the given span (unzoned start/end with other misc data) can be selected.\nCalendar.prototype.isSelectionSpanAllowed = function(span) {\n\treturn this.isSpanAllowed(span, this.options.selectConstraint, this.options.selectOverlap) &&\n\t\t(!this.options.selectAllow || this.options.selectAllow(span) !== false);\n};\n\n\n// Returns true if the given span (caused by an event drop/resize or a selection) is allowed to exist\n// according to the constraint/overlap settings.\n// `event` is not required if checking a selection.\nCalendar.prototype.isSpanAllowed = function(span, constraint, overlap, event) {\n\tvar constraintEvents;\n\tvar anyContainment;\n\tvar peerEvents;\n\tvar i, peerEvent;\n\tvar peerOverlap;\n\n\t// the range must be fully contained by at least one of produced constraint events\n\tif (constraint != null) {\n\n\t\t// not treated as an event! intermediate data structure\n\t\t// TODO: use ranges in the future\n\t\tconstraintEvents = this.constraintToEvents(constraint);\n\t\tif (constraintEvents) { // not invalid\n\n\t\t\tanyContainment = false;\n\t\t\tfor (i = 0; i < constraintEvents.length; i++) {\n\t\t\t\tif (this.spanContainsSpan(constraintEvents[i], span)) {\n\t\t\t\t\tanyContainment = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!anyContainment) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tpeerEvents = this.getPeerEvents(span, event);\n\n\tfor (i = 0; i < peerEvents.length; i++)  {\n\t\tpeerEvent = peerEvents[i];\n\n\t\t// there needs to be an actual intersection before disallowing anything\n\t\tif (this.eventIntersectsRange(peerEvent, span)) {\n\n\t\t\t// evaluate overlap for the given range and short-circuit if necessary\n\t\t\tif (overlap === false) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// if the event's overlap is a test function, pass the peer event in question as the first param\n\t\t\telse if (typeof overlap === 'function' && !overlap(peerEvent, event)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// if we are computing if the given range is allowable for an event, consider the other event's\n\t\t\t// EventObject-specific or Source-specific `overlap` property\n\t\t\tif (event) {\n\t\t\t\tpeerOverlap = firstDefined(\n\t\t\t\t\tpeerEvent.overlap,\n\t\t\t\t\t(peerEvent.source || {}).overlap\n\t\t\t\t\t// we already considered the global `eventOverlap`\n\t\t\t\t);\n\t\t\t\tif (peerOverlap === false) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// if the peer event's overlap is a test function, pass the subject event as the first param\n\t\t\t\tif (typeof peerOverlap === 'function' && !peerOverlap(event, peerEvent)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n};\n\n\n// Given an event input from the API, produces an array of event objects. Possible event inputs:\n// 'businessHours'\n// An event ID (number or string)\n// An object with specific start/end dates or a recurring event (like what businessHours accepts)\nCalendar.prototype.constraintToEvents = function(constraintInput) {\n\n\tif (constraintInput === 'businessHours') {\n\t\treturn this.getCurrentBusinessHourEvents();\n\t}\n\n\tif (typeof constraintInput === 'object') {\n\t\tif (constraintInput.start != null) { // needs to be event-like input\n\t\t\treturn this.expandEvent(this.buildEventFromInput(constraintInput));\n\t\t}\n\t\telse {\n\t\t\treturn null; // invalid\n\t\t}\n\t}\n\n\treturn this.clientEvents(constraintInput); // probably an ID\n};\n\n\n// Does the event's date range intersect with the given range?\n// start/end already assumed to have stripped zones :(\nCalendar.prototype.eventIntersectsRange = function(event, range) {\n\tvar eventStart = event.start.clone().stripZone();\n\tvar eventEnd = this.getEventEnd(event).stripZone();\n\n\treturn range.start < eventEnd && range.end > eventStart;\n};\n\n\n/* Business Hours\n-----------------------------------------------------------------------------------------*/\n\nvar BUSINESS_HOUR_EVENT_DEFAULTS = {\n\tid: '_fcBusinessHours', // will relate events from different calls to expandEvent\n\tstart: '09:00',\n\tend: '17:00',\n\tdow: [ 1, 2, 3, 4, 5 ], // monday - friday\n\trendering: 'inverse-background'\n\t// classNames are defined in businessHoursSegClasses\n};\n\n// Return events objects for business hours within the current view.\n// Abuse of our event system :(\nCalendar.prototype.getCurrentBusinessHourEvents = function(wholeDay) {\n\treturn this.computeBusinessHourEvents(wholeDay, this.options.businessHours);\n};\n\n// Given a raw input value from options, return events objects for business hours within the current view.\nCalendar.prototype.computeBusinessHourEvents = function(wholeDay, input) {\n\tif (input === true) {\n\t\treturn this.expandBusinessHourEvents(wholeDay, [ {} ]);\n\t}\n\telse if ($.isPlainObject(input)) {\n\t\treturn this.expandBusinessHourEvents(wholeDay, [ input ]);\n\t}\n\telse if ($.isArray(input)) {\n\t\treturn this.expandBusinessHourEvents(wholeDay, input, true);\n\t}\n\telse {\n\t\treturn [];\n\t}\n};\n\n// inputs expected to be an array of objects.\n// if ignoreNoDow is true, will ignore entries that don't specify a day-of-week (dow) key.\nCalendar.prototype.expandBusinessHourEvents = function(wholeDay, inputs, ignoreNoDow) {\n\tvar view = this.getView();\n\tvar events = [];\n\tvar i, input;\n\n\tfor (i = 0; i < inputs.length; i++) {\n\t\tinput = inputs[i];\n\n\t\tif (ignoreNoDow && !input.dow) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// give defaults. will make a copy\n\t\tinput = $.extend({}, BUSINESS_HOUR_EVENT_DEFAULTS, input);\n\n\t\t// if a whole-day series is requested, clear the start/end times\n\t\tif (wholeDay) {\n\t\t\tinput.start = null;\n\t\t\tinput.end = null;\n\t\t}\n\n\t\tevents.push.apply(events, // append\n\t\t\tthis.expandEvent(\n\t\t\t\tthis.buildEventFromInput(input),\n\t\t\t\tview.start,\n\t\t\t\tview.end\n\t\t\t)\n\t\t);\n\t}\n\n\treturn events;\n};\n\n;;\n\n/* An abstract class for the \"basic\" views, as well as month view. Renders one or more rows of day cells.\n----------------------------------------------------------------------------------------------------------------------*/\n// It is a manager for a DayGrid subcomponent, which does most of the heavy lifting.\n// It is responsible for managing width/height.\n\nvar BasicView = FC.BasicView = View.extend({\n\n\tscroller: null,\n\n\tdayGridClass: DayGrid, // class the dayGrid will be instantiated from (overridable by subclasses)\n\tdayGrid: null, // the main subcomponent that does most of the heavy lifting\n\n\tdayNumbersVisible: false, // display day numbers on each day cell?\n\tcolWeekNumbersVisible: false, // display week numbers along the side?\n\tcellWeekNumbersVisible: false, // display week numbers in day cell?\n\n\tweekNumberWidth: null, // width of all the week-number cells running down the side\n\n\theadContainerEl: null, // div that hold's the dayGrid's rendered date header\n\theadRowEl: null, // the fake row element of the day-of-week header\n\n\n\tinitialize: function() {\n\t\tthis.dayGrid = this.instantiateDayGrid();\n\n\t\tthis.scroller = new Scroller({\n\t\t\toverflowX: 'hidden',\n\t\t\toverflowY: 'auto'\n\t\t});\n\t},\n\n\n\t// Generates the DayGrid object this view needs. Draws from this.dayGridClass\n\tinstantiateDayGrid: function() {\n\t\t// generate a subclass on the fly with BasicView-specific behavior\n\t\t// TODO: cache this subclass\n\t\tvar subclass = this.dayGridClass.extend(basicDayGridMethods);\n\n\t\treturn new subclass(this);\n\t},\n\n\n\t// Sets the display range and computes all necessary dates\n\tsetRange: function(range) {\n\t\tView.prototype.setRange.call(this, range); // call the super-method\n\n\t\tthis.dayGrid.breakOnWeeks = /year|month|week/.test(this.intervalUnit); // do before setRange\n\t\tthis.dayGrid.setRange(range);\n\t},\n\n\n\t// Compute the value to feed into setRange. Overrides superclass.\n\tcomputeRange: function(date) {\n\t\tvar range = View.prototype.computeRange.call(this, date); // get value from the super-method\n\n\t\t// year and month views should be aligned with weeks. this is already done for week\n\t\tif (/year|month/.test(range.intervalUnit)) {\n\t\t\trange.start.startOf('week');\n\t\t\trange.start = this.skipHiddenDays(range.start);\n\n\t\t\t// make end-of-week if not already\n\t\t\tif (range.end.weekday()) {\n\t\t\t\trange.end.add(1, 'week').startOf('week');\n\t\t\t\trange.end = this.skipHiddenDays(range.end, -1, true); // exclusively move backwards\n\t\t\t}\n\t\t}\n\n\t\treturn range;\n\t},\n\n\n\t// Renders the view into `this.el`, which should already be assigned\n\trenderDates: function() {\n\n\t\tthis.dayNumbersVisible = this.dayGrid.rowCnt > 1; // TODO: make grid responsible\n\t\tif (this.opt('weekNumbers')) {\n\t\t\tif (this.opt('weekNumbersWithinDays')) {\n\t\t\t\tthis.cellWeekNumbersVisible = true;\n\t\t\t\tthis.colWeekNumbersVisible = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.cellWeekNumbersVisible = false;\n\t\t\t\tthis.colWeekNumbersVisible = true;\n\t\t\t};\n\t\t}\n\t\tthis.dayGrid.numbersVisible = this.dayNumbersVisible ||\n\t\t\tthis.cellWeekNumbersVisible || this.colWeekNumbersVisible;\n\n\t\tthis.el.addClass('fc-basic-view').html(this.renderSkeletonHtml());\n\t\tthis.renderHead();\n\n\t\tthis.scroller.render();\n\t\tvar dayGridContainerEl = this.scroller.el.addClass('fc-day-grid-container');\n\t\tvar dayGridEl = $('<div class=\"fc-day-grid\" />').appendTo(dayGridContainerEl);\n\t\tthis.el.find('.fc-body > tr > td').append(dayGridContainerEl);\n\n\t\tthis.dayGrid.setElement(dayGridEl);\n\t\tthis.dayGrid.renderDates(this.hasRigidRows());\n\t},\n\n\n\t// render the day-of-week headers\n\trenderHead: function() {\n\t\tthis.headContainerEl =\n\t\t\tthis.el.find('.fc-head-container')\n\t\t\t\t.html(this.dayGrid.renderHeadHtml());\n\t\tthis.headRowEl = this.headContainerEl.find('.fc-row');\n\t},\n\n\n\t// Unrenders the content of the view. Since we haven't separated skeleton rendering from date rendering,\n\t// always completely kill the dayGrid's rendering.\n\tunrenderDates: function() {\n\t\tthis.dayGrid.unrenderDates();\n\t\tthis.dayGrid.removeElement();\n\t\tthis.scroller.destroy();\n\t},\n\n\n\trenderBusinessHours: function() {\n\t\tthis.dayGrid.renderBusinessHours();\n\t},\n\n\n\tunrenderBusinessHours: function() {\n\t\tthis.dayGrid.unrenderBusinessHours();\n\t},\n\n\n\t// Builds the HTML skeleton for the view.\n\t// The day-grid component will render inside of a container defined by this HTML.\n\trenderSkeletonHtml: function() {\n\t\treturn '' +\n\t\t\t'<table>' +\n\t\t\t\t'<thead class=\"fc-head\">' +\n\t\t\t\t\t'<tr>' +\n\t\t\t\t\t\t'<td class=\"fc-head-container ' + this.widgetHeaderClass + '\"></td>' +\n\t\t\t\t\t'</tr>' +\n\t\t\t\t'</thead>' +\n\t\t\t\t'<tbody class=\"fc-body\">' +\n\t\t\t\t\t'<tr>' +\n\t\t\t\t\t\t'<td class=\"' + this.widgetContentClass + '\"></td>' +\n\t\t\t\t\t'</tr>' +\n\t\t\t\t'</tbody>' +\n\t\t\t'</table>';\n\t},\n\n\n\t// Generates an HTML attribute string for setting the width of the week number column, if it is known\n\tweekNumberStyleAttr: function() {\n\t\tif (this.weekNumberWidth !== null) {\n\t\t\treturn 'style=\"width:' + this.weekNumberWidth + 'px\"';\n\t\t}\n\t\treturn '';\n\t},\n\n\n\t// Determines whether each row should have a constant height\n\thasRigidRows: function() {\n\t\tvar eventLimit = this.opt('eventLimit');\n\t\treturn eventLimit && typeof eventLimit !== 'number';\n\t},\n\n\n\t/* Dimensions\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Refreshes the horizontal dimensions of the view\n\tupdateWidth: function() {\n\t\tif (this.colWeekNumbersVisible) {\n\t\t\t// Make sure all week number cells running down the side have the same width.\n\t\t\t// Record the width for cells created later.\n\t\t\tthis.weekNumberWidth = matchCellWidths(\n\t\t\t\tthis.el.find('.fc-week-number')\n\t\t\t);\n\t\t}\n\t},\n\n\n\t// Adjusts the vertical dimensions of the view to the specified values\n\tsetHeight: function(totalHeight, isAuto) {\n\t\tvar eventLimit = this.opt('eventLimit');\n\t\tvar scrollerHeight;\n\t\tvar scrollbarWidths;\n\n\t\t// reset all heights to be natural\n\t\tthis.scroller.clear();\n\t\tuncompensateScroll(this.headRowEl);\n\n\t\tthis.dayGrid.removeSegPopover(); // kill the \"more\" popover if displayed\n\n\t\t// is the event limit a constant level number?\n\t\tif (eventLimit && typeof eventLimit === 'number') {\n\t\t\tthis.dayGrid.limitRows(eventLimit); // limit the levels first so the height can redistribute after\n\t\t}\n\n\t\t// distribute the height to the rows\n\t\t// (totalHeight is a \"recommended\" value if isAuto)\n\t\tscrollerHeight = this.computeScrollerHeight(totalHeight);\n\t\tthis.setGridHeight(scrollerHeight, isAuto);\n\n\t\t// is the event limit dynamically calculated?\n\t\tif (eventLimit && typeof eventLimit !== 'number') {\n\t\t\tthis.dayGrid.limitRows(eventLimit); // limit the levels after the grid's row heights have been set\n\t\t}\n\n\t\tif (!isAuto) { // should we force dimensions of the scroll container?\n\n\t\t\tthis.scroller.setHeight(scrollerHeight);\n\t\t\tscrollbarWidths = this.scroller.getScrollbarWidths();\n\n\t\t\tif (scrollbarWidths.left || scrollbarWidths.right) { // using scrollbars?\n\n\t\t\t\tcompensateScroll(this.headRowEl, scrollbarWidths);\n\n\t\t\t\t// doing the scrollbar compensation might have created text overflow which created more height. redo\n\t\t\t\tscrollerHeight = this.computeScrollerHeight(totalHeight);\n\t\t\t\tthis.scroller.setHeight(scrollerHeight);\n\t\t\t}\n\n\t\t\t// guarantees the same scrollbar widths\n\t\t\tthis.scroller.lockOverflow(scrollbarWidths);\n\t\t}\n\t},\n\n\n\t// given a desired total height of the view, returns what the height of the scroller should be\n\tcomputeScrollerHeight: function(totalHeight) {\n\t\treturn totalHeight -\n\t\t\tsubtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller\n\t},\n\n\n\t// Sets the height of just the DayGrid component in this view\n\tsetGridHeight: function(height, isAuto) {\n\t\tif (isAuto) {\n\t\t\tundistributeHeight(this.dayGrid.rowEls); // let the rows be their natural height with no expanding\n\t\t}\n\t\telse {\n\t\t\tdistributeHeight(this.dayGrid.rowEls, height, true); // true = compensate for height-hogging rows\n\t\t}\n\t},\n\n\n\t/* Scroll\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\tqueryScroll: function() {\n\t\treturn this.scroller.getScrollTop();\n\t},\n\n\n\tsetScroll: function(top) {\n\t\tthis.scroller.setScrollTop(top);\n\t},\n\n\n\t/* Hit Areas\n\t------------------------------------------------------------------------------------------------------------------*/\n\t// forward all hit-related method calls to dayGrid\n\n\n\tprepareHits: function() {\n\t\tthis.dayGrid.prepareHits();\n\t},\n\n\n\treleaseHits: function() {\n\t\tthis.dayGrid.releaseHits();\n\t},\n\n\n\tqueryHit: function(left, top) {\n\t\treturn this.dayGrid.queryHit(left, top);\n\t},\n\n\n\tgetHitSpan: function(hit) {\n\t\treturn this.dayGrid.getHitSpan(hit);\n\t},\n\n\n\tgetHitEl: function(hit) {\n\t\treturn this.dayGrid.getHitEl(hit);\n\t},\n\n\n\t/* Events\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Renders the given events onto the view and populates the segments array\n\trenderEvents: function(events) {\n\t\tthis.dayGrid.renderEvents(events);\n\n\t\tthis.updateHeight(); // must compensate for events that overflow the row\n\t},\n\n\n\t// Retrieves all segment objects that are rendered in the view\n\tgetEventSegs: function() {\n\t\treturn this.dayGrid.getEventSegs();\n\t},\n\n\n\t// Unrenders all event elements and clears internal segment data\n\tunrenderEvents: function() {\n\t\tthis.dayGrid.unrenderEvents();\n\n\t\t// we DON'T need to call updateHeight() because\n\t\t// a renderEvents() call always happens after this, which will eventually call updateHeight()\n\t},\n\n\n\t/* Dragging (for both events and external elements)\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// A returned value of `true` signals that a mock \"helper\" event has been rendered.\n\trenderDrag: function(dropLocation, seg) {\n\t\treturn this.dayGrid.renderDrag(dropLocation, seg);\n\t},\n\n\n\tunrenderDrag: function() {\n\t\tthis.dayGrid.unrenderDrag();\n\t},\n\n\n\t/* Selection\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Renders a visual indication of a selection\n\trenderSelection: function(span) {\n\t\tthis.dayGrid.renderSelection(span);\n\t},\n\n\n\t// Unrenders a visual indications of a selection\n\tunrenderSelection: function() {\n\t\tthis.dayGrid.unrenderSelection();\n\t}\n\n});\n\n\n// Methods that will customize the rendering behavior of the BasicView's dayGrid\nvar basicDayGridMethods = {\n\n\n\t// Generates the HTML that will go before the day-of week header cells\n\trenderHeadIntroHtml: function() {\n\t\tvar view = this.view;\n\n\t\tif (view.colWeekNumbersVisible) {\n\t\t\treturn '' +\n\t\t\t\t'<th class=\"fc-week-number ' + view.widgetHeaderClass + '\" ' + view.weekNumberStyleAttr() + '>' +\n\t\t\t\t\t'<span>' + // needed for matchCellWidths\n\t\t\t\t\t\thtmlEscape(view.opt('weekNumberTitle')) +\n\t\t\t\t\t'</span>' +\n\t\t\t\t'</th>';\n\t\t}\n\n\t\treturn '';\n\t},\n\n\n\t// Generates the HTML that will go before content-skeleton cells that display the day/week numbers\n\trenderNumberIntroHtml: function(row) {\n\t\tvar view = this.view;\n\t\tvar weekStart = this.getCellDate(row, 0);\n\n\t\tif (view.colWeekNumbersVisible) {\n\t\t\treturn '' +\n\t\t\t\t'<td class=\"fc-week-number\" ' + view.weekNumberStyleAttr() + '>' +\n\t\t\t\t\tview.buildGotoAnchorHtml( // aside from link, important for matchCellWidths\n\t\t\t\t\t\t{ date: weekStart, type: 'week', forceOff: this.colCnt === 1 },\n\t\t\t\t\t\tweekStart.format('w') // inner HTML\n\t\t\t\t\t) +\n\t\t\t\t'</td>';\n\t\t}\n\n\t\treturn '';\n\t},\n\n\n\t// Generates the HTML that goes before the day bg cells for each day-row\n\trenderBgIntroHtml: function() {\n\t\tvar view = this.view;\n\n\t\tif (view.colWeekNumbersVisible) {\n\t\t\treturn '<td class=\"fc-week-number ' + view.widgetContentClass + '\" ' +\n\t\t\t\tview.weekNumberStyleAttr() + '></td>';\n\t\t}\n\n\t\treturn '';\n\t},\n\n\n\t// Generates the HTML that goes before every other type of row generated by DayGrid.\n\t// Affects helper-skeleton and highlight-skeleton rows.\n\trenderIntroHtml: function() {\n\t\tvar view = this.view;\n\n\t\tif (view.colWeekNumbersVisible) {\n\t\t\treturn '<td class=\"fc-week-number\" ' + view.weekNumberStyleAttr() + '></td>';\n\t\t}\n\n\t\treturn '';\n\t}\n\n};\n\n;;\n\n/* A month view with day cells running in rows (one-per-week) and columns\n----------------------------------------------------------------------------------------------------------------------*/\n\nvar MonthView = FC.MonthView = BasicView.extend({\n\n\t// Produces information about what range to display\n\tcomputeRange: function(date) {\n\t\tvar range = BasicView.prototype.computeRange.call(this, date); // get value from super-method\n\t\tvar rowCnt;\n\n\t\t// ensure 6 weeks\n\t\tif (this.isFixedWeeks()) {\n\t\t\trowCnt = Math.ceil(range.end.diff(range.start, 'weeks', true)); // could be partial weeks due to hiddenDays\n\t\t\trange.end.add(6 - rowCnt, 'weeks');\n\t\t}\n\n\t\treturn range;\n\t},\n\n\n\t// Overrides the default BasicView behavior to have special multi-week auto-height logic\n\tsetGridHeight: function(height, isAuto) {\n\n\t\t// if auto, make the height of each row the height that it would be if there were 6 weeks\n\t\tif (isAuto) {\n\t\t\theight *= this.rowCnt / 6;\n\t\t}\n\n\t\tdistributeHeight(this.dayGrid.rowEls, height, !isAuto); // if auto, don't compensate for height-hogging rows\n\t},\n\n\n\tisFixedWeeks: function() {\n\t\treturn this.opt('fixedWeekCount');\n\t}\n\n});\n\n;;\n\nfcViews.basic = {\n\t'class': BasicView\n};\n\nfcViews.basicDay = {\n\ttype: 'basic',\n\tduration: { days: 1 }\n};\n\nfcViews.basicWeek = {\n\ttype: 'basic',\n\tduration: { weeks: 1 }\n};\n\nfcViews.month = {\n\t'class': MonthView,\n\tduration: { months: 1 }, // important for prev/next\n\tdefaults: {\n\t\tfixedWeekCount: true\n\t}\n};\n;;\n\n/* An abstract class for all agenda-related views. Displays one more columns with time slots running vertically.\n----------------------------------------------------------------------------------------------------------------------*/\n// Is a manager for the TimeGrid subcomponent and possibly the DayGrid subcomponent (if allDaySlot is on).\n// Responsible for managing width/height.\n\nvar AgendaView = FC.AgendaView = View.extend({\n\n\tscroller: null,\n\n\ttimeGridClass: TimeGrid, // class used to instantiate the timeGrid. subclasses can override\n\ttimeGrid: null, // the main time-grid subcomponent of this view\n\n\tdayGridClass: DayGrid, // class used to instantiate the dayGrid. subclasses can override\n\tdayGrid: null, // the \"all-day\" subcomponent. if all-day is turned off, this will be null\n\n\taxisWidth: null, // the width of the time axis running down the side\n\n\theadContainerEl: null, // div that hold's the timeGrid's rendered date header\n\tnoScrollRowEls: null, // set of fake row elements that must compensate when scroller has scrollbars\n\n\t// when the time-grid isn't tall enough to occupy the given height, we render an <hr> underneath\n\tbottomRuleEl: null,\n\n\n\tinitialize: function() {\n\t\tthis.timeGrid = this.instantiateTimeGrid();\n\n\t\tif (this.opt('allDaySlot')) { // should we display the \"all-day\" area?\n\t\t\tthis.dayGrid = this.instantiateDayGrid(); // the all-day subcomponent of this view\n\t\t}\n\n\t\tthis.scroller = new Scroller({\n\t\t\toverflowX: 'hidden',\n\t\t\toverflowY: 'auto'\n\t\t});\n\t},\n\n\n\t// Instantiates the TimeGrid object this view needs. Draws from this.timeGridClass\n\tinstantiateTimeGrid: function() {\n\t\tvar subclass = this.timeGridClass.extend(agendaTimeGridMethods);\n\n\t\treturn new subclass(this);\n\t},\n\n\n\t// Instantiates the DayGrid object this view might need. Draws from this.dayGridClass\n\tinstantiateDayGrid: function() {\n\t\tvar subclass = this.dayGridClass.extend(agendaDayGridMethods);\n\n\t\treturn new subclass(this);\n\t},\n\n\n\t/* Rendering\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Sets the display range and computes all necessary dates\n\tsetRange: function(range) {\n\t\tView.prototype.setRange.call(this, range); // call the super-method\n\n\t\tthis.timeGrid.setRange(range);\n\t\tif (this.dayGrid) {\n\t\t\tthis.dayGrid.setRange(range);\n\t\t}\n\t},\n\n\n\t// Renders the view into `this.el`, which has already been assigned\n\trenderDates: function() {\n\n\t\tthis.el.addClass('fc-agenda-view').html(this.renderSkeletonHtml());\n\t\tthis.renderHead();\n\n\t\tthis.scroller.render();\n\t\tvar timeGridWrapEl = this.scroller.el.addClass('fc-time-grid-container');\n\t\tvar timeGridEl = $('<div class=\"fc-time-grid\" />').appendTo(timeGridWrapEl);\n\t\tthis.el.find('.fc-body > tr > td').append(timeGridWrapEl);\n\n\t\tthis.timeGrid.setElement(timeGridEl);\n\t\tthis.timeGrid.renderDates();\n\n\t\t// the <hr> that sometimes displays under the time-grid\n\t\tthis.bottomRuleEl = $('<hr class=\"fc-divider ' + this.widgetHeaderClass + '\"/>')\n\t\t\t.appendTo(this.timeGrid.el); // inject it into the time-grid\n\n\t\tif (this.dayGrid) {\n\t\t\tthis.dayGrid.setElement(this.el.find('.fc-day-grid'));\n\t\t\tthis.dayGrid.renderDates();\n\n\t\t\t// have the day-grid extend it's coordinate area over the <hr> dividing the two grids\n\t\t\tthis.dayGrid.bottomCoordPadding = this.dayGrid.el.next('hr').outerHeight();\n\t\t}\n\n\t\tthis.noScrollRowEls = this.el.find('.fc-row:not(.fc-scroller *)'); // fake rows not within the scroller\n\t},\n\n\n\t// render the day-of-week headers\n\trenderHead: function() {\n\t\tthis.headContainerEl =\n\t\t\tthis.el.find('.fc-head-container')\n\t\t\t\t.html(this.timeGrid.renderHeadHtml());\n\t},\n\n\n\t// Unrenders the content of the view. Since we haven't separated skeleton rendering from date rendering,\n\t// always completely kill each grid's rendering.\n\tunrenderDates: function() {\n\t\tthis.timeGrid.unrenderDates();\n\t\tthis.timeGrid.removeElement();\n\n\t\tif (this.dayGrid) {\n\t\t\tthis.dayGrid.unrenderDates();\n\t\t\tthis.dayGrid.removeElement();\n\t\t}\n\n\t\tthis.scroller.destroy();\n\t},\n\n\n\t// Builds the HTML skeleton for the view.\n\t// The day-grid and time-grid components will render inside containers defined by this HTML.\n\trenderSkeletonHtml: function() {\n\t\treturn '' +\n\t\t\t'<table>' +\n\t\t\t\t'<thead class=\"fc-head\">' +\n\t\t\t\t\t'<tr>' +\n\t\t\t\t\t\t'<td class=\"fc-head-container ' + this.widgetHeaderClass + '\"></td>' +\n\t\t\t\t\t'</tr>' +\n\t\t\t\t'</thead>' +\n\t\t\t\t'<tbody class=\"fc-body\">' +\n\t\t\t\t\t'<tr>' +\n\t\t\t\t\t\t'<td class=\"' + this.widgetContentClass + '\">' +\n\t\t\t\t\t\t\t(this.dayGrid ?\n\t\t\t\t\t\t\t\t'<div class=\"fc-day-grid\"/>' +\n\t\t\t\t\t\t\t\t'<hr class=\"fc-divider ' + this.widgetHeaderClass + '\"/>' :\n\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t\t\t) +\n\t\t\t\t\t\t'</td>' +\n\t\t\t\t\t'</tr>' +\n\t\t\t\t'</tbody>' +\n\t\t\t'</table>';\n\t},\n\n\n\t// Generates an HTML attribute string for setting the width of the axis, if it is known\n\taxisStyleAttr: function() {\n\t\tif (this.axisWidth !== null) {\n\t\t\t return 'style=\"width:' + this.axisWidth + 'px\"';\n\t\t}\n\t\treturn '';\n\t},\n\n\n\t/* Business Hours\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\trenderBusinessHours: function() {\n\t\tthis.timeGrid.renderBusinessHours();\n\n\t\tif (this.dayGrid) {\n\t\t\tthis.dayGrid.renderBusinessHours();\n\t\t}\n\t},\n\n\n\tunrenderBusinessHours: function() {\n\t\tthis.timeGrid.unrenderBusinessHours();\n\n\t\tif (this.dayGrid) {\n\t\t\tthis.dayGrid.unrenderBusinessHours();\n\t\t}\n\t},\n\n\n\t/* Now Indicator\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\tgetNowIndicatorUnit: function() {\n\t\treturn this.timeGrid.getNowIndicatorUnit();\n\t},\n\n\n\trenderNowIndicator: function(date) {\n\t\tthis.timeGrid.renderNowIndicator(date);\n\t},\n\n\n\tunrenderNowIndicator: function() {\n\t\tthis.timeGrid.unrenderNowIndicator();\n\t},\n\n\n\t/* Dimensions\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\tupdateSize: function(isResize) {\n\t\tthis.timeGrid.updateSize(isResize);\n\n\t\tView.prototype.updateSize.call(this, isResize); // call the super-method\n\t},\n\n\n\t// Refreshes the horizontal dimensions of the view\n\tupdateWidth: function() {\n\t\t// make all axis cells line up, and record the width so newly created axis cells will have it\n\t\tthis.axisWidth = matchCellWidths(this.el.find('.fc-axis'));\n\t},\n\n\n\t// Adjusts the vertical dimensions of the view to the specified values\n\tsetHeight: function(totalHeight, isAuto) {\n\t\tvar eventLimit;\n\t\tvar scrollerHeight;\n\t\tvar scrollbarWidths;\n\n\t\t// reset all dimensions back to the original state\n\t\tthis.bottomRuleEl.hide(); // .show() will be called later if this <hr> is necessary\n\t\tthis.scroller.clear(); // sets height to 'auto' and clears overflow\n\t\tuncompensateScroll(this.noScrollRowEls);\n\n\t\t// limit number of events in the all-day area\n\t\tif (this.dayGrid) {\n\t\t\tthis.dayGrid.removeSegPopover(); // kill the \"more\" popover if displayed\n\n\t\t\teventLimit = this.opt('eventLimit');\n\t\t\tif (eventLimit && typeof eventLimit !== 'number') {\n\t\t\t\teventLimit = AGENDA_ALL_DAY_EVENT_LIMIT; // make sure \"auto\" goes to a real number\n\t\t\t}\n\t\t\tif (eventLimit) {\n\t\t\t\tthis.dayGrid.limitRows(eventLimit);\n\t\t\t}\n\t\t}\n\n\t\tif (!isAuto) { // should we force dimensions of the scroll container?\n\n\t\t\tscrollerHeight = this.computeScrollerHeight(totalHeight);\n\t\t\tthis.scroller.setHeight(scrollerHeight);\n\t\t\tscrollbarWidths = this.scroller.getScrollbarWidths();\n\n\t\t\tif (scrollbarWidths.left || scrollbarWidths.right) { // using scrollbars?\n\n\t\t\t\t// make the all-day and header rows lines up\n\t\t\t\tcompensateScroll(this.noScrollRowEls, scrollbarWidths);\n\n\t\t\t\t// the scrollbar compensation might have changed text flow, which might affect height, so recalculate\n\t\t\t\t// and reapply the desired height to the scroller.\n\t\t\t\tscrollerHeight = this.computeScrollerHeight(totalHeight);\n\t\t\t\tthis.scroller.setHeight(scrollerHeight);\n\t\t\t}\n\n\t\t\t// guarantees the same scrollbar widths\n\t\t\tthis.scroller.lockOverflow(scrollbarWidths);\n\n\t\t\t// if there's any space below the slats, show the horizontal rule.\n\t\t\t// this won't cause any new overflow, because lockOverflow already called.\n\t\t\tif (this.timeGrid.getTotalSlatHeight() < scrollerHeight) {\n\t\t\t\tthis.bottomRuleEl.show();\n\t\t\t}\n\t\t}\n\t},\n\n\n\t// given a desired total height of the view, returns what the height of the scroller should be\n\tcomputeScrollerHeight: function(totalHeight) {\n\t\treturn totalHeight -\n\t\t\tsubtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller\n\t},\n\n\n\t/* Scroll\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Computes the initial pre-configured scroll state prior to allowing the user to change it\n\tcomputeInitialScroll: function() {\n\t\tvar scrollTime = moment.duration(this.opt('scrollTime'));\n\t\tvar top = this.timeGrid.computeTimeTop(scrollTime);\n\n\t\t// zoom can give weird floating-point values. rather scroll a little bit further\n\t\ttop = Math.ceil(top);\n\n\t\tif (top) {\n\t\t\ttop++; // to overcome top border that slots beyond the first have. looks better\n\t\t}\n\n\t\treturn top;\n\t},\n\n\n\tqueryScroll: function() {\n\t\treturn this.scroller.getScrollTop();\n\t},\n\n\n\tsetScroll: function(top) {\n\t\tthis.scroller.setScrollTop(top);\n\t},\n\n\n\t/* Hit Areas\n\t------------------------------------------------------------------------------------------------------------------*/\n\t// forward all hit-related method calls to the grids (dayGrid might not be defined)\n\n\n\tprepareHits: function() {\n\t\tthis.timeGrid.prepareHits();\n\t\tif (this.dayGrid) {\n\t\t\tthis.dayGrid.prepareHits();\n\t\t}\n\t},\n\n\n\treleaseHits: function() {\n\t\tthis.timeGrid.releaseHits();\n\t\tif (this.dayGrid) {\n\t\t\tthis.dayGrid.releaseHits();\n\t\t}\n\t},\n\n\n\tqueryHit: function(left, top) {\n\t\tvar hit = this.timeGrid.queryHit(left, top);\n\n\t\tif (!hit && this.dayGrid) {\n\t\t\thit = this.dayGrid.queryHit(left, top);\n\t\t}\n\n\t\treturn hit;\n\t},\n\n\n\tgetHitSpan: function(hit) {\n\t\t// TODO: hit.component is set as a hack to identify where the hit came from\n\t\treturn hit.component.getHitSpan(hit);\n\t},\n\n\n\tgetHitEl: function(hit) {\n\t\t// TODO: hit.component is set as a hack to identify where the hit came from\n\t\treturn hit.component.getHitEl(hit);\n\t},\n\n\n\t/* Events\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Renders events onto the view and populates the View's segment array\n\trenderEvents: function(events) {\n\t\tvar dayEvents = [];\n\t\tvar timedEvents = [];\n\t\tvar daySegs = [];\n\t\tvar timedSegs;\n\t\tvar i;\n\n\t\t// separate the events into all-day and timed\n\t\tfor (i = 0; i < events.length; i++) {\n\t\t\tif (events[i].allDay) {\n\t\t\t\tdayEvents.push(events[i]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttimedEvents.push(events[i]);\n\t\t\t}\n\t\t}\n\n\t\t// render the events in the subcomponents\n\t\ttimedSegs = this.timeGrid.renderEvents(timedEvents);\n\t\tif (this.dayGrid) {\n\t\t\tdaySegs = this.dayGrid.renderEvents(dayEvents);\n\t\t}\n\n\t\t// the all-day area is flexible and might have a lot of events, so shift the height\n\t\tthis.updateHeight();\n\t},\n\n\n\t// Retrieves all segment objects that are rendered in the view\n\tgetEventSegs: function() {\n\t\treturn this.timeGrid.getEventSegs().concat(\n\t\t\tthis.dayGrid ? this.dayGrid.getEventSegs() : []\n\t\t);\n\t},\n\n\n\t// Unrenders all event elements and clears internal segment data\n\tunrenderEvents: function() {\n\n\t\t// unrender the events in the subcomponents\n\t\tthis.timeGrid.unrenderEvents();\n\t\tif (this.dayGrid) {\n\t\t\tthis.dayGrid.unrenderEvents();\n\t\t}\n\n\t\t// we DON'T need to call updateHeight() because\n\t\t// a renderEvents() call always happens after this, which will eventually call updateHeight()\n\t},\n\n\n\t/* Dragging (for events and external elements)\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// A returned value of `true` signals that a mock \"helper\" event has been rendered.\n\trenderDrag: function(dropLocation, seg) {\n\t\tif (dropLocation.start.hasTime()) {\n\t\t\treturn this.timeGrid.renderDrag(dropLocation, seg);\n\t\t}\n\t\telse if (this.dayGrid) {\n\t\t\treturn this.dayGrid.renderDrag(dropLocation, seg);\n\t\t}\n\t},\n\n\n\tunrenderDrag: function() {\n\t\tthis.timeGrid.unrenderDrag();\n\t\tif (this.dayGrid) {\n\t\t\tthis.dayGrid.unrenderDrag();\n\t\t}\n\t},\n\n\n\t/* Selection\n\t------------------------------------------------------------------------------------------------------------------*/\n\n\n\t// Renders a visual indication of a selection\n\trenderSelection: function(span) {\n\t\tif (span.start.hasTime() || span.end.hasTime()) {\n\t\t\tthis.timeGrid.renderSelection(span);\n\t\t}\n\t\telse if (this.dayGrid) {\n\t\t\tthis.dayGrid.renderSelection(span);\n\t\t}\n\t},\n\n\n\t// Unrenders a visual indications of a selection\n\tunrenderSelection: function() {\n\t\tthis.timeGrid.unrenderSelection();\n\t\tif (this.dayGrid) {\n\t\t\tthis.dayGrid.unrenderSelection();\n\t\t}\n\t}\n\n});\n\n\n// Methods that will customize the rendering behavior of the AgendaView's timeGrid\n// TODO: move into TimeGrid\nvar agendaTimeGridMethods = {\n\n\n\t// Generates the HTML that will go before the day-of week header cells\n\trenderHeadIntroHtml: function() {\n\t\tvar view = this.view;\n\t\tvar weekText;\n\n\t\tif (view.opt('weekNumbers')) {\n\t\t\tweekText = this.start.format(view.opt('smallWeekFormat'));\n\n\t\t\treturn '' +\n\t\t\t\t'<th class=\"fc-axis fc-week-number ' + view.widgetHeaderClass + '\" ' + view.axisStyleAttr() + '>' +\n\t\t\t\t\tview.buildGotoAnchorHtml( // aside from link, important for matchCellWidths\n\t\t\t\t\t\t{ date: this.start, type: 'week', forceOff: this.colCnt > 1 },\n\t\t\t\t\t\thtmlEscape(weekText) // inner HTML\n\t\t\t\t\t) +\n\t\t\t\t'</th>';\n\t\t}\n\t\telse {\n\t\t\treturn '<th class=\"fc-axis ' + view.widgetHeaderClass + '\" ' + view.axisStyleAttr() + '></th>';\n\t\t}\n\t},\n\n\n\t// Generates the HTML that goes before the bg of the TimeGrid slot area. Long vertical column.\n\trenderBgIntroHtml: function() {\n\t\tvar view = this.view;\n\n\t\treturn '<td class=\"fc-axis ' + view.widgetContentClass + '\" ' + view.axisStyleAttr() + '></td>';\n\t},\n\n\n\t// Generates the HTML that goes before all other types of cells.\n\t// Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.\n\trenderIntroHtml: function() {\n\t\tvar view = this.view;\n\n\t\treturn '<td class=\"fc-axis\" ' + view.axisStyleAttr() + '></td>';\n\t}\n\n};\n\n\n// Methods that will customize the rendering behavior of the AgendaView's dayGrid\nvar agendaDayGridMethods = {\n\n\n\t// Generates the HTML that goes before the all-day cells\n\trenderBgIntroHtml: function() {\n\t\tvar view = this.view;\n\n\t\treturn '' +\n\t\t\t'<td class=\"fc-axis ' + view.widgetContentClass + '\" ' + view.axisStyleAttr() + '>' +\n\t\t\t\t'<span>' + // needed for matchCellWidths\n\t\t\t\t\tview.getAllDayHtml() +\n\t\t\t\t'</span>' +\n\t\t\t'</td>';\n\t},\n\n\n\t// Generates the HTML that goes before all other types of cells.\n\t// Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.\n\trenderIntroHtml: function() {\n\t\tvar view = this.view;\n\n\t\treturn '<td class=\"fc-axis\" ' + view.axisStyleAttr() + '></td>';\n\t}\n\n};\n\n;;\n\nvar AGENDA_ALL_DAY_EVENT_LIMIT = 5;\n\n// potential nice values for the slot-duration and interval-duration\n// from largest to smallest\nvar AGENDA_STOCK_SUB_DURATIONS = [\n\t{ hours: 1 },\n\t{ minutes: 30 },\n\t{ minutes: 15 },\n\t{ seconds: 30 },\n\t{ seconds: 15 }\n];\n\nfcViews.agenda = {\n\t'class': AgendaView,\n\tdefaults: {\n\t\tallDaySlot: true,\n\t\tslotDuration: '00:30:00',\n\t\tminTime: '00:00:00',\n\t\tmaxTime: '24:00:00',\n\t\tslotEventOverlap: true // a bad name. confused with overlap/constraint system\n\t}\n};\n\nfcViews.agendaDay = {\n\ttype: 'agenda',\n\tduration: { days: 1 }\n};\n\nfcViews.agendaWeek = {\n\ttype: 'agenda',\n\tduration: { weeks: 1 }\n};\n;;\n\n/*\nResponsible for the scroller, and forwarding event-related actions into the \"grid\"\n*/\nvar ListView = View.extend({\n\n\tgrid: null,\n\tscroller: null,\n\n\tinitialize: function() {\n\t\tthis.grid = new ListViewGrid(this);\n\t\tthis.scroller = new Scroller({\n\t\t\toverflowX: 'hidden',\n\t\t\toverflowY: 'auto'\n\t\t});\n\t},\n\n\tsetRange: function(range) {\n\t\tView.prototype.setRange.call(this, range); // super\n\n\t\tthis.grid.setRange(range); // needs to process range-related options\n\t},\n\n\trenderSkeleton: function() {\n\t\tthis.el.addClass(\n\t\t\t'fc-list-view ' +\n\t\t\tthis.widgetContentClass\n\t\t);\n\n\t\tthis.scroller.render();\n\t\tthis.scroller.el.appendTo(this.el);\n\n\t\tthis.grid.setElement(this.scroller.scrollEl);\n\t},\n\n\tunrenderSkeleton: function() {\n\t\tthis.scroller.destroy(); // will remove the Grid too\n\t},\n\n\tsetHeight: function(totalHeight, isAuto) {\n\t\tthis.scroller.setHeight(this.computeScrollerHeight(totalHeight));\n\t},\n\n\tcomputeScrollerHeight: function(totalHeight) {\n\t\treturn totalHeight -\n\t\t\tsubtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller\n\t},\n\n\trenderEvents: function(events) {\n\t\tthis.grid.renderEvents(events);\n\t},\n\n\tunrenderEvents: function() {\n\t\tthis.grid.unrenderEvents();\n\t},\n\n\tisEventResizable: function(event) {\n\t\treturn false;\n\t},\n\n\tisEventDraggable: function(event) {\n\t\treturn false;\n\t}\n\n});\n\n/*\nResponsible for event rendering and user-interaction.\nIts \"el\" is the inner-content of the above view's scroller.\n*/\nvar ListViewGrid = Grid.extend({\n\n\tsegSelector: '.fc-list-item', // which elements accept event actions\n\thasDayInteractions: false, // no day selection or day clicking\n\n\t// slices by day\n\tspanToSegs: function(span) {\n\t\tvar view = this.view;\n\t\tvar dayStart = view.start.clone().time(0); // timed, so segs get times!\n\t\tvar dayIndex = 0;\n\t\tvar seg;\n\t\tvar segs = [];\n\n\t\twhile (dayStart < view.end) {\n\n\t\t\tseg = intersectRanges(span, {\n\t\t\t\tstart: dayStart,\n\t\t\t\tend: dayStart.clone().add(1, 'day')\n\t\t\t});\n\n\t\t\tif (seg) {\n\t\t\t\tseg.dayIndex = dayIndex;\n\t\t\t\tsegs.push(seg);\n\t\t\t}\n\n\t\t\tdayStart.add(1, 'day');\n\t\t\tdayIndex++;\n\n\t\t\t// detect when span won't go fully into the next day,\n\t\t\t// and mutate the latest seg to the be the end.\n\t\t\tif (\n\t\t\t\tseg && !seg.isEnd && span.end.hasTime() &&\n\t\t\t\tspan.end < dayStart.clone().add(this.view.nextDayThreshold)\n\t\t\t) {\n\t\t\t\tseg.end = span.end.clone();\n\t\t\t\tseg.isEnd = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn segs;\n\t},\n\n\t// like \"4:00am\"\n\tcomputeEventTimeFormat: function() {\n\t\treturn this.view.opt('mediumTimeFormat');\n\t},\n\n\t// for events with a url, the whole <tr> should be clickable,\n\t// but it's impossible to wrap with an <a> tag. simulate this.\n\thandleSegClick: function(seg, ev) {\n\t\tvar url;\n\n\t\tGrid.prototype.handleSegClick.apply(this, arguments); // super. might prevent the default action\n\n\t\t// not clicking on or within an <a> with an href\n\t\tif (!$(ev.target).closest('a[href]').length) {\n\t\t\turl = seg.event.url;\n\t\t\tif (url && !ev.isDefaultPrevented()) { // jsEvent not cancelled in handler\n\t\t\t\twindow.location.href = url; // simulate link click\n\t\t\t}\n\t\t}\n\t},\n\n\t// returns list of foreground segs that were actually rendered\n\trenderFgSegs: function(segs) {\n\t\tsegs = this.renderFgSegEls(segs); // might filter away hidden events\n\n\t\tif (!segs.length) {\n\t\t\tthis.renderEmptyMessage();\n\t\t}\n\t\telse {\n\t\t\tthis.renderSegList(segs);\n\t\t}\n\n\t\treturn segs;\n\t},\n\n\trenderEmptyMessage: function() {\n\t\tthis.el.html(\n\t\t\t'<div class=\"fc-list-empty-wrap2\">' + // TODO: try less wraps\n\t\t\t'<div class=\"fc-list-empty-wrap1\">' +\n\t\t\t'<div class=\"fc-list-empty\">' +\n\t\t\t\thtmlEscape(this.view.opt('noEventsMessage')) +\n\t\t\t'</div>' +\n\t\t\t'</div>' +\n\t\t\t'</div>'\n\t\t);\n\t},\n\n\t// render the event segments in the view\n\trenderSegList: function(allSegs) {\n\t\tvar segsByDay = this.groupSegsByDay(allSegs); // sparse array\n\t\tvar dayIndex;\n\t\tvar daySegs;\n\t\tvar i;\n\t\tvar tableEl = $('<table class=\"fc-list-table\"><tbody/></table>');\n\t\tvar tbodyEl = tableEl.find('tbody');\n\n\t\tfor (dayIndex = 0; dayIndex < segsByDay.length; dayIndex++) {\n\t\t\tdaySegs = segsByDay[dayIndex];\n\t\t\tif (daySegs) { // sparse array, so might be undefined\n\n\t\t\t\t// append a day header\n\t\t\t\ttbodyEl.append(this.dayHeaderHtml(\n\t\t\t\t\tthis.view.start.clone().add(dayIndex, 'days')\n\t\t\t\t));\n\n\t\t\t\tthis.sortEventSegs(daySegs);\n\n\t\t\t\tfor (i = 0; i < daySegs.length; i++) {\n\t\t\t\t\ttbodyEl.append(daySegs[i].el); // append event row\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.el.empty().append(tableEl);\n\t},\n\n\t// Returns a sparse array of arrays, segs grouped by their dayIndex\n\tgroupSegsByDay: function(segs) {\n\t\tvar segsByDay = []; // sparse array\n\t\tvar i, seg;\n\n\t\tfor (i = 0; i < segs.length; i++) {\n\t\t\tseg = segs[i];\n\t\t\t(segsByDay[seg.dayIndex] || (segsByDay[seg.dayIndex] = []))\n\t\t\t\t.push(seg);\n\t\t}\n\n\t\treturn segsByDay;\n\t},\n\n\t// generates the HTML for the day headers that live amongst the event rows\n\tdayHeaderHtml: function(dayDate) {\n\t\tvar view = this.view;\n\t\tvar mainFormat = view.opt('listDayFormat');\n\t\tvar altFormat = view.opt('listDayAltFormat');\n\n\t\treturn '<tr class=\"fc-list-heading\" data-date=\"' + dayDate.format('YYYY-MM-DD') + '\">' +\n\t\t\t'<td class=\"' + view.widgetHeaderClass + '\" colspan=\"3\">' +\n\t\t\t\t(mainFormat ?\n\t\t\t\t\tview.buildGotoAnchorHtml(\n\t\t\t\t\t\tdayDate,\n\t\t\t\t\t\t{ 'class': 'fc-list-heading-main' },\n\t\t\t\t\t\thtmlEscape(dayDate.format(mainFormat)) // inner HTML\n\t\t\t\t\t) :\n\t\t\t\t\t'') +\n\t\t\t\t(altFormat ?\n\t\t\t\t\tview.buildGotoAnchorHtml(\n\t\t\t\t\t\tdayDate,\n\t\t\t\t\t\t{ 'class': 'fc-list-heading-alt' },\n\t\t\t\t\t\thtmlEscape(dayDate.format(altFormat)) // inner HTML\n\t\t\t\t\t) :\n\t\t\t\t\t'') +\n\t\t\t'</td>' +\n\t\t'</tr>';\n\t},\n\n\t// generates the HTML for a single event row\n\tfgSegHtml: function(seg) {\n\t\tvar view = this.view;\n\t\tvar classes = [ 'fc-list-item' ].concat(this.getSegCustomClasses(seg));\n\t\tvar bgColor = this.getSegBackgroundColor(seg);\n\t\tvar event = seg.event;\n\t\tvar url = event.url;\n\t\tvar timeHtml;\n\n\t\tif (event.allDay) {\n\t\t\ttimeHtml = view.getAllDayHtml();\n\t\t}\n\t\telse if (view.isMultiDayEvent(event)) { // if the event appears to span more than one day\n\t\t\tif (seg.isStart || seg.isEnd) { // outer segment that probably lasts part of the day\n\t\t\t\ttimeHtml = htmlEscape(this.getEventTimeText(seg));\n\t\t\t}\n\t\t\telse { // inner segment that lasts the whole day\n\t\t\t\ttimeHtml = view.getAllDayHtml();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Display the normal time text for the *event's* times\n\t\t\ttimeHtml = htmlEscape(this.getEventTimeText(event));\n\t\t}\n\n\t\tif (url) {\n\t\t\tclasses.push('fc-has-url');\n\t\t}\n\n\t\treturn '<tr class=\"' + classes.join(' ') + '\">' +\n\t\t\t(this.displayEventTime ?\n\t\t\t\t'<td class=\"fc-list-item-time ' + view.widgetContentClass + '\">' +\n\t\t\t\t\t(timeHtml || '') +\n\t\t\t\t'</td>' :\n\t\t\t\t'') +\n\t\t\t'<td class=\"fc-list-item-marker ' + view.widgetContentClass + '\">' +\n\t\t\t\t'<span class=\"fc-event-dot\"' +\n\t\t\t\t(bgColor ?\n\t\t\t\t\t' style=\"background-color:' + bgColor + '\"' :\n\t\t\t\t\t'') +\n\t\t\t\t'></span>' +\n\t\t\t'</td>' +\n\t\t\t'<td class=\"fc-list-item-title ' + view.widgetContentClass + '\">' +\n\t\t\t\t'<a' + (url ? ' href=\"' + htmlEscape(url) + '\"' : '') + '>' +\n\t\t\t\t\thtmlEscape(seg.event.title || '') +\n\t\t\t\t'</a>' +\n\t\t\t'</td>' +\n\t\t'</tr>';\n\t}\n\n});\n\n;;\n\nfcViews.list = {\n\t'class': ListView,\n\tbuttonTextKey: 'list', // what to lookup in locale files\n\tdefaults: {\n\t\tbuttonText: 'list', // text to display for English\n\t\tlistDayFormat: 'LL', // like \"January 1, 2016\"\n\t\tnoEventsMessage: 'No events to display'\n\t}\n};\n\nfcViews.listDay = {\n\ttype: 'list',\n\tduration: { days: 1 },\n\tdefaults: {\n\t\tlistDayFormat: 'dddd' // day-of-week is all we need. full date is probably in header\n\t}\n};\n\nfcViews.listWeek = {\n\ttype: 'list',\n\tduration: { weeks: 1 },\n\tdefaults: {\n\t\tlistDayFormat: 'dddd', // day-of-week is more important\n\t\tlistDayAltFormat: 'LL'\n\t}\n};\n\nfcViews.listMonth = {\n\ttype: 'list',\n\tduration: { month: 1 },\n\tdefaults: {\n\t\tlistDayAltFormat: 'dddd' // day-of-week is nice-to-have\n\t}\n};\n\nfcViews.listYear = {\n\ttype: 'list',\n\tduration: { year: 1 },\n\tdefaults: {\n\t\tlistDayAltFormat: 'dddd' // day-of-week is nice-to-have\n\t}\n};\n\n;;\n\r\nreturn FC; // export for Node/CommonJS\r\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA3My5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vZnVsbGNhbGVuZGFyL2Rpc3QvZnVsbGNhbGVuZGFyLmpzP2I1NzciXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBGdWxsQ2FsZW5kYXIgdjMuMC4xXG4gKiBEb2NzICYgTGljZW5zZTogaHR0cDovL2Z1bGxjYWxlbmRhci5pby9cbiAqIChjKSAyMDE2IEFkYW0gU2hhd1xuICovXG5cbihmdW5jdGlvbihmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcblx0XHRkZWZpbmUoWyAnanF1ZXJ5JywgJ21vbWVudCcgXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7IC8vIE5vZGUvQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnanF1ZXJ5JyksIHJlcXVpcmUoJ21vbWVudCcpKTtcblx0fVxuXHRlbHNlIHtcblx0XHRmYWN0b3J5KGpRdWVyeSwgbW9tZW50KTtcblx0fVxufSkoZnVuY3Rpb24oJCwgbW9tZW50KSB7XG5cbjs7XG5cbnZhciBGQyA9ICQuZnVsbENhbGVuZGFyID0ge1xuXHR2ZXJzaW9uOiBcIjMuMC4xXCIsXG5cdGludGVybmFsQXBpVmVyc2lvbjogNlxufTtcbnZhciBmY1ZpZXdzID0gRkMudmlld3MgPSB7fTtcblxuXG4kLmZuLmZ1bGxDYWxlbmRhciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOyAvLyBmb3IgYSBwb3NzaWJsZSBtZXRob2QgY2FsbFxuXHR2YXIgcmVzID0gdGhpczsgLy8gd2hhdCB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuICh0aGlzIGpRdWVyeSBvYmplY3QgYnkgZGVmYXVsdClcblxuXHR0aGlzLmVhY2goZnVuY3Rpb24oaSwgX2VsZW1lbnQpIHsgLy8gbG9vcCBlYWNoIERPTSBlbGVtZW50IGludm9sdmVkXG5cdFx0dmFyIGVsZW1lbnQgPSAkKF9lbGVtZW50KTtcblx0XHR2YXIgY2FsZW5kYXIgPSBlbGVtZW50LmRhdGEoJ2Z1bGxDYWxlbmRhcicpOyAvLyBnZXQgdGhlIGV4aXN0aW5nIGNhbGVuZGFyIG9iamVjdCAoaWYgYW55KVxuXHRcdHZhciBzaW5nbGVSZXM7IC8vIHRoZSByZXR1cm5lZCB2YWx1ZSBvZiB0aGlzIHNpbmdsZSBtZXRob2QgY2FsbFxuXG5cdFx0Ly8gYSBtZXRob2QgY2FsbFxuXHRcdGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcblx0XHRcdGlmIChjYWxlbmRhciAmJiAkLmlzRnVuY3Rpb24oY2FsZW5kYXJbb3B0aW9uc10pKSB7XG5cdFx0XHRcdHNpbmdsZVJlcyA9IGNhbGVuZGFyW29wdGlvbnNdLmFwcGx5KGNhbGVuZGFyLCBhcmdzKTtcblx0XHRcdFx0aWYgKCFpKSB7XG5cdFx0XHRcdFx0cmVzID0gc2luZ2xlUmVzOyAvLyByZWNvcmQgdGhlIGZpcnN0IG1ldGhvZCBjYWxsIHJlc3VsdFxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChvcHRpb25zID09PSAnZGVzdHJveScpIHsgLy8gZm9yIHRoZSBkZXN0cm95IG1ldGhvZCwgbXVzdCByZW1vdmUgQ2FsZW5kYXIgb2JqZWN0IGRhdGFcblx0XHRcdFx0XHRlbGVtZW50LnJlbW92ZURhdGEoJ2Z1bGxDYWxlbmRhcicpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIGEgbmV3IGNhbGVuZGFyIGluaXRpYWxpemF0aW9uXG5cdFx0ZWxzZSBpZiAoIWNhbGVuZGFyKSB7IC8vIGRvbid0IGluaXRpYWxpemUgdHdpY2Vcblx0XHRcdGNhbGVuZGFyID0gbmV3IENhbGVuZGFyKGVsZW1lbnQsIG9wdGlvbnMpO1xuXHRcdFx0ZWxlbWVudC5kYXRhKCdmdWxsQ2FsZW5kYXInLCBjYWxlbmRhcik7XG5cdFx0XHRjYWxlbmRhci5yZW5kZXIoKTtcblx0XHR9XG5cdH0pO1xuXHRcblx0cmV0dXJuIHJlcztcbn07XG5cblxudmFyIGNvbXBsZXhPcHRpb25zID0gWyAvLyBuYW1lcyBvZiBvcHRpb25zIHRoYXQgYXJlIG9iamVjdHMgd2hvc2UgcHJvcGVydGllcyBzaG91bGQgYmUgY29tYmluZWRcblx0J2hlYWRlcicsXG5cdCdidXR0b25UZXh0Jyxcblx0J2J1dHRvbkljb25zJyxcblx0J3RoZW1lQnV0dG9uSWNvbnMnXG5dO1xuXG5cbi8vIE1lcmdlcyBhbiBhcnJheSBvZiBvcHRpb24gb2JqZWN0cyBpbnRvIGEgc2luZ2xlIG9iamVjdFxuZnVuY3Rpb24gbWVyZ2VPcHRpb25zKG9wdGlvbk9ianMpIHtcblx0cmV0dXJuIG1lcmdlUHJvcHMob3B0aW9uT2JqcywgY29tcGxleE9wdGlvbnMpO1xufVxuXG47O1xuXG4vLyBleHBvcnRzXG5GQy5pbnRlcnNlY3RSYW5nZXMgPSBpbnRlcnNlY3RSYW5nZXM7XG5GQy5hcHBseUFsbCA9IGFwcGx5QWxsO1xuRkMuZGVib3VuY2UgPSBkZWJvdW5jZTtcbkZDLmlzSW50ID0gaXNJbnQ7XG5GQy5odG1sRXNjYXBlID0gaHRtbEVzY2FwZTtcbkZDLmNzc1RvU3RyID0gY3NzVG9TdHI7XG5GQy5wcm94eSA9IHByb3h5O1xuRkMuY2FwaXRhbGlzZUZpcnN0TGV0dGVyID0gY2FwaXRhbGlzZUZpcnN0TGV0dGVyO1xuXG5cbi8qIEZ1bGxDYWxlbmRhci1zcGVjaWZpYyBET00gVXRpbGl0aWVzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG4vLyBHaXZlbiB0aGUgc2Nyb2xsYmFyIHdpZHRocyBvZiBzb21lIG90aGVyIGNvbnRhaW5lciwgY3JlYXRlIGJvcmRlcnMvbWFyZ2lucyBvbiByb3dFbHMgaW4gb3JkZXIgdG8gbWF0Y2ggdGhlIGxlZnRcbi8vIGFuZCByaWdodCBzcGFjZSB0aGF0IHdhcyBvZmZzZXQgYnkgdGhlIHNjcm9sbGJhcnMuIEEgMS1waXhlbCBib3JkZXIgZmlyc3QsIHRoZW4gbWFyZ2luIGJleW9uZCB0aGF0LlxuZnVuY3Rpb24gY29tcGVuc2F0ZVNjcm9sbChyb3dFbHMsIHNjcm9sbGJhcldpZHRocykge1xuXHRpZiAoc2Nyb2xsYmFyV2lkdGhzLmxlZnQpIHtcblx0XHRyb3dFbHMuY3NzKHtcblx0XHRcdCdib3JkZXItbGVmdC13aWR0aCc6IDEsXG5cdFx0XHQnbWFyZ2luLWxlZnQnOiBzY3JvbGxiYXJXaWR0aHMubGVmdCAtIDFcblx0XHR9KTtcblx0fVxuXHRpZiAoc2Nyb2xsYmFyV2lkdGhzLnJpZ2h0KSB7XG5cdFx0cm93RWxzLmNzcyh7XG5cdFx0XHQnYm9yZGVyLXJpZ2h0LXdpZHRoJzogMSxcblx0XHRcdCdtYXJnaW4tcmlnaHQnOiBzY3JvbGxiYXJXaWR0aHMucmlnaHQgLSAxXG5cdFx0fSk7XG5cdH1cbn1cblxuXG4vLyBVbmRvZXMgY29tcGVuc2F0ZVNjcm9sbCBhbmQgcmVzdG9yZXMgYWxsIGJvcmRlcnMvbWFyZ2luc1xuZnVuY3Rpb24gdW5jb21wZW5zYXRlU2Nyb2xsKHJvd0Vscykge1xuXHRyb3dFbHMuY3NzKHtcblx0XHQnbWFyZ2luLWxlZnQnOiAnJyxcblx0XHQnbWFyZ2luLXJpZ2h0JzogJycsXG5cdFx0J2JvcmRlci1sZWZ0LXdpZHRoJzogJycsXG5cdFx0J2JvcmRlci1yaWdodC13aWR0aCc6ICcnXG5cdH0pO1xufVxuXG5cbi8vIE1ha2UgdGhlIG1vdXNlIGN1cnNvciBleHByZXNzIHRoYXQgYW4gZXZlbnQgaXMgbm90IGFsbG93ZWQgaW4gdGhlIGN1cnJlbnQgYXJlYVxuZnVuY3Rpb24gZGlzYWJsZUN1cnNvcigpIHtcblx0JCgnYm9keScpLmFkZENsYXNzKCdmYy1ub3QtYWxsb3dlZCcpO1xufVxuXG5cbi8vIFJldHVybnMgdGhlIG1vdXNlIGN1cnNvciB0byBpdHMgb3JpZ2luYWwgbG9va1xuZnVuY3Rpb24gZW5hYmxlQ3Vyc29yKCkge1xuXHQkKCdib2R5JykucmVtb3ZlQ2xhc3MoJ2ZjLW5vdC1hbGxvd2VkJyk7XG59XG5cblxuLy8gR2l2ZW4gYSB0b3RhbCBhdmFpbGFibGUgaGVpZ2h0IHRvIGZpbGwsIGhhdmUgYGVsc2AgKGVzc2VudGlhbGx5IGNoaWxkIHJvd3MpIGV4cGFuZCB0byBhY2NvbW9kYXRlLlxuLy8gQnkgZGVmYXVsdCwgYWxsIGVsZW1lbnRzIHRoYXQgYXJlIHNob3J0ZXIgdGhhbiB0aGUgcmVjb21tZW5kZWQgaGVpZ2h0IGFyZSBleHBhbmRlZCB1bmlmb3JtbHksIG5vdCBjb25zaWRlcmluZ1xuLy8gYW55IG90aGVyIGVscyB0aGF0IGFyZSBhbHJlYWR5IHRvbyB0YWxsLiBpZiBgc2hvdWxkUmVkaXN0cmlidXRlYCBpcyBvbiwgaXQgY29uc2lkZXJzIHRoZXNlIHRhbGwgcm93cyBhbmQgXG4vLyByZWR1Y2VzIHRoZSBhdmFpbGFibGUgaGVpZ2h0LlxuZnVuY3Rpb24gZGlzdHJpYnV0ZUhlaWdodChlbHMsIGF2YWlsYWJsZUhlaWdodCwgc2hvdWxkUmVkaXN0cmlidXRlKSB7XG5cblx0Ly8gKkZMT09SSU5HIE5PVEUqOiB3ZSBmbG9vciBpbiBjZXJ0YWluIHBsYWNlcyBiZWNhdXNlIHpvb20gY2FuIGdpdmUgaW5hY2N1cmF0ZSBmbG9hdGluZy1wb2ludCBkaW1lbnNpb25zLFxuXHQvLyBhbmQgaXQgaXMgYmV0dGVyIHRvIGJlIHNob3J0ZXIgdGhhbiB0YWxsZXIsIHRvIGF2b2lkIGNyZWF0aW5nIHVubmVjZXNzYXJ5IHNjcm9sbGJhcnMuXG5cblx0dmFyIG1pbk9mZnNldDEgPSBNYXRoLmZsb29yKGF2YWlsYWJsZUhlaWdodCAvIGVscy5sZW5ndGgpOyAvLyBmb3Igbm9uLWxhc3QgZWxlbWVudFxuXHR2YXIgbWluT2Zmc2V0MiA9IE1hdGguZmxvb3IoYXZhaWxhYmxlSGVpZ2h0IC0gbWluT2Zmc2V0MSAqIChlbHMubGVuZ3RoIC0gMSkpOyAvLyBmb3IgbGFzdCBlbGVtZW50ICpGTE9PUklORyBOT1RFKlxuXHR2YXIgZmxleEVscyA9IFtdOyAvLyBlbGVtZW50cyB0aGF0IGFyZSBhbGxvd2VkIHRvIGV4cGFuZC4gYXJyYXkgb2YgRE9NIG5vZGVzXG5cdHZhciBmbGV4T2Zmc2V0cyA9IFtdOyAvLyBhbW91bnQgb2YgdmVydGljYWwgc3BhY2UgaXQgdGFrZXMgdXBcblx0dmFyIGZsZXhIZWlnaHRzID0gW107IC8vIGFjdHVhbCBjc3MgaGVpZ2h0XG5cdHZhciB1c2VkSGVpZ2h0ID0gMDtcblxuXHR1bmRpc3RyaWJ1dGVIZWlnaHQoZWxzKTsgLy8gZ2l2ZSBhbGwgZWxlbWVudHMgdGhlaXIgbmF0dXJhbCBoZWlnaHRcblxuXHQvLyBmaW5kIGVsZW1lbnRzIHRoYXQgYXJlIGJlbG93IHRoZSByZWNvbW1lbmRlZCBoZWlnaHQgKGV4cGFuZGFibGUpLlxuXHQvLyBpbXBvcnRhbnQgdG8gcXVlcnkgZm9yIGhlaWdodHMgaW4gYSBzaW5nbGUgZmlyc3QgcGFzcyAodG8gYXZvaWQgcmVmbG93IG9zY2lsbGF0aW9uKS5cblx0ZWxzLmVhY2goZnVuY3Rpb24oaSwgZWwpIHtcblx0XHR2YXIgbWluT2Zmc2V0ID0gaSA9PT0gZWxzLmxlbmd0aCAtIDEgPyBtaW5PZmZzZXQyIDogbWluT2Zmc2V0MTtcblx0XHR2YXIgbmF0dXJhbE9mZnNldCA9ICQoZWwpLm91dGVySGVpZ2h0KHRydWUpO1xuXG5cdFx0aWYgKG5hdHVyYWxPZmZzZXQgPCBtaW5PZmZzZXQpIHtcblx0XHRcdGZsZXhFbHMucHVzaChlbCk7XG5cdFx0XHRmbGV4T2Zmc2V0cy5wdXNoKG5hdHVyYWxPZmZzZXQpO1xuXHRcdFx0ZmxleEhlaWdodHMucHVzaCgkKGVsKS5oZWlnaHQoKSk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gdGhpcyBlbGVtZW50IHN0cmV0Y2hlcyBwYXN0IHJlY29tbWVuZGVkIGhlaWdodCAobm9uLWV4cGFuZGFibGUpLiBtYXJrIHRoZSBzcGFjZSBhcyBvY2N1cGllZC5cblx0XHRcdHVzZWRIZWlnaHQgKz0gbmF0dXJhbE9mZnNldDtcblx0XHR9XG5cdH0pO1xuXG5cdC8vIHJlYWRqdXN0IHRoZSByZWNvbW1lbmRlZCBoZWlnaHQgdG8gb25seSBjb25zaWRlciB0aGUgaGVpZ2h0IGF2YWlsYWJsZSB0byBub24tbWF4ZWQtb3V0IHJvd3MuXG5cdGlmIChzaG91bGRSZWRpc3RyaWJ1dGUpIHtcblx0XHRhdmFpbGFibGVIZWlnaHQgLT0gdXNlZEhlaWdodDtcblx0XHRtaW5PZmZzZXQxID0gTWF0aC5mbG9vcihhdmFpbGFibGVIZWlnaHQgLyBmbGV4RWxzLmxlbmd0aCk7XG5cdFx0bWluT2Zmc2V0MiA9IE1hdGguZmxvb3IoYXZhaWxhYmxlSGVpZ2h0IC0gbWluT2Zmc2V0MSAqIChmbGV4RWxzLmxlbmd0aCAtIDEpKTsgLy8gKkZMT09SSU5HIE5PVEUqXG5cdH1cblxuXHQvLyBhc3NpZ24gaGVpZ2h0cyB0byBhbGwgZXhwYW5kYWJsZSBlbGVtZW50c1xuXHQkKGZsZXhFbHMpLmVhY2goZnVuY3Rpb24oaSwgZWwpIHtcblx0XHR2YXIgbWluT2Zmc2V0ID0gaSA9PT0gZmxleEVscy5sZW5ndGggLSAxID8gbWluT2Zmc2V0MiA6IG1pbk9mZnNldDE7XG5cdFx0dmFyIG5hdHVyYWxPZmZzZXQgPSBmbGV4T2Zmc2V0c1tpXTtcblx0XHR2YXIgbmF0dXJhbEhlaWdodCA9IGZsZXhIZWlnaHRzW2ldO1xuXHRcdHZhciBuZXdIZWlnaHQgPSBtaW5PZmZzZXQgLSAobmF0dXJhbE9mZnNldCAtIG5hdHVyYWxIZWlnaHQpOyAvLyBzdWJ0cmFjdCB0aGUgbWFyZ2luL3BhZGRpbmdcblxuXHRcdGlmIChuYXR1cmFsT2Zmc2V0IDwgbWluT2Zmc2V0KSB7IC8vIHdlIGNoZWNrIHRoaXMgYWdhaW4gYmVjYXVzZSByZWRpc3RyaWJ1dGlvbiBtaWdodCBoYXZlIGNoYW5nZWQgdGhpbmdzXG5cdFx0XHQkKGVsKS5oZWlnaHQobmV3SGVpZ2h0KTtcblx0XHR9XG5cdH0pO1xufVxuXG5cbi8vIFVuZG9lcyBkaXN0cnVidXRlSGVpZ2h0LCByZXN0b3JpbmcgYWxsIGVscyB0byB0aGVpciBuYXR1cmFsIGhlaWdodFxuZnVuY3Rpb24gdW5kaXN0cmlidXRlSGVpZ2h0KGVscykge1xuXHRlbHMuaGVpZ2h0KCcnKTtcbn1cblxuXG4vLyBHaXZlbiBgZWxzYCwgYSBqUXVlcnkgc2V0IG9mIDx0ZD4gY2VsbHMsIGZpbmQgdGhlIGNlbGwgd2l0aCB0aGUgbGFyZ2VzdCBuYXR1cmFsIHdpZHRoIGFuZCBzZXQgdGhlIHdpZHRocyBvZiBhbGwgdGhlXG4vLyBjZWxscyB0byBiZSB0aGF0IHdpZHRoLlxuLy8gUFJFUkVRVUlTSVRFOiBpZiB5b3Ugd2FudCBhIGNlbGwgdG8gdGFrZSB1cCB3aWR0aCwgaXQgbmVlZHMgdG8gaGF2ZSBhIHNpbmdsZSBpbm5lciBlbGVtZW50IHcvIGRpc3BsYXk6aW5saW5lXG5mdW5jdGlvbiBtYXRjaENlbGxXaWR0aHMoZWxzKSB7XG5cdHZhciBtYXhJbm5lcldpZHRoID0gMDtcblxuXHRlbHMuZmluZCgnPiAqJykuZWFjaChmdW5jdGlvbihpLCBpbm5lckVsKSB7XG5cdFx0dmFyIGlubmVyV2lkdGggPSAkKGlubmVyRWwpLm91dGVyV2lkdGgoKTtcblx0XHRpZiAoaW5uZXJXaWR0aCA+IG1heElubmVyV2lkdGgpIHtcblx0XHRcdG1heElubmVyV2lkdGggPSBpbm5lcldpZHRoO1xuXHRcdH1cblx0fSk7XG5cblx0bWF4SW5uZXJXaWR0aCsrOyAvLyBzb21ldGltZXMgbm90IGFjY3VyYXRlIG9mIHdpZHRoIHRoZSB0ZXh0IG5lZWRzIHRvIHN0YXkgb24gb25lIGxpbmUuIGluc3VyYW5jZVxuXG5cdGVscy53aWR0aChtYXhJbm5lcldpZHRoKTtcblxuXHRyZXR1cm4gbWF4SW5uZXJXaWR0aDtcbn1cblxuXG4vLyBHaXZlbiBvbmUgZWxlbWVudCB0aGF0IHJlc2lkZXMgaW5zaWRlIGFub3RoZXIsXG4vLyBTdWJ0cmFjdHMgdGhlIGhlaWdodCBvZiB0aGUgaW5uZXIgZWxlbWVudCBmcm9tIHRoZSBvdXRlciBlbGVtZW50LlxuZnVuY3Rpb24gc3VidHJhY3RJbm5lckVsSGVpZ2h0KG91dGVyRWwsIGlubmVyRWwpIHtcblx0dmFyIGJvdGggPSBvdXRlckVsLmFkZChpbm5lckVsKTtcblx0dmFyIGRpZmY7XG5cblx0Ly8gZWZmaW4nIElFOC85LzEwLzExIHNvbWV0aW1lcyByZXR1cm5zIDAgZm9yIGRpbWVuc2lvbnMuIHRoaXMgd2VpcmQgaGFjayB3YXMgdGhlIG9ubHkgdGhpbmcgdGhhdCB3b3JrZWRcblx0Ym90aC5jc3Moe1xuXHRcdHBvc2l0aW9uOiAncmVsYXRpdmUnLCAvLyBjYXVzZSBhIHJlZmxvdywgd2hpY2ggd2lsbCBmb3JjZSBmcmVzaCBkaW1lbnNpb24gcmVjYWxjdWxhdGlvblxuXHRcdGxlZnQ6IC0xIC8vIGVuc3VyZSByZWZsb3cgaW4gY2FzZSB0aGUgZWwgd2FzIGFscmVhZHkgcmVsYXRpdmUuIG5lZ2F0aXZlIGlzIGxlc3MgbGlrZWx5IHRvIGNhdXNlIG5ldyBzY3JvbGxcblx0fSk7XG5cdGRpZmYgPSBvdXRlckVsLm91dGVySGVpZ2h0KCkgLSBpbm5lckVsLm91dGVySGVpZ2h0KCk7IC8vIGdyYWIgdGhlIGRpbWVuc2lvbnNcblx0Ym90aC5jc3MoeyBwb3NpdGlvbjogJycsIGxlZnQ6ICcnIH0pOyAvLyB1bmRvIGhhY2tcblxuXHRyZXR1cm4gZGlmZjtcbn1cblxuXG4vKiBFbGVtZW50IEdlb20gVXRpbGl0aWVzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuRkMuZ2V0T3V0ZXJSZWN0ID0gZ2V0T3V0ZXJSZWN0O1xuRkMuZ2V0Q2xpZW50UmVjdCA9IGdldENsaWVudFJlY3Q7XG5GQy5nZXRDb250ZW50UmVjdCA9IGdldENvbnRlbnRSZWN0O1xuRkMuZ2V0U2Nyb2xsYmFyV2lkdGhzID0gZ2V0U2Nyb2xsYmFyV2lkdGhzO1xuXG5cbi8vIGJvcnJvd2VkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnktdWkvYmxvYi8xLjExLjAvdWkvY29yZS5qcyNMNTFcbmZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChlbCkge1xuXHR2YXIgcG9zaXRpb24gPSBlbC5jc3MoJ3Bvc2l0aW9uJyksXG5cdFx0c2Nyb2xsUGFyZW50ID0gZWwucGFyZW50cygpLmZpbHRlcihmdW5jdGlvbigpIHtcblx0XHRcdHZhciBwYXJlbnQgPSAkKHRoaXMpO1xuXHRcdFx0cmV0dXJuICgvKGF1dG98c2Nyb2xsKS8pLnRlc3QoXG5cdFx0XHRcdHBhcmVudC5jc3MoJ292ZXJmbG93JykgKyBwYXJlbnQuY3NzKCdvdmVyZmxvdy15JykgKyBwYXJlbnQuY3NzKCdvdmVyZmxvdy14Jylcblx0XHRcdCk7XG5cdFx0fSkuZXEoMCk7XG5cblx0cmV0dXJuIHBvc2l0aW9uID09PSAnZml4ZWQnIHx8ICFzY3JvbGxQYXJlbnQubGVuZ3RoID8gJChlbFswXS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50KSA6IHNjcm9sbFBhcmVudDtcbn1cblxuXG4vLyBRdWVyaWVzIHRoZSBvdXRlciBib3VuZGluZyBhcmVhIG9mIGEgalF1ZXJ5IGVsZW1lbnQuXG4vLyBSZXR1cm5zIGEgcmVjdGFuZ2xlIHdpdGggYWJzb2x1dGUgY29vcmRpbmF0ZXM6IGxlZnQsIHJpZ2h0IChleGNsdXNpdmUpLCB0b3AsIGJvdHRvbSAoZXhjbHVzaXZlKS5cbi8vIE9yaWdpbiBpcyBvcHRpb25hbC5cbmZ1bmN0aW9uIGdldE91dGVyUmVjdChlbCwgb3JpZ2luKSB7XG5cdHZhciBvZmZzZXQgPSBlbC5vZmZzZXQoKTtcblx0dmFyIGxlZnQgPSBvZmZzZXQubGVmdCAtIChvcmlnaW4gPyBvcmlnaW4ubGVmdCA6IDApO1xuXHR2YXIgdG9wID0gb2Zmc2V0LnRvcCAtIChvcmlnaW4gPyBvcmlnaW4udG9wIDogMCk7XG5cblx0cmV0dXJuIHtcblx0XHRsZWZ0OiBsZWZ0LFxuXHRcdHJpZ2h0OiBsZWZ0ICsgZWwub3V0ZXJXaWR0aCgpLFxuXHRcdHRvcDogdG9wLFxuXHRcdGJvdHRvbTogdG9wICsgZWwub3V0ZXJIZWlnaHQoKVxuXHR9O1xufVxuXG5cbi8vIFF1ZXJpZXMgdGhlIGFyZWEgd2l0aGluIHRoZSBtYXJnaW4vYm9yZGVyL3Njcm9sbGJhcnMgb2YgYSBqUXVlcnkgZWxlbWVudC4gRG9lcyBub3QgZ28gd2l0aGluIHRoZSBwYWRkaW5nLlxuLy8gUmV0dXJucyBhIHJlY3RhbmdsZSB3aXRoIGFic29sdXRlIGNvb3JkaW5hdGVzOiBsZWZ0LCByaWdodCAoZXhjbHVzaXZlKSwgdG9wLCBib3R0b20gKGV4Y2x1c2l2ZSkuXG4vLyBPcmlnaW4gaXMgb3B0aW9uYWwuXG4vLyBOT1RFOiBzaG91bGQgdXNlIGNsaWVudExlZnQvY2xpZW50VG9wLCBidXQgdmVyeSB1bnJlbGlhYmxlIGNyb3NzLWJyb3dzZXIuXG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0KGVsLCBvcmlnaW4pIHtcblx0dmFyIG9mZnNldCA9IGVsLm9mZnNldCgpO1xuXHR2YXIgc2Nyb2xsYmFyV2lkdGhzID0gZ2V0U2Nyb2xsYmFyV2lkdGhzKGVsKTtcblx0dmFyIGxlZnQgPSBvZmZzZXQubGVmdCArIGdldENzc0Zsb2F0KGVsLCAnYm9yZGVyLWxlZnQtd2lkdGgnKSArIHNjcm9sbGJhcldpZHRocy5sZWZ0IC0gKG9yaWdpbiA/IG9yaWdpbi5sZWZ0IDogMCk7XG5cdHZhciB0b3AgPSBvZmZzZXQudG9wICsgZ2V0Q3NzRmxvYXQoZWwsICdib3JkZXItdG9wLXdpZHRoJykgKyBzY3JvbGxiYXJXaWR0aHMudG9wIC0gKG9yaWdpbiA/IG9yaWdpbi50b3AgOiAwKTtcblxuXHRyZXR1cm4ge1xuXHRcdGxlZnQ6IGxlZnQsXG5cdFx0cmlnaHQ6IGxlZnQgKyBlbFswXS5jbGllbnRXaWR0aCwgLy8gY2xpZW50V2lkdGggaW5jbHVkZXMgcGFkZGluZyBidXQgTk9UIHNjcm9sbGJhcnNcblx0XHR0b3A6IHRvcCxcblx0XHRib3R0b206IHRvcCArIGVsWzBdLmNsaWVudEhlaWdodCAvLyBjbGllbnRIZWlnaHQgaW5jbHVkZXMgcGFkZGluZyBidXQgTk9UIHNjcm9sbGJhcnNcblx0fTtcbn1cblxuXG4vLyBRdWVyaWVzIHRoZSBhcmVhIHdpdGhpbiB0aGUgbWFyZ2luL2JvcmRlci9wYWRkaW5nIG9mIGEgalF1ZXJ5IGVsZW1lbnQuIEFzc3VtZWQgbm90IHRvIGhhdmUgc2Nyb2xsYmFycy5cbi8vIFJldHVybnMgYSByZWN0YW5nbGUgd2l0aCBhYnNvbHV0ZSBjb29yZGluYXRlczogbGVmdCwgcmlnaHQgKGV4Y2x1c2l2ZSksIHRvcCwgYm90dG9tIChleGNsdXNpdmUpLlxuLy8gT3JpZ2luIGlzIG9wdGlvbmFsLlxuZnVuY3Rpb24gZ2V0Q29udGVudFJlY3QoZWwsIG9yaWdpbikge1xuXHR2YXIgb2Zmc2V0ID0gZWwub2Zmc2V0KCk7IC8vIGp1c3Qgb3V0c2lkZSBvZiBib3JkZXIsIG1hcmdpbiBub3QgaW5jbHVkZWRcblx0dmFyIGxlZnQgPSBvZmZzZXQubGVmdCArIGdldENzc0Zsb2F0KGVsLCAnYm9yZGVyLWxlZnQtd2lkdGgnKSArIGdldENzc0Zsb2F0KGVsLCAncGFkZGluZy1sZWZ0JykgLVxuXHRcdChvcmlnaW4gPyBvcmlnaW4ubGVmdCA6IDApO1xuXHR2YXIgdG9wID0gb2Zmc2V0LnRvcCArIGdldENzc0Zsb2F0KGVsLCAnYm9yZGVyLXRvcC13aWR0aCcpICsgZ2V0Q3NzRmxvYXQoZWwsICdwYWRkaW5nLXRvcCcpIC1cblx0XHQob3JpZ2luID8gb3JpZ2luLnRvcCA6IDApO1xuXG5cdHJldHVybiB7XG5cdFx0bGVmdDogbGVmdCxcblx0XHRyaWdodDogbGVmdCArIGVsLndpZHRoKCksXG5cdFx0dG9wOiB0b3AsXG5cdFx0Ym90dG9tOiB0b3AgKyBlbC5oZWlnaHQoKVxuXHR9O1xufVxuXG5cbi8vIFJldHVybnMgdGhlIGNvbXB1dGVkIGxlZnQvcmlnaHQvdG9wL2JvdHRvbSBzY3JvbGxiYXIgd2lkdGhzIGZvciB0aGUgZ2l2ZW4galF1ZXJ5IGVsZW1lbnQuXG4vLyBOT1RFOiBzaG91bGQgdXNlIGNsaWVudExlZnQvY2xpZW50VG9wLCBidXQgdmVyeSB1bnJlbGlhYmxlIGNyb3NzLWJyb3dzZXIuXG5mdW5jdGlvbiBnZXRTY3JvbGxiYXJXaWR0aHMoZWwpIHtcblx0dmFyIGxlZnRSaWdodFdpZHRoID0gZWwuaW5uZXJXaWR0aCgpIC0gZWxbMF0uY2xpZW50V2lkdGg7IC8vIHRoZSBwYWRkaW5ncyBjYW5jZWwgb3V0LCBsZWF2aW5nIHRoZSBzY3JvbGxiYXJzXG5cdHZhciB3aWR0aHMgPSB7XG5cdFx0bGVmdDogMCxcblx0XHRyaWdodDogMCxcblx0XHR0b3A6IDAsXG5cdFx0Ym90dG9tOiBlbC5pbm5lckhlaWdodCgpIC0gZWxbMF0uY2xpZW50SGVpZ2h0IC8vIHRoZSBwYWRkaW5ncyBjYW5jZWwgb3V0LCBsZWF2aW5nIHRoZSBib3R0b20gc2Nyb2xsYmFyXG5cdH07XG5cblx0aWYgKGdldElzTGVmdFJ0bFNjcm9sbGJhcnMoKSAmJiBlbC5jc3MoJ2RpcmVjdGlvbicpID09ICdydGwnKSB7IC8vIGlzIHRoZSBzY3JvbGxiYXIgb24gdGhlIGxlZnQgc2lkZT9cblx0XHR3aWR0aHMubGVmdCA9IGxlZnRSaWdodFdpZHRoO1xuXHR9XG5cdGVsc2Uge1xuXHRcdHdpZHRocy5yaWdodCA9IGxlZnRSaWdodFdpZHRoO1xuXHR9XG5cblx0cmV0dXJuIHdpZHRocztcbn1cblxuXG4vLyBMb2dpYyBmb3IgZGV0ZXJtaW5pbmcgaWYsIHdoZW4gdGhlIGVsZW1lbnQgaXMgcmlnaHQtdG8tbGVmdCwgdGhlIHNjcm9sbGJhciBhcHBlYXJzIG9uIHRoZSBsZWZ0IHNpZGVcblxudmFyIF9pc0xlZnRSdGxTY3JvbGxiYXJzID0gbnVsbDtcblxuZnVuY3Rpb24gZ2V0SXNMZWZ0UnRsU2Nyb2xsYmFycygpIHsgLy8gcmVzcG9uc2libGUgZm9yIGNhY2hpbmcgdGhlIGNvbXB1dGF0aW9uXG5cdGlmIChfaXNMZWZ0UnRsU2Nyb2xsYmFycyA9PT0gbnVsbCkge1xuXHRcdF9pc0xlZnRSdGxTY3JvbGxiYXJzID0gY29tcHV0ZUlzTGVmdFJ0bFNjcm9sbGJhcnMoKTtcblx0fVxuXHRyZXR1cm4gX2lzTGVmdFJ0bFNjcm9sbGJhcnM7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVJc0xlZnRSdGxTY3JvbGxiYXJzKCkgeyAvLyBjcmVhdGVzIGFuIG9mZnNjcmVlbiB0ZXN0IGVsZW1lbnQsIHRoZW4gcmVtb3ZlcyBpdFxuXHR2YXIgZWwgPSAkKCc8ZGl2PjxkaXYvPjwvZGl2PicpXG5cdFx0LmNzcyh7XG5cdFx0XHRwb3NpdGlvbjogJ2Fic29sdXRlJyxcblx0XHRcdHRvcDogLTEwMDAsXG5cdFx0XHRsZWZ0OiAwLFxuXHRcdFx0Ym9yZGVyOiAwLFxuXHRcdFx0cGFkZGluZzogMCxcblx0XHRcdG92ZXJmbG93OiAnc2Nyb2xsJyxcblx0XHRcdGRpcmVjdGlvbjogJ3J0bCdcblx0XHR9KVxuXHRcdC5hcHBlbmRUbygnYm9keScpO1xuXHR2YXIgaW5uZXJFbCA9IGVsLmNoaWxkcmVuKCk7XG5cdHZhciByZXMgPSBpbm5lckVsLm9mZnNldCgpLmxlZnQgPiBlbC5vZmZzZXQoKS5sZWZ0OyAvLyBpcyB0aGUgaW5uZXIgZGl2IHNoaWZ0ZWQgdG8gYWNjb21tb2RhdGUgYSBsZWZ0IHNjcm9sbGJhcj9cblx0ZWwucmVtb3ZlKCk7XG5cdHJldHVybiByZXM7XG59XG5cblxuLy8gUmV0cmlldmVzIGEgalF1ZXJ5IGVsZW1lbnQncyBjb21wdXRlZCBDU1MgdmFsdWUgYXMgYSBmbG9hdGluZy1wb2ludCBudW1iZXIuXG4vLyBJZiB0aGUgcXVlcmllZCB2YWx1ZSBpcyBub24tbnVtZXJpYyAoZXg6IElFIGNhbiByZXR1cm4gXCJtZWRpdW1cIiBmb3IgYm9yZGVyIHdpZHRoKSwgd2lsbCBqdXN0IHJldHVybiB6ZXJvLlxuZnVuY3Rpb24gZ2V0Q3NzRmxvYXQoZWwsIHByb3ApIHtcblx0cmV0dXJuIHBhcnNlRmxvYXQoZWwuY3NzKHByb3ApKSB8fCAwO1xufVxuXG5cbi8qIE1vdXNlIC8gVG91Y2ggVXRpbGl0aWVzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuRkMucHJldmVudERlZmF1bHQgPSBwcmV2ZW50RGVmYXVsdDtcblxuXG4vLyBSZXR1cm5zIGEgYm9vbGVhbiB3aGV0aGVyIHRoaXMgd2FzIGEgbGVmdCBtb3VzZSBjbGljayBhbmQgbm8gY3RybCBrZXkgKHdoaWNoIG1lYW5zIHJpZ2h0IGNsaWNrIG9uIE1hYylcbmZ1bmN0aW9uIGlzUHJpbWFyeU1vdXNlQnV0dG9uKGV2KSB7XG5cdHJldHVybiBldi53aGljaCA9PSAxICYmICFldi5jdHJsS2V5O1xufVxuXG5cbmZ1bmN0aW9uIGdldEV2WChldikge1xuXHRpZiAoZXYucGFnZVggIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBldi5wYWdlWDtcblx0fVxuXHR2YXIgdG91Y2hlcyA9IGV2Lm9yaWdpbmFsRXZlbnQudG91Y2hlcztcblx0aWYgKHRvdWNoZXMpIHtcblx0XHRyZXR1cm4gdG91Y2hlc1swXS5wYWdlWDtcblx0fVxufVxuXG5cbmZ1bmN0aW9uIGdldEV2WShldikge1xuXHRpZiAoZXYucGFnZVkgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBldi5wYWdlWTtcblx0fVxuXHR2YXIgdG91Y2hlcyA9IGV2Lm9yaWdpbmFsRXZlbnQudG91Y2hlcztcblx0aWYgKHRvdWNoZXMpIHtcblx0XHRyZXR1cm4gdG91Y2hlc1swXS5wYWdlWTtcblx0fVxufVxuXG5cbmZ1bmN0aW9uIGdldEV2SXNUb3VjaChldikge1xuXHRyZXR1cm4gL150b3VjaC8udGVzdChldi50eXBlKTtcbn1cblxuXG5mdW5jdGlvbiBwcmV2ZW50U2VsZWN0aW9uKGVsKSB7XG5cdGVsLmFkZENsYXNzKCdmYy11bnNlbGVjdGFibGUnKVxuXHRcdC5vbignc2VsZWN0c3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XG59XG5cblxuLy8gU3RvcHMgYSBtb3VzZS90b3VjaCBldmVudCBmcm9tIGRvaW5nIGl0J3MgbmF0aXZlIGJyb3dzZXIgYWN0aW9uXG5mdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldikge1xuXHRldi5wcmV2ZW50RGVmYXVsdCgpO1xufVxuXG5cbi8vIGF0dGFjaCBhIGhhbmRsZXIgdG8gZ2V0IGNhbGxlZCB3aGVuIEFOWSBzY3JvbGwgYWN0aW9uIGhhcHBlbnMgb24gdGhlIHBhZ2UuXG4vLyB0aGlzIHdhcyBpbXBvc3NpYmxlIHRvIGRvIHdpdGggbm9ybWFsIG9uL29mZiBiZWNhdXNlICdzY3JvbGwnIGRvZXNuJ3QgYnViYmxlLlxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzI5NTQ1NjUvOTYzNDJcbi8vIHJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3MuXG5mdW5jdGlvbiBiaW5kQW55U2Nyb2xsKGhhbmRsZXIpIHtcblx0aWYgKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhhbmRsZXIsIHRydWUpOyAvLyB1c2VDYXB0dXJlPXRydWVcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59XG5cblxuLy8gdW5kb2VzIGJpbmRBbnlTY3JvbGwuIG11c3QgcGFzcyBpbiB0aGUgb3JpZ2luYWwgZnVuY3Rpb24uXG4vLyByZXR1cm5zIGB0cnVlYCBvbiBzdWNjZXNzLlxuZnVuY3Rpb24gdW5iaW5kQW55U2Nyb2xsKGhhbmRsZXIpIHtcblx0aWYgKHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG5cdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhhbmRsZXIsIHRydWUpOyAvLyB1c2VDYXB0dXJlPXRydWVcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59XG5cblxuLyogR2VuZXJhbCBHZW9tZXRyeSBVdGlsc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbkZDLmludGVyc2VjdFJlY3RzID0gaW50ZXJzZWN0UmVjdHM7XG5cbi8vIFJldHVybnMgYSBuZXcgcmVjdGFuZ2xlIHRoYXQgaXMgdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgdHdvIHJlY3RhbmdsZXMuIElmIHRoZXkgZG9uJ3QgaW50ZXJzZWN0LCByZXR1cm5zIGZhbHNlXG5mdW5jdGlvbiBpbnRlcnNlY3RSZWN0cyhyZWN0MSwgcmVjdDIpIHtcblx0dmFyIHJlcyA9IHtcblx0XHRsZWZ0OiBNYXRoLm1heChyZWN0MS5sZWZ0LCByZWN0Mi5sZWZ0KSxcblx0XHRyaWdodDogTWF0aC5taW4ocmVjdDEucmlnaHQsIHJlY3QyLnJpZ2h0KSxcblx0XHR0b3A6IE1hdGgubWF4KHJlY3QxLnRvcCwgcmVjdDIudG9wKSxcblx0XHRib3R0b206IE1hdGgubWluKHJlY3QxLmJvdHRvbSwgcmVjdDIuYm90dG9tKVxuXHR9O1xuXG5cdGlmIChyZXMubGVmdCA8IHJlcy5yaWdodCAmJiByZXMudG9wIDwgcmVzLmJvdHRvbSkge1xuXHRcdHJldHVybiByZXM7XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufVxuXG5cbi8vIFJldHVybnMgYSBuZXcgcG9pbnQgdGhhdCB3aWxsIGhhdmUgYmVlbiBtb3ZlZCB0byByZXNpZGUgd2l0aGluIHRoZSBnaXZlbiByZWN0YW5nbGVcbmZ1bmN0aW9uIGNvbnN0cmFpblBvaW50KHBvaW50LCByZWN0KSB7XG5cdHJldHVybiB7XG5cdFx0bGVmdDogTWF0aC5taW4oTWF0aC5tYXgocG9pbnQubGVmdCwgcmVjdC5sZWZ0KSwgcmVjdC5yaWdodCksXG5cdFx0dG9wOiBNYXRoLm1pbihNYXRoLm1heChwb2ludC50b3AsIHJlY3QudG9wKSwgcmVjdC5ib3R0b20pXG5cdH07XG59XG5cblxuLy8gUmV0dXJucyBhIHBvaW50IHRoYXQgaXMgdGhlIGNlbnRlciBvZiB0aGUgZ2l2ZW4gcmVjdGFuZ2xlXG5mdW5jdGlvbiBnZXRSZWN0Q2VudGVyKHJlY3QpIHtcblx0cmV0dXJuIHtcblx0XHRsZWZ0OiAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyLFxuXHRcdHRvcDogKHJlY3QudG9wICsgcmVjdC5ib3R0b20pIC8gMlxuXHR9O1xufVxuXG5cbi8vIFN1YnRyYWN0cyBwb2ludDIncyBjb29yZGluYXRlcyBmcm9tIHBvaW50MSdzIGNvb3JkaW5hdGVzLCByZXR1cm5pbmcgYSBkZWx0YVxuZnVuY3Rpb24gZGlmZlBvaW50cyhwb2ludDEsIHBvaW50Mikge1xuXHRyZXR1cm4ge1xuXHRcdGxlZnQ6IHBvaW50MS5sZWZ0IC0gcG9pbnQyLmxlZnQsXG5cdFx0dG9wOiBwb2ludDEudG9wIC0gcG9pbnQyLnRvcFxuXHR9O1xufVxuXG5cbi8qIE9iamVjdCBPcmRlcmluZyBieSBGaWVsZFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbkZDLnBhcnNlRmllbGRTcGVjcyA9IHBhcnNlRmllbGRTcGVjcztcbkZDLmNvbXBhcmVCeUZpZWxkU3BlY3MgPSBjb21wYXJlQnlGaWVsZFNwZWNzO1xuRkMuY29tcGFyZUJ5RmllbGRTcGVjID0gY29tcGFyZUJ5RmllbGRTcGVjO1xuRkMuZmxleGlibGVDb21wYXJlID0gZmxleGlibGVDb21wYXJlO1xuXG5cbmZ1bmN0aW9uIHBhcnNlRmllbGRTcGVjcyhpbnB1dCkge1xuXHR2YXIgc3BlY3MgPSBbXTtcblx0dmFyIHRva2VucyA9IFtdO1xuXHR2YXIgaSwgdG9rZW47XG5cblx0aWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcblx0XHR0b2tlbnMgPSBpbnB1dC5zcGxpdCgvXFxzKixcXHMqLyk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dG9rZW5zID0gWyBpbnB1dCBdO1xuXHR9XG5cdGVsc2UgaWYgKCQuaXNBcnJheShpbnB1dCkpIHtcblx0XHR0b2tlbnMgPSBpbnB1dDtcblx0fVxuXG5cdGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcblx0XHR0b2tlbiA9IHRva2Vuc1tpXTtcblxuXHRcdGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRzcGVjcy5wdXNoKFxuXHRcdFx0XHR0b2tlbi5jaGFyQXQoMCkgPT0gJy0nID9cblx0XHRcdFx0XHR7IGZpZWxkOiB0b2tlbi5zdWJzdHJpbmcoMSksIG9yZGVyOiAtMSB9IDpcblx0XHRcdFx0XHR7IGZpZWxkOiB0b2tlbiwgb3JkZXI6IDEgfVxuXHRcdFx0KTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAodHlwZW9mIHRva2VuID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRzcGVjcy5wdXNoKHsgZnVuYzogdG9rZW4gfSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHNwZWNzO1xufVxuXG5cbmZ1bmN0aW9uIGNvbXBhcmVCeUZpZWxkU3BlY3Mob2JqMSwgb2JqMiwgZmllbGRTcGVjcykge1xuXHR2YXIgaTtcblx0dmFyIGNtcDtcblxuXHRmb3IgKGkgPSAwOyBpIDwgZmllbGRTcGVjcy5sZW5ndGg7IGkrKykge1xuXHRcdGNtcCA9IGNvbXBhcmVCeUZpZWxkU3BlYyhvYmoxLCBvYmoyLCBmaWVsZFNwZWNzW2ldKTtcblx0XHRpZiAoY21wKSB7XG5cdFx0XHRyZXR1cm4gY21wO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiAwO1xufVxuXG5cbmZ1bmN0aW9uIGNvbXBhcmVCeUZpZWxkU3BlYyhvYmoxLCBvYmoyLCBmaWVsZFNwZWMpIHtcblx0aWYgKGZpZWxkU3BlYy5mdW5jKSB7XG5cdFx0cmV0dXJuIGZpZWxkU3BlYy5mdW5jKG9iajEsIG9iajIpO1xuXHR9XG5cdHJldHVybiBmbGV4aWJsZUNvbXBhcmUob2JqMVtmaWVsZFNwZWMuZmllbGRdLCBvYmoyW2ZpZWxkU3BlYy5maWVsZF0pICpcblx0XHQoZmllbGRTcGVjLm9yZGVyIHx8IDEpO1xufVxuXG5cbmZ1bmN0aW9uIGZsZXhpYmxlQ29tcGFyZShhLCBiKSB7XG5cdGlmICghYSAmJiAhYikge1xuXHRcdHJldHVybiAwO1xuXHR9XG5cdGlmIChiID09IG51bGwpIHtcblx0XHRyZXR1cm4gLTE7XG5cdH1cblx0aWYgKGEgPT0gbnVsbCkge1xuXHRcdHJldHVybiAxO1xuXHR9XG5cdGlmICgkLnR5cGUoYSkgPT09ICdzdHJpbmcnIHx8ICQudHlwZShiKSA9PT0gJ3N0cmluZycpIHtcblx0XHRyZXR1cm4gU3RyaW5nKGEpLmxvY2FsZUNvbXBhcmUoU3RyaW5nKGIpKTtcblx0fVxuXHRyZXR1cm4gYSAtIGI7XG59XG5cblxuLyogRnVsbENhbGVuZGFyLXNwZWNpZmljIE1pc2MgVXRpbGl0aWVzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG4vLyBDb21wdXRlcyB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoZSB0d28gcmFuZ2VzLiBXaWxsIHJldHVybiBmcmVzaCBkYXRlIGNsb25lcyBpbiBhIHJhbmdlLlxuLy8gUmV0dXJucyB1bmRlZmluZWQgaWYgbm8gaW50ZXJzZWN0aW9uLlxuLy8gRXhwZWN0cyBhbGwgZGF0ZXMgdG8gYmUgbm9ybWFsaXplZCB0byB0aGUgc2FtZSB0aW1lem9uZSBiZWZvcmVoYW5kLlxuLy8gVE9ETzogbW92ZSB0byBkYXRlIHNlY3Rpb24/XG5mdW5jdGlvbiBpbnRlcnNlY3RSYW5nZXMoc3ViamVjdFJhbmdlLCBjb25zdHJhaW50UmFuZ2UpIHtcblx0dmFyIHN1YmplY3RTdGFydCA9IHN1YmplY3RSYW5nZS5zdGFydDtcblx0dmFyIHN1YmplY3RFbmQgPSBzdWJqZWN0UmFuZ2UuZW5kO1xuXHR2YXIgY29uc3RyYWludFN0YXJ0ID0gY29uc3RyYWludFJhbmdlLnN0YXJ0O1xuXHR2YXIgY29uc3RyYWludEVuZCA9IGNvbnN0cmFpbnRSYW5nZS5lbmQ7XG5cdHZhciBzZWdTdGFydCwgc2VnRW5kO1xuXHR2YXIgaXNTdGFydCwgaXNFbmQ7XG5cblx0aWYgKHN1YmplY3RFbmQgPiBjb25zdHJhaW50U3RhcnQgJiYgc3ViamVjdFN0YXJ0IDwgY29uc3RyYWludEVuZCkgeyAvLyBpbiBib3VuZHMgYXQgYWxsP1xuXG5cdFx0aWYgKHN1YmplY3RTdGFydCA+PSBjb25zdHJhaW50U3RhcnQpIHtcblx0XHRcdHNlZ1N0YXJ0ID0gc3ViamVjdFN0YXJ0LmNsb25lKCk7XG5cdFx0XHRpc1N0YXJ0ID0gdHJ1ZTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRzZWdTdGFydCA9IGNvbnN0cmFpbnRTdGFydC5jbG9uZSgpO1xuXHRcdFx0aXNTdGFydCA9ICBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAoc3ViamVjdEVuZCA8PSBjb25zdHJhaW50RW5kKSB7XG5cdFx0XHRzZWdFbmQgPSBzdWJqZWN0RW5kLmNsb25lKCk7XG5cdFx0XHRpc0VuZCA9IHRydWU7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0c2VnRW5kID0gY29uc3RyYWludEVuZC5jbG9uZSgpO1xuXHRcdFx0aXNFbmQgPSBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0c3RhcnQ6IHNlZ1N0YXJ0LFxuXHRcdFx0ZW5kOiBzZWdFbmQsXG5cdFx0XHRpc1N0YXJ0OiBpc1N0YXJ0LFxuXHRcdFx0aXNFbmQ6IGlzRW5kXG5cdFx0fTtcblx0fVxufVxuXG5cbi8qIERhdGUgVXRpbGl0aWVzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuRkMuY29tcHV0ZUludGVydmFsVW5pdCA9IGNvbXB1dGVJbnRlcnZhbFVuaXQ7XG5GQy5kaXZpZGVSYW5nZUJ5RHVyYXRpb24gPSBkaXZpZGVSYW5nZUJ5RHVyYXRpb247XG5GQy5kaXZpZGVEdXJhdGlvbkJ5RHVyYXRpb24gPSBkaXZpZGVEdXJhdGlvbkJ5RHVyYXRpb247XG5GQy5tdWx0aXBseUR1cmF0aW9uID0gbXVsdGlwbHlEdXJhdGlvbjtcbkZDLmR1cmF0aW9uSGFzVGltZSA9IGR1cmF0aW9uSGFzVGltZTtcblxudmFyIGRheUlEcyA9IFsgJ3N1bicsICdtb24nLCAndHVlJywgJ3dlZCcsICd0aHUnLCAnZnJpJywgJ3NhdCcgXTtcbnZhciBpbnRlcnZhbFVuaXRzID0gWyAneWVhcicsICdtb250aCcsICd3ZWVrJywgJ2RheScsICdob3VyJywgJ21pbnV0ZScsICdzZWNvbmQnLCAnbWlsbGlzZWNvbmQnIF07XG5cblxuLy8gRGlmZnMgdGhlIHR3byBtb21lbnRzIGludG8gYSBEdXJhdGlvbiB3aGVyZSBmdWxsLWRheXMgYXJlIHJlY29yZGVkIGZpcnN0LCB0aGVuIHRoZSByZW1haW5pbmcgdGltZS5cbi8vIE1vbWVudHMgd2lsbCBoYXZlIHRoZWlyIHRpbWV6b25lcyBub3JtYWxpemVkLlxuZnVuY3Rpb24gZGlmZkRheVRpbWUoYSwgYikge1xuXHRyZXR1cm4gbW9tZW50LmR1cmF0aW9uKHtcblx0XHRkYXlzOiBhLmNsb25lKCkuc3RyaXBUaW1lKCkuZGlmZihiLmNsb25lKCkuc3RyaXBUaW1lKCksICdkYXlzJyksXG5cdFx0bXM6IGEudGltZSgpIC0gYi50aW1lKCkgLy8gdGltZS1vZi1kYXkgZnJvbSBkYXkgc3RhcnQuIGRpc3JlZ2FyZHMgdGltZXpvbmVcblx0fSk7XG59XG5cblxuLy8gRGlmZnMgdGhlIHR3byBtb21lbnRzIHZpYSB0aGVpciBzdGFydC1vZi1kYXkgKHJlZ2FyZGxlc3Mgb2YgdGltZXpvbmUpLiBQcm9kdWNlcyB3aG9sZS1kYXkgZHVyYXRpb25zLlxuZnVuY3Rpb24gZGlmZkRheShhLCBiKSB7XG5cdHJldHVybiBtb21lbnQuZHVyYXRpb24oe1xuXHRcdGRheXM6IGEuY2xvbmUoKS5zdHJpcFRpbWUoKS5kaWZmKGIuY2xvbmUoKS5zdHJpcFRpbWUoKSwgJ2RheXMnKVxuXHR9KTtcbn1cblxuXG4vLyBEaWZmcyB0d28gbW9tZW50cywgcHJvZHVjaW5nIGEgZHVyYXRpb24sIG1hZGUgb2YgYSB3aG9sZS11bml0LWluY3JlbWVudCBvZiB0aGUgZ2l2ZW4gdW5pdC4gVXNlcyByb3VuZGluZy5cbmZ1bmN0aW9uIGRpZmZCeVVuaXQoYSwgYiwgdW5pdCkge1xuXHRyZXR1cm4gbW9tZW50LmR1cmF0aW9uKFxuXHRcdE1hdGgucm91bmQoYS5kaWZmKGIsIHVuaXQsIHRydWUpKSwgLy8gcmV0dXJuRmxvYXQ9dHJ1ZVxuXHRcdHVuaXRcblx0KTtcbn1cblxuXG4vLyBDb21wdXRlcyB0aGUgdW5pdCBuYW1lIG9mIHRoZSBsYXJnZXN0IHdob2xlLXVuaXQgcGVyaW9kIG9mIHRpbWUuXG4vLyBGb3IgZXhhbXBsZSwgNDggaG91cnMgd2lsbCBiZSBcImRheXNcIiB3aGVyZWFzIDQ5IGhvdXJzIHdpbGwgYmUgXCJob3Vyc1wiLlxuLy8gQWNjZXB0cyBzdGFydC9lbmQsIGEgcmFuZ2Ugb2JqZWN0LCBvciBhbiBvcmlnaW5hbCBkdXJhdGlvbiBvYmplY3QuXG5mdW5jdGlvbiBjb21wdXRlSW50ZXJ2YWxVbml0KHN0YXJ0LCBlbmQpIHtcblx0dmFyIGksIHVuaXQ7XG5cdHZhciB2YWw7XG5cblx0Zm9yIChpID0gMDsgaSA8IGludGVydmFsVW5pdHMubGVuZ3RoOyBpKyspIHtcblx0XHR1bml0ID0gaW50ZXJ2YWxVbml0c1tpXTtcblx0XHR2YWwgPSBjb21wdXRlUmFuZ2VBcyh1bml0LCBzdGFydCwgZW5kKTtcblxuXHRcdGlmICh2YWwgPj0gMSAmJiBpc0ludCh2YWwpKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdW5pdDsgLy8gd2lsbCBiZSBcIm1pbGxpc2Vjb25kc1wiIGlmIG5vdGhpbmcgZWxzZSBtYXRjaGVzXG59XG5cblxuLy8gQ29tcHV0ZXMgdGhlIG51bWJlciBvZiB1bml0cyAobGlrZSBcImhvdXJzXCIpIGluIHRoZSBnaXZlbiByYW5nZS5cbi8vIFJhbmdlIGNhbiBiZSBhIHtzdGFydCxlbmR9IG9iamVjdCwgc2VwYXJhdGUgc3RhcnQvZW5kIGFyZ3MsIG9yIGEgRHVyYXRpb24uXG4vLyBSZXN1bHRzIGFyZSBiYXNlZCBvbiBNb21lbnQncyAuYXMoKSBhbmQgLmRpZmYoKSBtZXRob2RzLCBzbyByZXN1bHRzIGNhbiBkZXBlbmQgb24gaW50ZXJuYWwgaGFuZGxpbmdcbi8vIG9mIG1vbnRoLWRpZmZpbmcgbG9naWMgKHdoaWNoIHRlbmRzIHRvIHZhcnkgZnJvbSB2ZXJzaW9uIHRvIHZlcnNpb24pLlxuZnVuY3Rpb24gY29tcHV0ZVJhbmdlQXModW5pdCwgc3RhcnQsIGVuZCkge1xuXG5cdGlmIChlbmQgIT0gbnVsbCkgeyAvLyBnaXZlbiBzdGFydCwgZW5kXG5cdFx0cmV0dXJuIGVuZC5kaWZmKHN0YXJ0LCB1bml0LCB0cnVlKTtcblx0fVxuXHRlbHNlIGlmIChtb21lbnQuaXNEdXJhdGlvbihzdGFydCkpIHsgLy8gZ2l2ZW4gZHVyYXRpb25cblx0XHRyZXR1cm4gc3RhcnQuYXModW5pdCk7XG5cdH1cblx0ZWxzZSB7IC8vIGdpdmVuIHsgc3RhcnQsIGVuZCB9IHJhbmdlIG9iamVjdFxuXHRcdHJldHVybiBzdGFydC5lbmQuZGlmZihzdGFydC5zdGFydCwgdW5pdCwgdHJ1ZSk7XG5cdH1cbn1cblxuXG4vLyBJbnRlbGxpZ2VudGx5IGRpdmlkZXMgYSByYW5nZSAoc3BlY2lmaWVkIGJ5IGEgc3RhcnQvZW5kIHBhcmFtcykgYnkgYSBkdXJhdGlvblxuZnVuY3Rpb24gZGl2aWRlUmFuZ2VCeUR1cmF0aW9uKHN0YXJ0LCBlbmQsIGR1cikge1xuXHR2YXIgbW9udGhzO1xuXG5cdGlmIChkdXJhdGlvbkhhc1RpbWUoZHVyKSkge1xuXHRcdHJldHVybiAoZW5kIC0gc3RhcnQpIC8gZHVyO1xuXHR9XG5cdG1vbnRocyA9IGR1ci5hc01vbnRocygpO1xuXHRpZiAoTWF0aC5hYnMobW9udGhzKSA+PSAxICYmIGlzSW50KG1vbnRocykpIHtcblx0XHRyZXR1cm4gZW5kLmRpZmYoc3RhcnQsICdtb250aHMnLCB0cnVlKSAvIG1vbnRocztcblx0fVxuXHRyZXR1cm4gZW5kLmRpZmYoc3RhcnQsICdkYXlzJywgdHJ1ZSkgLyBkdXIuYXNEYXlzKCk7XG59XG5cblxuLy8gSW50ZWxsaWdlbnRseSBkaXZpZGVzIG9uZSBkdXJhdGlvbiBieSBhbm90aGVyXG5mdW5jdGlvbiBkaXZpZGVEdXJhdGlvbkJ5RHVyYXRpb24oZHVyMSwgZHVyMikge1xuXHR2YXIgbW9udGhzMSwgbW9udGhzMjtcblxuXHRpZiAoZHVyYXRpb25IYXNUaW1lKGR1cjEpIHx8IGR1cmF0aW9uSGFzVGltZShkdXIyKSkge1xuXHRcdHJldHVybiBkdXIxIC8gZHVyMjtcblx0fVxuXHRtb250aHMxID0gZHVyMS5hc01vbnRocygpO1xuXHRtb250aHMyID0gZHVyMi5hc01vbnRocygpO1xuXHRpZiAoXG5cdFx0TWF0aC5hYnMobW9udGhzMSkgPj0gMSAmJiBpc0ludChtb250aHMxKSAmJlxuXHRcdE1hdGguYWJzKG1vbnRoczIpID49IDEgJiYgaXNJbnQobW9udGhzMilcblx0KSB7XG5cdFx0cmV0dXJuIG1vbnRoczEgLyBtb250aHMyO1xuXHR9XG5cdHJldHVybiBkdXIxLmFzRGF5cygpIC8gZHVyMi5hc0RheXMoKTtcbn1cblxuXG4vLyBJbnRlbGxpZ2VudGx5IG11bHRpcGxpZXMgYSBkdXJhdGlvbiBieSBhIG51bWJlclxuZnVuY3Rpb24gbXVsdGlwbHlEdXJhdGlvbihkdXIsIG4pIHtcblx0dmFyIG1vbnRocztcblxuXHRpZiAoZHVyYXRpb25IYXNUaW1lKGR1cikpIHtcblx0XHRyZXR1cm4gbW9tZW50LmR1cmF0aW9uKGR1ciAqIG4pO1xuXHR9XG5cdG1vbnRocyA9IGR1ci5hc01vbnRocygpO1xuXHRpZiAoTWF0aC5hYnMobW9udGhzKSA+PSAxICYmIGlzSW50KG1vbnRocykpIHtcblx0XHRyZXR1cm4gbW9tZW50LmR1cmF0aW9uKHsgbW9udGhzOiBtb250aHMgKiBuIH0pO1xuXHR9XG5cdHJldHVybiBtb21lbnQuZHVyYXRpb24oeyBkYXlzOiBkdXIuYXNEYXlzKCkgKiBuIH0pO1xufVxuXG5cbi8vIFJldHVybnMgYSBib29sZWFuIGFib3V0IHdoZXRoZXIgdGhlIGdpdmVuIGR1cmF0aW9uIGhhcyBhbnkgdGltZSBwYXJ0cyAoaG91cnMvbWludXRlcy9zZWNvbmRzL21zKVxuZnVuY3Rpb24gZHVyYXRpb25IYXNUaW1lKGR1cikge1xuXHRyZXR1cm4gQm9vbGVhbihkdXIuaG91cnMoKSB8fCBkdXIubWludXRlcygpIHx8IGR1ci5zZWNvbmRzKCkgfHwgZHVyLm1pbGxpc2Vjb25kcygpKTtcbn1cblxuXG5mdW5jdGlvbiBpc05hdGl2ZURhdGUoaW5wdXQpIHtcblx0cmV0dXJuICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBEYXRlXScgfHwgaW5wdXQgaW5zdGFuY2VvZiBEYXRlO1xufVxuXG5cbi8vIFJldHVybnMgYSBib29sZWFuIGFib3V0IHdoZXRoZXIgdGhlIGdpdmVuIGlucHV0IGlzIGEgdGltZSBzdHJpbmcsIGxpa2UgXCIwNjo0MDowMFwiIG9yIFwiMDY6MDBcIlxuZnVuY3Rpb24gaXNUaW1lU3RyaW5nKHN0cikge1xuXHRyZXR1cm4gL15cXGQrXFw6XFxkKyg/OlxcOlxcZCtcXC4/KD86XFxkezN9KT8pPyQvLnRlc3Qoc3RyKTtcbn1cblxuXG4vKiBMb2dnaW5nIGFuZCBEZWJ1Z1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbkZDLmxvZyA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgY29uc29sZSA9IHdpbmRvdy5jb25zb2xlO1xuXG5cdGlmIChjb25zb2xlICYmIGNvbnNvbGUubG9nKSB7XG5cdFx0cmV0dXJuIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG5cdH1cbn07XG5cbkZDLndhcm4gPSBmdW5jdGlvbigpIHtcblx0dmFyIGNvbnNvbGUgPSB3aW5kb3cuY29uc29sZTtcblxuXHRpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIHtcblx0XHRyZXR1cm4gY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0cmV0dXJuIEZDLmxvZy5hcHBseShGQywgYXJndW1lbnRzKTtcblx0fVxufTtcblxuXG4vKiBHZW5lcmFsIFV0aWxpdGllc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbnZhciBoYXNPd25Qcm9wTWV0aG9kID0ge30uaGFzT3duUHJvcGVydHk7XG5cblxuLy8gTWVyZ2VzIGFuIGFycmF5IG9mIG9iamVjdHMgaW50byBhIHNpbmdsZSBvYmplY3QuXG4vLyBUaGUgc2Vjb25kIGFyZ3VtZW50IGFsbG93cyBmb3IgYW4gYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgd2hvJ3Mgb2JqZWN0IHZhbHVlcyB3aWxsIGJlIG1lcmdlZCB0b2dldGhlci5cbmZ1bmN0aW9uIG1lcmdlUHJvcHMocHJvcE9ianMsIGNvbXBsZXhQcm9wcykge1xuXHR2YXIgZGVzdCA9IHt9O1xuXHR2YXIgaSwgbmFtZTtcblx0dmFyIGNvbXBsZXhPYmpzO1xuXHR2YXIgaiwgdmFsO1xuXHR2YXIgcHJvcHM7XG5cblx0aWYgKGNvbXBsZXhQcm9wcykge1xuXHRcdGZvciAoaSA9IDA7IGkgPCBjb21wbGV4UHJvcHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdG5hbWUgPSBjb21wbGV4UHJvcHNbaV07XG5cdFx0XHRjb21wbGV4T2JqcyA9IFtdO1xuXG5cdFx0XHQvLyBjb2xsZWN0IHRoZSB0cmFpbGluZyBvYmplY3QgdmFsdWVzLCBzdG9wcGluZyB3aGVuIGEgbm9uLW9iamVjdCBpcyBkaXNjb3ZlcmVkXG5cdFx0XHRmb3IgKGogPSBwcm9wT2Jqcy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuXHRcdFx0XHR2YWwgPSBwcm9wT2Jqc1tqXVtuYW1lXTtcblxuXHRcdFx0XHRpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRjb21wbGV4T2Jqcy51bnNoaWZ0KHZhbCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRkZXN0W25hbWVdID0gdmFsOyAvLyBpZiB0aGVyZSB3ZXJlIG5vIG9iamVjdHMsIHRoaXMgdmFsdWUgd2lsbCBiZSB1c2VkXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gaWYgdGhlIHRyYWlsaW5nIHZhbHVlcyB3ZXJlIG9iamVjdHMsIHVzZSB0aGUgbWVyZ2VkIHZhbHVlXG5cdFx0XHRpZiAoY29tcGxleE9ianMubGVuZ3RoKSB7XG5cdFx0XHRcdGRlc3RbbmFtZV0gPSBtZXJnZVByb3BzKGNvbXBsZXhPYmpzKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBjb3B5IHZhbHVlcyBpbnRvIHRoZSBkZXN0aW5hdGlvbiwgZ29pbmcgZnJvbSBsYXN0IHRvIGZpcnN0XG5cdGZvciAoaSA9IHByb3BPYmpzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0cHJvcHMgPSBwcm9wT2Jqc1tpXTtcblxuXHRcdGZvciAobmFtZSBpbiBwcm9wcykge1xuXHRcdFx0aWYgKCEobmFtZSBpbiBkZXN0KSkgeyAvLyBpZiBhbHJlYWR5IGFzc2lnbmVkIGJ5IHByZXZpb3VzIHByb3BzIG9yIGNvbXBsZXggcHJvcHMsIGRvbid0IHJlYXNzaWduXG5cdFx0XHRcdGRlc3RbbmFtZV0gPSBwcm9wc1tuYW1lXTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZGVzdDtcbn1cblxuXG4vLyBDcmVhdGUgYW4gb2JqZWN0IHRoYXQgaGFzIHRoZSBnaXZlbiBwcm90b3R5cGUuIEp1c3QgbGlrZSBPYmplY3QuY3JlYXRlXG5mdW5jdGlvbiBjcmVhdGVPYmplY3QocHJvdG8pIHtcblx0dmFyIGYgPSBmdW5jdGlvbigpIHt9O1xuXHRmLnByb3RvdHlwZSA9IHByb3RvO1xuXHRyZXR1cm4gbmV3IGYoKTtcbn1cblxuXG5mdW5jdGlvbiBjb3B5T3duUHJvcHMoc3JjLCBkZXN0KSB7XG5cdGZvciAodmFyIG5hbWUgaW4gc3JjKSB7XG5cdFx0aWYgKGhhc093blByb3Aoc3JjLCBuYW1lKSkge1xuXHRcdFx0ZGVzdFtuYW1lXSA9IHNyY1tuYW1lXTtcblx0XHR9XG5cdH1cbn1cblxuXG5mdW5jdGlvbiBoYXNPd25Qcm9wKG9iaiwgbmFtZSkge1xuXHRyZXR1cm4gaGFzT3duUHJvcE1ldGhvZC5jYWxsKG9iaiwgbmFtZSk7XG59XG5cblxuLy8gSXMgdGhlIGdpdmVuIHZhbHVlIGEgbm9uLW9iamVjdCBub24tZnVuY3Rpb24gdmFsdWU/XG5mdW5jdGlvbiBpc0F0b21pYyh2YWwpIHtcblx0cmV0dXJuIC91bmRlZmluZWR8bnVsbHxib29sZWFufG51bWJlcnxzdHJpbmcvLnRlc3QoJC50eXBlKHZhbCkpO1xufVxuXG5cbmZ1bmN0aW9uIGFwcGx5QWxsKGZ1bmN0aW9ucywgdGhpc09iaiwgYXJncykge1xuXHRpZiAoJC5pc0Z1bmN0aW9uKGZ1bmN0aW9ucykpIHtcblx0XHRmdW5jdGlvbnMgPSBbIGZ1bmN0aW9ucyBdO1xuXHR9XG5cdGlmIChmdW5jdGlvbnMpIHtcblx0XHR2YXIgaTtcblx0XHR2YXIgcmV0O1xuXHRcdGZvciAoaT0wOyBpPGZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuXHRcdFx0cmV0ID0gZnVuY3Rpb25zW2ldLmFwcGx5KHRoaXNPYmosIGFyZ3MpIHx8IHJldDtcblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fVxufVxuXG5cbmZ1bmN0aW9uIGZpcnN0RGVmaW5lZCgpIHtcblx0Zm9yICh2YXIgaT0wOyBpPGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdGlmIChhcmd1bWVudHNbaV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIGFyZ3VtZW50c1tpXTtcblx0XHR9XG5cdH1cbn1cblxuXG5mdW5jdGlvbiBodG1sRXNjYXBlKHMpIHtcblx0cmV0dXJuIChzICsgJycpLnJlcGxhY2UoLyYvZywgJyZhbXA7Jylcblx0XHQucmVwbGFjZSgvPC9nLCAnJmx0OycpXG5cdFx0LnJlcGxhY2UoLz4vZywgJyZndDsnKVxuXHRcdC5yZXBsYWNlKC8nL2csICcmIzAzOTsnKVxuXHRcdC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jylcblx0XHQucmVwbGFjZSgvXFxuL2csICc8YnIgLz4nKTtcbn1cblxuXG5mdW5jdGlvbiBzdHJpcEh0bWxFbnRpdGllcyh0ZXh0KSB7XG5cdHJldHVybiB0ZXh0LnJlcGxhY2UoLyYuKj87L2csICcnKTtcbn1cblxuXG4vLyBHaXZlbiBhIGhhc2ggb2YgQ1NTIHByb3BlcnRpZXMsIHJldHVybnMgYSBzdHJpbmcgb2YgQ1NTLlxuLy8gVXNlcyBwcm9wZXJ0eSBuYW1lcyBhcy1pcyAobm8gY2FtZWwtY2FzZSBjb252ZXJzaW9uKS4gV2lsbCBub3QgbWFrZSBzdGF0ZW1lbnRzIGZvciBudWxsL3VuZGVmaW5lZCB2YWx1ZXMuXG5mdW5jdGlvbiBjc3NUb1N0cihjc3NQcm9wcykge1xuXHR2YXIgc3RhdGVtZW50cyA9IFtdO1xuXG5cdCQuZWFjaChjc3NQcm9wcywgZnVuY3Rpb24obmFtZSwgdmFsKSB7XG5cdFx0aWYgKHZhbCAhPSBudWxsKSB7XG5cdFx0XHRzdGF0ZW1lbnRzLnB1c2gobmFtZSArICc6JyArIHZhbCk7XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4gc3RhdGVtZW50cy5qb2luKCc7Jyk7XG59XG5cblxuLy8gR2l2ZW4gYW4gb2JqZWN0IGhhc2ggb2YgSFRNTCBhdHRyaWJ1dGUgbmFtZXMgdG8gdmFsdWVzLFxuLy8gZ2VuZXJhdGVzIGEgc3RyaW5nIHRoYXQgY2FuIGJlIGluamVjdGVkIGJldHdlZW4gPCA+IGluIEhUTUxcbmZ1bmN0aW9uIGF0dHJzVG9TdHIoYXR0cnMpIHtcblx0dmFyIHBhcnRzID0gW107XG5cblx0JC5lYWNoKGF0dHJzLCBmdW5jdGlvbihuYW1lLCB2YWwpIHtcblx0XHRpZiAodmFsICE9IG51bGwpIHtcblx0XHRcdHBhcnRzLnB1c2gobmFtZSArICc9XCInICsgaHRtbEVzY2FwZSh2YWwpICsgJ1wiJyk7XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4gcGFydHMuam9pbignICcpO1xufVxuXG5cbmZ1bmN0aW9uIGNhcGl0YWxpc2VGaXJzdExldHRlcihzdHIpIHtcblx0cmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn1cblxuXG5mdW5jdGlvbiBjb21wYXJlTnVtYmVycyhhLCBiKSB7IC8vIGZvciAuc29ydCgpXG5cdHJldHVybiBhIC0gYjtcbn1cblxuXG5mdW5jdGlvbiBpc0ludChuKSB7XG5cdHJldHVybiBuICUgMSA9PT0gMDtcbn1cblxuXG4vLyBSZXR1cm5zIGEgbWV0aG9kIGJvdW5kIHRvIHRoZSBnaXZlbiBvYmplY3QgY29udGV4dC5cbi8vIEp1c3QgbGlrZSBvbmUgb2YgdGhlIGpRdWVyeS5wcm94eSBzaWduYXR1cmVzLCBidXQgd2l0aG91dCB0aGUgdW5kZXNpcmVkIGJlaGF2aW9yIG9mIHRyZWF0aW5nIHRoZSBzYW1lIG1ldGhvZCB3aXRoXG4vLyBkaWZmZXJlbnQgY29udGV4dHMgYXMgaWRlbnRpY2FsIHdoZW4gYmluZGluZy91bmJpbmRpbmcgZXZlbnRzLlxuZnVuY3Rpb24gcHJveHkob2JqLCBtZXRob2ROYW1lKSB7XG5cdHZhciBtZXRob2QgPSBvYmpbbWV0aG9kTmFtZV07XG5cblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBtZXRob2QuYXBwbHkob2JqLCBhcmd1bWVudHMpO1xuXHR9O1xufVxuXG5cbi8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3Rcbi8vIGJlIHRyaWdnZXJlZC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGl0IHN0b3BzIGJlaW5nIGNhbGxlZCBmb3Jcbi8vIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxuLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZS9ibG9iLzEuNi4wL3VuZGVyc2NvcmUuanMjTDcxNFxuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG5cdHZhciB0aW1lb3V0LCBhcmdzLCBjb250ZXh0LCB0aW1lc3RhbXAsIHJlc3VsdDtcblxuXHR2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGFzdCA9ICtuZXcgRGF0ZSgpIC0gdGltZXN0YW1wO1xuXHRcdGlmIChsYXN0IDwgd2FpdCkge1xuXHRcdFx0dGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR0aW1lb3V0ID0gbnVsbDtcblx0XHRcdGlmICghaW1tZWRpYXRlKSB7XG5cdFx0XHRcdHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG5cdFx0XHRcdGNvbnRleHQgPSBhcmdzID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdGNvbnRleHQgPSB0aGlzO1xuXHRcdGFyZ3MgPSBhcmd1bWVudHM7XG5cdFx0dGltZXN0YW1wID0gK25ldyBEYXRlKCk7XG5cdFx0dmFyIGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXQ7XG5cdFx0aWYgKCF0aW1lb3V0KSB7XG5cdFx0XHR0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG5cdFx0fVxuXHRcdGlmIChjYWxsTm93KSB7XG5cdFx0XHRyZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuXHRcdFx0Y29udGV4dCA9IGFyZ3MgPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xufVxuXG5cbi8vIEhBQ0sgYXJvdW5kIGpRdWVyeSdzIG5vdyBBKyBwcm9taXNlczogZXhlY3V0ZSBjYWxsYmFjayBzeW5jaHJvbm91c2x5IGlmIGFscmVhZHkgcmVzb2x2ZWQuXG4vLyB0aGVuRnVuYyBzaG91bGRuJ3QgYWNjZXB0IGFyZ3MuXG4vLyBzaW1pbGFyIHRvIHdoZW5SZXNvdXJjZXMgaW4gU2NoZWR1bGVyIHBsdWdpbi5cbmZ1bmN0aW9uIHN5bmNUaGVuKHByb21pc2UsIHRoZW5GdW5jKSB7XG5cdC8vIG5vdCBhIHByb21pc2UsIG9yIGFuIGFscmVhZHktcmVzb2x2ZWQgcHJvbWlzZT9cblx0aWYgKCFwcm9taXNlIHx8ICFwcm9taXNlLnRoZW4gfHwgcHJvbWlzZS5zdGF0ZSgpID09PSAncmVzb2x2ZWQnKSB7XG5cdFx0cmV0dXJuICQud2hlbih0aGVuRnVuYygpKTsgLy8gcmVzb2x2ZSBpbW1lZGlhdGVseVxuXHR9XG5cdGVsc2UgaWYgKHRoZW5GdW5jKSB7XG5cdFx0cmV0dXJuIHByb21pc2UudGhlbih0aGVuRnVuYyk7XG5cdH1cbn1cblxuOztcblxuLypcbkdFTkVSQUwgTk9URSBvbiBtb21lbnRzIHRocm91Z2hvdXQgdGhlICplbnRpcmUgcmVzdCogb2YgdGhlIGNvZGViYXNlOlxuQWxsIG1vbWVudHMgYXJlIGFzc3VtZWQgdG8gYmUgYW1iaWd1b3VzbHktem9uZWQgdW5sZXNzIG90aGVyd2lzZSBub3RlZCxcbndpdGggdGhlIE5PVEFCTEUgRVhDRU9QVElPTiBvZiBzdGFydC9lbmQgZGF0ZXMgdGhhdCBsaXZlIG9uICpFdmVudCBPYmplY3RzKi5cbkFtYmlndW91c2x5LVRJTUVEIG1vbWVudHMgYXJlIGFzc3VtZWQgdG8gYmUgYW1iaWd1b3VzbHktem9uZWQgYnkgbmF0dXJlLlxuKi9cblxudmFyIGFtYmlnRGF0ZU9mTW9udGhSZWdleCA9IC9eXFxzKlxcZHs0fS1cXGRcXGQkLztcbnZhciBhbWJpZ1RpbWVPclpvbmVSZWdleCA9XG5cdC9eXFxzKlxcZHs0fS0oPzooXFxkXFxkLVxcZFxcZCl8KFdcXGRcXGQkKXwoV1xcZFxcZC1cXGQpfChcXGRcXGRcXGQpKSgoVHwgKShcXGRcXGQoOlxcZFxcZCg6XFxkXFxkKFxcLlxcZCspPyk/KT8pPyk/JC87XG52YXIgbmV3TW9tZW50UHJvdG8gPSBtb21lbnQuZm47IC8vIHdoZXJlIHdlIHdpbGwgYXR0YWNoIG91ciBuZXcgbWV0aG9kc1xudmFyIG9sZE1vbWVudFByb3RvID0gJC5leHRlbmQoe30sIG5ld01vbWVudFByb3RvKTsgLy8gY29weSBvZiBvcmlnaW5hbCBtb21lbnQgbWV0aG9kc1xuXG4vLyB0ZWxsIG1vbWVudGpzIHRvIHRyYW5zZmVyIHRoZXNlIHByb3BlcnRpZXMgdXBvbiBjbG9uZVxudmFyIG1vbWVudFByb3BlcnRpZXMgPSBtb21lbnQubW9tZW50UHJvcGVydGllcztcbm1vbWVudFByb3BlcnRpZXMucHVzaCgnX2Z1bGxDYWxlbmRhcicpO1xubW9tZW50UHJvcGVydGllcy5wdXNoKCdfYW1iaWdUaW1lJyk7XG5tb21lbnRQcm9wZXJ0aWVzLnB1c2goJ19hbWJpZ1pvbmUnKTtcblxuXG4vLyBDcmVhdGluZ1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBDcmVhdGVzIGEgbmV3IG1vbWVudCwgc2ltaWxhciB0byB0aGUgdmFuaWxsYSBtb21lbnQoLi4uKSBjb25zdHJ1Y3RvciwgYnV0IHdpdGhcbi8vIGV4dHJhIGZlYXR1cmVzIChhbWJpZ3VvdXMgdGltZSwgZW5oYW5jZWQgZm9ybWF0dGluZykuIFdoZW4gZ2l2ZW4gYW4gZXhpc3RpbmcgbW9tZW50LFxuLy8gaXQgd2lsbCBmdW5jdGlvbiBhcyBhIGNsb25lIChhbmQgcmV0YWluIHRoZSB6b25lIG9mIHRoZSBtb21lbnQpLiBBbnl0aGluZyBlbHNlIHdpbGxcbi8vIHJlc3VsdCBpbiBhIG1vbWVudCBpbiB0aGUgbG9jYWwgem9uZS5cbkZDLm1vbWVudCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gbWFrZU1vbWVudChhcmd1bWVudHMpO1xufTtcblxuLy8gU2FtZXMgYXMgRkMubW9tZW50LCBidXQgZm9yY2VzIHRoZSByZXN1bHRpbmcgbW9tZW50IHRvIGJlIGluIHRoZSBVVEMgdGltZXpvbmUuXG5GQy5tb21lbnQudXRjID0gZnVuY3Rpb24oKSB7XG5cdHZhciBtb20gPSBtYWtlTW9tZW50KGFyZ3VtZW50cywgdHJ1ZSk7XG5cblx0Ly8gRm9yY2UgaXQgaW50byBVVEMgYmVjYXVzZSBtYWtlTW9tZW50IGRvZXNuJ3QgZ3VhcmFudGVlIGl0XG5cdC8vIChpZiBnaXZlbiBhIHByZS1leGlzdGluZyBtb21lbnQgZm9yIGV4YW1wbGUpXG5cdGlmIChtb20uaGFzVGltZSgpKSB7IC8vIGRvbid0IGdpdmUgYW1iaWd1b3VzbHktdGltZWQgbW9tZW50cyBhIFVUQyB6b25lXG5cdFx0bW9tLnV0YygpO1xuXHR9XG5cblx0cmV0dXJuIG1vbTtcbn07XG5cbi8vIFNhbWUgYXMgRkMubW9tZW50LCBidXQgd2hlbiBnaXZlbiBhbiBJU084NjAxIHN0cmluZywgdGhlIHRpbWV6b25lIG9mZnNldCBpcyBwcmVzZXJ2ZWQuXG4vLyBJU084NjAxIHN0cmluZ3Mgd2l0aCBubyB0aW1lem9uZSBvZmZzZXQgd2lsbCBiZWNvbWUgYW1iaWd1b3VzbHkgem9uZWQuXG5GQy5tb21lbnQucGFyc2Vab25lID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiBtYWtlTW9tZW50KGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSk7XG59O1xuXG4vLyBCdWlsZHMgYW4gZW5oYW5jZWQgbW9tZW50IGZyb20gYXJncy4gV2hlbiBnaXZlbiBhbiBleGlzdGluZyBtb21lbnQsIGl0IGNsb25lcy4gV2hlbiBnaXZlbiBhXG4vLyBuYXRpdmUgRGF0ZSwgb3IgY2FsbGVkIHdpdGggbm8gYXJndW1lbnRzICh0aGUgY3VycmVudCB0aW1lKSwgdGhlIHJlc3VsdGluZyBtb21lbnQgd2lsbCBiZSBsb2NhbC5cbi8vIEFueXRoaW5nIGVsc2UgbmVlZHMgdG8gYmUgXCJwYXJzZWRcIiAoYSBzdHJpbmcgb3IgYW4gYXJyYXkpLCBhbmQgd2lsbCBiZSBhZmZlY3RlZCBieTpcbi8vICAgIHBhcnNlQXNVVEMgLSBpZiB0aGVyZSBpcyBubyB6b25lIGluZm9ybWF0aW9uLCBzaG91bGQgd2UgcGFyc2UgdGhlIGlucHV0IGluIFVUQz9cbi8vICAgIHBhcnNlWm9uZSAtIGlmIHRoZXJlIGlzIHpvbmUgaW5mb3JtYXRpb24sIHNob3VsZCB3ZSBmb3JjZSB0aGUgem9uZSBvZiB0aGUgbW9tZW50P1xuZnVuY3Rpb24gbWFrZU1vbWVudChhcmdzLCBwYXJzZUFzVVRDLCBwYXJzZVpvbmUpIHtcblx0dmFyIGlucHV0ID0gYXJnc1swXTtcblx0dmFyIGlzU2luZ2xlU3RyaW5nID0gYXJncy5sZW5ndGggPT0gMSAmJiB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnO1xuXHR2YXIgaXNBbWJpZ1RpbWU7XG5cdHZhciBpc0FtYmlnWm9uZTtcblx0dmFyIGFtYmlnTWF0Y2g7XG5cdHZhciBtb207XG5cblx0aWYgKG1vbWVudC5pc01vbWVudChpbnB1dCkgfHwgaXNOYXRpdmVEYXRlKGlucHV0KSB8fCBpbnB1dCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0bW9tID0gbW9tZW50LmFwcGx5KG51bGwsIGFyZ3MpO1xuXHR9XG5cdGVsc2UgeyAvLyBcInBhcnNpbmdcIiBpcyByZXF1aXJlZFxuXHRcdGlzQW1iaWdUaW1lID0gZmFsc2U7XG5cdFx0aXNBbWJpZ1pvbmUgPSBmYWxzZTtcblxuXHRcdGlmIChpc1NpbmdsZVN0cmluZykge1xuXHRcdFx0aWYgKGFtYmlnRGF0ZU9mTW9udGhSZWdleC50ZXN0KGlucHV0KSkge1xuXHRcdFx0XHQvLyBhY2NlcHQgc3RyaW5ncyBsaWtlICcyMDE0LTA1JywgYnV0IGNvbnZlcnQgdG8gdGhlIGZpcnN0IG9mIHRoZSBtb250aFxuXHRcdFx0XHRpbnB1dCArPSAnLTAxJztcblx0XHRcdFx0YXJncyA9IFsgaW5wdXQgXTsgLy8gZm9yIHdoZW4gd2UgcGFzcyBpdCBvbiB0byBtb21lbnQncyBjb25zdHJ1Y3RvclxuXHRcdFx0XHRpc0FtYmlnVGltZSA9IHRydWU7XG5cdFx0XHRcdGlzQW1iaWdab25lID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKChhbWJpZ01hdGNoID0gYW1iaWdUaW1lT3Jab25lUmVnZXguZXhlYyhpbnB1dCkpKSB7XG5cdFx0XHRcdGlzQW1iaWdUaW1lID0gIWFtYmlnTWF0Y2hbNV07IC8vIG5vIHRpbWUgcGFydD9cblx0XHRcdFx0aXNBbWJpZ1pvbmUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmICgkLmlzQXJyYXkoaW5wdXQpKSB7XG5cdFx0XHQvLyBhcnJheXMgaGF2ZSBubyB0aW1lem9uZSBpbmZvcm1hdGlvbiwgc28gYXNzdW1lIGFtYmlndW91cyB6b25lXG5cdFx0XHRpc0FtYmlnWm9uZSA9IHRydWU7XG5cdFx0fVxuXHRcdC8vIG90aGVyd2lzZSwgcHJvYmFibHkgYSBzdHJpbmcgd2l0aCBhIGZvcm1hdFxuXG5cdFx0aWYgKHBhcnNlQXNVVEMgfHwgaXNBbWJpZ1RpbWUpIHtcblx0XHRcdG1vbSA9IG1vbWVudC51dGMuYXBwbHkobW9tZW50LCBhcmdzKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRtb20gPSBtb21lbnQuYXBwbHkobnVsbCwgYXJncyk7XG5cdFx0fVxuXG5cdFx0aWYgKGlzQW1iaWdUaW1lKSB7XG5cdFx0XHRtb20uX2FtYmlnVGltZSA9IHRydWU7XG5cdFx0XHRtb20uX2FtYmlnWm9uZSA9IHRydWU7IC8vIGFtYmlndW91cyB0aW1lIGFsd2F5cyBtZWFucyBhbWJpZ3VvdXMgem9uZVxuXHRcdH1cblx0XHRlbHNlIGlmIChwYXJzZVpvbmUpIHsgLy8gbGV0J3MgcmVjb3JkIHRoZSBpbnB1dHRlZCB6b25lIHNvbWVob3dcblx0XHRcdGlmIChpc0FtYmlnWm9uZSkge1xuXHRcdFx0XHRtb20uX2FtYmlnWm9uZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChpc1NpbmdsZVN0cmluZykge1xuXHRcdFx0XHRtb20udXRjT2Zmc2V0KGlucHV0KTsgLy8gaWYgbm90IGEgdmFsaWQgem9uZSwgd2lsbCBhc3NpZ24gVVRDXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0bW9tLl9mdWxsQ2FsZW5kYXIgPSB0cnVlOyAvLyBmbGFnIGZvciBleHRlbmRlZCBmdW5jdGlvbmFsaXR5XG5cblx0cmV0dXJuIG1vbTtcbn1cblxuXG4vLyBXZWVrIE51bWJlclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbi8vIFJldHVybnMgdGhlIHdlZWsgbnVtYmVyLCBjb25zaWRlcmluZyB0aGUgbG9jYWxlJ3MgY3VzdG9tIHdlZWsgbnVtYmVyIGNhbGN1YXRpb25cbi8vIGB3ZWVrc2AgaXMgYW4gYWxpYXMgZm9yIGB3ZWVrYFxubmV3TW9tZW50UHJvdG8ud2VlayA9IG5ld01vbWVudFByb3RvLndlZWtzID0gZnVuY3Rpb24oaW5wdXQpIHtcblx0dmFyIHdlZWtDYWxjID0gdGhpcy5fbG9jYWxlLl9mdWxsQ2FsZW5kYXJfd2Vla0NhbGM7XG5cblx0aWYgKGlucHV0ID09IG51bGwgJiYgdHlwZW9mIHdlZWtDYWxjID09PSAnZnVuY3Rpb24nKSB7IC8vIGN1c3RvbSBmdW5jdGlvbiBvbmx5IHdvcmtzIGZvciBnZXR0ZXJcblx0XHRyZXR1cm4gd2Vla0NhbGModGhpcyk7XG5cdH1cblx0ZWxzZSBpZiAod2Vla0NhbGMgPT09ICdJU08nKSB7XG5cdFx0cmV0dXJuIG9sZE1vbWVudFByb3RvLmlzb1dlZWsuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gSVNPIGdldHRlci9zZXR0ZXJcblx0fVxuXG5cdHJldHVybiBvbGRNb21lbnRQcm90by53ZWVrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIGxvY2FsIGdldHRlci9zZXR0ZXJcbn07XG5cblxuLy8gVGltZS1vZi1kYXlcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gR0VUVEVSXG4vLyBSZXR1cm5zIGEgRHVyYXRpb24gd2l0aCB0aGUgaG91cnMvbWludXRlcy9zZWNvbmRzL21zIHZhbHVlcyBvZiB0aGUgbW9tZW50LlxuLy8gSWYgdGhlIG1vbWVudCBoYXMgYW4gYW1iaWd1b3VzIHRpbWUsIGEgZHVyYXRpb24gb2YgMDA6MDAgd2lsbCBiZSByZXR1cm5lZC5cbi8vXG4vLyBTRVRURVJcbi8vIFlvdSBjYW4gc3VwcGx5IGEgRHVyYXRpb24sIGEgTW9tZW50LCBvciBhIER1cmF0aW9uLWxpa2UgYXJndW1lbnQuXG4vLyBXaGVuIHNldHRpbmcgdGhlIHRpbWUsIGFuZCB0aGUgbW9tZW50IGhhcyBhbiBhbWJpZ3VvdXMgdGltZSwgaXQgdGhlbiBiZWNvbWVzIHVuYW1iaWd1b3VzLlxubmV3TW9tZW50UHJvdG8udGltZSA9IGZ1bmN0aW9uKHRpbWUpIHtcblxuXHQvLyBGYWxsYmFjayB0byB0aGUgb3JpZ2luYWwgbWV0aG9kIChpZiB0aGVyZSBpcyBvbmUpIGlmIHRoaXMgbW9tZW50IHdhc24ndCBjcmVhdGVkIHZpYSBGdWxsQ2FsZW5kYXIuXG5cdC8vIGB0aW1lYCBpcyBhIGdlbmVyaWMgZW5vdWdoIG1ldGhvZCBuYW1lIHdoZXJlIHRoaXMgcHJlY2F1dGlvbiBpcyBuZWNlc3NhcnkgdG8gYXZvaWQgY29sbGlzaW9ucyB3LyBvdGhlciBwbHVnaW5zLlxuXHRpZiAoIXRoaXMuX2Z1bGxDYWxlbmRhcikge1xuXHRcdHJldHVybiBvbGRNb21lbnRQcm90by50aW1lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH1cblxuXHRpZiAodGltZSA9PSBudWxsKSB7IC8vIGdldHRlclxuXHRcdHJldHVybiBtb21lbnQuZHVyYXRpb24oe1xuXHRcdFx0aG91cnM6IHRoaXMuaG91cnMoKSxcblx0XHRcdG1pbnV0ZXM6IHRoaXMubWludXRlcygpLFxuXHRcdFx0c2Vjb25kczogdGhpcy5zZWNvbmRzKCksXG5cdFx0XHRtaWxsaXNlY29uZHM6IHRoaXMubWlsbGlzZWNvbmRzKClcblx0XHR9KTtcblx0fVxuXHRlbHNlIHsgLy8gc2V0dGVyXG5cblx0XHR0aGlzLl9hbWJpZ1RpbWUgPSBmYWxzZTsgLy8gbWFyayB0aGF0IHRoZSBtb21lbnQgbm93IGhhcyBhIHRpbWVcblxuXHRcdGlmICghbW9tZW50LmlzRHVyYXRpb24odGltZSkgJiYgIW1vbWVudC5pc01vbWVudCh0aW1lKSkge1xuXHRcdFx0dGltZSA9IG1vbWVudC5kdXJhdGlvbih0aW1lKTtcblx0XHR9XG5cblx0XHQvLyBUaGUgZGF5IHZhbHVlIHNob3VsZCBjYXVzZSBvdmVyZmxvdyAoc28gMjQgaG91cnMgYmVjb21lcyAwMDowMDowMCBvZiBuZXh0IGRheSkuXG5cdFx0Ly8gT25seSBmb3IgRHVyYXRpb24gdGltZXMsIG5vdCBNb21lbnQgdGltZXMuXG5cdFx0dmFyIGRheUhvdXJzID0gMDtcblx0XHRpZiAobW9tZW50LmlzRHVyYXRpb24odGltZSkpIHtcblx0XHRcdGRheUhvdXJzID0gTWF0aC5mbG9vcih0aW1lLmFzRGF5cygpKSAqIDI0O1xuXHRcdH1cblxuXHRcdC8vIFdlIG5lZWQgdG8gc2V0IHRoZSBpbmRpdmlkdWFsIGZpZWxkcy5cblx0XHQvLyBDYW4ndCB1c2Ugc3RhcnRPZignZGF5JykgdGhlbiBhZGQgZHVyYXRpb24uIEluIGNhc2Ugb2YgRFNUIGF0IHN0YXJ0IG9mIGRheS5cblx0XHRyZXR1cm4gdGhpcy5ob3VycyhkYXlIb3VycyArIHRpbWUuaG91cnMoKSlcblx0XHRcdC5taW51dGVzKHRpbWUubWludXRlcygpKVxuXHRcdFx0LnNlY29uZHModGltZS5zZWNvbmRzKCkpXG5cdFx0XHQubWlsbGlzZWNvbmRzKHRpbWUubWlsbGlzZWNvbmRzKCkpO1xuXHR9XG59O1xuXG4vLyBDb252ZXJ0cyB0aGUgbW9tZW50IHRvIFVUQywgc3RyaXBwaW5nIG91dCBpdHMgdGltZS1vZi1kYXkgYW5kIHRpbWV6b25lIG9mZnNldCxcbi8vIGJ1dCBwcmVzZXJ2aW5nIGl0cyBZTUQuIEEgbW9tZW50IHdpdGggYSBzdHJpcHBlZCB0aW1lIHdpbGwgZGlzcGxheSBubyB0aW1lXG4vLyBub3IgdGltZXpvbmUgb2Zmc2V0IHdoZW4gLmZvcm1hdCgpIGlzIGNhbGxlZC5cbm5ld01vbWVudFByb3RvLnN0cmlwVGltZSA9IGZ1bmN0aW9uKCkge1xuXG5cdGlmICghdGhpcy5fYW1iaWdUaW1lKSB7XG5cblx0XHR0aGlzLnV0Yyh0cnVlKTsgLy8ga2VlcExvY2FsVGltZT10cnVlIChmb3Iga2VlcGluZyAqZGF0ZSogdmFsdWUpXG5cblx0XHQvLyBzZXQgdGltZSB0byB6ZXJvXG5cdFx0dGhpcy5zZXQoe1xuXHRcdFx0aG91cnM6IDAsXG5cdFx0XHRtaW51dGVzOiAwLFxuXHRcdFx0c2Vjb25kczogMCxcblx0XHRcdG1zOiAwXG5cdFx0fSk7XG5cblx0XHQvLyBNYXJrIHRoZSB0aW1lIGFzIGFtYmlndW91cy4gVGhpcyBuZWVkcyB0byBoYXBwZW4gYWZ0ZXIgdGhlIC51dGMoKSBjYWxsLCB3aGljaCBtaWdodCBjYWxsIC51dGNPZmZzZXQoKSxcblx0XHQvLyB3aGljaCBjbGVhcnMgYWxsIGFtYmlnIGZsYWdzLlxuXHRcdHRoaXMuX2FtYmlnVGltZSA9IHRydWU7XG5cdFx0dGhpcy5fYW1iaWdab25lID0gdHJ1ZTsgLy8gaWYgYW1iaWd1b3VzIHRpbWUsIGFsc28gYW1iaWd1b3VzIHRpbWV6b25lIG9mZnNldFxuXHR9XG5cblx0cmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xufTtcblxuLy8gUmV0dXJucyBpZiB0aGUgbW9tZW50IGhhcyBhIG5vbi1hbWJpZ3VvdXMgdGltZSAoYm9vbGVhbilcbm5ld01vbWVudFByb3RvLmhhc1RpbWUgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuICF0aGlzLl9hbWJpZ1RpbWU7XG59O1xuXG5cbi8vIFRpbWV6b25lXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIENvbnZlcnRzIHRoZSBtb21lbnQgdG8gVVRDLCBzdHJpcHBpbmcgb3V0IGl0cyB0aW1lem9uZSBvZmZzZXQsIGJ1dCBwcmVzZXJ2aW5nIGl0c1xuLy8gWU1EIGFuZCB0aW1lLW9mLWRheS4gQSBtb21lbnQgd2l0aCBhIHN0cmlwcGVkIHRpbWV6b25lIG9mZnNldCB3aWxsIGRpc3BsYXkgbm9cbi8vIHRpbWV6b25lIG9mZnNldCB3aGVuIC5mb3JtYXQoKSBpcyBjYWxsZWQuXG5uZXdNb21lbnRQcm90by5zdHJpcFpvbmUgPSBmdW5jdGlvbigpIHtcblx0dmFyIHdhc0FtYmlnVGltZTtcblxuXHRpZiAoIXRoaXMuX2FtYmlnWm9uZSkge1xuXG5cdFx0d2FzQW1iaWdUaW1lID0gdGhpcy5fYW1iaWdUaW1lO1xuXG5cdFx0dGhpcy51dGModHJ1ZSk7IC8vIGtlZXBMb2NhbFRpbWU9dHJ1ZSAoZm9yIGtlZXBpbmcgZGF0ZSBhbmQgdGltZSB2YWx1ZXMpXG5cblx0XHQvLyB0aGUgYWJvdmUgY2FsbCB0byAudXRjKCkvLnV0Y09mZnNldCgpIHVuZm9ydHVuYXRlbHkgbWlnaHQgY2xlYXIgdGhlIGFtYmlnIGZsYWdzLCBzbyByZXN0b3JlXG5cdFx0dGhpcy5fYW1iaWdUaW1lID0gd2FzQW1iaWdUaW1lIHx8IGZhbHNlO1xuXG5cdFx0Ly8gTWFyayB0aGUgem9uZSBhcyBhbWJpZ3VvdXMuIFRoaXMgbmVlZHMgdG8gaGFwcGVuIGFmdGVyIHRoZSAudXRjKCkgY2FsbCwgd2hpY2ggbWlnaHQgY2FsbCAudXRjT2Zmc2V0KCksXG5cdFx0Ly8gd2hpY2ggY2xlYXJzIHRoZSBhbWJpZyBmbGFncy5cblx0XHR0aGlzLl9hbWJpZ1pvbmUgPSB0cnVlO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xufTtcblxuLy8gUmV0dXJucyBvZiB0aGUgbW9tZW50IGhhcyBhIG5vbi1hbWJpZ3VvdXMgdGltZXpvbmUgb2Zmc2V0IChib29sZWFuKVxubmV3TW9tZW50UHJvdG8uaGFzWm9uZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gIXRoaXMuX2FtYmlnWm9uZTtcbn07XG5cblxuLy8gaW1wbGljaXRseSBtYXJrcyBhIHpvbmVcbm5ld01vbWVudFByb3RvLmxvY2FsID0gZnVuY3Rpb24oa2VlcExvY2FsVGltZSkge1xuXG5cdC8vIGZvciB3aGVuIGNvbnZlcnRpbmcgZnJvbSBhbWJpZ3VvdXNseS16b25lZCB0byBsb2NhbCxcblx0Ly8ga2VlcCB0aGUgdGltZSB2YWx1ZXMgd2hlbiBjb252ZXJ0aW5nIGZyb20gVVRDIC0+IGxvY2FsXG5cdG9sZE1vbWVudFByb3RvLmxvY2FsLmNhbGwodGhpcywgdGhpcy5fYW1iaWdab25lIHx8IGtlZXBMb2NhbFRpbWUpO1xuXG5cdC8vIGVuc3VyZSBub24tYW1iaWd1b3VzXG5cdC8vIHRoaXMgcHJvYmFibHkgYWxyZWFkeSBoYXBwZW5lZCB2aWEgbG9jYWwoKSAtPiB1dGNPZmZzZXQoKSwgYnV0IGRvbid0IHJlbHkgb24gTW9tZW50J3MgaW50ZXJuYWxzXG5cdHRoaXMuX2FtYmlnVGltZSA9IGZhbHNlO1xuXHR0aGlzLl9hbWJpZ1pvbmUgPSBmYWxzZTtcblxuXHRyZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXG59O1xuXG5cbi8vIGltcGxpY2l0bHkgbWFya3MgYSB6b25lXG5uZXdNb21lbnRQcm90by51dGMgPSBmdW5jdGlvbihrZWVwTG9jYWxUaW1lKSB7XG5cblx0b2xkTW9tZW50UHJvdG8udXRjLmNhbGwodGhpcywga2VlcExvY2FsVGltZSk7XG5cblx0Ly8gZW5zdXJlIG5vbi1hbWJpZ3VvdXNcblx0Ly8gdGhpcyBwcm9iYWJseSBhbHJlYWR5IGhhcHBlbmVkIHZpYSB1dGMoKSAtPiB1dGNPZmZzZXQoKSwgYnV0IGRvbid0IHJlbHkgb24gTW9tZW50J3MgaW50ZXJuYWxzXG5cdHRoaXMuX2FtYmlnVGltZSA9IGZhbHNlO1xuXHR0aGlzLl9hbWJpZ1pvbmUgPSBmYWxzZTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuLy8gaW1wbGljaXRseSBtYXJrcyBhIHpvbmUgKHdpbGwgcHJvYmFibHkgZ2V0IGNhbGxlZCB1cG9uIC51dGMoKSBhbmQgLmxvY2FsKCkpXG5uZXdNb21lbnRQcm90by51dGNPZmZzZXQgPSBmdW5jdGlvbih0em8pIHtcblxuXHRpZiAodHpvICE9IG51bGwpIHsgLy8gc2V0dGVyXG5cdFx0Ly8gdGhlc2UgYXNzaWdubWVudHMgbmVlZHMgdG8gaGFwcGVuIGJlZm9yZSB0aGUgb3JpZ2luYWwgem9uZSBtZXRob2QgaXMgY2FsbGVkLlxuXHRcdC8vIEkgZm9yZ2V0IHdoeSwgc29tZXRoaW5nIHRvIGRvIHdpdGggYSBicm93c2VyIGNyYXNoLlxuXHRcdHRoaXMuX2FtYmlnVGltZSA9IGZhbHNlO1xuXHRcdHRoaXMuX2FtYmlnWm9uZSA9IGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIG9sZE1vbWVudFByb3RvLnV0Y09mZnNldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuXG4vLyBGb3JtYXR0aW5nXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbm5ld01vbWVudFByb3RvLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAodGhpcy5fZnVsbENhbGVuZGFyICYmIGFyZ3VtZW50c1swXSkgeyAvLyBhbiBlbmhhbmNlZCBtb21lbnQ/IGFuZCBhIGZvcm1hdCBzdHJpbmcgcHJvdmlkZWQ/XG5cdFx0cmV0dXJuIGZvcm1hdERhdGUodGhpcywgYXJndW1lbnRzWzBdKTsgLy8gb3VyIGV4dGVuZGVkIGZvcm1hdHRpbmdcblx0fVxuXHRpZiAodGhpcy5fYW1iaWdUaW1lKSB7XG5cdFx0cmV0dXJuIG9sZE1vbWVudEZvcm1hdCh0aGlzLCAnWVlZWS1NTS1ERCcpO1xuXHR9XG5cdGlmICh0aGlzLl9hbWJpZ1pvbmUpIHtcblx0XHRyZXR1cm4gb2xkTW9tZW50Rm9ybWF0KHRoaXMsICdZWVlZLU1NLUREW1RdSEg6bW06c3MnKTtcblx0fVxuXHRyZXR1cm4gb2xkTW9tZW50UHJvdG8uZm9ybWF0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG5uZXdNb21lbnRQcm90by50b0lTT1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRpZiAodGhpcy5fYW1iaWdUaW1lKSB7XG5cdFx0cmV0dXJuIG9sZE1vbWVudEZvcm1hdCh0aGlzLCAnWVlZWS1NTS1ERCcpO1xuXHR9XG5cdGlmICh0aGlzLl9hbWJpZ1pvbmUpIHtcblx0XHRyZXR1cm4gb2xkTW9tZW50Rm9ybWF0KHRoaXMsICdZWVlZLU1NLUREW1RdSEg6bW06c3MnKTtcblx0fVxuXHRyZXR1cm4gb2xkTW9tZW50UHJvdG8udG9JU09TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbjs7XG5cbi8vIFNpbmdsZSBEYXRlIEZvcm1hdHRpbmdcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4vLyBjYWxsIHRoaXMgaWYgeW91IHdhbnQgTW9tZW50J3Mgb3JpZ2luYWwgZm9ybWF0IG1ldGhvZCB0byBiZSB1c2VkXG5mdW5jdGlvbiBvbGRNb21lbnRGb3JtYXQobW9tLCBmb3JtYXRTdHIpIHtcblx0cmV0dXJuIG9sZE1vbWVudFByb3RvLmZvcm1hdC5jYWxsKG1vbSwgZm9ybWF0U3RyKTsgLy8gb2xkTW9tZW50UHJvdG8gZGVmaW5lZCBpbiBtb21lbnQtZXh0LmpzXG59XG5cblxuLy8gRm9ybWF0cyBgZGF0ZWAgd2l0aCBhIE1vbWVudCBmb3JtYXR0aW5nIHN0cmluZywgYnV0IGFsbG93IG91ciBub24temVybyBhcmVhcyBhbmRcbi8vIGFkZGl0aW9uYWwgdG9rZW4uXG5mdW5jdGlvbiBmb3JtYXREYXRlKGRhdGUsIGZvcm1hdFN0cikge1xuXHRyZXR1cm4gZm9ybWF0RGF0ZVdpdGhDaHVua3MoZGF0ZSwgZ2V0Rm9ybWF0U3RyaW5nQ2h1bmtzKGZvcm1hdFN0cikpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdERhdGVXaXRoQ2h1bmtzKGRhdGUsIGNodW5rcykge1xuXHR2YXIgcyA9ICcnO1xuXHR2YXIgaTtcblxuXHRmb3IgKGk9MDsgaTxjaHVua3MubGVuZ3RoOyBpKyspIHtcblx0XHRzICs9IGZvcm1hdERhdGVXaXRoQ2h1bmsoZGF0ZSwgY2h1bmtzW2ldKTtcblx0fVxuXG5cdHJldHVybiBzO1xufVxuXG5cbi8vIGFkZGl0aW9uIGZvcm1hdHRpbmcgdG9rZW5zIHdlIHdhbnQgcmVjb2duaXplZFxudmFyIHRva2VuT3ZlcnJpZGVzID0ge1xuXHR0OiBmdW5jdGlvbihkYXRlKSB7IC8vIFwiYVwiIG9yIFwicFwiXG5cdFx0cmV0dXJuIG9sZE1vbWVudEZvcm1hdChkYXRlLCAnYScpLmNoYXJBdCgwKTtcblx0fSxcblx0VDogZnVuY3Rpb24oZGF0ZSkgeyAvLyBcIkFcIiBvciBcIlBcIlxuXHRcdHJldHVybiBvbGRNb21lbnRGb3JtYXQoZGF0ZSwgJ0EnKS5jaGFyQXQoMCk7XG5cdH1cbn07XG5cblxuZnVuY3Rpb24gZm9ybWF0RGF0ZVdpdGhDaHVuayhkYXRlLCBjaHVuaykge1xuXHR2YXIgdG9rZW47XG5cdHZhciBtYXliZVN0cjtcblxuXHRpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykgeyAvLyBhIGxpdGVyYWwgc3RyaW5nXG5cdFx0cmV0dXJuIGNodW5rO1xuXHR9XG5cdGVsc2UgaWYgKCh0b2tlbiA9IGNodW5rLnRva2VuKSkgeyAvLyBhIHRva2VuLCBsaWtlIFwiWVlZWVwiXG5cdFx0aWYgKHRva2VuT3ZlcnJpZGVzW3Rva2VuXSkge1xuXHRcdFx0cmV0dXJuIHRva2VuT3ZlcnJpZGVzW3Rva2VuXShkYXRlKTsgLy8gdXNlIG91ciBjdXN0b20gdG9rZW5cblx0XHR9XG5cdFx0cmV0dXJuIG9sZE1vbWVudEZvcm1hdChkYXRlLCB0b2tlbik7XG5cdH1cblx0ZWxzZSBpZiAoY2h1bmsubWF5YmUpIHsgLy8gYSBncm91cGluZyBvZiBvdGhlciBjaHVua3MgdGhhdCBtdXN0IGJlIG5vbi16ZXJvXG5cdFx0bWF5YmVTdHIgPSBmb3JtYXREYXRlV2l0aENodW5rcyhkYXRlLCBjaHVuay5tYXliZSk7XG5cdFx0aWYgKG1heWJlU3RyLm1hdGNoKC9bMS05XS8pKSB7XG5cdFx0XHRyZXR1cm4gbWF5YmVTdHI7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuICcnO1xufVxuXG5cbi8vIERhdGUgUmFuZ2UgRm9ybWF0dGluZ1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVE9ETzogbWFrZSBpdCB3b3JrIHdpdGggdGltZXpvbmUgb2Zmc2V0XG5cbi8vIFVzaW5nIGEgZm9ybWF0dGluZyBzdHJpbmcgbWVhbnQgZm9yIGEgc2luZ2xlIGRhdGUsIGdlbmVyYXRlIGEgcmFuZ2Ugc3RyaW5nLCBsaWtlXG4vLyBcIlNlcCAyIC0gOSAyMDEzXCIsIHRoYXQgaW50ZWxsaWdlbnRseSBpbnNlcnRzIGEgc2VwYXJhdG9yIHdoZXJlIHRoZSBkYXRlcyBkaWZmZXIuXG4vLyBJZiB0aGUgZGF0ZXMgYXJlIHRoZSBzYW1lIGFzIGZhciBhcyB0aGUgZm9ybWF0IHN0cmluZyBpcyBjb25jZXJuZWQsIGp1c3QgcmV0dXJuIGEgc2luZ2xlXG4vLyByZW5kZXJpbmcgb2Ygb25lIGRhdGUsIHdpdGhvdXQgYW55IHNlcGFyYXRvci5cbmZ1bmN0aW9uIGZvcm1hdFJhbmdlKGRhdGUxLCBkYXRlMiwgZm9ybWF0U3RyLCBzZXBhcmF0b3IsIGlzUlRMKSB7XG5cdHZhciBsb2NhbGVEYXRhO1xuXG5cdGRhdGUxID0gRkMubW9tZW50LnBhcnNlWm9uZShkYXRlMSk7XG5cdGRhdGUyID0gRkMubW9tZW50LnBhcnNlWm9uZShkYXRlMik7XG5cblx0bG9jYWxlRGF0YSA9IGRhdGUxLmxvY2FsZURhdGEoKTtcblxuXHQvLyBFeHBhbmQgbG9jYWxpemVkIGZvcm1hdCBzdHJpbmdzLCBsaWtlIFwiTExcIiAtPiBcIk1NTU0gRCBZWVlZXCJcblx0Zm9ybWF0U3RyID0gbG9jYWxlRGF0YS5sb25nRGF0ZUZvcm1hdChmb3JtYXRTdHIpIHx8IGZvcm1hdFN0cjtcblx0Ly8gQlRXLCB0aGlzIGlzIG5vdCBpbXBvcnRhbnQgZm9yIGBmb3JtYXREYXRlYCBiZWNhdXNlIGl0IGlzIGltcG9zc2libGUgdG8gcHV0IGN1c3RvbSB0b2tlbnNcblx0Ly8gb3Igbm9uLXplcm8gYXJlYXMgaW4gTW9tZW50J3MgbG9jYWxpemVkIGZvcm1hdCBzdHJpbmdzLlxuXG5cdHNlcGFyYXRvciA9IHNlcGFyYXRvciB8fCAnIC0gJztcblxuXHRyZXR1cm4gZm9ybWF0UmFuZ2VXaXRoQ2h1bmtzKFxuXHRcdGRhdGUxLFxuXHRcdGRhdGUyLFxuXHRcdGdldEZvcm1hdFN0cmluZ0NodW5rcyhmb3JtYXRTdHIpLFxuXHRcdHNlcGFyYXRvcixcblx0XHRpc1JUTFxuXHQpO1xufVxuRkMuZm9ybWF0UmFuZ2UgPSBmb3JtYXRSYW5nZTsgLy8gZXhwb3NlXG5cblxuZnVuY3Rpb24gZm9ybWF0UmFuZ2VXaXRoQ2h1bmtzKGRhdGUxLCBkYXRlMiwgY2h1bmtzLCBzZXBhcmF0b3IsIGlzUlRMKSB7XG5cdHZhciB1bnpvbmVkRGF0ZTEgPSBkYXRlMS5jbG9uZSgpLnN0cmlwWm9uZSgpOyAvLyBmb3IgZm9ybWF0U2ltaWxhckNodW5rXG5cdHZhciB1bnpvbmVkRGF0ZTIgPSBkYXRlMi5jbG9uZSgpLnN0cmlwWm9uZSgpOyAvLyBcIlxuXHR2YXIgY2h1bmtTdHI7IC8vIHRoZSByZW5kZXJpbmcgb2YgdGhlIGNodW5rXG5cdHZhciBsZWZ0STtcblx0dmFyIGxlZnRTdHIgPSAnJztcblx0dmFyIHJpZ2h0STtcblx0dmFyIHJpZ2h0U3RyID0gJyc7XG5cdHZhciBtaWRkbGVJO1xuXHR2YXIgbWlkZGxlU3RyMSA9ICcnO1xuXHR2YXIgbWlkZGxlU3RyMiA9ICcnO1xuXHR2YXIgbWlkZGxlU3RyID0gJyc7XG5cblx0Ly8gU3RhcnQgYXQgdGhlIGxlZnRtb3N0IHNpZGUgb2YgdGhlIGZvcm1hdHRpbmcgc3RyaW5nIGFuZCBjb250aW51ZSB1bnRpbCB5b3UgaGl0IGEgdG9rZW5cblx0Ly8gdGhhdCBpcyBub3QgdGhlIHNhbWUgYmV0d2VlbiBkYXRlcy5cblx0Zm9yIChsZWZ0ST0wOyBsZWZ0STxjaHVua3MubGVuZ3RoOyBsZWZ0SSsrKSB7XG5cdFx0Y2h1bmtTdHIgPSBmb3JtYXRTaW1pbGFyQ2h1bmsoZGF0ZTEsIGRhdGUyLCB1bnpvbmVkRGF0ZTEsIHVuem9uZWREYXRlMiwgY2h1bmtzW2xlZnRJXSk7XG5cdFx0aWYgKGNodW5rU3RyID09PSBmYWxzZSkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdGxlZnRTdHIgKz0gY2h1bmtTdHI7XG5cdH1cblxuXHQvLyBTaW1pbGFybHksIHN0YXJ0IGF0IHRoZSByaWdodG1vc3Qgc2lkZSBvZiB0aGUgZm9ybWF0dGluZyBzdHJpbmcgYW5kIG1vdmUgbGVmdFxuXHRmb3IgKHJpZ2h0ST1jaHVua3MubGVuZ3RoLTE7IHJpZ2h0ST5sZWZ0STsgcmlnaHRJLS0pIHtcblx0XHRjaHVua1N0ciA9IGZvcm1hdFNpbWlsYXJDaHVuayhkYXRlMSwgZGF0ZTIsIHVuem9uZWREYXRlMSwgdW56b25lZERhdGUyLCAgY2h1bmtzW3JpZ2h0SV0pO1xuXHRcdGlmIChjaHVua1N0ciA9PT0gZmFsc2UpIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHRyaWdodFN0ciA9IGNodW5rU3RyICsgcmlnaHRTdHI7XG5cdH1cblxuXHQvLyBUaGUgYXJlYSBpbiB0aGUgbWlkZGxlIGlzIGRpZmZlcmVudCBmb3IgYm90aCBvZiB0aGUgZGF0ZXMuXG5cdC8vIENvbGxlY3QgdGhlbSBkaXN0aW5jdGx5IHNvIHdlIGNhbiBqYW0gdGhlbSB0b2dldGhlciBsYXRlci5cblx0Zm9yIChtaWRkbGVJPWxlZnRJOyBtaWRkbGVJPD1yaWdodEk7IG1pZGRsZUkrKykge1xuXHRcdG1pZGRsZVN0cjEgKz0gZm9ybWF0RGF0ZVdpdGhDaHVuayhkYXRlMSwgY2h1bmtzW21pZGRsZUldKTtcblx0XHRtaWRkbGVTdHIyICs9IGZvcm1hdERhdGVXaXRoQ2h1bmsoZGF0ZTIsIGNodW5rc1ttaWRkbGVJXSk7XG5cdH1cblxuXHRpZiAobWlkZGxlU3RyMSB8fCBtaWRkbGVTdHIyKSB7XG5cdFx0aWYgKGlzUlRMKSB7XG5cdFx0XHRtaWRkbGVTdHIgPSBtaWRkbGVTdHIyICsgc2VwYXJhdG9yICsgbWlkZGxlU3RyMTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRtaWRkbGVTdHIgPSBtaWRkbGVTdHIxICsgc2VwYXJhdG9yICsgbWlkZGxlU3RyMjtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbGVmdFN0ciArIG1pZGRsZVN0ciArIHJpZ2h0U3RyO1xufVxuXG5cbnZhciBzaW1pbGFyVW5pdE1hcCA9IHtcblx0WTogJ3llYXInLFxuXHRNOiAnbW9udGgnLFxuXHREOiAnZGF5JywgLy8gZGF5IG9mIG1vbnRoXG5cdGQ6ICdkYXknLCAvLyBkYXkgb2Ygd2Vla1xuXHQvLyBwcmV2ZW50cyBhIHNlcGFyYXRvciBiZXR3ZWVuIGFueXRoaW5nIHRpbWUtcmVsYXRlZC4uLlxuXHRBOiAnc2Vjb25kJywgLy8gQU0vUE1cblx0YTogJ3NlY29uZCcsIC8vIGFtL3BtXG5cdFQ6ICdzZWNvbmQnLCAvLyBBL1Bcblx0dDogJ3NlY29uZCcsIC8vIGEvcFxuXHRIOiAnc2Vjb25kJywgLy8gaG91ciAoMjQpXG5cdGg6ICdzZWNvbmQnLCAvLyBob3VyICgxMilcblx0bTogJ3NlY29uZCcsIC8vIG1pbnV0ZVxuXHRzOiAnc2Vjb25kJyAvLyBzZWNvbmRcbn07XG4vLyBUT0RPOiB3ZWVrIG1heWJlP1xuXG5cbi8vIEdpdmVuIGEgZm9ybWF0dGluZyBjaHVuaywgYW5kIGdpdmVuIHRoYXQgYm90aCBkYXRlcyBhcmUgc2ltaWxhciBpbiB0aGUgcmVnYXJkIHRoZVxuLy8gZm9ybWF0dGluZyBjaHVuayBpcyBjb25jZXJuZWQsIGZvcm1hdCBkYXRlMSBhZ2FpbnN0IGBjaHVua2AuIE90aGVyd2lzZSwgcmV0dXJuIGBmYWxzZWAuXG5mdW5jdGlvbiBmb3JtYXRTaW1pbGFyQ2h1bmsoZGF0ZTEsIGRhdGUyLCB1bnpvbmVkRGF0ZTEsIHVuem9uZWREYXRlMiwgY2h1bmspIHtcblx0dmFyIHRva2VuO1xuXHR2YXIgdW5pdDtcblxuXHRpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykgeyAvLyBhIGxpdGVyYWwgc3RyaW5nXG5cdFx0cmV0dXJuIGNodW5rO1xuXHR9XG5cdGVsc2UgaWYgKCh0b2tlbiA9IGNodW5rLnRva2VuKSkge1xuXHRcdHVuaXQgPSBzaW1pbGFyVW5pdE1hcFt0b2tlbi5jaGFyQXQoMCldO1xuXG5cdFx0Ly8gYXJlIHRoZSBkYXRlcyB0aGUgc2FtZSBmb3IgdGhpcyB1bml0IG9mIG1lYXN1cmVtZW50P1xuXHRcdC8vIHVzZSB0aGUgdW56b25lZCBkYXRlcyBmb3IgdGhpcyBjYWxjdWxhdGlvbiBiZWNhdXNlIHVucmVsaWFibGUgd2hlbiBuZWFyIERTVCAoYnVnICMyMzk2KVxuXHRcdGlmICh1bml0ICYmIHVuem9uZWREYXRlMS5pc1NhbWUodW56b25lZERhdGUyLCB1bml0KSkge1xuXHRcdFx0cmV0dXJuIG9sZE1vbWVudEZvcm1hdChkYXRlMSwgdG9rZW4pOyAvLyB3b3VsZCBiZSB0aGUgc2FtZSBpZiB3ZSB1c2VkIGBkYXRlMmBcblx0XHRcdC8vIEJUVywgZG9uJ3Qgc3VwcG9ydCBjdXN0b20gdG9rZW5zXG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZhbHNlOyAvLyB0aGUgY2h1bmsgaXMgTk9UIHRoZSBzYW1lIGZvciB0aGUgdHdvIGRhdGVzXG5cdC8vIEJUVywgZG9uJ3Qgc3VwcG9ydCBzcGxpdHRpbmcgb24gbm9uLXplcm8gYXJlYXNcbn1cblxuXG4vLyBDaHVua2luZyBVdGlsc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbnZhciBmb3JtYXRTdHJpbmdDaHVua0NhY2hlID0ge307XG5cblxuZnVuY3Rpb24gZ2V0Rm9ybWF0U3RyaW5nQ2h1bmtzKGZvcm1hdFN0cikge1xuXHRpZiAoZm9ybWF0U3RyIGluIGZvcm1hdFN0cmluZ0NodW5rQ2FjaGUpIHtcblx0XHRyZXR1cm4gZm9ybWF0U3RyaW5nQ2h1bmtDYWNoZVtmb3JtYXRTdHJdO1xuXHR9XG5cdHJldHVybiAoZm9ybWF0U3RyaW5nQ2h1bmtDYWNoZVtmb3JtYXRTdHJdID0gY2h1bmtGb3JtYXRTdHJpbmcoZm9ybWF0U3RyKSk7XG59XG5cblxuLy8gQnJlYWsgdGhlIGZvcm1hdHRpbmcgc3RyaW5nIGludG8gYW4gYXJyYXkgb2YgY2h1bmtzXG5mdW5jdGlvbiBjaHVua0Zvcm1hdFN0cmluZyhmb3JtYXRTdHIpIHtcblx0dmFyIGNodW5rcyA9IFtdO1xuXHR2YXIgY2h1bmtlciA9IC9cXFsoW15cXF1dKilcXF18XFwoKFteXFwpXSopXFwpfChMVFN8TFR8KFxcdylcXDQqbz8pfChbXlxcd1xcW1xcKF0rKS9nOyAvLyBUT0RPOiBtb3JlIGRlc2NyaW1pbmF0aW9uXG5cdHZhciBtYXRjaDtcblxuXHR3aGlsZSAoKG1hdGNoID0gY2h1bmtlci5leGVjKGZvcm1hdFN0cikpKSB7XG5cdFx0aWYgKG1hdGNoWzFdKSB7IC8vIGEgbGl0ZXJhbCBzdHJpbmcgaW5zaWRlIFsgLi4uIF1cblx0XHRcdGNodW5rcy5wdXNoKG1hdGNoWzFdKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAobWF0Y2hbMl0pIHsgLy8gbm9uLXplcm8gZm9ybWF0dGluZyBpbnNpZGUgKCAuLi4gKVxuXHRcdFx0Y2h1bmtzLnB1c2goeyBtYXliZTogY2h1bmtGb3JtYXRTdHJpbmcobWF0Y2hbMl0pIH0pO1xuXHRcdH1cblx0XHRlbHNlIGlmIChtYXRjaFszXSkgeyAvLyBhIGZvcm1hdHRpbmcgdG9rZW5cblx0XHRcdGNodW5rcy5wdXNoKHsgdG9rZW46IG1hdGNoWzNdIH0pO1xuXHRcdH1cblx0XHRlbHNlIGlmIChtYXRjaFs1XSkgeyAvLyBhbiB1bmVuY2xvc2VkIGxpdGVyYWwgc3RyaW5nXG5cdFx0XHRjaHVua3MucHVzaChtYXRjaFs1XSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNodW5rcztcbn1cblxuXG4vLyBNaXNjIFV0aWxzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuLy8gZ3JhbnVsYXJpdHkgb25seSBnb2VzIHVwIHVudGlsIGRheVxuLy8gVE9ETzogdW5pZnkgd2l0aCBzaW1pbGFyVW5pdE1hcFxudmFyIHRva2VuR3JhbnVsYXJpdGllcyA9IHtcblx0WTogeyB2YWx1ZTogMSwgdW5pdDogJ3llYXInIH0sXG5cdE06IHsgdmFsdWU6IDIsIHVuaXQ6ICdtb250aCcgfSxcblx0VzogeyB2YWx1ZTogMywgdW5pdDogJ3dlZWsnIH0sXG5cdHc6IHsgdmFsdWU6IDMsIHVuaXQ6ICd3ZWVrJyB9LFxuXHREOiB7IHZhbHVlOiA0LCB1bml0OiAnZGF5JyB9LCAvLyBkYXkgb2YgbW9udGhcblx0ZDogeyB2YWx1ZTogNCwgdW5pdDogJ2RheScgfSAvLyBkYXkgb2Ygd2Vla1xufTtcblxuLy8gcmV0dXJucyBhIHVuaXQgc3RyaW5nLCBlaXRoZXIgJ3llYXInLCAnbW9udGgnLCAnZGF5Jywgb3IgbnVsbFxuLy8gZm9yIHRoZSBtb3N0IGdyYW51bGFyIGZvcm1hdHRpbmcgdG9rZW4gaW4gdGhlIHN0cmluZy5cbkZDLnF1ZXJ5TW9zdEdyYW51bGFyRm9ybWF0VW5pdCA9IGZ1bmN0aW9uKGZvcm1hdFN0cikge1xuXHR2YXIgY2h1bmtzID0gZ2V0Rm9ybWF0U3RyaW5nQ2h1bmtzKGZvcm1hdFN0cik7XG5cdHZhciBpLCBjaHVuaztcblx0dmFyIGNhbmRpZGF0ZTtcblx0dmFyIGJlc3Q7XG5cblx0Zm9yIChpID0gMDsgaSA8IGNodW5rcy5sZW5ndGg7IGkrKykge1xuXHRcdGNodW5rID0gY2h1bmtzW2ldO1xuXHRcdGlmIChjaHVuay50b2tlbikge1xuXHRcdFx0Y2FuZGlkYXRlID0gdG9rZW5HcmFudWxhcml0aWVzW2NodW5rLnRva2VuLmNoYXJBdCgwKV07XG5cdFx0XHRpZiAoY2FuZGlkYXRlKSB7XG5cdFx0XHRcdGlmICghYmVzdCB8fCBjYW5kaWRhdGUudmFsdWUgPiBiZXN0LnZhbHVlKSB7XG5cdFx0XHRcdFx0YmVzdCA9IGNhbmRpZGF0ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmIChiZXN0KSB7XG5cdFx0cmV0dXJuIGJlc3QudW5pdDtcblx0fVxuXG5cdHJldHVybiBudWxsO1xufTtcblxuOztcblxuRkMuQ2xhc3MgPSBDbGFzczsgLy8gZXhwb3J0XG5cbi8vIENsYXNzIHRoYXQgYWxsIG90aGVyIGNsYXNzZXMgd2lsbCBpbmhlcml0IGZyb21cbmZ1bmN0aW9uIENsYXNzKCkgeyB9XG5cblxuLy8gQ2FsbGVkIG9uIGEgY2xhc3MgdG8gY3JlYXRlIGEgc3ViY2xhc3MuXG4vLyBMYXN0IGFyZ3VtZW50IGNvbnRhaW5zIGluc3RhbmNlIG1ldGhvZHMuIEFueSBhcmd1bWVudCBiZWZvcmUgdGhlIGxhc3QgYXJlIGNvbnNpZGVyZWQgbWl4aW5zLlxuQ2xhc3MuZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG5cdHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXHR2YXIgaTtcblx0dmFyIG1lbWJlcnM7XG5cblx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0bWVtYmVycyA9IGFyZ3VtZW50c1tpXTtcblx0XHRpZiAoaSA8IGxlbiAtIDEpIHsgLy8gbm90IHRoZSBsYXN0IGFyZ3VtZW50P1xuXHRcdFx0bWl4SW50b0NsYXNzKHRoaXMsIG1lbWJlcnMpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBleHRlbmRDbGFzcyh0aGlzLCBtZW1iZXJzIHx8IHt9KTsgLy8gbWVtYmVycyB3aWxsIGJlIHVuZGVmaW5lZCBpZiBubyBhcmd1bWVudHNcbn07XG5cblxuLy8gQWRkcyBuZXcgbWVtYmVyIHZhcmlhYmxlcy9tZXRob2RzIHRvIHRoZSBjbGFzcydzIHByb3RvdHlwZS5cbi8vIENhbiBiZSBjYWxsZWQgd2l0aCBhbm90aGVyIGNsYXNzLCBvciBhIHBsYWluIG9iamVjdCBoYXNoIGNvbnRhaW5pbmcgbmV3IG1lbWJlcnMuXG5DbGFzcy5taXhpbiA9IGZ1bmN0aW9uKG1lbWJlcnMpIHtcblx0bWl4SW50b0NsYXNzKHRoaXMsIG1lbWJlcnMpO1xufTtcblxuXG5mdW5jdGlvbiBleHRlbmRDbGFzcyhzdXBlckNsYXNzLCBtZW1iZXJzKSB7XG5cdHZhciBzdWJDbGFzcztcblxuXHQvLyBlbnN1cmUgYSBjb25zdHJ1Y3RvciBmb3IgdGhlIHN1YmNsYXNzLCBmb3J3YXJkaW5nIGFsbCBhcmd1bWVudHMgdG8gdGhlIHN1cGVyLWNvbnN0cnVjdG9yIGlmIGl0IGRvZXNuJ3QgZXhpc3Rcblx0aWYgKGhhc093blByb3AobWVtYmVycywgJ2NvbnN0cnVjdG9yJykpIHtcblx0XHRzdWJDbGFzcyA9IG1lbWJlcnMuY29uc3RydWN0b3I7XG5cdH1cblx0aWYgKHR5cGVvZiBzdWJDbGFzcyAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHN1YkNsYXNzID0gbWVtYmVycy5jb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0c3VwZXJDbGFzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH1cblxuXHQvLyBidWlsZCB0aGUgYmFzZSBwcm90b3R5cGUgZm9yIHRoZSBzdWJjbGFzcywgd2hpY2ggaXMgYW4gbmV3IG9iamVjdCBjaGFpbmVkIHRvIHRoZSBzdXBlcmNsYXNzJ3MgcHJvdG90eXBlXG5cdHN1YkNsYXNzLnByb3RvdHlwZSA9IGNyZWF0ZU9iamVjdChzdXBlckNsYXNzLnByb3RvdHlwZSk7XG5cblx0Ly8gY29weSBlYWNoIG1lbWJlciB2YXJpYWJsZS9tZXRob2Qgb250byB0aGUgdGhlIHN1YmNsYXNzJ3MgcHJvdG90eXBlXG5cdGNvcHlPd25Qcm9wcyhtZW1iZXJzLCBzdWJDbGFzcy5wcm90b3R5cGUpO1xuXG5cdC8vIGNvcHkgb3ZlciBhbGwgY2xhc3MgdmFyaWFibGVzL21ldGhvZHMgdG8gdGhlIHN1YmNsYXNzLCBzdWNoIGFzIGBleHRlbmRgIGFuZCBgbWl4aW5gXG5cdGNvcHlPd25Qcm9wcyhzdXBlckNsYXNzLCBzdWJDbGFzcyk7XG5cblx0cmV0dXJuIHN1YkNsYXNzO1xufVxuXG5cbmZ1bmN0aW9uIG1peEludG9DbGFzcyh0aGVDbGFzcywgbWVtYmVycykge1xuXHRjb3B5T3duUHJvcHMobWVtYmVycywgdGhlQ2xhc3MucHJvdG90eXBlKTtcbn1cbjs7XG5cbnZhciBFbWl0dGVyTWl4aW4gPSBGQy5FbWl0dGVyTWl4aW4gPSB7XG5cblx0Ly8galF1ZXJ5LWlmaWNhdGlvbiB2aWEgJCh0aGlzKSBhbGxvd3MgYSBub24tRE9NIG9iamVjdCB0byBoYXZlXG5cdC8vIHRoZSBzYW1lIGV2ZW50IGhhbmRsaW5nIGNhcGFiaWxpdGllcyAoaW5jbHVkaW5nIG5hbWVzcGFjZXMpLlxuXG5cblx0b246IGZ1bmN0aW9uKHR5cGVzLCBoYW5kbGVyKSB7XG5cblx0XHQvLyBoYW5kbGVycyBhcmUgYWx3YXlzIGNhbGxlZCB3aXRoIGFuIFwiZXZlbnRcIiBvYmplY3QgYXMgdGhlaXIgZmlyc3QgcGFyYW0uXG5cdFx0Ly8gc25lYWsgdGhlIGB0aGlzYCBjb250ZXh0IGFuZCBhcmd1bWVudHMgaW50byB0aGUgZXh0cmEgcGFyYW1ldGVyIG9iamVjdFxuXHRcdC8vIGFuZCBmb3J3YXJkIHRoZW0gb24gdG8gdGhlIG9yaWdpbmFsIGhhbmRsZXIuXG5cdFx0dmFyIGludGVyY2VwdCA9IGZ1bmN0aW9uKGV2LCBleHRyYSkge1xuXHRcdFx0cmV0dXJuIGhhbmRsZXIuYXBwbHkoXG5cdFx0XHRcdGV4dHJhLmNvbnRleHQgfHwgdGhpcyxcblx0XHRcdFx0ZXh0cmEuYXJncyB8fCBbXVxuXHRcdFx0KTtcblx0XHR9O1xuXG5cdFx0Ly8gbWltaWNrIGpRdWVyeSdzIGludGVybmFsIFwicHJveHlcIiBzeXN0ZW0gKHJpc2t5LCBJIGtub3cpXG5cdFx0Ly8gY2F1c2luZyBhbGwgZnVuY3Rpb25zIHdpdGggdGhlIHNhbWUgLmd1aWQgdG8gYXBwZWFyIHRvIGJlIHRoZSBzYW1lLlxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L2Jsb2IvMi4yLjQvc3JjL2NvcmUuanMjTDQ0OFxuXHRcdC8vIHRoaXMgaXMgbmVlZGVkIGZvciBjYWxsaW5nIC5vZmYgd2l0aCB0aGUgb3JpZ2luYWwgbm9uLWludGVyY2VwdCBoYW5kbGVyLlxuXHRcdGlmICghaGFuZGxlci5ndWlkKSB7XG5cdFx0XHRoYW5kbGVyLmd1aWQgPSAkLmd1aWQrKztcblx0XHR9XG5cdFx0aW50ZXJjZXB0Lmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG5cblx0XHQkKHRoaXMpLm9uKHR5cGVzLCBpbnRlcmNlcHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xuXHR9LFxuXG5cblx0b2ZmOiBmdW5jdGlvbih0eXBlcywgaGFuZGxlcikge1xuXHRcdCQodGhpcykub2ZmKHR5cGVzLCBoYW5kbGVyKTtcblxuXHRcdHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5pbmdcblx0fSxcblxuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKHR5cGVzKSB7XG5cdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOyAvLyBhcmd1bWVudHMgYWZ0ZXIgdGhlIGZpcnN0XG5cblx0XHQvLyBwYXNzIGluIFwiZXh0cmFcIiBpbmZvIHRvIHRoZSBpbnRlcmNlcHRcblx0XHQkKHRoaXMpLnRyaWdnZXJIYW5kbGVyKHR5cGVzLCB7IGFyZ3M6IGFyZ3MgfSk7XG5cblx0XHRyZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXG5cdH0sXG5cblxuXHR0cmlnZ2VyV2l0aDogZnVuY3Rpb24odHlwZXMsIGNvbnRleHQsIGFyZ3MpIHtcblxuXHRcdC8vIGB0cmlnZ2VySGFuZGxlcmAgaXMgbGVzcyByZWxpYW50IG9uIHRoZSBET00gY29tcGFyZWQgdG8gYHRyaWdnZXJgLlxuXHRcdC8vIHBhc3MgaW4gXCJleHRyYVwiIGluZm8gdG8gdGhlIGludGVyY2VwdC5cblx0XHQkKHRoaXMpLnRyaWdnZXJIYW5kbGVyKHR5cGVzLCB7IGNvbnRleHQ6IGNvbnRleHQsIGFyZ3M6IGFyZ3MgfSk7XG5cblx0XHRyZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXG5cdH1cblxufTtcblxuOztcblxuLypcblV0aWxpdHkgbWV0aG9kcyBmb3IgZWFzaWx5IGxpc3RlbmluZyB0byBldmVudHMgb24gYW5vdGhlciBvYmplY3QsXG5hbmQgbW9yZSBpbXBvcnRhbnRseSwgZWFzaWx5IHVubGlzdGVuaW5nIGZyb20gdGhlbS5cbiovXG52YXIgTGlzdGVuZXJNaXhpbiA9IEZDLkxpc3RlbmVyTWl4aW4gPSAoZnVuY3Rpb24oKSB7XG5cdHZhciBndWlkID0gMDtcblx0dmFyIExpc3RlbmVyTWl4aW4gPSB7XG5cblx0XHRsaXN0ZW5lcklkOiBudWxsLFxuXG5cdFx0Lypcblx0XHRHaXZlbiBhbiBgb3RoZXJgIG9iamVjdCB0aGF0IGhhcyBvbi9vZmYgbWV0aG9kcywgYmluZCB0aGUgZ2l2ZW4gYGNhbGxiYWNrYCB0byBhbiBldmVudCBieSB0aGUgZ2l2ZW4gbmFtZS5cblx0XHRUaGUgYGNhbGxiYWNrYCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSBgdGhpc2AgY29udGV4dCBvZiB0aGUgb2JqZWN0IHRoYXQgLmxpc3RlblRvIGlzIGJlaW5nIGNhbGxlZCBvbi5cblx0XHRDYW4gYmUgY2FsbGVkOlxuXHRcdFx0Lmxpc3RlblRvKG90aGVyLCBldmVudE5hbWUsIGNhbGxiYWNrKVxuXHRcdE9SXG5cdFx0XHQubGlzdGVuVG8ob3RoZXIsIHtcblx0XHRcdFx0ZXZlbnROYW1lMTogY2FsbGJhY2sxLFxuXHRcdFx0XHRldmVudE5hbWUyOiBjYWxsYmFjazJcblx0XHRcdH0pXG5cdFx0Ki9cblx0XHRsaXN0ZW5UbzogZnVuY3Rpb24ob3RoZXIsIGFyZywgY2FsbGJhY2spIHtcblx0XHRcdGlmICh0eXBlb2YgYXJnID09PSAnb2JqZWN0JykgeyAvLyBnaXZlbiBkaWN0aW9uYXJ5IG9mIGNhbGxiYWNrc1xuXHRcdFx0XHRmb3IgKHZhciBldmVudE5hbWUgaW4gYXJnKSB7XG5cdFx0XHRcdFx0aWYgKGFyZy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmxpc3RlblRvKG90aGVyLCBldmVudE5hbWUsIGFyZ1tldmVudE5hbWVdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdG90aGVyLm9uKFxuXHRcdFx0XHRcdGFyZyArICcuJyArIHRoaXMuZ2V0TGlzdGVuZXJOYW1lc3BhY2UoKSwgLy8gdXNlIGV2ZW50IG5hbWVzcGFjaW5nIHRvIGlkZW50aWZ5IHRoaXMgb2JqZWN0XG5cdFx0XHRcdFx0JC5wcm94eShjYWxsYmFjaywgdGhpcykgLy8gYWx3YXlzIHVzZSBgdGhpc2AgY29udGV4dFxuXHRcdFx0XHRcdFx0Ly8gdGhlIHVzdWFsbHktdW5kZXNpcmVkIGpRdWVyeSBndWlkIGJlaGF2aW9yIGRvZXNuJ3QgbWF0dGVyLFxuXHRcdFx0XHRcdFx0Ly8gYmVjYXVzZSB3ZSBhbHdheXMgdW5iaW5kIHZpYSBuYW1lc3BhY2Vcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Lypcblx0XHRDYXVzZXMgdGhlIGN1cnJlbnQgb2JqZWN0IHRvIHN0b3AgbGlzdGVuaW5nIHRvIGV2ZW50cyBvbiB0aGUgYG90aGVyYCBvYmplY3QuXG5cdFx0YGV2ZW50TmFtZWAgaXMgb3B0aW9uYWwuIElmIG9taXR0ZWQsIHdpbGwgc3RvcCBsaXN0ZW5pbmcgdG8gQUxMIGV2ZW50cyBvbiBgb3RoZXJgLlxuXHRcdCovXG5cdFx0c3RvcExpc3RlbmluZ1RvOiBmdW5jdGlvbihvdGhlciwgZXZlbnROYW1lKSB7XG5cdFx0XHRvdGhlci5vZmYoKGV2ZW50TmFtZSB8fCAnJykgKyAnLicgKyB0aGlzLmdldExpc3RlbmVyTmFtZXNwYWNlKCkpO1xuXHRcdH0sXG5cblx0XHQvKlxuXHRcdFJldHVybnMgYSBzdHJpbmcsIHVuaXF1ZSB0byB0aGlzIG9iamVjdCwgdG8gYmUgdXNlZCBmb3IgZXZlbnQgbmFtZXNwYWNpbmdcblx0XHQqL1xuXHRcdGdldExpc3RlbmVyTmFtZXNwYWNlOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICh0aGlzLmxpc3RlbmVySWQgPT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLmxpc3RlbmVySWQgPSBndWlkKys7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gJ19saXN0ZW5lcicgKyB0aGlzLmxpc3RlbmVySWQ7XG5cdFx0fVxuXG5cdH07XG5cdHJldHVybiBMaXN0ZW5lck1peGluO1xufSkoKTtcbjs7XG5cbi8vIHNpbXBsZSBjbGFzcyBmb3IgdG9nZ2xlIGEgYGlzSWdub3JpbmdNb3VzZWAgZmxhZyBvbiBkZWxheVxuLy8gaW5pdE1vdXNlSWdub3JpbmcgbXVzdCBmaXJzdCBiZSBjYWxsZWQsIHdpdGggYSBtaWxsaXNlY29uZCBkZWxheSBzZXR0aW5nLlxudmFyIE1vdXNlSWdub3Jlck1peGluID0ge1xuXG5cdGlzSWdub3JpbmdNb3VzZTogZmFsc2UsIC8vIGJvb2xcblx0ZGVsYXlVbmlnbm9yZU1vdXNlOiBudWxsLCAvLyBtZXRob2RcblxuXG5cdGluaXRNb3VzZUlnbm9yaW5nOiBmdW5jdGlvbihkZWxheSkge1xuXHRcdHRoaXMuZGVsYXlVbmlnbm9yZU1vdXNlID0gZGVib3VuY2UocHJveHkodGhpcywgJ3VuaWdub3JlTW91c2UnKSwgZGVsYXkgfHwgMTAwMCk7XG5cdH0sXG5cblxuXHQvLyB0ZW1wb3JhcmlseSBpZ25vcmUgbW91c2UgYWN0aW9ucyBvbiBzZWdtZW50c1xuXHR0ZW1wSWdub3JlTW91c2U6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaXNJZ25vcmluZ01vdXNlID0gdHJ1ZTtcblx0XHR0aGlzLmRlbGF5VW5pZ25vcmVNb3VzZSgpO1xuXHR9LFxuXG5cblx0Ly8gZGVsYXlVbmlnbm9yZU1vdXNlIGV2ZW50dWFsbHkgY2FsbHMgdGhpc1xuXHR1bmlnbm9yZU1vdXNlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmlzSWdub3JpbmdNb3VzZSA9IGZhbHNlO1xuXHR9XG5cbn07XG5cbjs7XG5cbi8qIEEgcmVjdGFuZ3VsYXIgcGFuZWwgdGhhdCBpcyBhYnNvbHV0ZWx5IHBvc2l0aW9uZWQgb3ZlciBvdGhlciBjb250ZW50XG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbk9wdGlvbnM6XG5cdC0gY2xhc3NOYW1lIChzdHJpbmcpXG5cdC0gY29udGVudCAoSFRNTCBzdHJpbmcgb3IgalF1ZXJ5IGVsZW1lbnQgc2V0KVxuXHQtIHBhcmVudEVsXG5cdC0gdG9wXG5cdC0gbGVmdFxuXHQtIHJpZ2h0ICh0aGUgeCBjb29yZCBvZiB3aGVyZSB0aGUgcmlnaHQgZWRnZSBzaG91bGQgYmUuIG5vdCBhIFwiQ1NTXCIgcmlnaHQpXG5cdC0gYXV0b0hpZGUgKGJvb2xlYW4pXG5cdC0gc2hvdyAoY2FsbGJhY2spXG5cdC0gaGlkZSAoY2FsbGJhY2spXG4qL1xuXG52YXIgUG9wb3ZlciA9IENsYXNzLmV4dGVuZChMaXN0ZW5lck1peGluLCB7XG5cblx0aXNIaWRkZW46IHRydWUsXG5cdG9wdGlvbnM6IG51bGwsXG5cdGVsOiBudWxsLCAvLyB0aGUgY29udGFpbmVyIGVsZW1lbnQgZm9yIHRoZSBwb3BvdmVyLiBnZW5lcmF0ZWQgYnkgdGhpcyBvYmplY3Rcblx0bWFyZ2luOiAxMCwgLy8gdGhlIHNwYWNlIHJlcXVpcmVkIGJldHdlZW4gdGhlIHBvcG92ZXIgYW5kIHRoZSBlZGdlcyBvZiB0aGUgc2Nyb2xsIGNvbnRhaW5lclxuXG5cblx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHR9LFxuXG5cblx0Ly8gU2hvd3MgdGhlIHBvcG92ZXIgb24gdGhlIHNwZWNpZmllZCBwb3NpdGlvbi4gUmVuZGVycyBpdCBpZiBub3QgYWxyZWFkeVxuXHRzaG93OiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5pc0hpZGRlbikge1xuXHRcdFx0aWYgKCF0aGlzLmVsKSB7XG5cdFx0XHRcdHRoaXMucmVuZGVyKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmVsLnNob3coKTtcblx0XHRcdHRoaXMucG9zaXRpb24oKTtcblx0XHRcdHRoaXMuaXNIaWRkZW4gPSBmYWxzZTtcblx0XHRcdHRoaXMudHJpZ2dlcignc2hvdycpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIEhpZGVzIHRoZSBwb3BvdmVyLCB0aHJvdWdoIENTUywgYnV0IGRvZXMgbm90IHJlbW92ZSBpdCBmcm9tIHRoZSBET01cblx0aGlkZTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLmlzSGlkZGVuKSB7XG5cdFx0XHR0aGlzLmVsLmhpZGUoKTtcblx0XHRcdHRoaXMuaXNIaWRkZW4gPSB0cnVlO1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdoaWRlJyk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gQ3JlYXRlcyBgdGhpcy5lbGAgYW5kIHJlbmRlcnMgY29udGVudCBpbnNpZGUgb2YgaXRcblx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0dGhpcy5lbCA9ICQoJzxkaXYgY2xhc3M9XCJmYy1wb3BvdmVyXCIvPicpXG5cdFx0XHQuYWRkQ2xhc3Mob3B0aW9ucy5jbGFzc05hbWUgfHwgJycpXG5cdFx0XHQuY3NzKHtcblx0XHRcdFx0Ly8gcG9zaXRpb24gaW5pdGlhbGx5IHRvIHRoZSB0b3AgbGVmdCB0byBhdm9pZCBjcmVhdGluZyBzY3JvbGxiYXJzXG5cdFx0XHRcdHRvcDogMCxcblx0XHRcdFx0bGVmdDogMFxuXHRcdFx0fSlcblx0XHRcdC5hcHBlbmQob3B0aW9ucy5jb250ZW50KVxuXHRcdFx0LmFwcGVuZFRvKG9wdGlvbnMucGFyZW50RWwpO1xuXG5cdFx0Ly8gd2hlbiBhIGNsaWNrIGhhcHBlbnMgb24gYW55dGhpbmcgaW5zaWRlIHdpdGggYSAnZmMtY2xvc2UnIGNsYXNzTmFtZSwgaGlkZSB0aGUgcG9wb3ZlclxuXHRcdHRoaXMuZWwub24oJ2NsaWNrJywgJy5mYy1jbG9zZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0X3RoaXMuaGlkZSgpO1xuXHRcdH0pO1xuXG5cdFx0aWYgKG9wdGlvbnMuYXV0b0hpZGUpIHtcblx0XHRcdHRoaXMubGlzdGVuVG8oJChkb2N1bWVudCksICdtb3VzZWRvd24nLCB0aGlzLmRvY3VtZW50TW91c2Vkb3duKTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBUcmlnZ2VyZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgKmFueXdoZXJlKiBpbiB0aGUgZG9jdW1lbnQsIGZvciB0aGUgYXV0b0hpZGUgZmVhdHVyZVxuXHRkb2N1bWVudE1vdXNlZG93bjogZnVuY3Rpb24oZXYpIHtcblx0XHQvLyBvbmx5IGhpZGUgdGhlIHBvcG92ZXIgaWYgdGhlIGNsaWNrIGhhcHBlbmVkIG91dHNpZGUgdGhlIHBvcG92ZXJcblx0XHRpZiAodGhpcy5lbCAmJiAhJChldi50YXJnZXQpLmNsb3Nlc3QodGhpcy5lbCkubGVuZ3RoKSB7XG5cdFx0XHR0aGlzLmhpZGUoKTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBIaWRlcyBhbmQgdW5yZWdpc3RlcnMgYW55IGhhbmRsZXJzXG5cdHJlbW92ZUVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaGlkZSgpO1xuXG5cdFx0aWYgKHRoaXMuZWwpIHtcblx0XHRcdHRoaXMuZWwucmVtb3ZlKCk7XG5cdFx0XHR0aGlzLmVsID0gbnVsbDtcblx0XHR9XG5cblx0XHR0aGlzLnN0b3BMaXN0ZW5pbmdUbygkKGRvY3VtZW50KSwgJ21vdXNlZG93bicpO1xuXHR9LFxuXG5cblx0Ly8gUG9zaXRpb25zIHRoZSBwb3BvdmVyIG9wdGltYWxseSwgdXNpbmcgdGhlIHRvcC9sZWZ0L3JpZ2h0IG9wdGlvbnNcblx0cG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXHRcdHZhciBvcmlnaW4gPSB0aGlzLmVsLm9mZnNldFBhcmVudCgpLm9mZnNldCgpO1xuXHRcdHZhciB3aWR0aCA9IHRoaXMuZWwub3V0ZXJXaWR0aCgpO1xuXHRcdHZhciBoZWlnaHQgPSB0aGlzLmVsLm91dGVySGVpZ2h0KCk7XG5cdFx0dmFyIHdpbmRvd0VsID0gJCh3aW5kb3cpO1xuXHRcdHZhciB2aWV3cG9ydEVsID0gZ2V0U2Nyb2xsUGFyZW50KHRoaXMuZWwpO1xuXHRcdHZhciB2aWV3cG9ydFRvcDtcblx0XHR2YXIgdmlld3BvcnRMZWZ0O1xuXHRcdHZhciB2aWV3cG9ydE9mZnNldDtcblx0XHR2YXIgdG9wOyAvLyB0aGUgXCJwb3NpdGlvblwiIChub3QgXCJvZmZzZXRcIikgdmFsdWVzIGZvciB0aGUgcG9wb3ZlclxuXHRcdHZhciBsZWZ0OyAvL1xuXG5cdFx0Ly8gY29tcHV0ZSB0b3AgYW5kIGxlZnRcblx0XHR0b3AgPSBvcHRpb25zLnRvcCB8fCAwO1xuXHRcdGlmIChvcHRpb25zLmxlZnQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0bGVmdCA9IG9wdGlvbnMubGVmdDtcblx0XHR9XG5cdFx0ZWxzZSBpZiAob3B0aW9ucy5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRsZWZ0ID0gb3B0aW9ucy5yaWdodCAtIHdpZHRoOyAvLyBkZXJpdmUgdGhlIGxlZnQgdmFsdWUgZnJvbSB0aGUgcmlnaHQgdmFsdWVcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRsZWZ0ID0gMDtcblx0XHR9XG5cblx0XHRpZiAodmlld3BvcnRFbC5pcyh3aW5kb3cpIHx8IHZpZXdwb3J0RWwuaXMoZG9jdW1lbnQpKSB7IC8vIG5vcm1hbGl6ZSBnZXRTY3JvbGxQYXJlbnQncyByZXN1bHRcblx0XHRcdHZpZXdwb3J0RWwgPSB3aW5kb3dFbDtcblx0XHRcdHZpZXdwb3J0VG9wID0gMDsgLy8gdGhlIHdpbmRvdyBpcyBhbHdheXMgYXQgdGhlIHRvcCBsZWZ0XG5cdFx0XHR2aWV3cG9ydExlZnQgPSAwOyAvLyAoYW5kIC5vZmZzZXQoKSB3b24ndCB3b3JrIGlmIGNhbGxlZCBoZXJlKVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHZpZXdwb3J0T2Zmc2V0ID0gdmlld3BvcnRFbC5vZmZzZXQoKTtcblx0XHRcdHZpZXdwb3J0VG9wID0gdmlld3BvcnRPZmZzZXQudG9wO1xuXHRcdFx0dmlld3BvcnRMZWZ0ID0gdmlld3BvcnRPZmZzZXQubGVmdDtcblx0XHR9XG5cblx0XHQvLyBpZiB0aGUgd2luZG93IGlzIHNjcm9sbGVkLCBpdCBjYXVzZXMgdGhlIHZpc2libGUgYXJlYSB0byBiZSBmdXJ0aGVyIGRvd25cblx0XHR2aWV3cG9ydFRvcCArPSB3aW5kb3dFbC5zY3JvbGxUb3AoKTtcblx0XHR2aWV3cG9ydExlZnQgKz0gd2luZG93RWwuc2Nyb2xsTGVmdCgpO1xuXG5cdFx0Ly8gY29uc3RyYWluIHRvIHRoZSB2aWV3IHBvcnQuIGlmIGNvbnN0cmFpbmVkIGJ5IHR3byBlZGdlcywgZ2l2ZSBwcmVjZWRlbmNlIHRvIHRvcC9sZWZ0XG5cdFx0aWYgKG9wdGlvbnMudmlld3BvcnRDb25zdHJhaW4gIT09IGZhbHNlKSB7XG5cdFx0XHR0b3AgPSBNYXRoLm1pbih0b3AsIHZpZXdwb3J0VG9wICsgdmlld3BvcnRFbC5vdXRlckhlaWdodCgpIC0gaGVpZ2h0IC0gdGhpcy5tYXJnaW4pO1xuXHRcdFx0dG9wID0gTWF0aC5tYXgodG9wLCB2aWV3cG9ydFRvcCArIHRoaXMubWFyZ2luKTtcblx0XHRcdGxlZnQgPSBNYXRoLm1pbihsZWZ0LCB2aWV3cG9ydExlZnQgKyB2aWV3cG9ydEVsLm91dGVyV2lkdGgoKSAtIHdpZHRoIC0gdGhpcy5tYXJnaW4pO1xuXHRcdFx0bGVmdCA9IE1hdGgubWF4KGxlZnQsIHZpZXdwb3J0TGVmdCArIHRoaXMubWFyZ2luKTtcblx0XHR9XG5cblx0XHR0aGlzLmVsLmNzcyh7XG5cdFx0XHR0b3A6IHRvcCAtIG9yaWdpbi50b3AsXG5cdFx0XHRsZWZ0OiBsZWZ0IC0gb3JpZ2luLmxlZnRcblx0XHR9KTtcblx0fSxcblxuXG5cdC8vIFRyaWdnZXJzIGEgY2FsbGJhY2suIENhbGxzIGEgZnVuY3Rpb24gaW4gdGhlIG9wdGlvbiBoYXNoIG9mIHRoZSBzYW1lIG5hbWUuXG5cdC8vIEFyZ3VtZW50cyBiZXlvbmQgdGhlIGZpcnN0IGBuYW1lYCBhcmUgZm9yd2FyZGVkIG9uLlxuXHQvLyBUT0RPOiBiZXR0ZXIgY29kZSByZXVzZSBmb3IgdGhpcy4gUmVwZWF0IGNvZGVcblx0dHJpZ2dlcjogZnVuY3Rpb24obmFtZSkge1xuXHRcdGlmICh0aGlzLm9wdGlvbnNbbmFtZV0pIHtcblx0XHRcdHRoaXMub3B0aW9uc1tuYW1lXS5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcblx0XHR9XG5cdH1cblxufSk7XG5cbjs7XG5cbi8qXG5BIGNhY2hlIGZvciB0aGUgbGVmdC9yaWdodC90b3AvYm90dG9tL3dpZHRoL2hlaWdodCB2YWx1ZXMgZm9yIG9uZSBvciBtb3JlIGVsZW1lbnRzLlxuV29ya3Mgd2l0aCBib3RoIG9mZnNldCAoZnJvbSB0b3BsZWZ0IGRvY3VtZW50KSBhbmQgcG9zaXRpb24gKGZyb20gb2Zmc2V0UGFyZW50KS5cblxub3B0aW9uczpcbi0gZWxzXG4tIGlzSG9yaXpvbnRhbFxuLSBpc1ZlcnRpY2FsXG4qL1xudmFyIENvb3JkQ2FjaGUgPSBGQy5Db29yZENhY2hlID0gQ2xhc3MuZXh0ZW5kKHtcblxuXHRlbHM6IG51bGwsIC8vIGpRdWVyeSBzZXQgKGFzc3VtZWQgdG8gYmUgc2libGluZ3MpXG5cdGZvcmNlZE9mZnNldFBhcmVudEVsOiBudWxsLCAvLyBvcHRpb25zIGNhbiBvdmVycmlkZSB0aGUgbmF0dXJhbCBvZmZzZXRQYXJlbnRcblx0b3JpZ2luOiBudWxsLCAvLyB7bGVmdCx0b3B9IHBvc2l0aW9uIG9mIG9mZnNldFBhcmVudCBvZiBlbHNcblx0Ym91bmRpbmdSZWN0OiBudWxsLCAvLyBjb25zdHJhaW4gY29yZGluYXRlcyB0byB0aGlzIHJlY3RhbmdsZS4ge2xlZnQscmlnaHQsdG9wLGJvdHRvbX0gb3IgbnVsbFxuXHRpc0hvcml6b250YWw6IGZhbHNlLCAvLyB3aGV0aGVyIHRvIHF1ZXJ5IGZvciBsZWZ0L3JpZ2h0L3dpZHRoXG5cdGlzVmVydGljYWw6IGZhbHNlLCAvLyB3aGV0aGVyIHRvIHF1ZXJ5IGZvciB0b3AvYm90dG9tL2hlaWdodFxuXG5cdC8vIGFycmF5cyBvZiBjb29yZGluYXRlcyAob2Zmc2V0cyBmcm9tIHRvcGxlZnQgb2YgZG9jdW1lbnQpXG5cdGxlZnRzOiBudWxsLFxuXHRyaWdodHM6IG51bGwsXG5cdHRvcHM6IG51bGwsXG5cdGJvdHRvbXM6IG51bGwsXG5cblxuXHRjb25zdHJ1Y3RvcjogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHRoaXMuZWxzID0gJChvcHRpb25zLmVscyk7XG5cdFx0dGhpcy5pc0hvcml6b250YWwgPSBvcHRpb25zLmlzSG9yaXpvbnRhbDtcblx0XHR0aGlzLmlzVmVydGljYWwgPSBvcHRpb25zLmlzVmVydGljYWw7XG5cdFx0dGhpcy5mb3JjZWRPZmZzZXRQYXJlbnRFbCA9IG9wdGlvbnMub2Zmc2V0UGFyZW50ID8gJChvcHRpb25zLm9mZnNldFBhcmVudCkgOiBudWxsO1xuXHR9LFxuXG5cblx0Ly8gUXVlcmllcyB0aGUgZWxzIGZvciBjb29yZGluYXRlcyBhbmQgc3RvcmVzIHRoZW0uXG5cdC8vIENhbGwgdGhpcyBtZXRob2QgYmVmb3JlIHVzaW5nIGFuZCBvZiB0aGUgZ2V0KiBtZXRob2RzIGJlbG93LlxuXHRidWlsZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG9mZnNldFBhcmVudEVsID0gdGhpcy5mb3JjZWRPZmZzZXRQYXJlbnRFbCB8fCB0aGlzLmVscy5lcSgwKS5vZmZzZXRQYXJlbnQoKTtcblxuXHRcdHRoaXMub3JpZ2luID0gb2Zmc2V0UGFyZW50RWwub2Zmc2V0KCk7XG5cdFx0dGhpcy5ib3VuZGluZ1JlY3QgPSB0aGlzLnF1ZXJ5Qm91bmRpbmdSZWN0KCk7XG5cblx0XHRpZiAodGhpcy5pc0hvcml6b250YWwpIHtcblx0XHRcdHRoaXMuYnVpbGRFbEhvcml6b250YWxzKCk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLmlzVmVydGljYWwpIHtcblx0XHRcdHRoaXMuYnVpbGRFbFZlcnRpY2FscygpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIERlc3Ryb3lzIGFsbCBpbnRlcm5hbCBkYXRhIGFib3V0IGNvb3JkaW5hdGVzLCBmcmVlaW5nIG1lbW9yeVxuXHRjbGVhcjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5vcmlnaW4gPSBudWxsO1xuXHRcdHRoaXMuYm91bmRpbmdSZWN0ID0gbnVsbDtcblx0XHR0aGlzLmxlZnRzID0gbnVsbDtcblx0XHR0aGlzLnJpZ2h0cyA9IG51bGw7XG5cdFx0dGhpcy50b3BzID0gbnVsbDtcblx0XHR0aGlzLmJvdHRvbXMgPSBudWxsO1xuXHR9LFxuXG5cblx0Ly8gV2hlbiBjYWxsZWQsIGlmIGNvb3JkIGNhY2hlcyBhcmVuJ3QgYnVpbHQsIGJ1aWxkcyB0aGVtXG5cdGVuc3VyZUJ1aWx0OiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMub3JpZ2luKSB7XG5cdFx0XHR0aGlzLmJ1aWxkKCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gUG9wdWxhdGVzIHRoZSBsZWZ0L3JpZ2h0IGludGVybmFsIGNvb3JkaW5hdGUgYXJyYXlzXG5cdGJ1aWxkRWxIb3Jpem9udGFsczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxlZnRzID0gW107XG5cdFx0dmFyIHJpZ2h0cyA9IFtdO1xuXG5cdFx0dGhpcy5lbHMuZWFjaChmdW5jdGlvbihpLCBub2RlKSB7XG5cdFx0XHR2YXIgZWwgPSAkKG5vZGUpO1xuXHRcdFx0dmFyIGxlZnQgPSBlbC5vZmZzZXQoKS5sZWZ0O1xuXHRcdFx0dmFyIHdpZHRoID0gZWwub3V0ZXJXaWR0aCgpO1xuXG5cdFx0XHRsZWZ0cy5wdXNoKGxlZnQpO1xuXHRcdFx0cmlnaHRzLnB1c2gobGVmdCArIHdpZHRoKTtcblx0XHR9KTtcblxuXHRcdHRoaXMubGVmdHMgPSBsZWZ0cztcblx0XHR0aGlzLnJpZ2h0cyA9IHJpZ2h0cztcblx0fSxcblxuXG5cdC8vIFBvcHVsYXRlcyB0aGUgdG9wL2JvdHRvbSBpbnRlcm5hbCBjb29yZGluYXRlIGFycmF5c1xuXHRidWlsZEVsVmVydGljYWxzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdG9wcyA9IFtdO1xuXHRcdHZhciBib3R0b21zID0gW107XG5cblx0XHR0aGlzLmVscy5lYWNoKGZ1bmN0aW9uKGksIG5vZGUpIHtcblx0XHRcdHZhciBlbCA9ICQobm9kZSk7XG5cdFx0XHR2YXIgdG9wID0gZWwub2Zmc2V0KCkudG9wO1xuXHRcdFx0dmFyIGhlaWdodCA9IGVsLm91dGVySGVpZ2h0KCk7XG5cblx0XHRcdHRvcHMucHVzaCh0b3ApO1xuXHRcdFx0Ym90dG9tcy5wdXNoKHRvcCArIGhlaWdodCk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLnRvcHMgPSB0b3BzO1xuXHRcdHRoaXMuYm90dG9tcyA9IGJvdHRvbXM7XG5cdH0sXG5cblxuXHQvLyBHaXZlbiBhIGxlZnQgb2Zmc2V0IChmcm9tIGRvY3VtZW50IGxlZnQpLCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZWwgdGhhdCBpdCBob3Jpem9udGFsbHkgaW50ZXJzZWN0cy5cblx0Ly8gSWYgbm8gaW50ZXJzZWN0aW9uIGlzIG1hZGUsIHJldHVybnMgdW5kZWZpbmVkLlxuXHRnZXRIb3Jpem9udGFsSW5kZXg6IGZ1bmN0aW9uKGxlZnRPZmZzZXQpIHtcblx0XHR0aGlzLmVuc3VyZUJ1aWx0KCk7XG5cblx0XHR2YXIgbGVmdHMgPSB0aGlzLmxlZnRzO1xuXHRcdHZhciByaWdodHMgPSB0aGlzLnJpZ2h0cztcblx0XHR2YXIgbGVuID0gbGVmdHMubGVuZ3RoO1xuXHRcdHZhciBpO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAobGVmdE9mZnNldCA+PSBsZWZ0c1tpXSAmJiBsZWZ0T2Zmc2V0IDwgcmlnaHRzW2ldKSB7XG5cdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXG5cdC8vIEdpdmVuIGEgdG9wIG9mZnNldCAoZnJvbSBkb2N1bWVudCB0b3ApLCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZWwgdGhhdCBpdCB2ZXJ0aWNhbGx5IGludGVyc2VjdHMuXG5cdC8vIElmIG5vIGludGVyc2VjdGlvbiBpcyBtYWRlLCByZXR1cm5zIHVuZGVmaW5lZC5cblx0Z2V0VmVydGljYWxJbmRleDogZnVuY3Rpb24odG9wT2Zmc2V0KSB7XG5cdFx0dGhpcy5lbnN1cmVCdWlsdCgpO1xuXG5cdFx0dmFyIHRvcHMgPSB0aGlzLnRvcHM7XG5cdFx0dmFyIGJvdHRvbXMgPSB0aGlzLmJvdHRvbXM7XG5cdFx0dmFyIGxlbiA9IHRvcHMubGVuZ3RoO1xuXHRcdHZhciBpO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAodG9wT2Zmc2V0ID49IHRvcHNbaV0gJiYgdG9wT2Zmc2V0IDwgYm90dG9tc1tpXSkge1xuXHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblxuXHQvLyBHZXRzIHRoZSBsZWZ0IG9mZnNldCAoZnJvbSBkb2N1bWVudCBsZWZ0KSBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXhcblx0Z2V0TGVmdE9mZnNldDogZnVuY3Rpb24obGVmdEluZGV4KSB7XG5cdFx0dGhpcy5lbnN1cmVCdWlsdCgpO1xuXHRcdHJldHVybiB0aGlzLmxlZnRzW2xlZnRJbmRleF07XG5cdH0sXG5cblxuXHQvLyBHZXRzIHRoZSBsZWZ0IHBvc2l0aW9uIChmcm9tIG9mZnNldFBhcmVudCBsZWZ0KSBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXhcblx0Z2V0TGVmdFBvc2l0aW9uOiBmdW5jdGlvbihsZWZ0SW5kZXgpIHtcblx0XHR0aGlzLmVuc3VyZUJ1aWx0KCk7XG5cdFx0cmV0dXJuIHRoaXMubGVmdHNbbGVmdEluZGV4XSAtIHRoaXMub3JpZ2luLmxlZnQ7XG5cdH0sXG5cblxuXHQvLyBHZXRzIHRoZSByaWdodCBvZmZzZXQgKGZyb20gZG9jdW1lbnQgbGVmdCkgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4LlxuXHQvLyBUaGlzIHZhbHVlIGlzIE5PVCByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnQncyByaWdodCBlZGdlLCBsaWtlIHRoZSBDU1MgY29uY2VwdCBvZiBcInJpZ2h0XCIgd291bGQgYmUuXG5cdGdldFJpZ2h0T2Zmc2V0OiBmdW5jdGlvbihsZWZ0SW5kZXgpIHtcblx0XHR0aGlzLmVuc3VyZUJ1aWx0KCk7XG5cdFx0cmV0dXJuIHRoaXMucmlnaHRzW2xlZnRJbmRleF07XG5cdH0sXG5cblxuXHQvLyBHZXRzIHRoZSByaWdodCBwb3NpdGlvbiAoZnJvbSBvZmZzZXRQYXJlbnQgbGVmdCkgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4LlxuXHQvLyBUaGlzIHZhbHVlIGlzIE5PVCByZWxhdGl2ZSB0byB0aGUgb2Zmc2V0UGFyZW50J3MgcmlnaHQgZWRnZSwgbGlrZSB0aGUgQ1NTIGNvbmNlcHQgb2YgXCJyaWdodFwiIHdvdWxkIGJlLlxuXHRnZXRSaWdodFBvc2l0aW9uOiBmdW5jdGlvbihsZWZ0SW5kZXgpIHtcblx0XHR0aGlzLmVuc3VyZUJ1aWx0KCk7XG5cdFx0cmV0dXJuIHRoaXMucmlnaHRzW2xlZnRJbmRleF0gLSB0aGlzLm9yaWdpbi5sZWZ0O1xuXHR9LFxuXG5cblx0Ly8gR2V0cyB0aGUgd2lkdGggb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4XG5cdGdldFdpZHRoOiBmdW5jdGlvbihsZWZ0SW5kZXgpIHtcblx0XHR0aGlzLmVuc3VyZUJ1aWx0KCk7XG5cdFx0cmV0dXJuIHRoaXMucmlnaHRzW2xlZnRJbmRleF0gLSB0aGlzLmxlZnRzW2xlZnRJbmRleF07XG5cdH0sXG5cblxuXHQvLyBHZXRzIHRoZSB0b3Agb2Zmc2V0IChmcm9tIGRvY3VtZW50IHRvcCkgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4XG5cdGdldFRvcE9mZnNldDogZnVuY3Rpb24odG9wSW5kZXgpIHtcblx0XHR0aGlzLmVuc3VyZUJ1aWx0KCk7XG5cdFx0cmV0dXJuIHRoaXMudG9wc1t0b3BJbmRleF07XG5cdH0sXG5cblxuXHQvLyBHZXRzIHRoZSB0b3AgcG9zaXRpb24gKGZyb20gb2Zmc2V0UGFyZW50IHRvcCkgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uXG5cdGdldFRvcFBvc2l0aW9uOiBmdW5jdGlvbih0b3BJbmRleCkge1xuXHRcdHRoaXMuZW5zdXJlQnVpbHQoKTtcblx0XHRyZXR1cm4gdGhpcy50b3BzW3RvcEluZGV4XSAtIHRoaXMub3JpZ2luLnRvcDtcblx0fSxcblxuXHQvLyBHZXRzIHRoZSBib3R0b20gb2Zmc2V0IChmcm9tIHRoZSBkb2N1bWVudCB0b3ApIG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleC5cblx0Ly8gVGhpcyB2YWx1ZSBpcyBOT1QgcmVsYXRpdmUgdG8gdGhlIG9mZnNldFBhcmVudCdzIGJvdHRvbSBlZGdlLCBsaWtlIHRoZSBDU1MgY29uY2VwdCBvZiBcImJvdHRvbVwiIHdvdWxkIGJlLlxuXHRnZXRCb3R0b21PZmZzZXQ6IGZ1bmN0aW9uKHRvcEluZGV4KSB7XG5cdFx0dGhpcy5lbnN1cmVCdWlsdCgpO1xuXHRcdHJldHVybiB0aGlzLmJvdHRvbXNbdG9wSW5kZXhdO1xuXHR9LFxuXG5cblx0Ly8gR2V0cyB0aGUgYm90dG9tIHBvc2l0aW9uIChmcm9tIHRoZSBvZmZzZXRQYXJlbnQgdG9wKSBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXguXG5cdC8vIFRoaXMgdmFsdWUgaXMgTk9UIHJlbGF0aXZlIHRvIHRoZSBvZmZzZXRQYXJlbnQncyBib3R0b20gZWRnZSwgbGlrZSB0aGUgQ1NTIGNvbmNlcHQgb2YgXCJib3R0b21cIiB3b3VsZCBiZS5cblx0Z2V0Qm90dG9tUG9zaXRpb246IGZ1bmN0aW9uKHRvcEluZGV4KSB7XG5cdFx0dGhpcy5lbnN1cmVCdWlsdCgpO1xuXHRcdHJldHVybiB0aGlzLmJvdHRvbXNbdG9wSW5kZXhdIC0gdGhpcy5vcmlnaW4udG9wO1xuXHR9LFxuXG5cblx0Ly8gR2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleFxuXHRnZXRIZWlnaHQ6IGZ1bmN0aW9uKHRvcEluZGV4KSB7XG5cdFx0dGhpcy5lbnN1cmVCdWlsdCgpO1xuXHRcdHJldHVybiB0aGlzLmJvdHRvbXNbdG9wSW5kZXhdIC0gdGhpcy50b3BzW3RvcEluZGV4XTtcblx0fSxcblxuXG5cdC8vIEJvdW5kaW5nIFJlY3Rcblx0Ly8gVE9ETzogZGVjb3VwbGUgdGhpcyBmcm9tIENvb3JkQ2FjaGVcblxuXHQvLyBDb21wdXRlIGFuZCByZXR1cm4gd2hhdCB0aGUgZWxlbWVudHMnIGJvdW5kaW5nIHJlY3RhbmdsZSBpcywgZnJvbSB0aGUgdXNlcidzIHBlcnNwZWN0aXZlLlxuXHQvLyBSaWdodCBub3csIG9ubHkgcmV0dXJucyBhIHJlY3RhbmdsZSBpZiBjb25zdHJhaW5lZCBieSBhbiBvdmVyZmxvdzpzY3JvbGwgZWxlbWVudC5cblx0cXVlcnlCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzY3JvbGxQYXJlbnRFbCA9IGdldFNjcm9sbFBhcmVudCh0aGlzLmVscy5lcSgwKSk7XG5cblx0XHRpZiAoIXNjcm9sbFBhcmVudEVsLmlzKGRvY3VtZW50KSkge1xuXHRcdFx0cmV0dXJuIGdldENsaWVudFJlY3Qoc2Nyb2xsUGFyZW50RWwpO1xuXHRcdH1cblx0fSxcblxuXHRpc1BvaW50SW5Cb3VuZHM6IGZ1bmN0aW9uKGxlZnRPZmZzZXQsIHRvcE9mZnNldCkge1xuXHRcdHJldHVybiB0aGlzLmlzTGVmdEluQm91bmRzKGxlZnRPZmZzZXQpICYmIHRoaXMuaXNUb3BJbkJvdW5kcyh0b3BPZmZzZXQpO1xuXHR9LFxuXG5cdGlzTGVmdEluQm91bmRzOiBmdW5jdGlvbihsZWZ0T2Zmc2V0KSB7XG5cdFx0cmV0dXJuICF0aGlzLmJvdW5kaW5nUmVjdCB8fCAobGVmdE9mZnNldCA+PSB0aGlzLmJvdW5kaW5nUmVjdC5sZWZ0ICYmIGxlZnRPZmZzZXQgPCB0aGlzLmJvdW5kaW5nUmVjdC5yaWdodCk7XG5cdH0sXG5cblx0aXNUb3BJbkJvdW5kczogZnVuY3Rpb24odG9wT2Zmc2V0KSB7XG5cdFx0cmV0dXJuICF0aGlzLmJvdW5kaW5nUmVjdCB8fCAodG9wT2Zmc2V0ID49IHRoaXMuYm91bmRpbmdSZWN0LnRvcCAmJiB0b3BPZmZzZXQgPCB0aGlzLmJvdW5kaW5nUmVjdC5ib3R0b20pO1xuXHR9XG5cbn0pO1xuXG47O1xuXG4vKiBUcmFja3MgYSBkcmFnJ3MgbW91c2UgbW92ZW1lbnQsIGZpcmluZyB2YXJpb3VzIGhhbmRsZXJzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8vIFRPRE86IHVzZSBFbWl0dGVyXG5cbnZhciBEcmFnTGlzdGVuZXIgPSBGQy5EcmFnTGlzdGVuZXIgPSBDbGFzcy5leHRlbmQoTGlzdGVuZXJNaXhpbiwgTW91c2VJZ25vcmVyTWl4aW4sIHtcblxuXHRvcHRpb25zOiBudWxsLFxuXHRzdWJqZWN0RWw6IG51bGwsXG5cblx0Ly8gY29vcmRpbmF0ZXMgb2YgdGhlIGluaXRpYWwgbW91c2Vkb3duXG5cdG9yaWdpblg6IG51bGwsXG5cdG9yaWdpblk6IG51bGwsXG5cblx0Ly8gdGhlIHdyYXBwaW5nIGVsZW1lbnQgdGhhdCBzY3JvbGxzLCBvciBNSUdIVCBzY3JvbGwgaWYgdGhlcmUncyBvdmVyZmxvdy5cblx0Ly8gVE9ETzogZG8gdGhpcyBmb3Igd3JhcHBlcnMgdGhhdCBoYXZlIG92ZXJmbG93OmhpZGRlbiBhcyB3ZWxsLlxuXHRzY3JvbGxFbDogbnVsbCxcblxuXHRpc0ludGVyYWN0aW5nOiBmYWxzZSxcblx0aXNEaXN0YW5jZVN1cnBhc3NlZDogZmFsc2UsXG5cdGlzRGVsYXlFbmRlZDogZmFsc2UsXG5cdGlzRHJhZ2dpbmc6IGZhbHNlLFxuXHRpc1RvdWNoOiBmYWxzZSxcblxuXHRkZWxheTogbnVsbCxcblx0ZGVsYXlUaW1lb3V0SWQ6IG51bGwsXG5cdG1pbkRpc3RhbmNlOiBudWxsLFxuXG5cdGhhbmRsZVRvdWNoU2Nyb2xsUHJveHk6IG51bGwsIC8vIGNhbGxzIGhhbmRsZVRvdWNoU2Nyb2xsLCBhbHdheXMgYm91bmQgdG8gYHRoaXNgXG5cblxuXHRjb25zdHJ1Y3RvcjogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0dGhpcy5oYW5kbGVUb3VjaFNjcm9sbFByb3h5ID0gcHJveHkodGhpcywgJ2hhbmRsZVRvdWNoU2Nyb2xsJyk7XG5cdFx0dGhpcy5pbml0TW91c2VJZ25vcmluZyg1MDApO1xuXHR9LFxuXG5cblx0Ly8gSW50ZXJhY3Rpb24gKGhpZ2gtbGV2ZWwpXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuXHRzdGFydEludGVyYWN0aW9uOiBmdW5jdGlvbihldiwgZXh0cmFPcHRpb25zKSB7XG5cdFx0dmFyIGlzVG91Y2ggPSBnZXRFdklzVG91Y2goZXYpO1xuXG5cdFx0aWYgKGV2LnR5cGUgPT09ICdtb3VzZWRvd24nKSB7XG5cdFx0XHRpZiAodGhpcy5pc0lnbm9yaW5nTW91c2UpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIWlzUHJpbWFyeU1vdXNlQnV0dG9uKGV2KSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0ZXYucHJldmVudERlZmF1bHQoKTsgLy8gcHJldmVudHMgbmF0aXZlIHNlbGVjdGlvbiBpbiBtb3N0IGJyb3dzZXJzXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLmlzSW50ZXJhY3RpbmcpIHtcblxuXHRcdFx0Ly8gcHJvY2VzcyBvcHRpb25zXG5cdFx0XHRleHRyYU9wdGlvbnMgPSBleHRyYU9wdGlvbnMgfHwge307XG5cdFx0XHR0aGlzLmRlbGF5ID0gZmlyc3REZWZpbmVkKGV4dHJhT3B0aW9ucy5kZWxheSwgdGhpcy5vcHRpb25zLmRlbGF5LCAwKTtcblx0XHRcdHRoaXMubWluRGlzdGFuY2UgPSBmaXJzdERlZmluZWQoZXh0cmFPcHRpb25zLmRpc3RhbmNlLCB0aGlzLm9wdGlvbnMuZGlzdGFuY2UsIDApO1xuXHRcdFx0dGhpcy5zdWJqZWN0RWwgPSB0aGlzLm9wdGlvbnMuc3ViamVjdEVsO1xuXG5cdFx0XHR0aGlzLmlzSW50ZXJhY3RpbmcgPSB0cnVlO1xuXHRcdFx0dGhpcy5pc1RvdWNoID0gaXNUb3VjaDtcblx0XHRcdHRoaXMuaXNEZWxheUVuZGVkID0gZmFsc2U7XG5cdFx0XHR0aGlzLmlzRGlzdGFuY2VTdXJwYXNzZWQgPSBmYWxzZTtcblxuXHRcdFx0dGhpcy5vcmlnaW5YID0gZ2V0RXZYKGV2KTtcblx0XHRcdHRoaXMub3JpZ2luWSA9IGdldEV2WShldik7XG5cdFx0XHR0aGlzLnNjcm9sbEVsID0gZ2V0U2Nyb2xsUGFyZW50KCQoZXYudGFyZ2V0KSk7XG5cblx0XHRcdHRoaXMuYmluZEhhbmRsZXJzKCk7XG5cdFx0XHR0aGlzLmluaXRBdXRvU2Nyb2xsKCk7XG5cdFx0XHR0aGlzLmhhbmRsZUludGVyYWN0aW9uU3RhcnQoZXYpO1xuXHRcdFx0dGhpcy5zdGFydERlbGF5KGV2KTtcblxuXHRcdFx0aWYgKCF0aGlzLm1pbkRpc3RhbmNlKSB7XG5cdFx0XHRcdHRoaXMuaGFuZGxlRGlzdGFuY2VTdXJwYXNzZWQoZXYpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXG5cdGhhbmRsZUludGVyYWN0aW9uU3RhcnQ6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0dGhpcy50cmlnZ2VyKCdpbnRlcmFjdGlvblN0YXJ0JywgZXYpO1xuXHR9LFxuXG5cblx0ZW5kSW50ZXJhY3Rpb246IGZ1bmN0aW9uKGV2LCBpc0NhbmNlbGxlZCkge1xuXHRcdGlmICh0aGlzLmlzSW50ZXJhY3RpbmcpIHtcblx0XHRcdHRoaXMuZW5kRHJhZyhldik7XG5cblx0XHRcdGlmICh0aGlzLmRlbGF5VGltZW91dElkKSB7XG5cdFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLmRlbGF5VGltZW91dElkKTtcblx0XHRcdFx0dGhpcy5kZWxheVRpbWVvdXRJZCA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZGVzdHJveUF1dG9TY3JvbGwoKTtcblx0XHRcdHRoaXMudW5iaW5kSGFuZGxlcnMoKTtcblxuXHRcdFx0dGhpcy5pc0ludGVyYWN0aW5nID0gZmFsc2U7XG5cdFx0XHR0aGlzLmhhbmRsZUludGVyYWN0aW9uRW5kKGV2LCBpc0NhbmNlbGxlZCk7XG5cblx0XHRcdC8vIGEgdG91Y2hzdGFydCt0b3VjaGVuZCBvbiB0aGUgc2FtZSBlbGVtZW50IHdpbGwgcmVzdWx0IGluIHRoZSBmb2xsb3dpbmcgYWRkaXRpb24gc2ltdWxhdGVkIGV2ZW50czpcblx0XHRcdC8vIG1vdXNlb3ZlciArIG1vdXNlb3V0ICsgY2xpY2tcblx0XHRcdC8vIGxldCdzIGlnbm9yZSB0aGVzZSBib2d1cyBldmVudHNcblx0XHRcdGlmICh0aGlzLmlzVG91Y2gpIHtcblx0XHRcdFx0dGhpcy50ZW1wSWdub3JlTW91c2UoKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblxuXHRoYW5kbGVJbnRlcmFjdGlvbkVuZDogZnVuY3Rpb24oZXYsIGlzQ2FuY2VsbGVkKSB7XG5cdFx0dGhpcy50cmlnZ2VyKCdpbnRlcmFjdGlvbkVuZCcsIGV2LCBpc0NhbmNlbGxlZCB8fCBmYWxzZSk7XG5cdH0sXG5cblxuXHQvLyBCaW5kaW5nIFRvIERPTVxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblx0YmluZEhhbmRsZXJzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHZhciB0b3VjaFN0YXJ0SWdub3JlcyA9IDE7XG5cblx0XHRpZiAodGhpcy5pc1RvdWNoKSB7XG5cdFx0XHR0aGlzLmxpc3RlblRvKCQoZG9jdW1lbnQpLCB7XG5cdFx0XHRcdHRvdWNobW92ZTogdGhpcy5oYW5kbGVUb3VjaE1vdmUsXG5cdFx0XHRcdHRvdWNoZW5kOiB0aGlzLmVuZEludGVyYWN0aW9uLFxuXHRcdFx0XHR0b3VjaGNhbmNlbDogdGhpcy5lbmRJbnRlcmFjdGlvbixcblxuXHRcdFx0XHQvLyBTb21ldGltZXMgdG91Y2hlbmQgZG9lc24ndCBmaXJlXG5cdFx0XHRcdC8vIChjYW4ndCBmaWd1cmUgb3V0IHdoeS4gdG91Y2hjYW5jZWwgZG9lc24ndCBmaXJlIGVpdGhlci4gaGFzIHRvIGRvIHdpdGggc2Nyb2xsaW5nPylcblx0XHRcdFx0Ly8gSWYgYW5vdGhlciB0b3VjaHN0YXJ0IGhhcHBlbnMsIHdlIGtub3cgaXQncyBib2d1cywgc28gY2FuY2VsIHRoZSBkcmFnLlxuXHRcdFx0XHQvLyB0b3VjaGVuZCB3aWxsIGNvbnRpbnVlIHRvIGJlIGJyb2tlbiB1bnRpbCB1c2VyIGRvZXMgYSBzaG9ydHRhcC9zY3JvbGwsIGJ1dCB0aGlzIGlzIGJlc3Qgd2UgY2FuIGRvLlxuXHRcdFx0XHR0b3VjaHN0YXJ0OiBmdW5jdGlvbihldikge1xuXHRcdFx0XHRcdGlmICh0b3VjaFN0YXJ0SWdub3JlcykgeyAvLyBiaW5kSGFuZGxlcnMgaXMgY2FsbGVkIGZyb20gd2l0aGluIGEgdG91Y2hzdGFydCxcblx0XHRcdFx0XHRcdHRvdWNoU3RhcnRJZ25vcmVzLS07IC8vIGFuZCB3ZSBkb24ndCB3YW50IHRoaXMgdG8gZmlyZSBpbW1lZGlhdGVseSwgc28gaWdub3JlLlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdF90aGlzLmVuZEludGVyYWN0aW9uKGV2LCB0cnVlKTsgLy8gaXNDYW5jZWxsZWQ9dHJ1ZVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIGxpc3RlbiB0byBBTEwgc2Nyb2xsIGFjdGlvbnMgb24gdGhlIHBhZ2Vcblx0XHRcdGlmIChcblx0XHRcdFx0IWJpbmRBbnlTY3JvbGwodGhpcy5oYW5kbGVUb3VjaFNjcm9sbFByb3h5KSAmJiAvLyBob3BlZnVsbHkgdGhpcyB3b3JrcyBhbmQgc2hvcnQtY2lyY3VpdHMgdGhlIHJlc3Rcblx0XHRcdFx0dGhpcy5zY3JvbGxFbCAvLyBvdGhlcndpc2UsIGF0dGFjaCBhIHNpbmdsZSBoYW5kbGVyIHRvIHRoaXNcblx0XHRcdCkge1xuXHRcdFx0XHR0aGlzLmxpc3RlblRvKHRoaXMuc2Nyb2xsRWwsICdzY3JvbGwnLCB0aGlzLmhhbmRsZVRvdWNoU2Nyb2xsKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR0aGlzLmxpc3RlblRvKCQoZG9jdW1lbnQpLCB7XG5cdFx0XHRcdG1vdXNlbW92ZTogdGhpcy5oYW5kbGVNb3VzZU1vdmUsXG5cdFx0XHRcdG1vdXNldXA6IHRoaXMuZW5kSW50ZXJhY3Rpb25cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHRoaXMubGlzdGVuVG8oJChkb2N1bWVudCksIHtcblx0XHRcdHNlbGVjdHN0YXJ0OiBwcmV2ZW50RGVmYXVsdCwgLy8gZG9uJ3QgYWxsb3cgc2VsZWN0aW9uIHdoaWxlIGRyYWdnaW5nXG5cdFx0XHRjb250ZXh0bWVudTogcHJldmVudERlZmF1bHQgLy8gbG9uZyB0YXBzIHdvdWxkIG9wZW4gbWVudSBvbiBDaHJvbWUgZGV2IHRvb2xzXG5cdFx0fSk7XG5cdH0sXG5cblxuXHR1bmJpbmRIYW5kbGVyczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5zdG9wTGlzdGVuaW5nVG8oJChkb2N1bWVudCkpO1xuXG5cdFx0Ly8gdW5iaW5kIHNjcm9sbCBsaXN0ZW5pbmdcblx0XHR1bmJpbmRBbnlTY3JvbGwodGhpcy5oYW5kbGVUb3VjaFNjcm9sbFByb3h5KTtcblx0XHRpZiAodGhpcy5zY3JvbGxFbCkge1xuXHRcdFx0dGhpcy5zdG9wTGlzdGVuaW5nVG8odGhpcy5zY3JvbGxFbCwgJ3Njcm9sbCcpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIERyYWcgKGhpZ2gtbGV2ZWwpXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuXHQvLyBleHRyYU9wdGlvbnMgaWdub3JlZCBpZiBkcmFnIGFscmVhZHkgc3RhcnRlZFxuXHRzdGFydERyYWc6IGZ1bmN0aW9uKGV2LCBleHRyYU9wdGlvbnMpIHtcblx0XHR0aGlzLnN0YXJ0SW50ZXJhY3Rpb24oZXYsIGV4dHJhT3B0aW9ucyk7IC8vIGVuc3VyZSBpbnRlcmFjdGlvbiBiZWdhblxuXG5cdFx0aWYgKCF0aGlzLmlzRHJhZ2dpbmcpIHtcblx0XHRcdHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7XG5cdFx0XHR0aGlzLmhhbmRsZURyYWdTdGFydChldik7XG5cdFx0fVxuXHR9LFxuXG5cblx0aGFuZGxlRHJhZ1N0YXJ0OiBmdW5jdGlvbihldikge1xuXHRcdHRoaXMudHJpZ2dlcignZHJhZ1N0YXJ0JywgZXYpO1xuXHR9LFxuXG5cblx0aGFuZGxlTW92ZTogZnVuY3Rpb24oZXYpIHtcblx0XHR2YXIgZHggPSBnZXRFdlgoZXYpIC0gdGhpcy5vcmlnaW5YO1xuXHRcdHZhciBkeSA9IGdldEV2WShldikgLSB0aGlzLm9yaWdpblk7XG5cdFx0dmFyIG1pbkRpc3RhbmNlID0gdGhpcy5taW5EaXN0YW5jZTtcblx0XHR2YXIgZGlzdGFuY2VTcTsgLy8gY3VycmVudCBkaXN0YW5jZSBmcm9tIHRoZSBvcmlnaW4sIHNxdWFyZWRcblxuXHRcdGlmICghdGhpcy5pc0Rpc3RhbmNlU3VycGFzc2VkKSB7XG5cdFx0XHRkaXN0YW5jZVNxID0gZHggKiBkeCArIGR5ICogZHk7XG5cdFx0XHRpZiAoZGlzdGFuY2VTcSA+PSBtaW5EaXN0YW5jZSAqIG1pbkRpc3RhbmNlKSB7IC8vIHVzZSBweXRoYWdvcmVhbiB0aGVvcmVtXG5cdFx0XHRcdHRoaXMuaGFuZGxlRGlzdGFuY2VTdXJwYXNzZWQoZXYpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0aGlzLmlzRHJhZ2dpbmcpIHtcblx0XHRcdHRoaXMuaGFuZGxlRHJhZyhkeCwgZHksIGV2KTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBDYWxsZWQgd2hpbGUgdGhlIG1vdXNlIGlzIGJlaW5nIG1vdmVkIGFuZCB3aGVuIHdlIGtub3cgYSBsZWdpdGltYXRlIGRyYWcgaXMgdGFraW5nIHBsYWNlXG5cdGhhbmRsZURyYWc6IGZ1bmN0aW9uKGR4LCBkeSwgZXYpIHtcblx0XHR0aGlzLnRyaWdnZXIoJ2RyYWcnLCBkeCwgZHksIGV2KTtcblx0XHR0aGlzLnVwZGF0ZUF1dG9TY3JvbGwoZXYpOyAvLyB3aWxsIHBvc3NpYmx5IGNhdXNlIHNjcm9sbGluZ1xuXHR9LFxuXG5cblx0ZW5kRHJhZzogZnVuY3Rpb24oZXYpIHtcblx0XHRpZiAodGhpcy5pc0RyYWdnaW5nKSB7XG5cdFx0XHR0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcblx0XHRcdHRoaXMuaGFuZGxlRHJhZ0VuZChldik7XG5cdFx0fVxuXHR9LFxuXG5cblx0aGFuZGxlRHJhZ0VuZDogZnVuY3Rpb24oZXYpIHtcblx0XHR0aGlzLnRyaWdnZXIoJ2RyYWdFbmQnLCBldik7XG5cdH0sXG5cblxuXHQvLyBEZWxheVxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblx0c3RhcnREZWxheTogZnVuY3Rpb24oaW5pdGlhbEV2KSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblxuXHRcdGlmICh0aGlzLmRlbGF5KSB7XG5cdFx0XHR0aGlzLmRlbGF5VGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0X3RoaXMuaGFuZGxlRGVsYXlFbmQoaW5pdGlhbEV2KTtcblx0XHRcdH0sIHRoaXMuZGVsYXkpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHRoaXMuaGFuZGxlRGVsYXlFbmQoaW5pdGlhbEV2KTtcblx0XHR9XG5cdH0sXG5cblxuXHRoYW5kbGVEZWxheUVuZDogZnVuY3Rpb24oaW5pdGlhbEV2KSB7XG5cdFx0dGhpcy5pc0RlbGF5RW5kZWQgPSB0cnVlO1xuXG5cdFx0aWYgKHRoaXMuaXNEaXN0YW5jZVN1cnBhc3NlZCkge1xuXHRcdFx0dGhpcy5zdGFydERyYWcoaW5pdGlhbEV2KTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBEaXN0YW5jZVxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblx0aGFuZGxlRGlzdGFuY2VTdXJwYXNzZWQ6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0dGhpcy5pc0Rpc3RhbmNlU3VycGFzc2VkID0gdHJ1ZTtcblxuXHRcdGlmICh0aGlzLmlzRGVsYXlFbmRlZCkge1xuXHRcdFx0dGhpcy5zdGFydERyYWcoZXYpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIE1vdXNlIC8gVG91Y2hcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5cdGhhbmRsZVRvdWNoTW92ZTogZnVuY3Rpb24oZXYpIHtcblx0XHQvLyBwcmV2ZW50IGluZXJ0aWEgYW5kIHRvdWNobW92ZS1zY3JvbGxpbmcgd2hpbGUgZHJhZ2dpbmdcblx0XHRpZiAodGhpcy5pc0RyYWdnaW5nKSB7XG5cdFx0XHRldi5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblxuXHRcdHRoaXMuaGFuZGxlTW92ZShldik7XG5cdH0sXG5cblxuXHRoYW5kbGVNb3VzZU1vdmU6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0dGhpcy5oYW5kbGVNb3ZlKGV2KTtcblx0fSxcblxuXG5cdC8vIFNjcm9sbGluZyAodW5yZWxhdGVkIHRvIGF1dG8tc2Nyb2xsKVxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblx0aGFuZGxlVG91Y2hTY3JvbGw6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0Ly8gaWYgdGhlIGRyYWcgaXMgYmVpbmcgaW5pdGlhdGVkIGJ5IHRvdWNoLCBidXQgYSBzY3JvbGwgaGFwcGVucyBiZWZvcmVcblx0XHQvLyB0aGUgZHJhZy1pbml0aWF0aW5nIGRlbGF5IGlzIG92ZXIsIGNhbmNlbCB0aGUgZHJhZ1xuXHRcdGlmICghdGhpcy5pc0RyYWdnaW5nKSB7XG5cdFx0XHR0aGlzLmVuZEludGVyYWN0aW9uKGV2LCB0cnVlKTsgLy8gaXNDYW5jZWxsZWQ9dHJ1ZVxuXHRcdH1cblx0fSxcblxuXG5cdC8vIFV0aWxzXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuXHQvLyBUcmlnZ2VycyBhIGNhbGxiYWNrLiBDYWxscyBhIGZ1bmN0aW9uIGluIHRoZSBvcHRpb24gaGFzaCBvZiB0aGUgc2FtZSBuYW1lLlxuXHQvLyBBcmd1bWVudHMgYmV5b25kIHRoZSBmaXJzdCBgbmFtZWAgYXJlIGZvcndhcmRlZCBvbi5cblx0dHJpZ2dlcjogZnVuY3Rpb24obmFtZSkge1xuXHRcdGlmICh0aGlzLm9wdGlvbnNbbmFtZV0pIHtcblx0XHRcdHRoaXMub3B0aW9uc1tuYW1lXS5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcblx0XHR9XG5cdFx0Ly8gbWFrZXMgX21ldGhvZHMgY2FsbGFibGUgYnkgZXZlbnQgbmFtZS4gVE9ETzoga2lsbCB0aGlzXG5cdFx0aWYgKHRoaXNbJ18nICsgbmFtZV0pIHtcblx0XHRcdHRoaXNbJ18nICsgbmFtZV0uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG5cdFx0fVxuXHR9XG5cblxufSk7XG5cbjs7XG4vKlxudGhpcy5zY3JvbGxFbCBpcyBzZXQgaW4gRHJhZ0xpc3RlbmVyXG4qL1xuRHJhZ0xpc3RlbmVyLm1peGluKHtcblxuXHRpc0F1dG9TY3JvbGw6IGZhbHNlLFxuXG5cdHNjcm9sbEJvdW5kczogbnVsbCwgLy8geyB0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHQgfVxuXHRzY3JvbGxUb3BWZWw6IG51bGwsIC8vIHBpeGVscyBwZXIgc2Vjb25kXG5cdHNjcm9sbExlZnRWZWw6IG51bGwsIC8vIHBpeGVscyBwZXIgc2Vjb25kXG5cdHNjcm9sbEludGVydmFsSWQ6IG51bGwsIC8vIElEIG9mIHNldFRpbWVvdXQgZm9yIHNjcm9sbGluZyBhbmltYXRpb24gbG9vcFxuXG5cdC8vIGRlZmF1bHRzXG5cdHNjcm9sbFNlbnNpdGl2aXR5OiAzMCwgLy8gcGl4ZWxzIGZyb20gZWRnZSBmb3Igc2Nyb2xsaW5nIHRvIHN0YXJ0XG5cdHNjcm9sbFNwZWVkOiAyMDAsIC8vIHBpeGVscyBwZXIgc2Vjb25kLCBhdCBtYXhpbXVtIHNwZWVkXG5cdHNjcm9sbEludGVydmFsTXM6IDUwLCAvLyBtaWxsaXNlY29uZCB3YWl0IGJldHdlZW4gc2Nyb2xsIGluY3JlbWVudFxuXG5cblx0aW5pdEF1dG9TY3JvbGw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzY3JvbGxFbCA9IHRoaXMuc2Nyb2xsRWw7XG5cblx0XHR0aGlzLmlzQXV0b1Njcm9sbCA9XG5cdFx0XHR0aGlzLm9wdGlvbnMuc2Nyb2xsICYmXG5cdFx0XHRzY3JvbGxFbCAmJlxuXHRcdFx0IXNjcm9sbEVsLmlzKHdpbmRvdykgJiZcblx0XHRcdCFzY3JvbGxFbC5pcyhkb2N1bWVudCk7XG5cblx0XHRpZiAodGhpcy5pc0F1dG9TY3JvbGwpIHtcblx0XHRcdC8vIGRlYm91bmNlIG1ha2VzIHN1cmUgcmFwaWQgY2FsbHMgZG9uJ3QgaGFwcGVuXG5cdFx0XHR0aGlzLmxpc3RlblRvKHNjcm9sbEVsLCAnc2Nyb2xsJywgZGVib3VuY2UodGhpcy5oYW5kbGVEZWJvdW5jZWRTY3JvbGwsIDEwMCkpO1xuXHRcdH1cblx0fSxcblxuXG5cdGRlc3Ryb3lBdXRvU2Nyb2xsOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmVuZEF1dG9TY3JvbGwoKTsgLy8ga2lsbCBhbnkgYW5pbWF0aW9uIGxvb3BcblxuXHRcdC8vIHJlbW92ZSB0aGUgc2Nyb2xsIGhhbmRsZXIgaWYgdGhlcmUgaXMgYSBzY3JvbGxFbFxuXHRcdGlmICh0aGlzLmlzQXV0b1Njcm9sbCkge1xuXHRcdFx0dGhpcy5zdG9wTGlzdGVuaW5nVG8odGhpcy5zY3JvbGxFbCwgJ3Njcm9sbCcpOyAvLyB3aWxsIHByb2JhYmx5IGdldCByZW1vdmVkIGJ5IHVuYmluZEhhbmRsZXJzIHRvbyA6KFxuXHRcdH1cblx0fSxcblxuXG5cdC8vIENvbXB1dGVzIGFuZCBzdG9yZXMgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZSBvZiBzY3JvbGxFbFxuXHRjb21wdXRlU2Nyb2xsQm91bmRzOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5pc0F1dG9TY3JvbGwpIHtcblx0XHRcdHRoaXMuc2Nyb2xsQm91bmRzID0gZ2V0T3V0ZXJSZWN0KHRoaXMuc2Nyb2xsRWwpO1xuXHRcdFx0Ly8gVE9ETzogdXNlIGdldENsaWVudFJlY3QgaW4gZnV0dXJlLiBidXQgcHJldmVudHMgYXV0byBzY3JvbGxpbmcgd2hlbiBvbiB0b3Agb2Ygc2Nyb2xsYmFyc1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIENhbGxlZCB3aGVuIHRoZSBkcmFnZ2luZyBpcyBpbiBwcm9ncmVzcyBhbmQgc2Nyb2xsaW5nIHNob3VsZCBiZSB1cGRhdGVkXG5cdHVwZGF0ZUF1dG9TY3JvbGw6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0dmFyIHNlbnNpdGl2aXR5ID0gdGhpcy5zY3JvbGxTZW5zaXRpdml0eTtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5zY3JvbGxCb3VuZHM7XG5cdFx0dmFyIHRvcENsb3NlbmVzcywgYm90dG9tQ2xvc2VuZXNzO1xuXHRcdHZhciBsZWZ0Q2xvc2VuZXNzLCByaWdodENsb3NlbmVzcztcblx0XHR2YXIgdG9wVmVsID0gMDtcblx0XHR2YXIgbGVmdFZlbCA9IDA7XG5cblx0XHRpZiAoYm91bmRzKSB7IC8vIG9ubHkgc2Nyb2xsIGlmIHNjcm9sbEVsIGV4aXN0c1xuXG5cdFx0XHQvLyBjb21wdXRlIGNsb3NlbmVzcyB0byBlZGdlcy4gdmFsaWQgcmFuZ2UgaXMgZnJvbSAwLjAgLSAxLjBcblx0XHRcdHRvcENsb3NlbmVzcyA9IChzZW5zaXRpdml0eSAtIChnZXRFdlkoZXYpIC0gYm91bmRzLnRvcCkpIC8gc2Vuc2l0aXZpdHk7XG5cdFx0XHRib3R0b21DbG9zZW5lc3MgPSAoc2Vuc2l0aXZpdHkgLSAoYm91bmRzLmJvdHRvbSAtIGdldEV2WShldikpKSAvIHNlbnNpdGl2aXR5O1xuXHRcdFx0bGVmdENsb3NlbmVzcyA9IChzZW5zaXRpdml0eSAtIChnZXRFdlgoZXYpIC0gYm91bmRzLmxlZnQpKSAvIHNlbnNpdGl2aXR5O1xuXHRcdFx0cmlnaHRDbG9zZW5lc3MgPSAoc2Vuc2l0aXZpdHkgLSAoYm91bmRzLnJpZ2h0IC0gZ2V0RXZYKGV2KSkpIC8gc2Vuc2l0aXZpdHk7XG5cblx0XHRcdC8vIHRyYW5zbGF0ZSB2ZXJ0aWNhbCBjbG9zZW5lc3MgaW50byB2ZWxvY2l0eS5cblx0XHRcdC8vIG1vdXNlIG11c3QgYmUgY29tcGxldGVseSBpbiBib3VuZHMgZm9yIHZlbG9jaXR5IHRvIGhhcHBlbi5cblx0XHRcdGlmICh0b3BDbG9zZW5lc3MgPj0gMCAmJiB0b3BDbG9zZW5lc3MgPD0gMSkge1xuXHRcdFx0XHR0b3BWZWwgPSB0b3BDbG9zZW5lc3MgKiB0aGlzLnNjcm9sbFNwZWVkICogLTE7IC8vIG5lZ2F0aXZlLiBmb3Igc2Nyb2xsaW5nIHVwXG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChib3R0b21DbG9zZW5lc3MgPj0gMCAmJiBib3R0b21DbG9zZW5lc3MgPD0gMSkge1xuXHRcdFx0XHR0b3BWZWwgPSBib3R0b21DbG9zZW5lc3MgKiB0aGlzLnNjcm9sbFNwZWVkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyB0cmFuc2xhdGUgaG9yaXpvbnRhbCBjbG9zZW5lc3MgaW50byB2ZWxvY2l0eVxuXHRcdFx0aWYgKGxlZnRDbG9zZW5lc3MgPj0gMCAmJiBsZWZ0Q2xvc2VuZXNzIDw9IDEpIHtcblx0XHRcdFx0bGVmdFZlbCA9IGxlZnRDbG9zZW5lc3MgKiB0aGlzLnNjcm9sbFNwZWVkICogLTE7IC8vIG5lZ2F0aXZlLiBmb3Igc2Nyb2xsaW5nIGxlZnRcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHJpZ2h0Q2xvc2VuZXNzID49IDAgJiYgcmlnaHRDbG9zZW5lc3MgPD0gMSkge1xuXHRcdFx0XHRsZWZ0VmVsID0gcmlnaHRDbG9zZW5lc3MgKiB0aGlzLnNjcm9sbFNwZWVkO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuc2V0U2Nyb2xsVmVsKHRvcFZlbCwgbGVmdFZlbCk7XG5cdH0sXG5cblxuXHQvLyBTZXRzIHRoZSBzcGVlZC1vZi1zY3JvbGxpbmcgZm9yIHRoZSBzY3JvbGxFbFxuXHRzZXRTY3JvbGxWZWw6IGZ1bmN0aW9uKHRvcFZlbCwgbGVmdFZlbCkge1xuXG5cdFx0dGhpcy5zY3JvbGxUb3BWZWwgPSB0b3BWZWw7XG5cdFx0dGhpcy5zY3JvbGxMZWZ0VmVsID0gbGVmdFZlbDtcblxuXHRcdHRoaXMuY29uc3RyYWluU2Nyb2xsVmVsKCk7IC8vIG1hc3NhZ2VzIGludG8gcmVhbGlzdGljIHZhbHVlc1xuXG5cdFx0Ly8gaWYgdGhlcmUgaXMgbm9uLXplcm8gdmVsb2NpdHksIGFuZCBhbiBhbmltYXRpb24gbG9vcCBoYXNuJ3QgYWxyZWFkeSBzdGFydGVkLCB0aGVuIFNUQVJUXG5cdFx0aWYgKCh0aGlzLnNjcm9sbFRvcFZlbCB8fCB0aGlzLnNjcm9sbExlZnRWZWwpICYmICF0aGlzLnNjcm9sbEludGVydmFsSWQpIHtcblx0XHRcdHRoaXMuc2Nyb2xsSW50ZXJ2YWxJZCA9IHNldEludGVydmFsKFxuXHRcdFx0XHRwcm94eSh0aGlzLCAnc2Nyb2xsSW50ZXJ2YWxGdW5jJyksIC8vIHNjb3BlIHRvIGB0aGlzYFxuXHRcdFx0XHR0aGlzLnNjcm9sbEludGVydmFsTXNcblx0XHRcdCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gRm9yY2VzIHNjcm9sbFRvcFZlbCBhbmQgc2Nyb2xsTGVmdFZlbCB0byBiZSB6ZXJvIGlmIHNjcm9sbGluZyBoYXMgYWxyZWFkeSBnb25lIGFsbCB0aGUgd2F5XG5cdGNvbnN0cmFpblNjcm9sbFZlbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsID0gdGhpcy5zY3JvbGxFbDtcblxuXHRcdGlmICh0aGlzLnNjcm9sbFRvcFZlbCA8IDApIHsgLy8gc2Nyb2xsaW5nIHVwP1xuXHRcdFx0aWYgKGVsLnNjcm9sbFRvcCgpIDw9IDApIHsgLy8gYWxyZWFkeSBzY3JvbGxlZCBhbGwgdGhlIHdheSB1cD9cblx0XHRcdFx0dGhpcy5zY3JvbGxUb3BWZWwgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmICh0aGlzLnNjcm9sbFRvcFZlbCA+IDApIHsgLy8gc2Nyb2xsaW5nIGRvd24/XG5cdFx0XHRpZiAoZWwuc2Nyb2xsVG9wKCkgKyBlbFswXS5jbGllbnRIZWlnaHQgPj0gZWxbMF0uc2Nyb2xsSGVpZ2h0KSB7IC8vIGFscmVhZHkgc2Nyb2xsZWQgYWxsIHRoZSB3YXkgZG93bj9cblx0XHRcdFx0dGhpcy5zY3JvbGxUb3BWZWwgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0aGlzLnNjcm9sbExlZnRWZWwgPCAwKSB7IC8vIHNjcm9sbGluZyBsZWZ0P1xuXHRcdFx0aWYgKGVsLnNjcm9sbExlZnQoKSA8PSAwKSB7IC8vIGFscmVhZHkgc2Nyb2xsZWQgYWxsIHRoZSBsZWZ0P1xuXHRcdFx0XHR0aGlzLnNjcm9sbExlZnRWZWwgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmICh0aGlzLnNjcm9sbExlZnRWZWwgPiAwKSB7IC8vIHNjcm9sbGluZyByaWdodD9cblx0XHRcdGlmIChlbC5zY3JvbGxMZWZ0KCkgKyBlbFswXS5jbGllbnRXaWR0aCA+PSBlbFswXS5zY3JvbGxXaWR0aCkgeyAvLyBhbHJlYWR5IHNjcm9sbGVkIGFsbCB0aGUgd2F5IHJpZ2h0P1xuXHRcdFx0XHR0aGlzLnNjcm9sbExlZnRWZWwgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXG5cdC8vIFRoaXMgZnVuY3Rpb24gZ2V0cyBjYWxsZWQgZHVyaW5nIGV2ZXJ5IGl0ZXJhdGlvbiBvZiB0aGUgc2Nyb2xsaW5nIGFuaW1hdGlvbiBsb29wXG5cdHNjcm9sbEludGVydmFsRnVuYzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsID0gdGhpcy5zY3JvbGxFbDtcblx0XHR2YXIgZnJhYyA9IHRoaXMuc2Nyb2xsSW50ZXJ2YWxNcyAvIDEwMDA7IC8vIGNvbnNpZGVyaW5nIGFuaW1hdGlvbiBmcmVxdWVuY3ksIHdoYXQgdGhlIHZlbCBzaG91bGQgYmUgbXVsdCdkIGJ5XG5cblx0XHQvLyBjaGFuZ2UgdGhlIHZhbHVlIG9mIHNjcm9sbEVsJ3Mgc2Nyb2xsXG5cdFx0aWYgKHRoaXMuc2Nyb2xsVG9wVmVsKSB7XG5cdFx0XHRlbC5zY3JvbGxUb3AoZWwuc2Nyb2xsVG9wKCkgKyB0aGlzLnNjcm9sbFRvcFZlbCAqIGZyYWMpO1xuXHRcdH1cblx0XHRpZiAodGhpcy5zY3JvbGxMZWZ0VmVsKSB7XG5cdFx0XHRlbC5zY3JvbGxMZWZ0KGVsLnNjcm9sbExlZnQoKSArIHRoaXMuc2Nyb2xsTGVmdFZlbCAqIGZyYWMpO1xuXHRcdH1cblxuXHRcdHRoaXMuY29uc3RyYWluU2Nyb2xsVmVsKCk7IC8vIHNpbmNlIHRoZSBzY3JvbGwgdmFsdWVzIGNoYW5nZWQsIHJlY29tcHV0ZSB0aGUgdmVsb2NpdGllc1xuXG5cdFx0Ly8gaWYgc2Nyb2xsZWQgYWxsIHRoZSB3YXksIHdoaWNoIGNhdXNlcyB0aGUgdmVscyB0byBiZSB6ZXJvLCBzdG9wIHRoZSBhbmltYXRpb24gbG9vcFxuXHRcdGlmICghdGhpcy5zY3JvbGxUb3BWZWwgJiYgIXRoaXMuc2Nyb2xsTGVmdFZlbCkge1xuXHRcdFx0dGhpcy5lbmRBdXRvU2Nyb2xsKCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gS2lsbHMgYW55IGV4aXN0aW5nIHNjcm9sbGluZyBhbmltYXRpb24gbG9vcFxuXHRlbmRBdXRvU2Nyb2xsOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5zY3JvbGxJbnRlcnZhbElkKSB7XG5cdFx0XHRjbGVhckludGVydmFsKHRoaXMuc2Nyb2xsSW50ZXJ2YWxJZCk7XG5cdFx0XHR0aGlzLnNjcm9sbEludGVydmFsSWQgPSBudWxsO1xuXG5cdFx0XHR0aGlzLmhhbmRsZVNjcm9sbEVuZCgpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIEdldCBjYWxsZWQgd2hlbiB0aGUgc2Nyb2xsRWwgaXMgc2Nyb2xsZWQgKE5PVEU6IHRoaXMgaXMgZGVsYXllZCB2aWEgZGVib3VuY2UpXG5cdGhhbmRsZURlYm91bmNlZFNjcm9sbDogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gcmVjb21wdXRlIGFsbCBjb29yZGluYXRlcywgYnV0ICpvbmx5KiBpZiB0aGlzIGlzICpub3QqIHBhcnQgb2Ygb3VyIHNjcm9sbGluZyBhbmltYXRpb25cblx0XHRpZiAoIXRoaXMuc2Nyb2xsSW50ZXJ2YWxJZCkge1xuXHRcdFx0dGhpcy5oYW5kbGVTY3JvbGxFbmQoKTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBDYWxsZWQgd2hlbiBzY3JvbGxpbmcgaGFzIHN0b3BwZWQsIHdoZXRoZXIgdGhyb3VnaCBhdXRvIHNjcm9sbCwgb3IgdGhlIHVzZXIgc2Nyb2xsaW5nXG5cdGhhbmRsZVNjcm9sbEVuZDogZnVuY3Rpb24oKSB7XG5cdH1cblxufSk7XG47O1xuXG4vKiBUcmFja3MgbW91c2UgbW92ZW1lbnRzIG92ZXIgYSBjb21wb25lbnQgYW5kIHJhaXNlcyBldmVudHMgYWJvdXQgd2hpY2ggaGl0IHRoZSBtb3VzZSBpcyBvdmVyLlxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5vcHRpb25zOlxuLSBzdWJqZWN0RWxcbi0gc3ViamVjdENlbnRlclxuKi9cblxudmFyIEhpdERyYWdMaXN0ZW5lciA9IERyYWdMaXN0ZW5lci5leHRlbmQoe1xuXG5cdGNvbXBvbmVudDogbnVsbCwgLy8gY29udmVydHMgY29vcmRpbmF0ZXMgdG8gaGl0c1xuXHRcdC8vIG1ldGhvZHM6IHByZXBhcmVIaXRzLCByZWxlYXNlSGl0cywgcXVlcnlIaXRcblxuXHRvcmlnSGl0OiBudWxsLCAvLyB0aGUgaGl0IHRoZSBtb3VzZSB3YXMgb3ZlciB3aGVuIGxpc3RlbmluZyBzdGFydGVkXG5cdGhpdDogbnVsbCwgLy8gdGhlIGhpdCB0aGUgbW91c2UgaXMgb3ZlclxuXHRjb29yZEFkanVzdDogbnVsbCwgLy8gZGVsdGEgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBtb3VzZSBjb29yZGluYXRlcyB3aGVuIGNvbXB1dGluZyBjb2xsaXNpb25zXG5cblxuXHRjb25zdHJ1Y3RvcjogZnVuY3Rpb24oY29tcG9uZW50LCBvcHRpb25zKSB7XG5cdFx0RHJhZ0xpc3RlbmVyLmNhbGwodGhpcywgb3B0aW9ucyk7IC8vIGNhbGwgdGhlIHN1cGVyLWNvbnN0cnVjdG9yXG5cblx0XHR0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcblx0fSxcblxuXG5cdC8vIENhbGxlZCB3aGVuIGRyYWcgbGlzdGVuaW5nIHN0YXJ0cyAoYnV0IGEgcmVhbCBkcmFnIGhhcyBub3QgbmVjZXNzYXJpbHkgYmVnYW4pLlxuXHQvLyBldiBtaWdodCBiZSB1bmRlZmluZWQgaWYgZHJhZ2dpbmcgd2FzIHN0YXJ0ZWQgbWFudWFsbHkuXG5cdGhhbmRsZUludGVyYWN0aW9uU3RhcnQ6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0dmFyIHN1YmplY3RFbCA9IHRoaXMuc3ViamVjdEVsO1xuXHRcdHZhciBzdWJqZWN0UmVjdDtcblx0XHR2YXIgb3JpZ1BvaW50O1xuXHRcdHZhciBwb2ludDtcblxuXHRcdHRoaXMuY29tcHV0ZUNvb3JkcygpO1xuXG5cdFx0aWYgKGV2KSB7XG5cdFx0XHRvcmlnUG9pbnQgPSB7IGxlZnQ6IGdldEV2WChldiksIHRvcDogZ2V0RXZZKGV2KSB9O1xuXHRcdFx0cG9pbnQgPSBvcmlnUG9pbnQ7XG5cblx0XHRcdC8vIGNvbnN0cmFpbiB0aGUgcG9pbnQgdG8gYm91bmRzIG9mIHRoZSBlbGVtZW50IGJlaW5nIGRyYWdnZWRcblx0XHRcdGlmIChzdWJqZWN0RWwpIHtcblx0XHRcdFx0c3ViamVjdFJlY3QgPSBnZXRPdXRlclJlY3Qoc3ViamVjdEVsKTsgLy8gdXNlZCBmb3IgY2VudGVyaW5nIGFzIHdlbGxcblx0XHRcdFx0cG9pbnQgPSBjb25zdHJhaW5Qb2ludChwb2ludCwgc3ViamVjdFJlY3QpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm9yaWdIaXQgPSB0aGlzLnF1ZXJ5SGl0KHBvaW50LmxlZnQsIHBvaW50LnRvcCk7XG5cblx0XHRcdC8vIHRyZWF0IHRoZSBjZW50ZXIgb2YgdGhlIHN1YmplY3QgYXMgdGhlIGNvbGxpc2lvbiBwb2ludD9cblx0XHRcdGlmIChzdWJqZWN0RWwgJiYgdGhpcy5vcHRpb25zLnN1YmplY3RDZW50ZXIpIHtcblxuXHRcdFx0XHQvLyBvbmx5IGNvbnNpZGVyIHRoZSBhcmVhIHRoZSBzdWJqZWN0IG92ZXJsYXBzIHRoZSBoaXQuIGJlc3QgZm9yIGxhcmdlIHN1YmplY3RzLlxuXHRcdFx0XHQvLyBUT0RPOiBza2lwIHRoaXMgaWYgaGl0IGRpZG4ndCBzdXBwbHkgbGVmdC9yaWdodC90b3AvYm90dG9tXG5cdFx0XHRcdGlmICh0aGlzLm9yaWdIaXQpIHtcblx0XHRcdFx0XHRzdWJqZWN0UmVjdCA9IGludGVyc2VjdFJlY3RzKHRoaXMub3JpZ0hpdCwgc3ViamVjdFJlY3QpIHx8XG5cdFx0XHRcdFx0XHRzdWJqZWN0UmVjdDsgLy8gaW4gY2FzZSB0aGVyZSBpcyBubyBpbnRlcnNlY3Rpb25cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHBvaW50ID0gZ2V0UmVjdENlbnRlcihzdWJqZWN0UmVjdCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuY29vcmRBZGp1c3QgPSBkaWZmUG9pbnRzKHBvaW50LCBvcmlnUG9pbnQpOyAvLyBwb2ludCAtIG9yaWdQb2ludFxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHRoaXMub3JpZ0hpdCA9IG51bGw7XG5cdFx0XHR0aGlzLmNvb3JkQWRqdXN0ID0gbnVsbDtcblx0XHR9XG5cblx0XHQvLyBjYWxsIHRoZSBzdXBlci1tZXRob2QuIGRvIGl0IGFmdGVyIG9yaWdIaXQgaGFzIGJlZW4gY29tcHV0ZWRcblx0XHREcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZUludGVyYWN0aW9uU3RhcnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fSxcblxuXG5cdC8vIFJlY29tcHV0ZXMgdGhlIGRyYWctY3JpdGljYWwgcG9zaXRpb25zIG9mIGVsZW1lbnRzXG5cdGNvbXB1dGVDb29yZHM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuY29tcG9uZW50LnByZXBhcmVIaXRzKCk7XG5cdFx0dGhpcy5jb21wdXRlU2Nyb2xsQm91bmRzKCk7IC8vIHdoeSBpcyB0aGlzIGhlcmU/Pz8/Pz9cblx0fSxcblxuXG5cdC8vIENhbGxlZCB3aGVuIHRoZSBhY3R1YWwgZHJhZyBoYXMgc3RhcnRlZFxuXHRoYW5kbGVEcmFnU3RhcnQ6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0dmFyIGhpdDtcblxuXHRcdERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlRHJhZ1N0YXJ0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIGNhbGwgdGhlIHN1cGVyLW1ldGhvZFxuXG5cdFx0Ly8gbWlnaHQgYmUgZGlmZmVyZW50IGZyb20gdGhpcy5vcmlnSGl0IGlmIHRoZSBtaW4tZGlzdGFuY2UgaXMgbGFyZ2Vcblx0XHRoaXQgPSB0aGlzLnF1ZXJ5SGl0KGdldEV2WChldiksIGdldEV2WShldikpO1xuXG5cdFx0Ly8gcmVwb3J0IHRoZSBpbml0aWFsIGhpdCB0aGUgbW91c2UgaXMgb3ZlclxuXHRcdC8vIGVzcGVjaWFsbHkgaW1wb3J0YW50IGlmIG5vIG1pbi1kaXN0YW5jZSBhbmQgZHJhZyBzdGFydHMgaW1tZWRpYXRlbHlcblx0XHRpZiAoaGl0KSB7XG5cdFx0XHR0aGlzLmhhbmRsZUhpdE92ZXIoaGl0KTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBDYWxsZWQgd2hlbiB0aGUgZHJhZyBtb3Zlc1xuXHRoYW5kbGVEcmFnOiBmdW5jdGlvbihkeCwgZHksIGV2KSB7XG5cdFx0dmFyIGhpdDtcblxuXHRcdERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlRHJhZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBjYWxsIHRoZSBzdXBlci1tZXRob2RcblxuXHRcdGhpdCA9IHRoaXMucXVlcnlIaXQoZ2V0RXZYKGV2KSwgZ2V0RXZZKGV2KSk7XG5cblx0XHRpZiAoIWlzSGl0c0VxdWFsKGhpdCwgdGhpcy5oaXQpKSB7IC8vIGEgZGlmZmVyZW50IGhpdCB0aGFuIGJlZm9yZT9cblx0XHRcdGlmICh0aGlzLmhpdCkge1xuXHRcdFx0XHR0aGlzLmhhbmRsZUhpdE91dCgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGhpdCkge1xuXHRcdFx0XHR0aGlzLmhhbmRsZUhpdE92ZXIoaGl0KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblxuXHQvLyBDYWxsZWQgd2hlbiBkcmFnZ2luZyBoYXMgYmVlbiBzdG9wcGVkXG5cdGhhbmRsZURyYWdFbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaGFuZGxlSGl0RG9uZSgpO1xuXHRcdERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlRHJhZ0VuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBjYWxsIHRoZSBzdXBlci1tZXRob2Rcblx0fSxcblxuXG5cdC8vIENhbGxlZCB3aGVuIGEgdGhlIG1vdXNlIGhhcyBqdXN0IG1vdmVkIG92ZXIgYSBuZXcgaGl0XG5cdGhhbmRsZUhpdE92ZXI6IGZ1bmN0aW9uKGhpdCkge1xuXHRcdHZhciBpc09yaWcgPSBpc0hpdHNFcXVhbChoaXQsIHRoaXMub3JpZ0hpdCk7XG5cblx0XHR0aGlzLmhpdCA9IGhpdDtcblxuXHRcdHRoaXMudHJpZ2dlcignaGl0T3ZlcicsIHRoaXMuaGl0LCBpc09yaWcsIHRoaXMub3JpZ0hpdCk7XG5cdH0sXG5cblxuXHQvLyBDYWxsZWQgd2hlbiB0aGUgbW91c2UgaGFzIGp1c3QgbW92ZWQgb3V0IG9mIGEgaGl0XG5cdGhhbmRsZUhpdE91dDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuaGl0KSB7XG5cdFx0XHR0aGlzLnRyaWdnZXIoJ2hpdE91dCcsIHRoaXMuaGl0KTtcblx0XHRcdHRoaXMuaGFuZGxlSGl0RG9uZSgpO1xuXHRcdFx0dGhpcy5oaXQgPSBudWxsO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIENhbGxlZCBhZnRlciBhIGhpdE91dC4gQWxzbyBjYWxsZWQgYmVmb3JlIGEgZHJhZ1N0b3Bcblx0aGFuZGxlSGl0RG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuaGl0KSB7XG5cdFx0XHR0aGlzLnRyaWdnZXIoJ2hpdERvbmUnLCB0aGlzLmhpdCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gQ2FsbGVkIHdoZW4gdGhlIGludGVyYWN0aW9uIGVuZHMsIHdoZXRoZXIgdGhlcmUgd2FzIGEgcmVhbCBkcmFnIG9yIG5vdFxuXHRoYW5kbGVJbnRlcmFjdGlvbkVuZDogZnVuY3Rpb24oKSB7XG5cdFx0RHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVJbnRlcmFjdGlvbkVuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBjYWxsIHRoZSBzdXBlci1tZXRob2RcblxuXHRcdHRoaXMub3JpZ0hpdCA9IG51bGw7XG5cdFx0dGhpcy5oaXQgPSBudWxsO1xuXG5cdFx0dGhpcy5jb21wb25lbnQucmVsZWFzZUhpdHMoKTtcblx0fSxcblxuXG5cdC8vIENhbGxlZCB3aGVuIHNjcm9sbGluZyBoYXMgc3RvcHBlZCwgd2hldGhlciB0aHJvdWdoIGF1dG8gc2Nyb2xsLCBvciB0aGUgdXNlciBzY3JvbGxpbmdcblx0aGFuZGxlU2Nyb2xsRW5kOiBmdW5jdGlvbigpIHtcblx0XHREcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZVNjcm9sbEVuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBjYWxsIHRoZSBzdXBlci1tZXRob2RcblxuXHRcdHRoaXMuY29tcHV0ZUNvb3JkcygpOyAvLyBoaXRzJyBhYnNvbHV0ZSBwb3NpdGlvbnMgd2lsbCBiZSBpbiBuZXcgcGxhY2VzLiByZWNvbXB1dGVcblx0fSxcblxuXG5cdC8vIEdldHMgdGhlIGhpdCB1bmRlcm5lYXRoIHRoZSBjb29yZGluYXRlcyBmb3IgdGhlIGdpdmVuIG1vdXNlIGV2ZW50XG5cdHF1ZXJ5SGl0OiBmdW5jdGlvbihsZWZ0LCB0b3ApIHtcblxuXHRcdGlmICh0aGlzLmNvb3JkQWRqdXN0KSB7XG5cdFx0XHRsZWZ0ICs9IHRoaXMuY29vcmRBZGp1c3QubGVmdDtcblx0XHRcdHRvcCArPSB0aGlzLmNvb3JkQWRqdXN0LnRvcDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5jb21wb25lbnQucXVlcnlIaXQobGVmdCwgdG9wKTtcblx0fVxuXG59KTtcblxuXG4vLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgaGl0cyBhcmUgaWRlbnRpY2FsbHkgZXF1YWwuIGBmYWxzZWAgb3RoZXJ3aXNlLiBNdXN0IGJlIGZyb20gdGhlIHNhbWUgY29tcG9uZW50LlxuLy8gVHdvIG51bGwgdmFsdWVzIHdpbGwgYmUgY29uc2lkZXJlZCBlcXVhbCwgYXMgdHdvIFwib3V0IG9mIHRoZSBjb21wb25lbnRcIiBzdGF0ZXMgYXJlIHRoZSBzYW1lLlxuZnVuY3Rpb24gaXNIaXRzRXF1YWwoaGl0MCwgaGl0MSkge1xuXG5cdGlmICghaGl0MCAmJiAhaGl0MSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKGhpdDAgJiYgaGl0MSkge1xuXHRcdHJldHVybiBoaXQwLmNvbXBvbmVudCA9PT0gaGl0MS5jb21wb25lbnQgJiZcblx0XHRcdGlzSGl0UHJvcHNXaXRoaW4oaGl0MCwgaGl0MSkgJiZcblx0XHRcdGlzSGl0UHJvcHNXaXRoaW4oaGl0MSwgaGl0MCk7IC8vIGVuc3VyZXMgYWxsIHByb3BzIGFyZSBpZGVudGljYWxcblx0fVxuXG5cdHJldHVybiBmYWxzZTtcbn1cblxuXG4vLyBSZXR1cm5zIHRydWUgaWYgYWxsIG9mIHN1YkhpdCdzIG5vbi1zdGFuZGFyZCBwcm9wZXJ0aWVzIGFyZSB3aXRoaW4gc3VwZXJIaXRcbmZ1bmN0aW9uIGlzSGl0UHJvcHNXaXRoaW4oc3ViSGl0LCBzdXBlckhpdCkge1xuXHRmb3IgKHZhciBwcm9wTmFtZSBpbiBzdWJIaXQpIHtcblx0XHRpZiAoIS9eKGNvbXBvbmVudHxsZWZ0fHJpZ2h0fHRvcHxib3R0b20pJC8udGVzdChwcm9wTmFtZSkpIHtcblx0XHRcdGlmIChzdWJIaXRbcHJvcE5hbWVdICE9PSBzdXBlckhpdFtwcm9wTmFtZV0pIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuOztcblxuLyogQ3JlYXRlcyBhIGNsb25lIG9mIGFuIGVsZW1lbnQgYW5kIGxldHMgaXQgdHJhY2sgdGhlIG1vdXNlIGFzIGl0IG1vdmVzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxudmFyIE1vdXNlRm9sbG93ZXIgPSBDbGFzcy5leHRlbmQoTGlzdGVuZXJNaXhpbiwge1xuXG5cdG9wdGlvbnM6IG51bGwsXG5cblx0c291cmNlRWw6IG51bGwsIC8vIHRoZSBlbGVtZW50IHRoYXQgd2lsbCBiZSBjbG9uZWQgYW5kIG1hZGUgdG8gbG9vayBsaWtlIGl0IGlzIGRyYWdnaW5nXG5cdGVsOiBudWxsLCAvLyB0aGUgY2xvbmUgb2YgYHNvdXJjZUVsYCB0aGF0IHdpbGwgdHJhY2sgdGhlIG1vdXNlXG5cdHBhcmVudEVsOiBudWxsLCAvLyB0aGUgZWxlbWVudCB0aGF0IGBlbGAgKHRoZSBjbG9uZSkgd2lsbCBiZSBhdHRhY2hlZCB0b1xuXG5cdC8vIHRoZSBpbml0aWFsIHBvc2l0aW9uIG9mIGVsLCByZWxhdGl2ZSB0byB0aGUgb2Zmc2V0IHBhcmVudC4gbWFkZSB0byBtYXRjaCB0aGUgaW5pdGlhbCBvZmZzZXQgb2Ygc291cmNlRWxcblx0dG9wMDogbnVsbCxcblx0bGVmdDA6IG51bGwsXG5cblx0Ly8gdGhlIGFic29sdXRlIGNvb3JkaW5hdGVzIG9mIHRoZSBpbml0aWF0aW5nIHRvdWNoL21vdXNlIGFjdGlvblxuXHR5MDogbnVsbCxcblx0eDA6IG51bGwsXG5cblx0Ly8gdGhlIG51bWJlciBvZiBwaXhlbHMgdGhlIG1vdXNlIGhhcyBtb3ZlZCBmcm9tIGl0cyBpbml0aWFsIHBvc2l0aW9uXG5cdHRvcERlbHRhOiBudWxsLFxuXHRsZWZ0RGVsdGE6IG51bGwsXG5cblx0aXNGb2xsb3dpbmc6IGZhbHNlLFxuXHRpc0hpZGRlbjogZmFsc2UsXG5cdGlzQW5pbWF0aW5nOiBmYWxzZSwgLy8gZG9pbmcgdGhlIHJldmVydCBhbmltYXRpb24/XG5cblx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uKHNvdXJjZUVsLCBvcHRpb25zKSB7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0dGhpcy5zb3VyY2VFbCA9IHNvdXJjZUVsO1xuXHRcdHRoaXMucGFyZW50RWwgPSBvcHRpb25zLnBhcmVudEVsID8gJChvcHRpb25zLnBhcmVudEVsKSA6IHNvdXJjZUVsLnBhcmVudCgpOyAvLyBkZWZhdWx0IHRvIHNvdXJjZUVsJ3MgcGFyZW50XG5cdH0sXG5cblxuXHQvLyBDYXVzZXMgdGhlIGVsZW1lbnQgdG8gc3RhcnQgZm9sbG93aW5nIHRoZSBtb3VzZVxuXHRzdGFydDogZnVuY3Rpb24oZXYpIHtcblx0XHRpZiAoIXRoaXMuaXNGb2xsb3dpbmcpIHtcblx0XHRcdHRoaXMuaXNGb2xsb3dpbmcgPSB0cnVlO1xuXG5cdFx0XHR0aGlzLnkwID0gZ2V0RXZZKGV2KTtcblx0XHRcdHRoaXMueDAgPSBnZXRFdlgoZXYpO1xuXHRcdFx0dGhpcy50b3BEZWx0YSA9IDA7XG5cdFx0XHR0aGlzLmxlZnREZWx0YSA9IDA7XG5cblx0XHRcdGlmICghdGhpcy5pc0hpZGRlbikge1xuXHRcdFx0XHR0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChnZXRFdklzVG91Y2goZXYpKSB7XG5cdFx0XHRcdHRoaXMubGlzdGVuVG8oJChkb2N1bWVudCksICd0b3VjaG1vdmUnLCB0aGlzLmhhbmRsZU1vdmUpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHRoaXMubGlzdGVuVG8oJChkb2N1bWVudCksICdtb3VzZW1vdmUnLCB0aGlzLmhhbmRsZU1vdmUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXG5cdC8vIENhdXNlcyB0aGUgZWxlbWVudCB0byBzdG9wIGZvbGxvd2luZyB0aGUgbW91c2UuIElmIHNob3VsZFJldmVydCBpcyB0cnVlLCB3aWxsIGFuaW1hdGUgYmFjayB0byBvcmlnaW5hbCBwb3NpdGlvbi5cblx0Ly8gYGNhbGxiYWNrYCBnZXRzIGludm9rZWQgd2hlbiB0aGUgYW5pbWF0aW9uIGlzIGNvbXBsZXRlLiBJZiBubyBhbmltYXRpb24sIGl0IGlzIGludm9rZWQgaW1tZWRpYXRlbHkuXG5cdHN0b3A6IGZ1bmN0aW9uKHNob3VsZFJldmVydCwgY2FsbGJhY2spIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHZhciByZXZlcnREdXJhdGlvbiA9IHRoaXMub3B0aW9ucy5yZXZlcnREdXJhdGlvbjtcblxuXHRcdGZ1bmN0aW9uIGNvbXBsZXRlKCkgeyAvLyBtaWdodCBiZSBjYWxsZWQgYnkgLmFuaW1hdGUoKSwgd2hpY2ggbWlnaHQgY2hhbmdlIGB0aGlzYCBjb250ZXh0XG5cdFx0XHRfdGhpcy5pc0FuaW1hdGluZyA9IGZhbHNlO1xuXHRcdFx0X3RoaXMucmVtb3ZlRWxlbWVudCgpO1xuXG5cdFx0XHRfdGhpcy50b3AwID0gX3RoaXMubGVmdDAgPSBudWxsOyAvLyByZXNldCBzdGF0ZSBmb3IgZnV0dXJlIHVwZGF0ZVBvc2l0aW9uIGNhbGxzXG5cblx0XHRcdGlmIChjYWxsYmFjaykge1xuXHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0aGlzLmlzRm9sbG93aW5nICYmICF0aGlzLmlzQW5pbWF0aW5nKSB7IC8vIGRpc2FsbG93IG1vcmUgdGhhbiBvbmUgc3RvcCBhbmltYXRpb24gYXQgYSB0aW1lXG5cdFx0XHR0aGlzLmlzRm9sbG93aW5nID0gZmFsc2U7XG5cblx0XHRcdHRoaXMuc3RvcExpc3RlbmluZ1RvKCQoZG9jdW1lbnQpKTtcblxuXHRcdFx0aWYgKHNob3VsZFJldmVydCAmJiByZXZlcnREdXJhdGlvbiAmJiAhdGhpcy5pc0hpZGRlbikgeyAvLyBkbyBhIHJldmVydCBhbmltYXRpb24/XG5cdFx0XHRcdHRoaXMuaXNBbmltYXRpbmcgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLmVsLmFuaW1hdGUoe1xuXHRcdFx0XHRcdHRvcDogdGhpcy50b3AwLFxuXHRcdFx0XHRcdGxlZnQ6IHRoaXMubGVmdDBcblx0XHRcdFx0fSwge1xuXHRcdFx0XHRcdGR1cmF0aW9uOiByZXZlcnREdXJhdGlvbixcblx0XHRcdFx0XHRjb21wbGV0ZTogY29tcGxldGVcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Y29tcGxldGUoKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblxuXHQvLyBHZXRzIHRoZSB0cmFja2luZyBlbGVtZW50LiBDcmVhdGUgaXQgaWYgbmVjZXNzYXJ5XG5cdGdldEVsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWwgPSB0aGlzLmVsO1xuXG5cdFx0aWYgKCFlbCkge1xuXHRcdFx0ZWwgPSB0aGlzLmVsID0gdGhpcy5zb3VyY2VFbC5jbG9uZSgpXG5cdFx0XHRcdC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuYWRkaXRpb25hbENsYXNzIHx8ICcnKVxuXHRcdFx0XHQuY3NzKHtcblx0XHRcdFx0XHRwb3NpdGlvbjogJ2Fic29sdXRlJyxcblx0XHRcdFx0XHR2aXNpYmlsaXR5OiAnJywgLy8gaW4gY2FzZSBvcmlnaW5hbCBlbGVtZW50IHdhcyBoaWRkZW4gKGNvbW1vbmx5IHRocm91Z2ggaGlkZUV2ZW50cygpKVxuXHRcdFx0XHRcdGRpc3BsYXk6IHRoaXMuaXNIaWRkZW4gPyAnbm9uZScgOiAnJywgLy8gZm9yIHdoZW4gaW5pdGlhbGx5IGhpZGRlblxuXHRcdFx0XHRcdG1hcmdpbjogMCxcblx0XHRcdFx0XHRyaWdodDogJ2F1dG8nLCAvLyBlcmFzZSBhbmQgc2V0IHdpZHRoIGluc3RlYWRcblx0XHRcdFx0XHRib3R0b206ICdhdXRvJywgLy8gZXJhc2UgYW5kIHNldCBoZWlnaHQgaW5zdGVhZFxuXHRcdFx0XHRcdHdpZHRoOiB0aGlzLnNvdXJjZUVsLndpZHRoKCksIC8vIGV4cGxpY2l0IGhlaWdodCBpbiBjYXNlIHRoZXJlIHdhcyBhICdyaWdodCcgdmFsdWVcblx0XHRcdFx0XHRoZWlnaHQ6IHRoaXMuc291cmNlRWwuaGVpZ2h0KCksIC8vIGV4cGxpY2l0IHdpZHRoIGluIGNhc2UgdGhlcmUgd2FzIGEgJ2JvdHRvbScgdmFsdWVcblx0XHRcdFx0XHRvcGFjaXR5OiB0aGlzLm9wdGlvbnMub3BhY2l0eSB8fCAnJyxcblx0XHRcdFx0XHR6SW5kZXg6IHRoaXMub3B0aW9ucy56SW5kZXhcblx0XHRcdFx0fSk7XG5cblx0XHRcdC8vIHdlIGRvbid0IHdhbnQgbG9uZyB0YXBzIG9yIGFueSBtb3VzZSBpbnRlcmFjdGlvbiBjYXVzaW5nIHNlbGVjdGlvbi9tZW51cy5cblx0XHRcdC8vIHdvdWxkIHVzZSBwcmV2ZW50U2VsZWN0aW9uKCksIGJ1dCB0aGF0IHByZXZlbnRzIHNlbGVjdHN0YXJ0LCBjYXVzaW5nIHByb2JsZW1zLlxuXHRcdFx0ZWwuYWRkQ2xhc3MoJ2ZjLXVuc2VsZWN0YWJsZScpO1xuXG5cdFx0XHRlbC5hcHBlbmRUbyh0aGlzLnBhcmVudEVsKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZWw7XG5cdH0sXG5cblxuXHQvLyBSZW1vdmVzIHRoZSB0cmFja2luZyBlbGVtZW50IGlmIGl0IGhhcyBhbHJlYWR5IGJlZW4gY3JlYXRlZFxuXHRyZW1vdmVFbGVtZW50OiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5lbCkge1xuXHRcdFx0dGhpcy5lbC5yZW1vdmUoKTtcblx0XHRcdHRoaXMuZWwgPSBudWxsO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIFVwZGF0ZSB0aGUgQ1NTIHBvc2l0aW9uIG9mIHRoZSB0cmFja2luZyBlbGVtZW50XG5cdHVwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc291cmNlT2Zmc2V0O1xuXHRcdHZhciBvcmlnaW47XG5cblx0XHR0aGlzLmdldEVsKCk7IC8vIGVuc3VyZSB0aGlzLmVsXG5cblx0XHQvLyBtYWtlIHN1cmUgb3JpZ2luIGluZm8gd2FzIGNvbXB1dGVkXG5cdFx0aWYgKHRoaXMudG9wMCA9PT0gbnVsbCkge1xuXHRcdFx0c291cmNlT2Zmc2V0ID0gdGhpcy5zb3VyY2VFbC5vZmZzZXQoKTtcblx0XHRcdG9yaWdpbiA9IHRoaXMuZWwub2Zmc2V0UGFyZW50KCkub2Zmc2V0KCk7XG5cdFx0XHR0aGlzLnRvcDAgPSBzb3VyY2VPZmZzZXQudG9wIC0gb3JpZ2luLnRvcDtcblx0XHRcdHRoaXMubGVmdDAgPSBzb3VyY2VPZmZzZXQubGVmdCAtIG9yaWdpbi5sZWZ0O1xuXHRcdH1cblxuXHRcdHRoaXMuZWwuY3NzKHtcblx0XHRcdHRvcDogdGhpcy50b3AwICsgdGhpcy50b3BEZWx0YSxcblx0XHRcdGxlZnQ6IHRoaXMubGVmdDAgKyB0aGlzLmxlZnREZWx0YVxuXHRcdH0pO1xuXHR9LFxuXG5cblx0Ly8gR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBtb3ZlcyB0aGUgbW91c2Vcblx0aGFuZGxlTW92ZTogZnVuY3Rpb24oZXYpIHtcblx0XHR0aGlzLnRvcERlbHRhID0gZ2V0RXZZKGV2KSAtIHRoaXMueTA7XG5cdFx0dGhpcy5sZWZ0RGVsdGEgPSBnZXRFdlgoZXYpIC0gdGhpcy54MDtcblxuXHRcdGlmICghdGhpcy5pc0hpZGRlbikge1xuXHRcdFx0dGhpcy51cGRhdGVQb3NpdGlvbigpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIFRlbXBvcmFyaWx5IG1ha2VzIHRoZSB0cmFja2luZyBlbGVtZW50IGludmlzaWJsZS4gQ2FuIGJlIGNhbGxlZCBiZWZvcmUgZm9sbG93aW5nIHN0YXJ0c1xuXHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuaXNIaWRkZW4pIHtcblx0XHRcdHRoaXMuaXNIaWRkZW4gPSB0cnVlO1xuXHRcdFx0aWYgKHRoaXMuZWwpIHtcblx0XHRcdFx0dGhpcy5lbC5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gU2hvdyB0aGUgdHJhY2tpbmcgZWxlbWVudCBhZnRlciBpdCBoYXMgYmVlbiB0ZW1wb3JhcmlseSBoaWRkZW5cblx0c2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuaXNIaWRkZW4pIHtcblx0XHRcdHRoaXMuaXNIaWRkZW4gPSBmYWxzZTtcblx0XHRcdHRoaXMudXBkYXRlUG9zaXRpb24oKTtcblx0XHRcdHRoaXMuZ2V0RWwoKS5zaG93KCk7XG5cdFx0fVxuXHR9XG5cbn0pO1xuXG47O1xuXG4vKiBBbiBhYnN0cmFjdCBjbGFzcyBjb21wcmlzZWQgb2YgYSBcImdyaWRcIiBvZiBhcmVhcyB0aGF0IGVhY2ggcmVwcmVzZW50IGEgc3BlY2lmaWMgZGF0ZXRpbWVcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG52YXIgR3JpZCA9IEZDLkdyaWQgPSBDbGFzcy5leHRlbmQoTGlzdGVuZXJNaXhpbiwgTW91c2VJZ25vcmVyTWl4aW4sIHtcblxuXHQvLyBzZWxmLWNvbmZpZywgb3ZlcnJpZGFibGUgYnkgc3ViY2xhc3Nlc1xuXHRoYXNEYXlJbnRlcmFjdGlvbnM6IHRydWUsIC8vIGNhbiB1c2VyIGNsaWNrL3NlbGVjdCByYW5nZXMgb2YgdGltZT9cblxuXHR2aWV3OiBudWxsLCAvLyBhIFZpZXcgb2JqZWN0XG5cdGlzUlRMOiBudWxsLCAvLyBzaG9ydGN1dCB0byB0aGUgdmlldydzIGlzUlRMIG9wdGlvblxuXG5cdHN0YXJ0OiBudWxsLFxuXHRlbmQ6IG51bGwsXG5cblx0ZWw6IG51bGwsIC8vIHRoZSBjb250YWluaW5nIGVsZW1lbnRcblx0ZWxzQnlGaWxsOiBudWxsLCAvLyBhIGhhc2ggb2YgalF1ZXJ5IGVsZW1lbnQgc2V0cyB1c2VkIGZvciByZW5kZXJpbmcgZWFjaCBmaWxsLiBLZXllZCBieSBmaWxsIG5hbWUuXG5cblx0Ly8gZGVyaXZlZCBmcm9tIG9wdGlvbnNcblx0ZXZlbnRUaW1lRm9ybWF0OiBudWxsLFxuXHRkaXNwbGF5RXZlbnRUaW1lOiBudWxsLFxuXHRkaXNwbGF5RXZlbnRFbmQ6IG51bGwsXG5cblx0bWluUmVzaXplRHVyYXRpb246IG51bGwsIC8vIFRPRE86IGhhY2suIHNldCBieSBzdWJjbGFzc2VzLiBtaW51bXVtIGV2ZW50IHJlc2l6ZSBkdXJhdGlvblxuXG5cdC8vIGlmIGRlZmluZWQsIGhvbGRzIHRoZSB1bml0IGlkZW50aWZpZWQgKGV4OiBcInllYXJcIiBvciBcIm1vbnRoXCIpIHRoYXQgZGV0ZXJtaW5lcyB0aGUgbGV2ZWwgb2YgZ3JhbnVsYXJpdHlcblx0Ly8gb2YgdGhlIGRhdGUgYXJlYXMuIGlmIG5vdCBkZWZpbmVkLCBhc3N1bWVzIHRvIGJlIGRheSBhbmQgdGltZSBncmFudWxhcml0eS5cblx0Ly8gVE9ETzogcG9ydCBpc1RpbWVTY2FsZSBpbnRvIHNhbWUgc3lzdGVtP1xuXHRsYXJnZVVuaXQ6IG51bGwsXG5cblx0ZGF5RHJhZ0xpc3RlbmVyOiBudWxsLFxuXHRzZWdEcmFnTGlzdGVuZXI6IG51bGwsXG5cdHNlZ1Jlc2l6ZUxpc3RlbmVyOiBudWxsLFxuXHRleHRlcm5hbERyYWdMaXN0ZW5lcjogbnVsbCxcblxuXG5cdGNvbnN0cnVjdG9yOiBmdW5jdGlvbih2aWV3KSB7XG5cdFx0dGhpcy52aWV3ID0gdmlldztcblx0XHR0aGlzLmlzUlRMID0gdmlldy5vcHQoJ2lzUlRMJyk7XG5cdFx0dGhpcy5lbHNCeUZpbGwgPSB7fTtcblxuXHRcdHRoaXMuZGF5RHJhZ0xpc3RlbmVyID0gdGhpcy5idWlsZERheURyYWdMaXN0ZW5lcigpO1xuXHRcdHRoaXMuaW5pdE1vdXNlSWdub3JpbmcoKTtcblx0fSxcblxuXG5cdC8qIE9wdGlvbnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIEdlbmVyYXRlcyB0aGUgZm9ybWF0IHN0cmluZyB1c2VkIGZvciBldmVudCB0aW1lIHRleHQsIGlmIG5vdCBleHBsaWNpdGx5IGRlZmluZWQgYnkgJ3RpbWVGb3JtYXQnXG5cdGNvbXB1dGVFdmVudFRpbWVGb3JtYXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnZpZXcub3B0KCdzbWFsbFRpbWVGb3JtYXQnKTtcblx0fSxcblxuXG5cdC8vIERldGVybWluZXMgd2hldGhlciBldmVudHMgc2hvdWxkIGhhdmUgdGhlaXIgZW5kIHRpbWVzIGRpc3BsYXllZCwgaWYgbm90IGV4cGxpY2l0bHkgZGVmaW5lZCBieSAnZGlzcGxheUV2ZW50VGltZScuXG5cdC8vIE9ubHkgYXBwbGllcyB0byBub24tYWxsLWRheSBldmVudHMuXG5cdGNvbXB1dGVEaXNwbGF5RXZlbnRUaW1lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXG5cdC8vIERldGVybWluZXMgd2hldGhlciBldmVudHMgc2hvdWxkIGhhdmUgdGhlaXIgZW5kIHRpbWVzIGRpc3BsYXllZCwgaWYgbm90IGV4cGxpY2l0bHkgZGVmaW5lZCBieSAnZGlzcGxheUV2ZW50RW5kJ1xuXHRjb21wdXRlRGlzcGxheUV2ZW50RW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXG5cdC8qIERhdGVzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBUZWxscyB0aGUgZ3JpZCBhYm91dCB3aGF0IHBlcmlvZCBvZiB0aW1lIHRvIGRpc3BsYXkuXG5cdC8vIEFueSBkYXRlLXJlbGF0ZWQgaW50ZXJuYWwgZGF0YSBzaG91bGQgYmUgZ2VuZXJhdGVkLlxuXHRzZXRSYW5nZTogZnVuY3Rpb24ocmFuZ2UpIHtcblx0XHR0aGlzLnN0YXJ0ID0gcmFuZ2Uuc3RhcnQuY2xvbmUoKTtcblx0XHR0aGlzLmVuZCA9IHJhbmdlLmVuZC5jbG9uZSgpO1xuXG5cdFx0dGhpcy5yYW5nZVVwZGF0ZWQoKTtcblx0XHR0aGlzLnByb2Nlc3NSYW5nZU9wdGlvbnMoKTtcblx0fSxcblxuXG5cdC8vIENhbGxlZCB3aGVuIGludGVybmFsIHZhcmlhYmxlcyB0aGF0IHJlbHkgb24gdGhlIHJhbmdlIHNob3VsZCBiZSB1cGRhdGVkXG5cdHJhbmdlVXBkYXRlZDogZnVuY3Rpb24oKSB7XG5cdH0sXG5cblxuXHQvLyBVcGRhdGVzIHZhbHVlcyB0aGF0IHJlbHkgb24gb3B0aW9ucyBhbmQgYWxzbyByZWxhdGUgdG8gcmFuZ2Vcblx0cHJvY2Vzc1JhbmdlT3B0aW9uczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIGRpc3BsYXlFdmVudFRpbWU7XG5cdFx0dmFyIGRpc3BsYXlFdmVudEVuZDtcblxuXHRcdHRoaXMuZXZlbnRUaW1lRm9ybWF0ID1cblx0XHRcdHZpZXcub3B0KCdldmVudFRpbWVGb3JtYXQnKSB8fFxuXHRcdFx0dmlldy5vcHQoJ3RpbWVGb3JtYXQnKSB8fCAvLyBkZXByZWNhdGVkXG5cdFx0XHR0aGlzLmNvbXB1dGVFdmVudFRpbWVGb3JtYXQoKTtcblxuXHRcdGRpc3BsYXlFdmVudFRpbWUgPSB2aWV3Lm9wdCgnZGlzcGxheUV2ZW50VGltZScpO1xuXHRcdGlmIChkaXNwbGF5RXZlbnRUaW1lID09IG51bGwpIHtcblx0XHRcdGRpc3BsYXlFdmVudFRpbWUgPSB0aGlzLmNvbXB1dGVEaXNwbGF5RXZlbnRUaW1lKCk7IC8vIG1pZ2h0IGJlIGJhc2VkIG9mZiBvZiByYW5nZVxuXHRcdH1cblxuXHRcdGRpc3BsYXlFdmVudEVuZCA9IHZpZXcub3B0KCdkaXNwbGF5RXZlbnRFbmQnKTtcblx0XHRpZiAoZGlzcGxheUV2ZW50RW5kID09IG51bGwpIHtcblx0XHRcdGRpc3BsYXlFdmVudEVuZCA9IHRoaXMuY29tcHV0ZURpc3BsYXlFdmVudEVuZCgpOyAvLyBtaWdodCBiZSBiYXNlZCBvZmYgb2YgcmFuZ2Vcblx0XHR9XG5cblx0XHR0aGlzLmRpc3BsYXlFdmVudFRpbWUgPSBkaXNwbGF5RXZlbnRUaW1lO1xuXHRcdHRoaXMuZGlzcGxheUV2ZW50RW5kID0gZGlzcGxheUV2ZW50RW5kO1xuXHR9LFxuXG5cblx0Ly8gQ29udmVydHMgYSBzcGFuIChoYXMgdW56b25lZCBzdGFydC9lbmQgYW5kIGFueSBvdGhlciBncmlkLXNwZWNpZmljIGxvY2F0aW9uIGluZm9ybWF0aW9uKVxuXHQvLyBpbnRvIGFuIGFycmF5IG9mIHNlZ21lbnRzIChwaWVjZXMgb2YgZXZlbnRzIHdob3NlIGZvcm1hdCBpcyBkZWNpZGVkIGJ5IHRoZSBncmlkKS5cblx0c3BhblRvU2VnczogZnVuY3Rpb24oc3Bhbikge1xuXHRcdC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8vIERpZmZzIHRoZSB0d28gZGF0ZXMsIHJldHVybmluZyBhIGR1cmF0aW9uLCBiYXNlZCBvbiBncmFudWxhcml0eSBvZiB0aGUgZ3JpZFxuXHQvLyBUT0RPOiBwb3J0IGlzVGltZVNjYWxlIGludG8gdGhpcyBzeXN0ZW0/XG5cdGRpZmZEYXRlczogZnVuY3Rpb24oYSwgYikge1xuXHRcdGlmICh0aGlzLmxhcmdlVW5pdCkge1xuXHRcdFx0cmV0dXJuIGRpZmZCeVVuaXQoYSwgYiwgdGhpcy5sYXJnZVVuaXQpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHJldHVybiBkaWZmRGF5VGltZShhLCBiKTtcblx0XHR9XG5cdH0sXG5cblxuXHQvKiBIaXQgQXJlYVxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gQ2FsbGVkIGJlZm9yZSBvbmUgb3IgbW9yZSBxdWVyeUhpdCBjYWxscyBtaWdodCBoYXBwZW4uIFNob3VsZCBwcmVwYXJlIGFueSBjYWNoZWQgY29vcmRpbmF0ZXMgZm9yIHF1ZXJ5SGl0XG5cdHByZXBhcmVIaXRzOiBmdW5jdGlvbigpIHtcblx0fSxcblxuXG5cdC8vIENhbGxlZCB3aGVuIHF1ZXJ5SGl0IGNhbGxzIGhhdmUgc3Vic2lkZWQuIEdvb2QgcGxhY2UgdG8gY2xlYXIgYW55IGNvb3JkaW5hdGUgY2FjaGVzLlxuXHRyZWxlYXNlSGl0czogZnVuY3Rpb24oKSB7XG5cdH0sXG5cblxuXHQvLyBHaXZlbiBjb29yZGluYXRlcyBmcm9tIHRoZSB0b3BsZWZ0IG9mIHRoZSBkb2N1bWVudCwgcmV0dXJuIGRhdGEgYWJvdXQgdGhlIGRhdGUtcmVsYXRlZCBhcmVhIHVuZGVybmVhdGguXG5cdC8vIENhbiByZXR1cm4gYW4gb2JqZWN0IHdpdGggYXJiaXRyYXJ5IHByb3BlcnRpZXMgKGFsdGhvdWdoIHRvcC9yaWdodC9sZWZ0L2JvdHRvbSBhcmUgZW5jb3VyYWdlZCkuXG5cdC8vIE11c3QgaGF2ZSBhIGBncmlkYCBwcm9wZXJ0eSwgYSByZWZlcmVuY2UgdG8gdGhpcyBjdXJyZW50IGdyaWQuIFRPRE86IGF2b2lkIHRoaXNcblx0Ly8gVGhlIHJldHVybmVkIG9iamVjdCB3aWxsIGJlIHByb2Nlc3NlZCBieSBnZXRIaXRTcGFuIGFuZCBnZXRIaXRFbC5cblx0cXVlcnlIaXQ6IGZ1bmN0aW9uKGxlZnRPZmZzZXQsIHRvcE9mZnNldCkge1xuXHR9LFxuXG5cblx0Ly8gR2l2ZW4gcG9zaXRpb24tbGV2ZWwgaW5mb3JtYXRpb24gYWJvdXQgYSBkYXRlLXJlbGF0ZWQgYXJlYSB3aXRoaW4gdGhlIGdyaWQsXG5cdC8vIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0IHdpdGggYXQgbGVhc3QgYSBzdGFydC9lbmQgZGF0ZS4gQ2FuIHByb3ZpZGUgb3RoZXIgaW5mb3JtYXRpb24gYXMgd2VsbC5cblx0Z2V0SGl0U3BhbjogZnVuY3Rpb24oaGl0KSB7XG5cdH0sXG5cblxuXHQvLyBHaXZlbiBwb3NpdGlvbi1sZXZlbCBpbmZvcm1hdGlvbiBhYm91dCBhIGRhdGUtcmVsYXRlZCBhcmVhIHdpdGhpbiB0aGUgZ3JpZCxcblx0Ly8gc2hvdWxkIHJldHVybiBhIGpRdWVyeSBlbGVtZW50IHRoYXQgYmVzdCByZXByZXNlbnRzIGl0LiBwYXNzZWQgdG8gZGF5Q2xpY2sgY2FsbGJhY2suXG5cdGdldEhpdEVsOiBmdW5jdGlvbihoaXQpIHtcblx0fSxcblxuXG5cdC8qIFJlbmRlcmluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gU2V0cyB0aGUgY29udGFpbmVyIGVsZW1lbnQgdGhhdCB0aGUgZ3JpZCBzaG91bGQgcmVuZGVyIGluc2lkZSBvZi5cblx0Ly8gRG9lcyBvdGhlciBET00tcmVsYXRlZCBpbml0aWFsaXphdGlvbnMuXG5cdHNldEVsZW1lbnQ6IGZ1bmN0aW9uKGVsKSB7XG5cdFx0dGhpcy5lbCA9IGVsO1xuXG5cdFx0aWYgKHRoaXMuaGFzRGF5SW50ZXJhY3Rpb25zKSB7XG5cdFx0XHRwcmV2ZW50U2VsZWN0aW9uKGVsKTtcblxuXHRcdFx0dGhpcy5iaW5kRGF5SGFuZGxlcigndG91Y2hzdGFydCcsIHRoaXMuZGF5VG91Y2hTdGFydCk7XG5cdFx0XHR0aGlzLmJpbmREYXlIYW5kbGVyKCdtb3VzZWRvd24nLCB0aGlzLmRheU1vdXNlZG93bik7XG5cdFx0fVxuXG5cdFx0Ly8gYXR0YWNoIGV2ZW50LWVsZW1lbnQtcmVsYXRlZCBoYW5kbGVycy4gaW4gR3JpZC5ldmVudHNcblx0XHQvLyBzYW1lIGdhcmJhZ2UgY29sbGVjdGlvbiBub3RlIGFzIGFib3ZlLlxuXHRcdHRoaXMuYmluZFNlZ0hhbmRsZXJzKCk7XG5cblx0XHR0aGlzLmJpbmRHbG9iYWxIYW5kbGVycygpO1xuXHR9LFxuXG5cblx0YmluZERheUhhbmRsZXI6IGZ1bmN0aW9uKG5hbWUsIGhhbmRsZXIpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG5cdFx0Ly8gYXR0YWNoIGEgaGFuZGxlciB0byB0aGUgZ3JpZCdzIHJvb3QgZWxlbWVudC5cblx0XHQvLyBqUXVlcnkgd2lsbCB0YWtlIGNhcmUgb2YgdW5yZWdpc3RlcmluZyB0aGVtIHdoZW4gcmVtb3ZlRWxlbWVudCBnZXRzIGNhbGxlZC5cblx0XHR0aGlzLmVsLm9uKG5hbWUsIGZ1bmN0aW9uKGV2KSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdCEkKGV2LnRhcmdldCkuaXMoXG5cdFx0XHRcdFx0X3RoaXMuc2VnU2VsZWN0b3IgKyAnLCcgKyAvLyBkaXJlY3RseSBvbiBhbiBldmVudCBlbGVtZW50XG5cdFx0XHRcdFx0X3RoaXMuc2VnU2VsZWN0b3IgKyAnICosJyArIC8vIHdpdGhpbiBhbiBldmVudCBlbGVtZW50XG5cdFx0XHRcdFx0Jy5mYy1tb3JlLCcgKyAvLyBhIFwibW9yZS4uXCIgbGlua1xuXHRcdFx0XHRcdCdhW2RhdGEtZ290b10nIC8vIGEgY2xpY2thYmxlIG5hdiBsaW5rXG5cdFx0XHRcdClcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm4gaGFuZGxlci5jYWxsKF90aGlzLCBldik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblxuXHQvLyBSZW1vdmVzIHRoZSBncmlkJ3MgY29udGFpbmVyIGVsZW1lbnQgZnJvbSB0aGUgRE9NLiBVbmRvZXMgYW55IG90aGVyIERPTS1yZWxhdGVkIGF0dGFjaG1lbnRzLlxuXHQvLyBET0VTIE5PVCByZW1vdmUgYW55IGNvbnRlbnQgYmVmb3JlaGFuZCAoZG9lc24ndCBjbGVhciBldmVudHMgb3IgY2FsbCB1bnJlbmRlckRhdGVzKSwgdW5saWtlIFZpZXdcblx0cmVtb3ZlRWxlbWVudDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51bmJpbmRHbG9iYWxIYW5kbGVycygpO1xuXHRcdHRoaXMuY2xlYXJEcmFnTGlzdGVuZXJzKCk7XG5cblx0XHR0aGlzLmVsLnJlbW92ZSgpO1xuXG5cdFx0Ly8gTk9URTogd2UgZG9uJ3QgbnVsbC1vdXQgdGhpcy5lbCBmb3IgdGhlIHNhbWUgcmVhc29ucyB3ZSBkb24ndCBkbyBpdCB3aXRoaW4gVmlldzo6cmVtb3ZlRWxlbWVudFxuXHR9LFxuXG5cblx0Ly8gUmVuZGVycyB0aGUgYmFzaWMgc3RydWN0dXJlIG9mIGdyaWQgdmlldyBiZWZvcmUgYW55IGNvbnRlbnQgaXMgcmVuZGVyZWRcblx0cmVuZGVyU2tlbGV0b246IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxuXHR9LFxuXG5cblx0Ly8gUmVuZGVycyB0aGUgZ3JpZCdzIGRhdGUtcmVsYXRlZCBjb250ZW50IChsaWtlIGFyZWFzIHRoYXQgcmVwcmVzZW50IGRheXMvdGltZXMpLlxuXHQvLyBBc3N1bWVzIHNldFJhbmdlIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkIGFuZCB0aGUgc2tlbGV0b24gaGFzIGFscmVhZHkgYmVlbiByZW5kZXJlZC5cblx0cmVuZGVyRGF0ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxuXHR9LFxuXG5cblx0Ly8gVW5yZW5kZXJzIHRoZSBncmlkJ3MgZGF0ZS1yZWxhdGVkIGNvbnRlbnRcblx0dW5yZW5kZXJEYXRlczogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gc3ViY2xhc3NlcyBzaG91bGQgaW1wbGVtZW50XG5cdH0sXG5cblxuXHQvKiBIYW5kbGVyc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gQmluZHMgRE9NIGhhbmRsZXJzIHRvIGVsZW1lbnRzIHRoYXQgcmVzaWRlIG91dHNpZGUgdGhlIGdyaWQsIHN1Y2ggYXMgdGhlIGRvY3VtZW50XG5cdGJpbmRHbG9iYWxIYW5kbGVyczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5saXN0ZW5UbygkKGRvY3VtZW50KSwge1xuXHRcdFx0ZHJhZ3N0YXJ0OiB0aGlzLmV4dGVybmFsRHJhZ1N0YXJ0LCAvLyBqcXVpXG5cdFx0XHRzb3J0c3RhcnQ6IHRoaXMuZXh0ZXJuYWxEcmFnU3RhcnQgLy8ganF1aVxuXHRcdH0pO1xuXHR9LFxuXG5cblx0Ly8gVW5iaW5kcyBET00gaGFuZGxlcnMgZnJvbSBlbGVtZW50cyB0aGF0IHJlc2lkZSBvdXRzaWRlIHRoZSBncmlkXG5cdHVuYmluZEdsb2JhbEhhbmRsZXJzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnN0b3BMaXN0ZW5pbmdUbygkKGRvY3VtZW50KSk7XG5cdH0sXG5cblxuXHQvLyBQcm9jZXNzIGEgbW91c2Vkb3duIG9uIGFuIGVsZW1lbnQgdGhhdCByZXByZXNlbnRzIGEgZGF5LiBGb3IgZGF5IGNsaWNraW5nIGFuZCBzZWxlY3RpbmcuXG5cdGRheU1vdXNlZG93bjogZnVuY3Rpb24oZXYpIHtcblx0XHRpZiAoIXRoaXMuaXNJZ25vcmluZ01vdXNlKSB7XG5cdFx0XHR0aGlzLmRheURyYWdMaXN0ZW5lci5zdGFydEludGVyYWN0aW9uKGV2LCB7XG5cdFx0XHRcdC8vZGlzdGFuY2U6IDUsIC8vIG5lZWRzIG1vcmUgd29yayBpZiB3ZSB3YW50IGRheUNsaWNrIHRvIGZpcmUgY29ycmVjdGx5XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblxuXHRkYXlUb3VjaFN0YXJ0OiBmdW5jdGlvbihldikge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXG5cdFx0Ly8gSEFDSyB0byBwcmV2ZW50IGEgdXNlcidzIGNsaWNrYXdheSBmb3IgdW5zZWxlY3RpbmcgYSByYW5nZSBvciBhbiBldmVudFxuXHRcdC8vIGZyb20gY2F1c2luZyBhIGRheUNsaWNrLlxuXHRcdGlmICh2aWV3LmlzU2VsZWN0ZWQgfHwgdmlldy5zZWxlY3RlZEV2ZW50KSB7XG5cdFx0XHR0aGlzLnRlbXBJZ25vcmVNb3VzZSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuZGF5RHJhZ0xpc3RlbmVyLnN0YXJ0SW50ZXJhY3Rpb24oZXYsIHtcblx0XHRcdGRlbGF5OiB0aGlzLnZpZXcub3B0KCdsb25nUHJlc3NEZWxheScpXG5cdFx0fSk7XG5cdH0sXG5cblxuXHQvLyBDcmVhdGVzIGEgbGlzdGVuZXIgdGhhdCB0cmFja3MgdGhlIHVzZXIncyBkcmFnIGFjcm9zcyBkYXkgZWxlbWVudHMuXG5cdC8vIEZvciBkYXkgY2xpY2tpbmcgYW5kIHNlbGVjdGluZy5cblx0YnVpbGREYXlEcmFnTGlzdGVuZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIGlzU2VsZWN0YWJsZSA9IHZpZXcub3B0KCdzZWxlY3RhYmxlJyk7XG5cdFx0dmFyIGRheUNsaWNrSGl0OyAvLyBudWxsIGlmIGludmFsaWQgZGF5Q2xpY2tcblx0XHR2YXIgc2VsZWN0aW9uU3BhbjsgLy8gbnVsbCBpZiBpbnZhbGlkIHNlbGVjdGlvblxuXG5cdFx0Ly8gdGhpcyBsaXN0ZW5lciB0cmFja3MgYSBtb3VzZWRvd24gb24gYSBkYXkgZWxlbWVudCwgYW5kIGEgc3Vic2VxdWVudCBkcmFnLlxuXHRcdC8vIGlmIHRoZSBkcmFnIGVuZHMgb24gdGhlIHNhbWUgZGF5LCBpdCBpcyBhICdkYXlDbGljaycuXG5cdFx0Ly8gaWYgJ3NlbGVjdGFibGUnIGlzIGVuYWJsZWQsIHRoaXMgbGlzdGVuZXIgYWxzbyBkZXRlY3RzIHNlbGVjdGlvbnMuXG5cdFx0dmFyIGRyYWdMaXN0ZW5lciA9IG5ldyBIaXREcmFnTGlzdGVuZXIodGhpcywge1xuXHRcdFx0c2Nyb2xsOiB2aWV3Lm9wdCgnZHJhZ1Njcm9sbCcpLFxuXHRcdFx0aW50ZXJhY3Rpb25TdGFydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRheUNsaWNrSGl0ID0gZHJhZ0xpc3RlbmVyLm9yaWdIaXQ7IC8vIGZvciBkYXlDbGljaywgd2hlcmUgbm8gZHJhZ2dpbmcgaGFwcGVuc1xuXHRcdFx0XHRzZWxlY3Rpb25TcGFuID0gbnVsbDtcblx0XHRcdH0sXG5cdFx0XHRkcmFnU3RhcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2aWV3LnVuc2VsZWN0KCk7IC8vIHNpbmNlIHdlIGNvdWxkIGJlIHJlbmRlcmluZyBhIG5ldyBzZWxlY3Rpb24sIHdlIHdhbnQgdG8gY2xlYXIgYW55IG9sZCBvbmVcblx0XHRcdH0sXG5cdFx0XHRoaXRPdmVyOiBmdW5jdGlvbihoaXQsIGlzT3JpZywgb3JpZ0hpdCkge1xuXHRcdFx0XHRpZiAob3JpZ0hpdCkgeyAvLyBjbGljayBuZWVkcyB0byBoYXZlIHN0YXJ0ZWQgb24gYSBoaXRcblxuXHRcdFx0XHRcdC8vIGlmIHVzZXIgZHJhZ2dlZCB0byBhbm90aGVyIGNlbGwgYXQgYW55IHBvaW50LCBpdCBjYW4gbm8gbG9uZ2VyIGJlIGEgZGF5Q2xpY2tcblx0XHRcdFx0XHRpZiAoIWlzT3JpZykge1xuXHRcdFx0XHRcdFx0ZGF5Q2xpY2tIaXQgPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChpc1NlbGVjdGFibGUpIHtcblx0XHRcdFx0XHRcdHNlbGVjdGlvblNwYW4gPSBfdGhpcy5jb21wdXRlU2VsZWN0aW9uKFxuXHRcdFx0XHRcdFx0XHRfdGhpcy5nZXRIaXRTcGFuKG9yaWdIaXQpLFxuXHRcdFx0XHRcdFx0XHRfdGhpcy5nZXRIaXRTcGFuKGhpdClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRpZiAoc2VsZWN0aW9uU3Bhbikge1xuXHRcdFx0XHRcdFx0XHRfdGhpcy5yZW5kZXJTZWxlY3Rpb24oc2VsZWN0aW9uU3Bhbik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIGlmIChzZWxlY3Rpb25TcGFuID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0XHRkaXNhYmxlQ3Vyc29yKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0aGl0T3V0OiBmdW5jdGlvbigpIHsgLy8gY2FsbGVkIGJlZm9yZSBtb3VzZSBtb3ZlcyB0byBhIGRpZmZlcmVudCBoaXQgT1IgbW92ZWQgb3V0IG9mIGFsbCBoaXRzXG5cdFx0XHRcdGRheUNsaWNrSGl0ID0gbnVsbDtcblx0XHRcdFx0c2VsZWN0aW9uU3BhbiA9IG51bGw7XG5cdFx0XHRcdF90aGlzLnVucmVuZGVyU2VsZWN0aW9uKCk7XG5cdFx0XHR9LFxuXHRcdFx0aGl0RG9uZTogZnVuY3Rpb24oKSB7IC8vIGNhbGxlZCBhZnRlciBhIGhpdE91dCBPUiBiZWZvcmUgYSBkcmFnRW5kXG5cdFx0XHRcdGVuYWJsZUN1cnNvcigpO1xuXHRcdFx0fSxcblx0XHRcdGludGVyYWN0aW9uRW5kOiBmdW5jdGlvbihldiwgaXNDYW5jZWxsZWQpIHtcblx0XHRcdFx0aWYgKCFpc0NhbmNlbGxlZCkge1xuXHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdGRheUNsaWNrSGl0ICYmXG5cdFx0XHRcdFx0XHQhX3RoaXMuaXNJZ25vcmluZ01vdXNlIC8vIHNlZSBoYWNrIGluIGRheVRvdWNoU3RhcnRcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdHZpZXcudHJpZ2dlckRheUNsaWNrKFxuXHRcdFx0XHRcdFx0XHRfdGhpcy5nZXRIaXRTcGFuKGRheUNsaWNrSGl0KSxcblx0XHRcdFx0XHRcdFx0X3RoaXMuZ2V0SGl0RWwoZGF5Q2xpY2tIaXQpLFxuXHRcdFx0XHRcdFx0XHRldlxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHNlbGVjdGlvblNwYW4pIHtcblx0XHRcdFx0XHRcdC8vIHRoZSBzZWxlY3Rpb24gd2lsbCBhbHJlYWR5IGhhdmUgYmVlbiByZW5kZXJlZC4ganVzdCByZXBvcnQgaXRcblx0XHRcdFx0XHRcdHZpZXcucmVwb3J0U2VsZWN0aW9uKHNlbGVjdGlvblNwYW4sIGV2KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiBkcmFnTGlzdGVuZXI7XG5cdH0sXG5cblxuXHQvLyBLaWxscyBhbGwgaW4tcHJvZ3Jlc3MgZHJhZ2dpbmcuXG5cdC8vIFVzZWZ1bCBmb3Igd2hlbiBwdWJsaWMgQVBJIG1ldGhvZHMgdGhhdCByZXN1bHQgaW4gcmUtcmVuZGVyaW5nIGFyZSBpbnZva2VkIGR1cmluZyBhIGRyYWcuXG5cdC8vIEFsc28gdXNlZnVsIGZvciB3aGVuIHRvdWNoIGRldmljZXMgbWlzYmVoYXZlIGFuZCBkb24ndCBmaXJlIHRoZWlyIHRvdWNoZW5kLlxuXHRjbGVhckRyYWdMaXN0ZW5lcnM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZGF5RHJhZ0xpc3RlbmVyLmVuZEludGVyYWN0aW9uKCk7XG5cblx0XHRpZiAodGhpcy5zZWdEcmFnTGlzdGVuZXIpIHtcblx0XHRcdHRoaXMuc2VnRHJhZ0xpc3RlbmVyLmVuZEludGVyYWN0aW9uKCk7IC8vIHdpbGwgY2xlYXIgdGhpcy5zZWdEcmFnTGlzdGVuZXJcblx0XHR9XG5cdFx0aWYgKHRoaXMuc2VnUmVzaXplTGlzdGVuZXIpIHtcblx0XHRcdHRoaXMuc2VnUmVzaXplTGlzdGVuZXIuZW5kSW50ZXJhY3Rpb24oKTsgLy8gd2lsbCBjbGVhciB0aGlzLnNlZ1Jlc2l6ZUxpc3RlbmVyXG5cdFx0fVxuXHRcdGlmICh0aGlzLmV4dGVybmFsRHJhZ0xpc3RlbmVyKSB7XG5cdFx0XHR0aGlzLmV4dGVybmFsRHJhZ0xpc3RlbmVyLmVuZEludGVyYWN0aW9uKCk7IC8vIHdpbGwgY2xlYXIgdGhpcy5leHRlcm5hbERyYWdMaXN0ZW5lclxuXHRcdH1cblx0fSxcblxuXG5cdC8qIEV2ZW50IEhlbHBlclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHQvLyBUT0RPOiBzaG91bGQgcHJvYmFibHkgbW92ZSB0aGlzIHRvIEdyaWQuZXZlbnRzLCBsaWtlIHdlIGRpZCBldmVudCBkcmFnZ2luZyAvIHJlc2l6aW5nXG5cblxuXHQvLyBSZW5kZXJzIGEgbW9jayBldmVudCBhdCB0aGUgZ2l2ZW4gZXZlbnQgbG9jYXRpb24sIHdoaWNoIGNvbnRhaW5zIHpvbmVkIHN0YXJ0L2VuZCBwcm9wZXJ0aWVzLlxuXHQvLyBSZXR1cm5zIGFsbCBtb2NrIGV2ZW50IGVsZW1lbnRzLlxuXHRyZW5kZXJFdmVudExvY2F0aW9uSGVscGVyOiBmdW5jdGlvbihldmVudExvY2F0aW9uLCBzb3VyY2VTZWcpIHtcblx0XHR2YXIgZmFrZUV2ZW50ID0gdGhpcy5mYWJyaWNhdGVIZWxwZXJFdmVudChldmVudExvY2F0aW9uLCBzb3VyY2VTZWcpO1xuXG5cdFx0cmV0dXJuIHRoaXMucmVuZGVySGVscGVyKGZha2VFdmVudCwgc291cmNlU2VnKTsgLy8gZG8gdGhlIGFjdHVhbCByZW5kZXJpbmdcblx0fSxcblxuXG5cdC8vIEJ1aWxkcyBhIGZha2UgZXZlbnQgZ2l2ZW4gem9uZWQgZXZlbnQgZGF0ZSBwcm9wZXJ0aWVzIGFuZCBhIHNlZ21lbnQgaXMgc2hvdWxkIGJlIGluc3BpcmVkIGZyb20uXG5cdC8vIFRoZSByYW5nZSdzIGVuZCBjYW4gYmUgbnVsbCwgaW4gd2hpY2ggY2FzZSB0aGUgbW9jayBldmVudCB0aGF0IGlzIHJlbmRlcmVkIHdpbGwgaGF2ZSBhIG51bGwgZW5kIHRpbWUuXG5cdC8vIGBzb3VyY2VTZWdgIGlzIHRoZSBpbnRlcm5hbCBzZWdtZW50IG9iamVjdCBpbnZvbHZlZCBpbiB0aGUgZHJhZy4gSWYgbnVsbCwgc29tZXRoaW5nIGV4dGVybmFsIGlzIGRyYWdnaW5nLlxuXHRmYWJyaWNhdGVIZWxwZXJFdmVudDogZnVuY3Rpb24oZXZlbnRMb2NhdGlvbiwgc291cmNlU2VnKSB7XG5cdFx0dmFyIGZha2VFdmVudCA9IHNvdXJjZVNlZyA/IGNyZWF0ZU9iamVjdChzb3VyY2VTZWcuZXZlbnQpIDoge307IC8vIG1hc2sgdGhlIG9yaWdpbmFsIGV2ZW50IG9iamVjdCBpZiBwb3NzaWJsZVxuXG5cdFx0ZmFrZUV2ZW50LnN0YXJ0ID0gZXZlbnRMb2NhdGlvbi5zdGFydC5jbG9uZSgpO1xuXHRcdGZha2VFdmVudC5lbmQgPSBldmVudExvY2F0aW9uLmVuZCA/IGV2ZW50TG9jYXRpb24uZW5kLmNsb25lKCkgOiBudWxsO1xuXHRcdGZha2VFdmVudC5hbGxEYXkgPSBudWxsOyAvLyBmb3JjZSBpdCB0byBiZSBmcmVzaGx5IGNvbXB1dGVkIGJ5IG5vcm1hbGl6ZUV2ZW50RGF0ZXNcblx0XHR0aGlzLnZpZXcuY2FsZW5kYXIubm9ybWFsaXplRXZlbnREYXRlcyhmYWtlRXZlbnQpO1xuXG5cdFx0Ly8gdGhpcyBleHRyYSBjbGFzc05hbWUgd2lsbCBiZSB1c2VmdWwgZm9yIGRpZmZlcmVudGlhdGluZyByZWFsIGV2ZW50cyBmcm9tIG1vY2sgZXZlbnRzIGluIENTU1xuXHRcdGZha2VFdmVudC5jbGFzc05hbWUgPSAoZmFrZUV2ZW50LmNsYXNzTmFtZSB8fCBbXSkuY29uY2F0KCdmYy1oZWxwZXInKTtcblxuXHRcdC8vIGlmIHNvbWV0aGluZyBleHRlcm5hbCBpcyBiZWluZyBkcmFnZ2VkIGluLCBkb24ndCByZW5kZXIgYSByZXNpemVyXG5cdFx0aWYgKCFzb3VyY2VTZWcpIHtcblx0XHRcdGZha2VFdmVudC5lZGl0YWJsZSA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWtlRXZlbnQ7XG5cdH0sXG5cblxuXHQvLyBSZW5kZXJzIGEgbW9jayBldmVudC4gR2l2ZW4gem9uZWQgZXZlbnQgZGF0ZSBwcm9wZXJ0aWVzLlxuXHQvLyBNdXN0IHJldHVybiBhbGwgbW9jayBldmVudCBlbGVtZW50cy5cblx0cmVuZGVySGVscGVyOiBmdW5jdGlvbihldmVudExvY2F0aW9uLCBzb3VyY2VTZWcpIHtcblx0XHQvLyBzdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50XG5cdH0sXG5cblxuXHQvLyBVbnJlbmRlcnMgYSBtb2NrIGV2ZW50XG5cdHVucmVuZGVySGVscGVyOiBmdW5jdGlvbigpIHtcblx0XHQvLyBzdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50XG5cdH0sXG5cblxuXHQvKiBTZWxlY3Rpb25cblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIFJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhIHNlbGVjdGlvbi4gV2lsbCBoaWdobGlnaHQgYnkgZGVmYXVsdCBidXQgY2FuIGJlIG92ZXJyaWRkZW4gYnkgc3ViY2xhc3Nlcy5cblx0Ly8gR2l2ZW4gYSBzcGFuICh1bnpvbmVkIHN0YXJ0L2VuZCBhbmQgb3RoZXIgbWlzYyBkYXRhKVxuXHRyZW5kZXJTZWxlY3Rpb246IGZ1bmN0aW9uKHNwYW4pIHtcblx0XHR0aGlzLnJlbmRlckhpZ2hsaWdodChzcGFuKTtcblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyBhbnkgdmlzdWFsIGluZGljYXRpb25zIG9mIGEgc2VsZWN0aW9uLiBXaWxsIHVucmVuZGVyIGEgaGlnaGxpZ2h0IGJ5IGRlZmF1bHQuXG5cdHVucmVuZGVyU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnVucmVuZGVySGlnaGxpZ2h0KCk7XG5cdH0sXG5cblxuXHQvLyBHaXZlbiB0aGUgZmlyc3QgYW5kIGxhc3QgZGF0ZS1zcGFucyBvZiBhIHNlbGVjdGlvbiwgcmV0dXJucyBhbm90aGVyIGRhdGUtc3BhbiBvYmplY3QuXG5cdC8vIFN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlIGFuZCBwcm92aWRlIGFkZGl0aW9uYWwgZGF0YSBpbiB0aGUgc3BhbiBvYmplY3QuIFdpbGwgYmUgcGFzc2VkIHRvIHJlbmRlclNlbGVjdGlvbigpLlxuXHQvLyBXaWxsIHJldHVybiBmYWxzZSBpZiB0aGUgc2VsZWN0aW9uIGlzIGludmFsaWQgYW5kIHRoaXMgc2hvdWxkIGJlIGluZGljYXRlZCB0byB0aGUgdXNlci5cblx0Ly8gV2lsbCByZXR1cm4gbnVsbC91bmRlZmluZWQgaWYgYSBzZWxlY3Rpb24gaW52YWxpZCBidXQgbm8gZXJyb3Igc2hvdWxkIGJlIHJlcG9ydGVkLlxuXHRjb21wdXRlU2VsZWN0aW9uOiBmdW5jdGlvbihzcGFuMCwgc3BhbjEpIHtcblx0XHR2YXIgc3BhbiA9IHRoaXMuY29tcHV0ZVNlbGVjdGlvblNwYW4oc3BhbjAsIHNwYW4xKTtcblxuXHRcdGlmIChzcGFuICYmICF0aGlzLnZpZXcuY2FsZW5kYXIuaXNTZWxlY3Rpb25TcGFuQWxsb3dlZChzcGFuKSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiBzcGFuO1xuXHR9LFxuXG5cblx0Ly8gR2l2ZW4gdHdvIHNwYW5zLCBtdXN0IHJldHVybiB0aGUgY29tYmluYXRpb24gb2YgdGhlIHR3by5cblx0Ly8gVE9ETzogZG8gdGhpcyBzZXBhcmF0aW9uIG9mIGNvbmNlcm5zIChjb21iaW5pbmcgVlMgdmFsaWRhdGlvbikgZm9yIGV2ZW50IGRuZC9yZXNpemUgdG9vLlxuXHRjb21wdXRlU2VsZWN0aW9uU3BhbjogZnVuY3Rpb24oc3BhbjAsIHNwYW4xKSB7XG5cdFx0dmFyIGRhdGVzID0gWyBzcGFuMC5zdGFydCwgc3BhbjAuZW5kLCBzcGFuMS5zdGFydCwgc3BhbjEuZW5kIF07XG5cblx0XHRkYXRlcy5zb3J0KGNvbXBhcmVOdW1iZXJzKTsgLy8gc29ydHMgY2hyb25vbG9naWNhbGx5LiB3b3JrcyB3aXRoIE1vbWVudHNcblxuXHRcdHJldHVybiB7IHN0YXJ0OiBkYXRlc1swXS5jbG9uZSgpLCBlbmQ6IGRhdGVzWzNdLmNsb25lKCkgfTtcblx0fSxcblxuXG5cdC8qIEhpZ2hsaWdodFxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gUmVuZGVycyBhbiBlbXBoYXNpcyBvbiB0aGUgZ2l2ZW4gZGF0ZSByYW5nZS4gR2l2ZW4gYSBzcGFuICh1bnpvbmVkIHN0YXJ0L2VuZCBhbmQgb3RoZXIgbWlzYyBkYXRhKVxuXHRyZW5kZXJIaWdobGlnaHQ6IGZ1bmN0aW9uKHNwYW4pIHtcblx0XHR0aGlzLnJlbmRlckZpbGwoJ2hpZ2hsaWdodCcsIHRoaXMuc3BhblRvU2VncyhzcGFuKSk7XG5cdH0sXG5cblxuXHQvLyBVbnJlbmRlcnMgdGhlIGVtcGhhc2lzIG9uIGEgZGF0ZSByYW5nZVxuXHR1bnJlbmRlckhpZ2hsaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51bnJlbmRlckZpbGwoJ2hpZ2hsaWdodCcpO1xuXHR9LFxuXG5cblx0Ly8gR2VuZXJhdGVzIGFuIGFycmF5IG9mIGNsYXNzTmFtZXMgZm9yIHJlbmRlcmluZyB0aGUgaGlnaGxpZ2h0LiBVc2VkIGJ5IHRoZSBmaWxsIHN5c3RlbS5cblx0aGlnaGxpZ2h0U2VnQ2xhc3NlczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFsgJ2ZjLWhpZ2hsaWdodCcgXTtcblx0fSxcblxuXG5cdC8qIEJ1c2luZXNzIEhvdXJzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHRyZW5kZXJCdXNpbmVzc0hvdXJzOiBmdW5jdGlvbigpIHtcblx0fSxcblxuXG5cdHVucmVuZGVyQnVzaW5lc3NIb3VyczogZnVuY3Rpb24oKSB7XG5cdH0sXG5cblxuXHQvKiBOb3cgSW5kaWNhdG9yXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHRnZXROb3dJbmRpY2F0b3JVbml0OiBmdW5jdGlvbigpIHtcblx0fSxcblxuXG5cdHJlbmRlck5vd0luZGljYXRvcjogZnVuY3Rpb24oZGF0ZSkge1xuXHR9LFxuXG5cblx0dW5yZW5kZXJOb3dJbmRpY2F0b3I6IGZ1bmN0aW9uKCkge1xuXHR9LFxuXG5cblx0LyogRmlsbCBTeXN0ZW0gKGhpZ2hsaWdodCwgYmFja2dyb3VuZCBldmVudHMsIGJ1c2luZXNzIGhvdXJzKVxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRUT0RPOiByZW1vdmUgdGhpcyBzeXN0ZW0uIGxpa2Ugd2UgZGlkIGluIFRpbWVHcmlkXG5cdCovXG5cblxuXHQvLyBSZW5kZXJzIGEgc2V0IG9mIHJlY3RhbmdsZXMgb3ZlciB0aGUgZ2l2ZW4gc2VnbWVudHMgb2YgdGltZS5cblx0Ly8gTVVTVCBSRVRVUk4gYSBzdWJzZXQgb2Ygc2VncywgdGhlIHNlZ3MgdGhhdCB3ZXJlIGFjdHVhbGx5IHJlbmRlcmVkLlxuXHQvLyBSZXNwb25zaWJsZSBmb3IgcG9wdWxhdGluZyB0aGlzLmVsc0J5RmlsbC4gVE9ETzogYmV0dGVyIEFQSSBmb3IgZXhwcmVzc2luZyB0aGlzIHJlcXVpcmVtZW50XG5cdHJlbmRlckZpbGw6IGZ1bmN0aW9uKHR5cGUsIHNlZ3MpIHtcblx0XHQvLyBzdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50XG5cdH0sXG5cblxuXHQvLyBVbnJlbmRlcnMgYSBzcGVjaWZpYyB0eXBlIG9mIGZpbGwgdGhhdCBpcyBjdXJyZW50bHkgcmVuZGVyZWQgb24gdGhlIGdyaWRcblx0dW5yZW5kZXJGaWxsOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0dmFyIGVsID0gdGhpcy5lbHNCeUZpbGxbdHlwZV07XG5cblx0XHRpZiAoZWwpIHtcblx0XHRcdGVsLnJlbW92ZSgpO1xuXHRcdFx0ZGVsZXRlIHRoaXMuZWxzQnlGaWxsW3R5cGVdO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIFJlbmRlcnMgYW5kIGFzc2lnbnMgYW4gYGVsYCBwcm9wZXJ0eSBmb3IgZWFjaCBmaWxsIHNlZ21lbnQuIEdlbmVyaWMgZW5vdWdoIHRvIHdvcmsgd2l0aCBkaWZmZXJlbnQgdHlwZXMuXG5cdC8vIE9ubHkgcmV0dXJucyBzZWdtZW50cyB0aGF0IHN1Y2Nlc3NmdWxseSByZW5kZXJlZC5cblx0Ly8gVG8gYmUgaGFybmVzc2VkIGJ5IHJlbmRlckZpbGwgKGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzZXMpLlxuXHQvLyBBbmFsYWdvdXMgdG8gcmVuZGVyRmdTZWdFbHMuXG5cdHJlbmRlckZpbGxTZWdFbHM6IGZ1bmN0aW9uKHR5cGUsIHNlZ3MpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHZhciBzZWdFbE1ldGhvZCA9IHRoaXNbdHlwZSArICdTZWdFbCddO1xuXHRcdHZhciBodG1sID0gJyc7XG5cdFx0dmFyIHJlbmRlcmVkU2VncyA9IFtdO1xuXHRcdHZhciBpO1xuXG5cdFx0aWYgKHNlZ3MubGVuZ3RoKSB7XG5cblx0XHRcdC8vIGJ1aWxkIGEgbGFyZ2UgY29uY2F0ZW5hdGlvbiBvZiBzZWdtZW50IEhUTUxcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGh0bWwgKz0gdGhpcy5maWxsU2VnSHRtbCh0eXBlLCBzZWdzW2ldKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gR3JhYiBpbmRpdmlkdWFsIGVsZW1lbnRzIGZyb20gdGhlIGNvbWJpbmVkIEhUTUwgc3RyaW5nLiBVc2UgZWFjaCBhcyB0aGUgZGVmYXVsdCByZW5kZXJpbmcuXG5cdFx0XHQvLyBUaGVuLCBjb21wdXRlIHRoZSAnZWwnIGZvciBlYWNoIHNlZ21lbnQuXG5cdFx0XHQkKGh0bWwpLmVhY2goZnVuY3Rpb24oaSwgbm9kZSkge1xuXHRcdFx0XHR2YXIgc2VnID0gc2Vnc1tpXTtcblx0XHRcdFx0dmFyIGVsID0gJChub2RlKTtcblxuXHRcdFx0XHQvLyBhbGxvdyBjdXN0b20gZmlsdGVyIG1ldGhvZHMgcGVyLXR5cGVcblx0XHRcdFx0aWYgKHNlZ0VsTWV0aG9kKSB7XG5cdFx0XHRcdFx0ZWwgPSBzZWdFbE1ldGhvZC5jYWxsKF90aGlzLCBzZWcsIGVsKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChlbCkgeyAvLyBjdXN0b20gZmlsdGVycyBkaWQgbm90IGNhbmNlbCB0aGUgcmVuZGVyXG5cdFx0XHRcdFx0ZWwgPSAkKGVsKTsgLy8gYWxsb3cgY3VzdG9tIGZpbHRlciB0byByZXR1cm4gcmF3IERPTSBub2RlXG5cblx0XHRcdFx0XHQvLyBjb3JyZWN0IGVsZW1lbnQgdHlwZT8gKHdvdWxkIGJlIGJhZCBpZiBhIG5vbi1URCB3ZXJlIGluc2VydGVkIGludG8gYSB0YWJsZSBmb3IgZXhhbXBsZSlcblx0XHRcdFx0XHRpZiAoZWwuaXMoX3RoaXMuZmlsbFNlZ1RhZykpIHtcblx0XHRcdFx0XHRcdHNlZy5lbCA9IGVsO1xuXHRcdFx0XHRcdFx0cmVuZGVyZWRTZWdzLnB1c2goc2VnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiByZW5kZXJlZFNlZ3M7XG5cdH0sXG5cblxuXHRmaWxsU2VnVGFnOiAnZGl2JywgLy8gc3ViY2xhc3NlcyBjYW4gb3ZlcnJpZGVcblxuXG5cdC8vIEJ1aWxkcyB0aGUgSFRNTCBuZWVkZWQgZm9yIG9uZSBmaWxsIHNlZ21lbnQuIEdlbmVyaWMgZW5vdWdoIHRvIHdvcmsgd2l0aCBkaWZmZXJlbnQgdHlwZXMuXG5cdGZpbGxTZWdIdG1sOiBmdW5jdGlvbih0eXBlLCBzZWcpIHtcblxuXHRcdC8vIGN1c3RvbSBob29rcyBwZXItdHlwZVxuXHRcdHZhciBjbGFzc2VzTWV0aG9kID0gdGhpc1t0eXBlICsgJ1NlZ0NsYXNzZXMnXTtcblx0XHR2YXIgY3NzTWV0aG9kID0gdGhpc1t0eXBlICsgJ1NlZ0NzcyddO1xuXG5cdFx0dmFyIGNsYXNzZXMgPSBjbGFzc2VzTWV0aG9kID8gY2xhc3Nlc01ldGhvZC5jYWxsKHRoaXMsIHNlZykgOiBbXTtcblx0XHR2YXIgY3NzID0gY3NzVG9TdHIoY3NzTWV0aG9kID8gY3NzTWV0aG9kLmNhbGwodGhpcywgc2VnKSA6IHt9KTtcblxuXHRcdHJldHVybiAnPCcgKyB0aGlzLmZpbGxTZWdUYWcgK1xuXHRcdFx0KGNsYXNzZXMubGVuZ3RoID8gJyBjbGFzcz1cIicgKyBjbGFzc2VzLmpvaW4oJyAnKSArICdcIicgOiAnJykgK1xuXHRcdFx0KGNzcyA/ICcgc3R5bGU9XCInICsgY3NzICsgJ1wiJyA6ICcnKSArXG5cdFx0XHQnIC8+Jztcblx0fSxcblxuXG5cblx0LyogR2VuZXJpYyByZW5kZXJpbmcgdXRpbGl0aWVzIGZvciBzdWJjbGFzc2VzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBDb21wdXRlcyBIVE1MIGNsYXNzTmFtZXMgZm9yIGEgc2luZ2xlLWRheSBlbGVtZW50XG5cdGdldERheUNsYXNzZXM6IGZ1bmN0aW9uKGRhdGUpIHtcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblx0XHR2YXIgdG9kYXkgPSB2aWV3LmNhbGVuZGFyLmdldE5vdygpO1xuXHRcdHZhciBjbGFzc2VzID0gWyAnZmMtJyArIGRheUlEc1tkYXRlLmRheSgpXSBdO1xuXG5cdFx0aWYgKFxuXHRcdFx0dmlldy5pbnRlcnZhbER1cmF0aW9uLmFzKCdtb250aHMnKSA9PSAxICYmXG5cdFx0XHRkYXRlLm1vbnRoKCkgIT0gdmlldy5pbnRlcnZhbFN0YXJ0Lm1vbnRoKClcblx0XHQpIHtcblx0XHRcdGNsYXNzZXMucHVzaCgnZmMtb3RoZXItbW9udGgnKTtcblx0XHR9XG5cblx0XHRpZiAoZGF0ZS5pc1NhbWUodG9kYXksICdkYXknKSkge1xuXHRcdFx0Y2xhc3Nlcy5wdXNoKFxuXHRcdFx0XHQnZmMtdG9kYXknLFxuXHRcdFx0XHR2aWV3LmhpZ2hsaWdodFN0YXRlQ2xhc3Ncblx0XHRcdCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKGRhdGUgPCB0b2RheSkge1xuXHRcdFx0Y2xhc3Nlcy5wdXNoKCdmYy1wYXN0Jyk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Y2xhc3Nlcy5wdXNoKCdmYy1mdXR1cmUnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY2xhc3Nlcztcblx0fVxuXG59KTtcblxuOztcblxuLyogRXZlbnQtcmVuZGVyaW5nIGFuZCBldmVudC1pbnRlcmFjdGlvbiBtZXRob2RzIGZvciB0aGUgYWJzdHJhY3QgR3JpZCBjbGFzc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbkdyaWQubWl4aW4oe1xuXG5cdC8vIHNlbGYtY29uZmlnLCBvdmVycmlkYWJsZSBieSBzdWJjbGFzc2VzXG5cdHNlZ1NlbGVjdG9yOiAnLmZjLWV2ZW50LWNvbnRhaW5lciA+IConLCAvLyB3aGF0IGNvbnN0aXR1dGVzIGFuIGV2ZW50IGVsZW1lbnQ/XG5cblx0bW91c2VkT3ZlclNlZzogbnVsbCwgLy8gdGhlIHNlZ21lbnQgb2JqZWN0IHRoZSB1c2VyJ3MgbW91c2UgaXMgb3Zlci4gbnVsbCBpZiBvdmVyIG5vdGhpbmdcblx0aXNEcmFnZ2luZ1NlZzogZmFsc2UsIC8vIGlzIGEgc2VnbWVudCBiZWluZyBkcmFnZ2VkPyBib29sZWFuXG5cdGlzUmVzaXppbmdTZWc6IGZhbHNlLCAvLyBpcyBhIHNlZ21lbnQgYmVpbmcgcmVzaXplZD8gYm9vbGVhblxuXHRpc0RyYWdnaW5nRXh0ZXJuYWw6IGZhbHNlLCAvLyBqcXVpLWRyYWdnaW5nIGFuIGV4dGVybmFsIGVsZW1lbnQ/IGJvb2xlYW5cblx0c2VnczogbnVsbCwgLy8gdGhlICpldmVudCogc2VnbWVudHMgY3VycmVudGx5IHJlbmRlcmVkIGluIHRoZSBncmlkLiBUT0RPOiByZW5hbWUgdG8gYGV2ZW50U2Vnc2BcblxuXG5cdC8vIFJlbmRlcnMgdGhlIGdpdmVuIGV2ZW50cyBvbnRvIHRoZSBncmlkXG5cdHJlbmRlckV2ZW50czogZnVuY3Rpb24oZXZlbnRzKSB7XG5cdFx0dmFyIGJnRXZlbnRzID0gW107XG5cdFx0dmFyIGZnRXZlbnRzID0gW107XG5cdFx0dmFyIGk7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHQoaXNCZ0V2ZW50KGV2ZW50c1tpXSkgPyBiZ0V2ZW50cyA6IGZnRXZlbnRzKS5wdXNoKGV2ZW50c1tpXSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zZWdzID0gW10uY29uY2F0KCAvLyByZWNvcmQgYWxsIHNlZ3Ncblx0XHRcdHRoaXMucmVuZGVyQmdFdmVudHMoYmdFdmVudHMpLFxuXHRcdFx0dGhpcy5yZW5kZXJGZ0V2ZW50cyhmZ0V2ZW50cylcblx0XHQpO1xuXHR9LFxuXG5cblx0cmVuZGVyQmdFdmVudHM6IGZ1bmN0aW9uKGV2ZW50cykge1xuXHRcdHZhciBzZWdzID0gdGhpcy5ldmVudHNUb1NlZ3MoZXZlbnRzKTtcblxuXHRcdC8vIHJlbmRlckJnU2VncyBtaWdodCByZXR1cm4gYSBzdWJzZXQgb2Ygc2Vncywgc2VncyB0aGF0IHdlcmUgYWN0dWFsbHkgcmVuZGVyZWRcblx0XHRyZXR1cm4gdGhpcy5yZW5kZXJCZ1NlZ3Moc2VncykgfHwgc2Vncztcblx0fSxcblxuXG5cdHJlbmRlckZnRXZlbnRzOiBmdW5jdGlvbihldmVudHMpIHtcblx0XHR2YXIgc2VncyA9IHRoaXMuZXZlbnRzVG9TZWdzKGV2ZW50cyk7XG5cblx0XHQvLyByZW5kZXJGZ1NlZ3MgbWlnaHQgcmV0dXJuIGEgc3Vic2V0IG9mIHNlZ3MsIHNlZ3MgdGhhdCB3ZXJlIGFjdHVhbGx5IHJlbmRlcmVkXG5cdFx0cmV0dXJuIHRoaXMucmVuZGVyRmdTZWdzKHNlZ3MpIHx8IHNlZ3M7XG5cdH0sXG5cblxuXHQvLyBVbnJlbmRlcnMgYWxsIGV2ZW50cyBjdXJyZW50bHkgcmVuZGVyZWQgb24gdGhlIGdyaWRcblx0dW5yZW5kZXJFdmVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaGFuZGxlU2VnTW91c2VvdXQoKTsgLy8gdHJpZ2dlciBhbiBldmVudE1vdXNlb3V0IGlmIHVzZXIncyBtb3VzZSBpcyBvdmVyIGFuIGV2ZW50XG5cdFx0dGhpcy5jbGVhckRyYWdMaXN0ZW5lcnMoKTtcblxuXHRcdHRoaXMudW5yZW5kZXJGZ1NlZ3MoKTtcblx0XHR0aGlzLnVucmVuZGVyQmdTZWdzKCk7XG5cblx0XHR0aGlzLnNlZ3MgPSBudWxsO1xuXHR9LFxuXG5cblx0Ly8gUmV0cmlldmVzIGFsbCByZW5kZXJlZCBzZWdtZW50IG9iamVjdHMgY3VycmVudGx5IHJlbmRlcmVkIG9uIHRoZSBncmlkXG5cdGdldEV2ZW50U2VnczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2VncyB8fCBbXTtcblx0fSxcblxuXG5cdC8qIEZvcmVncm91bmQgU2VnbWVudCBSZW5kZXJpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIFJlbmRlcnMgZm9yZWdyb3VuZCBldmVudCBzZWdtZW50cyBvbnRvIHRoZSBncmlkLiBNYXkgcmV0dXJuIGEgc3Vic2V0IG9mIHNlZ3MgdGhhdCB3ZXJlIHJlbmRlcmVkLlxuXHRyZW5kZXJGZ1NlZ3M6IGZ1bmN0aW9uKHNlZ3MpIHtcblx0XHQvLyBzdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50XG5cdH0sXG5cblxuXHQvLyBVbnJlbmRlcnMgYWxsIGN1cnJlbnRseSByZW5kZXJlZCBmb3JlZ3JvdW5kIHNlZ21lbnRzXG5cdHVucmVuZGVyRmdTZWdzOiBmdW5jdGlvbigpIHtcblx0XHQvLyBzdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50XG5cdH0sXG5cblxuXHQvLyBSZW5kZXJzIGFuZCBhc3NpZ25zIGFuIGBlbGAgcHJvcGVydHkgZm9yIGVhY2ggZm9yZWdyb3VuZCBldmVudCBzZWdtZW50LlxuXHQvLyBPbmx5IHJldHVybnMgc2VnbWVudHMgdGhhdCBzdWNjZXNzZnVsbHkgcmVuZGVyZWQuXG5cdC8vIEEgdXRpbGl0eSB0aGF0IHN1YmNsYXNzZXMgbWF5IHVzZS5cblx0cmVuZGVyRmdTZWdFbHM6IGZ1bmN0aW9uKHNlZ3MsIGRpc2FibGVSZXNpemluZykge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXHRcdHZhciBodG1sID0gJyc7XG5cdFx0dmFyIHJlbmRlcmVkU2VncyA9IFtdO1xuXHRcdHZhciBpO1xuXG5cdFx0aWYgKHNlZ3MubGVuZ3RoKSB7IC8vIGRvbid0IGJ1aWxkIGFuIGVtcHR5IGh0bWwgc3RyaW5nXG5cblx0XHRcdC8vIGJ1aWxkIGEgbGFyZ2UgY29uY2F0ZW5hdGlvbiBvZiBldmVudCBzZWdtZW50IEhUTUxcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGh0bWwgKz0gdGhpcy5mZ1NlZ0h0bWwoc2Vnc1tpXSwgZGlzYWJsZVJlc2l6aW5nKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gR3JhYiBpbmRpdmlkdWFsIGVsZW1lbnRzIGZyb20gdGhlIGNvbWJpbmVkIEhUTUwgc3RyaW5nLiBVc2UgZWFjaCBhcyB0aGUgZGVmYXVsdCByZW5kZXJpbmcuXG5cdFx0XHQvLyBUaGVuLCBjb21wdXRlIHRoZSAnZWwnIGZvciBlYWNoIHNlZ21lbnQuIEFuIGVsIG1pZ2h0IGJlIG51bGwgaWYgdGhlIGV2ZW50UmVuZGVyIGNhbGxiYWNrIHJldHVybmVkIGZhbHNlLlxuXHRcdFx0JChodG1sKS5lYWNoKGZ1bmN0aW9uKGksIG5vZGUpIHtcblx0XHRcdFx0dmFyIHNlZyA9IHNlZ3NbaV07XG5cdFx0XHRcdHZhciBlbCA9IHZpZXcucmVzb2x2ZUV2ZW50RWwoc2VnLmV2ZW50LCAkKG5vZGUpKTtcblxuXHRcdFx0XHRpZiAoZWwpIHtcblx0XHRcdFx0XHRlbC5kYXRhKCdmYy1zZWcnLCBzZWcpOyAvLyB1c2VkIGJ5IGhhbmRsZXJzXG5cdFx0XHRcdFx0c2VnLmVsID0gZWw7XG5cdFx0XHRcdFx0cmVuZGVyZWRTZWdzLnB1c2goc2VnKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlbmRlcmVkU2Vncztcblx0fSxcblxuXG5cdC8vIEdlbmVyYXRlcyB0aGUgSFRNTCBmb3IgdGhlIGRlZmF1bHQgcmVuZGVyaW5nIG9mIGEgZm9yZWdyb3VuZCBldmVudCBzZWdtZW50LiBVc2VkIGJ5IHJlbmRlckZnU2VnRWxzKClcblx0ZmdTZWdIdG1sOiBmdW5jdGlvbihzZWcsIGRpc2FibGVSZXNpemluZykge1xuXHRcdC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxuXHR9LFxuXG5cblx0LyogQmFja2dyb3VuZCBTZWdtZW50IFJlbmRlcmluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gUmVuZGVycyB0aGUgZ2l2ZW4gYmFja2dyb3VuZCBldmVudCBzZWdtZW50cyBvbnRvIHRoZSBncmlkLlxuXHQvLyBSZXR1cm5zIGEgc3Vic2V0IG9mIHRoZSBzZWdzIHRoYXQgd2VyZSBhY3R1YWxseSByZW5kZXJlZC5cblx0cmVuZGVyQmdTZWdzOiBmdW5jdGlvbihzZWdzKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVuZGVyRmlsbCgnYmdFdmVudCcsIHNlZ3MpO1xuXHR9LFxuXG5cblx0Ly8gVW5yZW5kZXJzIGFsbCB0aGUgY3VycmVudGx5IHJlbmRlcmVkIGJhY2tncm91bmQgZXZlbnQgc2VnbWVudHNcblx0dW5yZW5kZXJCZ1NlZ3M6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudW5yZW5kZXJGaWxsKCdiZ0V2ZW50Jyk7XG5cdH0sXG5cblxuXHQvLyBSZW5kZXJzIGEgYmFja2dyb3VuZCBldmVudCBlbGVtZW50LCBnaXZlbiB0aGUgZGVmYXVsdCByZW5kZXJpbmcuIENhbGxlZCBieSB0aGUgZmlsbCBzeXN0ZW0uXG5cdGJnRXZlbnRTZWdFbDogZnVuY3Rpb24oc2VnLCBlbCkge1xuXHRcdHJldHVybiB0aGlzLnZpZXcucmVzb2x2ZUV2ZW50RWwoc2VnLmV2ZW50LCBlbCk7IC8vIHdpbGwgZmlsdGVyIHRocm91Z2ggZXZlbnRSZW5kZXJcblx0fSxcblxuXG5cdC8vIEdlbmVyYXRlcyBhbiBhcnJheSBvZiBjbGFzc05hbWVzIHRvIGJlIHVzZWQgZm9yIHRoZSBkZWZhdWx0IHJlbmRlcmluZyBvZiBhIGJhY2tncm91bmQgZXZlbnQuXG5cdC8vIENhbGxlZCBieSBmaWxsU2VnSHRtbC5cblx0YmdFdmVudFNlZ0NsYXNzZXM6IGZ1bmN0aW9uKHNlZykge1xuXHRcdHZhciBldmVudCA9IHNlZy5ldmVudDtcblx0XHR2YXIgc291cmNlID0gZXZlbnQuc291cmNlIHx8IHt9O1xuXG5cdFx0cmV0dXJuIFsgJ2ZjLWJnZXZlbnQnIF0uY29uY2F0KFxuXHRcdFx0ZXZlbnQuY2xhc3NOYW1lLFxuXHRcdFx0c291cmNlLmNsYXNzTmFtZSB8fCBbXVxuXHRcdCk7XG5cdH0sXG5cblxuXHQvLyBHZW5lcmF0ZXMgYSBzZW1pY29sb24tc2VwYXJhdGVkIENTUyBzdHJpbmcgdG8gYmUgdXNlZCBmb3IgdGhlIGRlZmF1bHQgcmVuZGVyaW5nIG9mIGEgYmFja2dyb3VuZCBldmVudC5cblx0Ly8gQ2FsbGVkIGJ5IGZpbGxTZWdIdG1sLlxuXHRiZ0V2ZW50U2VnQ3NzOiBmdW5jdGlvbihzZWcpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0J2JhY2tncm91bmQtY29sb3InOiB0aGlzLmdldFNlZ1NraW5Dc3Moc2VnKVsnYmFja2dyb3VuZC1jb2xvciddXG5cdFx0fTtcblx0fSxcblxuXG5cdC8vIEdlbmVyYXRlcyBhbiBhcnJheSBvZiBjbGFzc05hbWVzIHRvIGJlIHVzZWQgZm9yIHRoZSByZW5kZXJpbmcgYnVzaW5lc3MgaG91cnMgb3ZlcmxheS4gQ2FsbGVkIGJ5IHRoZSBmaWxsIHN5c3RlbS5cblx0Ly8gQ2FsbGVkIGJ5IGZpbGxTZWdIdG1sLlxuXHRidXNpbmVzc0hvdXJzU2VnQ2xhc3NlczogZnVuY3Rpb24oc2VnKSB7XG5cdFx0cmV0dXJuIFsgJ2ZjLW5vbmJ1c2luZXNzJywgJ2ZjLWJnZXZlbnQnIF07XG5cdH0sXG5cblxuXHQvKiBCdXNpbmVzcyBIb3Vyc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gQ29tcHV0ZSBidXNpbmVzcyBob3VyIHNlZ3MgZm9yIHRoZSBncmlkJ3MgY3VycmVudCBkYXRlIHJhbmdlLlxuXHQvLyBDYWxsZXIgbXVzdCBhc2sgaWYgd2hvbGUtZGF5IGJ1c2luZXNzIGhvdXJzIGFyZSBuZWVkZWQuXG5cdGJ1aWxkQnVzaW5lc3NIb3VyU2VnczogZnVuY3Rpb24od2hvbGVEYXkpIHtcblx0XHR2YXIgZXZlbnRzID0gdGhpcy52aWV3LmNhbGVuZGFyLmdldEN1cnJlbnRCdXNpbmVzc0hvdXJFdmVudHMod2hvbGVEYXkpO1xuXG5cdFx0Ly8gSEFDSy4gRXZlbnR1YWxseSByZWZhY3RvciBidXNpbmVzcyBob3VycyBcImV2ZW50c1wiIHN5c3RlbS5cblx0XHQvLyBJZiBubyBldmVudHMgYXJlIGdpdmVuLCBidXQgYnVzaW5lc3NIb3VycyBpcyBhY3RpdmF0ZWQsIHRoaXMgbWVhbnMgdGhlIGVudGlyZSB2aXNpYmxlIHJhbmdlIHNob3VsZCBiZVxuXHRcdC8vIG1hcmtlZCBhcyAqbm90KiBidXNpbmVzcy1ob3VycywgdmlhIGludmVyc2UtYmFja2dyb3VuZCByZW5kZXJpbmcuXG5cdFx0aWYgKFxuXHRcdFx0IWV2ZW50cy5sZW5ndGggJiZcblx0XHRcdHRoaXMudmlldy5jYWxlbmRhci5vcHRpb25zLmJ1c2luZXNzSG91cnMgLy8gZG9uJ3QgYWNjZXNzIHZpZXcgb3B0aW9uLiBkb2Vzbid0IHVwZGF0ZSB3aXRoIGR5bmFtaWMgb3B0aW9uc1xuXHRcdCkge1xuXHRcdFx0ZXZlbnRzID0gW1xuXHRcdFx0XHQkLmV4dGVuZCh7fSwgQlVTSU5FU1NfSE9VUl9FVkVOVF9ERUZBVUxUUywge1xuXHRcdFx0XHRcdHN0YXJ0OiB0aGlzLnZpZXcuZW5kLCAvLyBndWFyYW50ZWVkIG91dC1vZi1yYW5nZVxuXHRcdFx0XHRcdGVuZDogdGhpcy52aWV3LmVuZCwgICAvLyBcIlxuXHRcdFx0XHRcdGRvdzogbnVsbFxuXHRcdFx0XHR9KVxuXHRcdFx0XTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5ldmVudHNUb1NlZ3MoZXZlbnRzKTtcblx0fSxcblxuXG5cdC8qIEhhbmRsZXJzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBBdHRhY2hlcyBldmVudC1lbGVtZW50LXJlbGF0ZWQgaGFuZGxlcnMgZm9yICphbGwqIHJlbmRlcmVkIGV2ZW50IHNlZ21lbnRzIG9mIHRoZSB2aWV3LlxuXHRiaW5kU2VnSGFuZGxlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuYmluZFNlZ0hhbmRsZXJzVG9FbCh0aGlzLmVsKTtcblx0fSxcblxuXG5cdC8vIEF0dGFjaGVzIGV2ZW50LWVsZW1lbnQtcmVsYXRlZCBoYW5kbGVycyB0byBhbiBhcmJpdHJhcnkgY29udGFpbmVyIGVsZW1lbnQuIGxldmVyYWdlcyBidWJibGluZy5cblx0YmluZFNlZ0hhbmRsZXJzVG9FbDogZnVuY3Rpb24oZWwpIHtcblx0XHR0aGlzLmJpbmRTZWdIYW5kbGVyVG9FbChlbCwgJ3RvdWNoc3RhcnQnLCB0aGlzLmhhbmRsZVNlZ1RvdWNoU3RhcnQpO1xuXHRcdHRoaXMuYmluZFNlZ0hhbmRsZXJUb0VsKGVsLCAndG91Y2hlbmQnLCB0aGlzLmhhbmRsZVNlZ1RvdWNoRW5kKTtcblx0XHR0aGlzLmJpbmRTZWdIYW5kbGVyVG9FbChlbCwgJ21vdXNlZW50ZXInLCB0aGlzLmhhbmRsZVNlZ01vdXNlb3Zlcik7XG5cdFx0dGhpcy5iaW5kU2VnSGFuZGxlclRvRWwoZWwsICdtb3VzZWxlYXZlJywgdGhpcy5oYW5kbGVTZWdNb3VzZW91dCk7XG5cdFx0dGhpcy5iaW5kU2VnSGFuZGxlclRvRWwoZWwsICdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZVNlZ01vdXNlZG93bik7XG5cdFx0dGhpcy5iaW5kU2VnSGFuZGxlclRvRWwoZWwsICdjbGljaycsIHRoaXMuaGFuZGxlU2VnQ2xpY2spO1xuXHR9LFxuXG5cblx0Ly8gRXhlY3V0ZXMgYSBoYW5kbGVyIGZvciBhbnkgYSB1c2VyLWludGVyYWN0aW9uIG9uIGEgc2VnbWVudC5cblx0Ly8gSGFuZGxlciBnZXRzIGNhbGxlZCB3aXRoIChzZWcsIGV2KSwgYW5kIHdpdGggdGhlIGB0aGlzYCBjb250ZXh0IG9mIHRoZSBHcmlkXG5cdGJpbmRTZWdIYW5kbGVyVG9FbDogZnVuY3Rpb24oZWwsIG5hbWUsIGhhbmRsZXIpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG5cdFx0ZWwub24obmFtZSwgdGhpcy5zZWdTZWxlY3RvciwgZnVuY3Rpb24oZXYpIHtcblx0XHRcdHZhciBzZWcgPSAkKHRoaXMpLmRhdGEoJ2ZjLXNlZycpOyAvLyBncmFiIHNlZ21lbnQgZGF0YS4gcHV0IHRoZXJlIGJ5IFZpZXc6OnJlbmRlckV2ZW50c1xuXG5cdFx0XHQvLyBvbmx5IGNhbGwgdGhlIGhhbmRsZXJzIGlmIHRoZXJlIGlzIG5vdCBhIGRyYWcvcmVzaXplIGluIHByb2dyZXNzXG5cdFx0XHRpZiAoc2VnICYmICFfdGhpcy5pc0RyYWdnaW5nU2VnICYmICFfdGhpcy5pc1Jlc2l6aW5nU2VnKSB7XG5cdFx0XHRcdHJldHVybiBoYW5kbGVyLmNhbGwoX3RoaXMsIHNlZywgZXYpOyAvLyBjb250ZXh0IHdpbGwgYmUgdGhlIEdyaWRcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXG5cdGhhbmRsZVNlZ0NsaWNrOiBmdW5jdGlvbihzZWcsIGV2KSB7XG5cdFx0dmFyIHJlcyA9IHRoaXMudmlldy50cmlnZ2VyKCdldmVudENsaWNrJywgc2VnLmVsWzBdLCBzZWcuZXZlbnQsIGV2KTsgLy8gY2FuIHJldHVybiBgZmFsc2VgIHRvIGNhbmNlbFxuXHRcdGlmIChyZXMgPT09IGZhbHNlKSB7XG5cdFx0XHRldi5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIFVwZGF0ZXMgaW50ZXJuYWwgc3RhdGUgYW5kIHRyaWdnZXJzIGhhbmRsZXJzIGZvciB3aGVuIGFuIGV2ZW50IGVsZW1lbnQgaXMgbW91c2VkIG92ZXJcblx0aGFuZGxlU2VnTW91c2VvdmVyOiBmdW5jdGlvbihzZWcsIGV2KSB7XG5cdFx0aWYgKFxuXHRcdFx0IXRoaXMuaXNJZ25vcmluZ01vdXNlICYmXG5cdFx0XHQhdGhpcy5tb3VzZWRPdmVyU2VnXG5cdFx0KSB7XG5cdFx0XHR0aGlzLm1vdXNlZE92ZXJTZWcgPSBzZWc7XG5cdFx0XHRpZiAodGhpcy52aWV3LmlzRXZlbnRSZXNpemFibGUoc2VnLmV2ZW50KSkge1xuXHRcdFx0XHRzZWcuZWwuYWRkQ2xhc3MoJ2ZjLWFsbG93LW1vdXNlLXJlc2l6ZScpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy52aWV3LnRyaWdnZXIoJ2V2ZW50TW91c2VvdmVyJywgc2VnLmVsWzBdLCBzZWcuZXZlbnQsIGV2KTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBVcGRhdGVzIGludGVybmFsIHN0YXRlIGFuZCB0cmlnZ2VycyBoYW5kbGVycyBmb3Igd2hlbiBhbiBldmVudCBlbGVtZW50IGlzIG1vdXNlZCBvdXQuXG5cdC8vIENhbiBiZSBnaXZlbiBubyBhcmd1bWVudHMsIGluIHdoaWNoIGNhc2UgaXQgd2lsbCBtb3VzZW91dCB0aGUgc2VnbWVudCB0aGF0IHdhcyBwcmV2aW91c2x5IG1vdXNlZCBvdmVyLlxuXHRoYW5kbGVTZWdNb3VzZW91dDogZnVuY3Rpb24oc2VnLCBldikge1xuXHRcdGV2ID0gZXYgfHwge307IC8vIGlmIGdpdmVuIG5vIGFyZ3MsIG1ha2UgYSBtb2NrIG1vdXNlIGV2ZW50XG5cblx0XHRpZiAodGhpcy5tb3VzZWRPdmVyU2VnKSB7XG5cdFx0XHRzZWcgPSBzZWcgfHwgdGhpcy5tb3VzZWRPdmVyU2VnOyAvLyBpZiBnaXZlbiBubyBhcmdzLCB1c2UgdGhlIGN1cnJlbnRseSBtb3VzZWQtb3ZlciBzZWdtZW50XG5cdFx0XHR0aGlzLm1vdXNlZE92ZXJTZWcgPSBudWxsO1xuXHRcdFx0aWYgKHRoaXMudmlldy5pc0V2ZW50UmVzaXphYmxlKHNlZy5ldmVudCkpIHtcblx0XHRcdFx0c2VnLmVsLnJlbW92ZUNsYXNzKCdmYy1hbGxvdy1tb3VzZS1yZXNpemUnKTtcblx0XHRcdH1cblx0XHRcdHRoaXMudmlldy50cmlnZ2VyKCdldmVudE1vdXNlb3V0Jywgc2VnLmVsWzBdLCBzZWcuZXZlbnQsIGV2KTtcblx0XHR9XG5cdH0sXG5cblxuXHRoYW5kbGVTZWdNb3VzZWRvd246IGZ1bmN0aW9uKHNlZywgZXYpIHtcblx0XHR2YXIgaXNSZXNpemluZyA9IHRoaXMuc3RhcnRTZWdSZXNpemUoc2VnLCBldiwgeyBkaXN0YW5jZTogNSB9KTtcblxuXHRcdGlmICghaXNSZXNpemluZyAmJiB0aGlzLnZpZXcuaXNFdmVudERyYWdnYWJsZShzZWcuZXZlbnQpKSB7XG5cdFx0XHR0aGlzLmJ1aWxkU2VnRHJhZ0xpc3RlbmVyKHNlZylcblx0XHRcdFx0LnN0YXJ0SW50ZXJhY3Rpb24oZXYsIHtcblx0XHRcdFx0XHRkaXN0YW5jZTogNVxuXHRcdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblxuXHRoYW5kbGVTZWdUb3VjaFN0YXJ0OiBmdW5jdGlvbihzZWcsIGV2KSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIGV2ZW50ID0gc2VnLmV2ZW50O1xuXHRcdHZhciBpc1NlbGVjdGVkID0gdmlldy5pc0V2ZW50U2VsZWN0ZWQoZXZlbnQpO1xuXHRcdHZhciBpc0RyYWdnYWJsZSA9IHZpZXcuaXNFdmVudERyYWdnYWJsZShldmVudCk7XG5cdFx0dmFyIGlzUmVzaXphYmxlID0gdmlldy5pc0V2ZW50UmVzaXphYmxlKGV2ZW50KTtcblx0XHR2YXIgaXNSZXNpemluZyA9IGZhbHNlO1xuXHRcdHZhciBkcmFnTGlzdGVuZXI7XG5cblx0XHRpZiAoaXNTZWxlY3RlZCAmJiBpc1Jlc2l6YWJsZSkge1xuXHRcdFx0Ly8gb25seSBhbGxvdyByZXNpemluZyBvZiB0aGUgZXZlbnQgaXMgc2VsZWN0ZWRcblx0XHRcdGlzUmVzaXppbmcgPSB0aGlzLnN0YXJ0U2VnUmVzaXplKHNlZywgZXYpO1xuXHRcdH1cblxuXHRcdGlmICghaXNSZXNpemluZyAmJiAoaXNEcmFnZ2FibGUgfHwgaXNSZXNpemFibGUpKSB7IC8vIGFsbG93ZWQgdG8gYmUgc2VsZWN0ZWQ/XG5cblx0XHRcdGRyYWdMaXN0ZW5lciA9IGlzRHJhZ2dhYmxlID9cblx0XHRcdFx0dGhpcy5idWlsZFNlZ0RyYWdMaXN0ZW5lcihzZWcpIDpcblx0XHRcdFx0dGhpcy5idWlsZFNlZ1NlbGVjdExpc3RlbmVyKHNlZyk7IC8vIHNlZyBpc24ndCBkcmFnZ2FibGUsIGJ1dCBzdGlsbCBuZWVkcyB0byBiZSBzZWxlY3RlZFxuXG5cdFx0XHRkcmFnTGlzdGVuZXIuc3RhcnRJbnRlcmFjdGlvbihldiwgeyAvLyB3b24ndCBzdGFydCBpZiBhbHJlYWR5IHN0YXJ0ZWRcblx0XHRcdFx0ZGVsYXk6IGlzU2VsZWN0ZWQgPyAwIDogdGhpcy52aWV3Lm9wdCgnbG9uZ1ByZXNzRGVsYXknKSAvLyBkbyBkZWxheSBpZiBub3QgYWxyZWFkeSBzZWxlY3RlZFxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Ly8gYSBsb25nIHRhcCBzaW11bGF0ZXMgYSBtb3VzZW92ZXIuIGlnbm9yZSB0aGlzIGJvZ3VzIG1vdXNlb3Zlci5cblx0XHR0aGlzLnRlbXBJZ25vcmVNb3VzZSgpO1xuXHR9LFxuXG5cblx0aGFuZGxlU2VnVG91Y2hFbmQ6IGZ1bmN0aW9uKHNlZywgZXYpIHtcblx0XHQvLyB0b3VjaHN0YXJ0K3RvdWNoZW5kID0gY2xpY2ssIHdoaWNoIHNpbXVsYXRlcyBhIG1vdXNlb3Zlci5cblx0XHQvLyBpZ25vcmUgdGhpcyBib2d1cyBtb3VzZW92ZXIuXG5cdFx0dGhpcy50ZW1wSWdub3JlTW91c2UoKTtcblx0fSxcblxuXG5cdC8vIHJldHVybnMgYm9vbGVhbiB3aGV0aGVyIHJlc2l6aW5nIGFjdHVhbGx5IHN0YXJ0ZWQgb3Igbm90LlxuXHQvLyBhc3N1bWVzIHRoZSBzZWcgYWxsb3dzIHJlc2l6aW5nLlxuXHQvLyBgZHJhZ09wdGlvbnNgIGFyZSBvcHRpb25hbC5cblx0c3RhcnRTZWdSZXNpemU6IGZ1bmN0aW9uKHNlZywgZXYsIGRyYWdPcHRpb25zKSB7XG5cdFx0aWYgKCQoZXYudGFyZ2V0KS5pcygnLmZjLXJlc2l6ZXInKSkge1xuXHRcdFx0dGhpcy5idWlsZFNlZ1Jlc2l6ZUxpc3RlbmVyKHNlZywgJChldi50YXJnZXQpLmlzKCcuZmMtc3RhcnQtcmVzaXplcicpKVxuXHRcdFx0XHQuc3RhcnRJbnRlcmFjdGlvbihldiwgZHJhZ09wdGlvbnMpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXG5cblx0LyogRXZlbnQgRHJhZ2dpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIEJ1aWxkcyBhIGxpc3RlbmVyIHRoYXQgd2lsbCB0cmFjayB1c2VyLWRyYWdnaW5nIG9uIGFuIGV2ZW50IHNlZ21lbnQuXG5cdC8vIEdlbmVyaWMgZW5vdWdoIHRvIHdvcmsgd2l0aCBhbnkgdHlwZSBvZiBHcmlkLlxuXHQvLyBIYXMgc2lkZSBlZmZlY3Qgb2Ygc2V0dGluZy91bnNldHRpbmcgYHNlZ0RyYWdMaXN0ZW5lcmBcblx0YnVpbGRTZWdEcmFnTGlzdGVuZXI6IGZ1bmN0aW9uKHNlZykge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIGNhbGVuZGFyID0gdmlldy5jYWxlbmRhcjtcblx0XHR2YXIgZWwgPSBzZWcuZWw7XG5cdFx0dmFyIGV2ZW50ID0gc2VnLmV2ZW50O1xuXHRcdHZhciBpc0RyYWdnaW5nO1xuXHRcdHZhciBtb3VzZUZvbGxvd2VyOyAvLyBBIGNsb25lIG9mIHRoZSBvcmlnaW5hbCBlbGVtZW50IHRoYXQgd2lsbCBtb3ZlIHdpdGggdGhlIG1vdXNlXG5cdFx0dmFyIGRyb3BMb2NhdGlvbjsgLy8gem9uZWQgZXZlbnQgZGF0ZSBwcm9wZXJ0aWVzXG5cblx0XHRpZiAodGhpcy5zZWdEcmFnTGlzdGVuZXIpIHtcblx0XHRcdHJldHVybiB0aGlzLnNlZ0RyYWdMaXN0ZW5lcjtcblx0XHR9XG5cblx0XHQvLyBUcmFja3MgbW91c2UgbW92ZW1lbnQgb3ZlciB0aGUgKnZpZXcncyogY29vcmRpbmF0ZSBtYXAuIEFsbG93cyBkcmFnZ2luZyBhbmQgZHJvcHBpbmcgYmV0d2VlbiBzdWJjb21wb25lbnRzXG5cdFx0Ly8gb2YgdGhlIHZpZXcuXG5cdFx0dmFyIGRyYWdMaXN0ZW5lciA9IHRoaXMuc2VnRHJhZ0xpc3RlbmVyID0gbmV3IEhpdERyYWdMaXN0ZW5lcih2aWV3LCB7XG5cdFx0XHRzY3JvbGw6IHZpZXcub3B0KCdkcmFnU2Nyb2xsJyksXG5cdFx0XHRzdWJqZWN0RWw6IGVsLFxuXHRcdFx0c3ViamVjdENlbnRlcjogdHJ1ZSxcblx0XHRcdGludGVyYWN0aW9uU3RhcnQ6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0XHRcdHNlZy5jb21wb25lbnQgPSBfdGhpczsgLy8gZm9yIHJlbmRlckRyYWdcblx0XHRcdFx0aXNEcmFnZ2luZyA9IGZhbHNlO1xuXHRcdFx0XHRtb3VzZUZvbGxvd2VyID0gbmV3IE1vdXNlRm9sbG93ZXIoc2VnLmVsLCB7XG5cdFx0XHRcdFx0YWRkaXRpb25hbENsYXNzOiAnZmMtZHJhZ2dpbmcnLFxuXHRcdFx0XHRcdHBhcmVudEVsOiB2aWV3LmVsLFxuXHRcdFx0XHRcdG9wYWNpdHk6IGRyYWdMaXN0ZW5lci5pc1RvdWNoID8gbnVsbCA6IHZpZXcub3B0KCdkcmFnT3BhY2l0eScpLFxuXHRcdFx0XHRcdHJldmVydER1cmF0aW9uOiB2aWV3Lm9wdCgnZHJhZ1JldmVydER1cmF0aW9uJyksXG5cdFx0XHRcdFx0ekluZGV4OiAyIC8vIG9uZSBhYm92ZSB0aGUgLmZjLXZpZXdcblx0XHRcdFx0fSk7XG5cdFx0XHRcdG1vdXNlRm9sbG93ZXIuaGlkZSgpOyAvLyBkb24ndCBzaG93IHVudGlsIHdlIGtub3cgdGhpcyBpcyBhIHJlYWwgZHJhZ1xuXHRcdFx0XHRtb3VzZUZvbGxvd2VyLnN0YXJ0KGV2KTtcblx0XHRcdH0sXG5cdFx0XHRkcmFnU3RhcnQ6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0XHRcdGlmIChkcmFnTGlzdGVuZXIuaXNUb3VjaCAmJiAhdmlldy5pc0V2ZW50U2VsZWN0ZWQoZXZlbnQpKSB7XG5cdFx0XHRcdFx0Ly8gaWYgbm90IHByZXZpb3VzbHkgc2VsZWN0ZWQsIHdpbGwgZmlyZSBhZnRlciBhIGRlbGF5LiB0aGVuLCBzZWxlY3QgdGhlIGV2ZW50XG5cdFx0XHRcdFx0dmlldy5zZWxlY3RFdmVudChldmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aXNEcmFnZ2luZyA9IHRydWU7XG5cdFx0XHRcdF90aGlzLmhhbmRsZVNlZ01vdXNlb3V0KHNlZywgZXYpOyAvLyBlbnN1cmUgYSBtb3VzZW91dCBvbiB0aGUgbWFuaXB1bGF0ZWQgZXZlbnQgaGFzIGJlZW4gcmVwb3J0ZWRcblx0XHRcdFx0X3RoaXMuc2VnRHJhZ1N0YXJ0KHNlZywgZXYpO1xuXHRcdFx0XHR2aWV3LmhpZGVFdmVudChldmVudCk7IC8vIGhpZGUgYWxsIGV2ZW50IHNlZ21lbnRzLiBvdXIgbW91c2VGb2xsb3dlciB3aWxsIHRha2Ugb3ZlclxuXHRcdFx0fSxcblx0XHRcdGhpdE92ZXI6IGZ1bmN0aW9uKGhpdCwgaXNPcmlnLCBvcmlnSGl0KSB7XG5cdFx0XHRcdHZhciBkcmFnSGVscGVyRWxzO1xuXG5cdFx0XHRcdC8vIHN0YXJ0aW5nIGhpdCBjb3VsZCBiZSBmb3JjZWQgKERheUdyaWQubGltaXQpXG5cdFx0XHRcdGlmIChzZWcuaGl0KSB7XG5cdFx0XHRcdFx0b3JpZ0hpdCA9IHNlZy5oaXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBzaW5jZSB3ZSBhcmUgcXVlcnlpbmcgdGhlIHBhcmVudCB2aWV3LCBtaWdodCBub3QgYmVsb25nIHRvIHRoaXMgZ3JpZFxuXHRcdFx0XHRkcm9wTG9jYXRpb24gPSBfdGhpcy5jb21wdXRlRXZlbnREcm9wKFxuXHRcdFx0XHRcdG9yaWdIaXQuY29tcG9uZW50LmdldEhpdFNwYW4ob3JpZ0hpdCksXG5cdFx0XHRcdFx0aGl0LmNvbXBvbmVudC5nZXRIaXRTcGFuKGhpdCksXG5cdFx0XHRcdFx0ZXZlbnRcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRpZiAoZHJvcExvY2F0aW9uICYmICFjYWxlbmRhci5pc0V2ZW50U3BhbkFsbG93ZWQoX3RoaXMuZXZlbnRUb1NwYW4oZHJvcExvY2F0aW9uKSwgZXZlbnQpKSB7XG5cdFx0XHRcdFx0ZGlzYWJsZUN1cnNvcigpO1xuXHRcdFx0XHRcdGRyb3BMb2NhdGlvbiA9IG51bGw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBhIHZhbGlkIGRyb3AgbG9jYXRpb24sIGhhdmUgdGhlIHN1YmNsYXNzIHJlbmRlciBhIHZpc3VhbCBpbmRpY2F0aW9uXG5cdFx0XHRcdGlmIChkcm9wTG9jYXRpb24gJiYgKGRyYWdIZWxwZXJFbHMgPSB2aWV3LnJlbmRlckRyYWcoZHJvcExvY2F0aW9uLCBzZWcpKSkge1xuXG5cdFx0XHRcdFx0ZHJhZ0hlbHBlckVscy5hZGRDbGFzcygnZmMtZHJhZ2dpbmcnKTtcblx0XHRcdFx0XHRpZiAoIWRyYWdMaXN0ZW5lci5pc1RvdWNoKSB7XG5cdFx0XHRcdFx0XHRfdGhpcy5hcHBseURyYWdPcGFjaXR5KGRyYWdIZWxwZXJFbHMpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG1vdXNlRm9sbG93ZXIuaGlkZSgpOyAvLyBpZiB0aGUgc3ViY2xhc3MgaXMgYWxyZWFkeSB1c2luZyBhIG1vY2sgZXZlbnQgXCJoZWxwZXJcIiwgaGlkZSBvdXIgb3duXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0bW91c2VGb2xsb3dlci5zaG93KCk7IC8vIG90aGVyd2lzZSwgaGF2ZSB0aGUgaGVscGVyIGZvbGxvdyB0aGUgbW91c2UgKG5vIHNuYXBwaW5nKVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGlzT3JpZykge1xuXHRcdFx0XHRcdGRyb3BMb2NhdGlvbiA9IG51bGw7IC8vIG5lZWRzIHRvIGhhdmUgbW92ZWQgaGl0cyB0byBiZSBhIHZhbGlkIGRyb3Bcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGhpdE91dDogZnVuY3Rpb24oKSB7IC8vIGNhbGxlZCBiZWZvcmUgbW91c2UgbW92ZXMgdG8gYSBkaWZmZXJlbnQgaGl0IE9SIG1vdmVkIG91dCBvZiBhbGwgaGl0c1xuXHRcdFx0XHR2aWV3LnVucmVuZGVyRHJhZygpOyAvLyB1bnJlbmRlciB3aGF0ZXZlciB3YXMgZG9uZSBpbiByZW5kZXJEcmFnXG5cdFx0XHRcdG1vdXNlRm9sbG93ZXIuc2hvdygpOyAvLyBzaG93IGluIGNhc2Ugd2UgYXJlIG1vdmluZyBvdXQgb2YgYWxsIGhpdHNcblx0XHRcdFx0ZHJvcExvY2F0aW9uID0gbnVsbDtcblx0XHRcdH0sXG5cdFx0XHRoaXREb25lOiBmdW5jdGlvbigpIHsgLy8gQ2FsbGVkIGFmdGVyIGEgaGl0T3V0IE9SIGJlZm9yZSBhIGRyYWdFbmRcblx0XHRcdFx0ZW5hYmxlQ3Vyc29yKCk7XG5cdFx0XHR9LFxuXHRcdFx0aW50ZXJhY3Rpb25FbmQ6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0XHRcdGRlbGV0ZSBzZWcuY29tcG9uZW50OyAvLyBwcmV2ZW50IHNpZGUgZWZmZWN0c1xuXG5cdFx0XHRcdC8vIGRvIHJldmVydCBhbmltYXRpb24gaWYgaGFzbid0IGNoYW5nZWQuIGNhbGxzIGEgY2FsbGJhY2sgd2hlbiBmaW5pc2hlZCAod2hldGhlciBhbmltYXRpb24gb3Igbm90KVxuXHRcdFx0XHRtb3VzZUZvbGxvd2VyLnN0b3AoIWRyb3BMb2NhdGlvbiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKGlzRHJhZ2dpbmcpIHtcblx0XHRcdFx0XHRcdHZpZXcudW5yZW5kZXJEcmFnKCk7XG5cdFx0XHRcdFx0XHR2aWV3LnNob3dFdmVudChldmVudCk7XG5cdFx0XHRcdFx0XHRfdGhpcy5zZWdEcmFnU3RvcChzZWcsIGV2KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGRyb3BMb2NhdGlvbikge1xuXHRcdFx0XHRcdFx0dmlldy5yZXBvcnRFdmVudERyb3AoZXZlbnQsIGRyb3BMb2NhdGlvbiwgdGhpcy5sYXJnZVVuaXQsIGVsLCBldik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0X3RoaXMuc2VnRHJhZ0xpc3RlbmVyID0gbnVsbDtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiBkcmFnTGlzdGVuZXI7XG5cdH0sXG5cblxuXHQvLyBzZWcgaXNuJ3QgZHJhZ2dhYmxlLCBidXQgbGV0J3MgdXNlIGEgZ2VuZXJpYyBEcmFnTGlzdGVuZXJcblx0Ly8gc2ltcGx5IGZvciB0aGUgZGVsYXksIHNvIGl0IGNhbiBiZSBzZWxlY3RlZC5cblx0Ly8gSGFzIHNpZGUgZWZmZWN0IG9mIHNldHRpbmcvdW5zZXR0aW5nIGBzZWdEcmFnTGlzdGVuZXJgXG5cdGJ1aWxkU2VnU2VsZWN0TGlzdGVuZXI6IGZ1bmN0aW9uKHNlZykge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIGV2ZW50ID0gc2VnLmV2ZW50O1xuXG5cdFx0aWYgKHRoaXMuc2VnRHJhZ0xpc3RlbmVyKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZWdEcmFnTGlzdGVuZXI7XG5cdFx0fVxuXG5cdFx0dmFyIGRyYWdMaXN0ZW5lciA9IHRoaXMuc2VnRHJhZ0xpc3RlbmVyID0gbmV3IERyYWdMaXN0ZW5lcih7XG5cdFx0XHRkcmFnU3RhcnQ6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0XHRcdGlmIChkcmFnTGlzdGVuZXIuaXNUb3VjaCAmJiAhdmlldy5pc0V2ZW50U2VsZWN0ZWQoZXZlbnQpKSB7XG5cdFx0XHRcdFx0Ly8gaWYgbm90IHByZXZpb3VzbHkgc2VsZWN0ZWQsIHdpbGwgZmlyZSBhZnRlciBhIGRlbGF5LiB0aGVuLCBzZWxlY3QgdGhlIGV2ZW50XG5cdFx0XHRcdFx0dmlldy5zZWxlY3RFdmVudChldmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRpbnRlcmFjdGlvbkVuZDogZnVuY3Rpb24oZXYpIHtcblx0XHRcdFx0X3RoaXMuc2VnRHJhZ0xpc3RlbmVyID0gbnVsbDtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiBkcmFnTGlzdGVuZXI7XG5cdH0sXG5cblxuXHQvLyBDYWxsZWQgYmVmb3JlIGV2ZW50IHNlZ21lbnQgZHJhZ2dpbmcgc3RhcnRzXG5cdHNlZ0RyYWdTdGFydDogZnVuY3Rpb24oc2VnLCBldikge1xuXHRcdHRoaXMuaXNEcmFnZ2luZ1NlZyA9IHRydWU7XG5cdFx0dGhpcy52aWV3LnRyaWdnZXIoJ2V2ZW50RHJhZ1N0YXJ0Jywgc2VnLmVsWzBdLCBzZWcuZXZlbnQsIGV2LCB7fSk7IC8vIGxhc3QgYXJndW1lbnQgaXMganF1aSBkdW1teVxuXHR9LFxuXG5cblx0Ly8gQ2FsbGVkIGFmdGVyIGV2ZW50IHNlZ21lbnQgZHJhZ2dpbmcgc3RvcHNcblx0c2VnRHJhZ1N0b3A6IGZ1bmN0aW9uKHNlZywgZXYpIHtcblx0XHR0aGlzLmlzRHJhZ2dpbmdTZWcgPSBmYWxzZTtcblx0XHR0aGlzLnZpZXcudHJpZ2dlcignZXZlbnREcmFnU3RvcCcsIHNlZy5lbFswXSwgc2VnLmV2ZW50LCBldiwge30pOyAvLyBsYXN0IGFyZ3VtZW50IGlzIGpxdWkgZHVtbXlcblx0fSxcblxuXG5cdC8vIEdpdmVuIHRoZSBzcGFucyBhbiBldmVudCBkcmFnIGJlZ2FuLCBhbmQgdGhlIHNwYW4gZXZlbnQgd2FzIGRyb3BwZWQsIGNhbGN1bGF0ZXMgdGhlIG5ldyB6b25lZCBzdGFydC9lbmQvYWxsRGF5XG5cdC8vIHZhbHVlcyBmb3IgdGhlIGV2ZW50LiBTdWJjbGFzc2VzIG1heSBvdmVycmlkZSBhbmQgc2V0IGFkZGl0aW9uYWwgcHJvcGVydGllcyB0byBiZSB1c2VkIGJ5IHJlbmRlckRyYWcuXG5cdC8vIEEgZmFsc3kgcmV0dXJuZWQgdmFsdWUgaW5kaWNhdGVzIGFuIGludmFsaWQgZHJvcC5cblx0Ly8gRE9FUyBOT1QgY29uc2lkZXIgb3ZlcmxhcC9jb25zdHJhaW50LlxuXHRjb21wdXRlRXZlbnREcm9wOiBmdW5jdGlvbihzdGFydFNwYW4sIGVuZFNwYW4sIGV2ZW50KSB7XG5cdFx0dmFyIGNhbGVuZGFyID0gdGhpcy52aWV3LmNhbGVuZGFyO1xuXHRcdHZhciBkcmFnU3RhcnQgPSBzdGFydFNwYW4uc3RhcnQ7XG5cdFx0dmFyIGRyYWdFbmQgPSBlbmRTcGFuLnN0YXJ0O1xuXHRcdHZhciBkZWx0YTtcblx0XHR2YXIgZHJvcExvY2F0aW9uOyAvLyB6b25lZCBldmVudCBkYXRlIHByb3BlcnRpZXNcblxuXHRcdGlmIChkcmFnU3RhcnQuaGFzVGltZSgpID09PSBkcmFnRW5kLmhhc1RpbWUoKSkge1xuXHRcdFx0ZGVsdGEgPSB0aGlzLmRpZmZEYXRlcyhkcmFnRW5kLCBkcmFnU3RhcnQpO1xuXG5cdFx0XHQvLyBpZiBhbiBhbGwtZGF5IGV2ZW50IHdhcyBpbiBhIHRpbWVkIGFyZWEgYW5kIGl0IHdhcyBkcmFnZ2VkIHRvIGEgZGlmZmVyZW50IHRpbWUsXG5cdFx0XHQvLyBndWFyYW50ZWUgYW4gZW5kIGFuZCBhZGp1c3Qgc3RhcnQvZW5kIHRvIGhhdmUgdGltZXNcblx0XHRcdGlmIChldmVudC5hbGxEYXkgJiYgZHVyYXRpb25IYXNUaW1lKGRlbHRhKSkge1xuXHRcdFx0XHRkcm9wTG9jYXRpb24gPSB7XG5cdFx0XHRcdFx0c3RhcnQ6IGV2ZW50LnN0YXJ0LmNsb25lKCksXG5cdFx0XHRcdFx0ZW5kOiBjYWxlbmRhci5nZXRFdmVudEVuZChldmVudCksIC8vIHdpbGwgYmUgYW4gYW1iaWcgZGF5XG5cdFx0XHRcdFx0YWxsRGF5OiBmYWxzZSAvLyBmb3Igbm9ybWFsaXplRXZlbnRUaW1lc1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRjYWxlbmRhci5ub3JtYWxpemVFdmVudFRpbWVzKGRyb3BMb2NhdGlvbik7XG5cdFx0XHR9XG5cdFx0XHQvLyBvdGhld2lzZSwgd29yayBvZmYgZXhpc3RpbmcgdmFsdWVzXG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0ZHJvcExvY2F0aW9uID0gcGx1Y2tFdmVudERhdGVQcm9wcyhldmVudCk7XG5cdFx0XHR9XG5cblx0XHRcdGRyb3BMb2NhdGlvbi5zdGFydC5hZGQoZGVsdGEpO1xuXHRcdFx0aWYgKGRyb3BMb2NhdGlvbi5lbmQpIHtcblx0XHRcdFx0ZHJvcExvY2F0aW9uLmVuZC5hZGQoZGVsdGEpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIGlmIHN3aXRjaGluZyBmcm9tIGRheSA8LT4gdGltZWQsIHN0YXJ0IHNob3VsZCBiZSByZXNldCB0byB0aGUgZHJvcHBlZCBkYXRlLCBhbmQgdGhlIGVuZCBjbGVhcmVkXG5cdFx0XHRkcm9wTG9jYXRpb24gPSB7XG5cdFx0XHRcdHN0YXJ0OiBkcmFnRW5kLmNsb25lKCksXG5cdFx0XHRcdGVuZDogbnVsbCwgLy8gZW5kIHNob3VsZCBiZSBjbGVhcmVkXG5cdFx0XHRcdGFsbERheTogIWRyYWdFbmQuaGFzVGltZSgpXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHJldHVybiBkcm9wTG9jYXRpb247XG5cdH0sXG5cblxuXHQvLyBVdGlsaXR5IGZvciBhcHBseSBkcmFnT3BhY2l0eSB0byBhIGpRdWVyeSBzZXRcblx0YXBwbHlEcmFnT3BhY2l0eTogZnVuY3Rpb24oZWxzKSB7XG5cdFx0dmFyIG9wYWNpdHkgPSB0aGlzLnZpZXcub3B0KCdkcmFnT3BhY2l0eScpO1xuXG5cdFx0aWYgKG9wYWNpdHkgIT0gbnVsbCkge1xuXHRcdFx0ZWxzLmNzcygnb3BhY2l0eScsIG9wYWNpdHkpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8qIEV4dGVybmFsIEVsZW1lbnQgRHJhZ2dpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIENhbGxlZCB3aGVuIGEgalF1ZXJ5IFVJIGRyYWcgaXMgaW5pdGlhdGVkIGFueXdoZXJlIGluIHRoZSBET01cblx0ZXh0ZXJuYWxEcmFnU3RhcnQ6IGZ1bmN0aW9uKGV2LCB1aSkge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXHRcdHZhciBlbDtcblx0XHR2YXIgYWNjZXB0O1xuXG5cdFx0aWYgKHZpZXcub3B0KCdkcm9wcGFibGUnKSkgeyAvLyBvbmx5IGxpc3RlbiBpZiB0aGlzIHNldHRpbmcgaXMgb25cblx0XHRcdGVsID0gJCgodWkgPyB1aS5pdGVtIDogbnVsbCkgfHwgZXYudGFyZ2V0KTtcblxuXHRcdFx0Ly8gVGVzdCB0aGF0IHRoZSBkcmFnZ2VkIGVsZW1lbnQgcGFzc2VzIHRoZSBkcm9wQWNjZXB0IHNlbGVjdG9yIG9yIGZpbHRlciBmdW5jdGlvbi5cblx0XHRcdC8vIEZZSSwgdGhlIGRlZmF1bHQgaXMgXCIqXCIgKG1hdGNoZXMgYWxsKVxuXHRcdFx0YWNjZXB0ID0gdmlldy5vcHQoJ2Ryb3BBY2NlcHQnKTtcblx0XHRcdGlmICgkLmlzRnVuY3Rpb24oYWNjZXB0KSA/IGFjY2VwdC5jYWxsKGVsWzBdLCBlbCkgOiBlbC5pcyhhY2NlcHQpKSB7XG5cdFx0XHRcdGlmICghdGhpcy5pc0RyYWdnaW5nRXh0ZXJuYWwpIHsgLy8gcHJldmVudCBkb3VibGUtbGlzdGVuaW5nIGlmIGZpcmVkIHR3aWNlXG5cdFx0XHRcdFx0dGhpcy5saXN0ZW5Ub0V4dGVybmFsRHJhZyhlbCwgZXYsIHVpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXG5cdC8vIENhbGxlZCB3aGVuIGEgalF1ZXJ5IFVJIGRyYWcgc3RhcnRzIGFuZCBpdCBuZWVkcyB0byBiZSBtb25pdG9yZWQgZm9yIGRyb3BwaW5nXG5cdGxpc3RlblRvRXh0ZXJuYWxEcmFnOiBmdW5jdGlvbihlbCwgZXYsIHVpKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR2YXIgY2FsZW5kYXIgPSB0aGlzLnZpZXcuY2FsZW5kYXI7XG5cdFx0dmFyIG1ldGEgPSBnZXREcmFnZ2VkRWxNZXRhKGVsKTsgLy8gZXh0cmEgZGF0YSBhYm91dCBldmVudCBkcm9wLCBpbmNsdWRpbmcgcG9zc2libGUgZXZlbnQgdG8gY3JlYXRlXG5cdFx0dmFyIGRyb3BMb2NhdGlvbjsgLy8gYSBudWxsIHZhbHVlIHNpZ25hbHMgYW4gdW5zdWNjZXNzZnVsIGRyYWdcblxuXHRcdC8vIGxpc3RlbmVyIHRoYXQgdHJhY2tzIG1vdXNlIG1vdmVtZW50IG92ZXIgZGF0ZS1hc3NvY2lhdGVkIHBpeGVsIHJlZ2lvbnNcblx0XHR2YXIgZHJhZ0xpc3RlbmVyID0gX3RoaXMuZXh0ZXJuYWxEcmFnTGlzdGVuZXIgPSBuZXcgSGl0RHJhZ0xpc3RlbmVyKHRoaXMsIHtcblx0XHRcdGludGVyYWN0aW9uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRfdGhpcy5pc0RyYWdnaW5nRXh0ZXJuYWwgPSB0cnVlO1xuXHRcdFx0fSxcblx0XHRcdGhpdE92ZXI6IGZ1bmN0aW9uKGhpdCkge1xuXHRcdFx0XHRkcm9wTG9jYXRpb24gPSBfdGhpcy5jb21wdXRlRXh0ZXJuYWxEcm9wKFxuXHRcdFx0XHRcdGhpdC5jb21wb25lbnQuZ2V0SGl0U3BhbihoaXQpLCAvLyBzaW5jZSB3ZSBhcmUgcXVlcnlpbmcgdGhlIHBhcmVudCB2aWV3LCBtaWdodCBub3QgYmVsb25nIHRvIHRoaXMgZ3JpZFxuXHRcdFx0XHRcdG1ldGFcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRpZiAoIC8vIGludmFsaWQgaGl0P1xuXHRcdFx0XHRcdGRyb3BMb2NhdGlvbiAmJlxuXHRcdFx0XHRcdCFjYWxlbmRhci5pc0V4dGVybmFsU3BhbkFsbG93ZWQoX3RoaXMuZXZlbnRUb1NwYW4oZHJvcExvY2F0aW9uKSwgZHJvcExvY2F0aW9uLCBtZXRhLmV2ZW50UHJvcHMpXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGRpc2FibGVDdXJzb3IoKTtcblx0XHRcdFx0XHRkcm9wTG9jYXRpb24gPSBudWxsO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGRyb3BMb2NhdGlvbikge1xuXHRcdFx0XHRcdF90aGlzLnJlbmRlckRyYWcoZHJvcExvY2F0aW9uKTsgLy8gY2FsbGVkIHdpdGhvdXQgYSBzZWcgcGFyYW1ldGVyXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRoaXRPdXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkcm9wTG9jYXRpb24gPSBudWxsOyAvLyBzaWduYWwgdW5zdWNjZXNzZnVsXG5cdFx0XHR9LFxuXHRcdFx0aGl0RG9uZTogZnVuY3Rpb24oKSB7IC8vIENhbGxlZCBhZnRlciBhIGhpdE91dCBPUiBiZWZvcmUgYSBkcmFnRW5kXG5cdFx0XHRcdGVuYWJsZUN1cnNvcigpO1xuXHRcdFx0XHRfdGhpcy51bnJlbmRlckRyYWcoKTtcblx0XHRcdH0sXG5cdFx0XHRpbnRlcmFjdGlvbkVuZDogZnVuY3Rpb24oZXYpIHtcblx0XHRcdFx0aWYgKGRyb3BMb2NhdGlvbikgeyAvLyBlbGVtZW50IHdhcyBkcm9wcGVkIG9uIGEgdmFsaWQgaGl0XG5cdFx0XHRcdFx0X3RoaXMudmlldy5yZXBvcnRFeHRlcm5hbERyb3AobWV0YSwgZHJvcExvY2F0aW9uLCBlbCwgZXYsIHVpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRfdGhpcy5pc0RyYWdnaW5nRXh0ZXJuYWwgPSBmYWxzZTtcblx0XHRcdFx0X3RoaXMuZXh0ZXJuYWxEcmFnTGlzdGVuZXIgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0ZHJhZ0xpc3RlbmVyLnN0YXJ0RHJhZyhldik7IC8vIHN0YXJ0IGxpc3RlbmluZyBpbW1lZGlhdGVseVxuXHR9LFxuXG5cblx0Ly8gR2l2ZW4gYSBoaXQgdG8gYmUgZHJvcHBlZCB1cG9uLCBhbmQgbWlzYyBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUganF1aSBkcmFnIChndWFyYW50ZWVkIHRvIGJlIGEgcGxhaW4gb2JqZWN0KSxcblx0Ly8gcmV0dXJucyB0aGUgem9uZWQgc3RhcnQvZW5kIGRhdGVzIGZvciB0aGUgZXZlbnQgdGhhdCB3b3VsZCByZXN1bHQgZnJvbSB0aGUgaHlwb3RoZXRpY2FsIGRyb3AuIGVuZCBtaWdodCBiZSBudWxsLlxuXHQvLyBSZXR1cm5pbmcgYSBudWxsIHZhbHVlIHNpZ25hbHMgYW4gaW52YWxpZCBkcm9wIGhpdC5cblx0Ly8gRE9FUyBOT1QgY29uc2lkZXIgb3ZlcmxhcC9jb25zdHJhaW50LlxuXHRjb21wdXRlRXh0ZXJuYWxEcm9wOiBmdW5jdGlvbihzcGFuLCBtZXRhKSB7XG5cdFx0dmFyIGNhbGVuZGFyID0gdGhpcy52aWV3LmNhbGVuZGFyO1xuXHRcdHZhciBkcm9wTG9jYXRpb24gPSB7XG5cdFx0XHRzdGFydDogY2FsZW5kYXIuYXBwbHlUaW1lem9uZShzcGFuLnN0YXJ0KSwgLy8gc2ltdWxhdGUgYSB6b25lZCBldmVudCBzdGFydCBkYXRlXG5cdFx0XHRlbmQ6IG51bGxcblx0XHR9O1xuXG5cdFx0Ly8gaWYgZHJvcHBlZCBvbiBhbiBhbGwtZGF5IHNwYW4sIGFuZCBlbGVtZW50J3MgbWV0YWRhdGEgc3BlY2lmaWVkIGEgdGltZSwgc2V0IGl0XG5cdFx0aWYgKG1ldGEuc3RhcnRUaW1lICYmICFkcm9wTG9jYXRpb24uc3RhcnQuaGFzVGltZSgpKSB7XG5cdFx0XHRkcm9wTG9jYXRpb24uc3RhcnQudGltZShtZXRhLnN0YXJ0VGltZSk7XG5cdFx0fVxuXG5cdFx0aWYgKG1ldGEuZHVyYXRpb24pIHtcblx0XHRcdGRyb3BMb2NhdGlvbi5lbmQgPSBkcm9wTG9jYXRpb24uc3RhcnQuY2xvbmUoKS5hZGQobWV0YS5kdXJhdGlvbik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRyb3BMb2NhdGlvbjtcblx0fSxcblxuXG5cblx0LyogRHJhZyBSZW5kZXJpbmcgKGZvciBib3RoIGV2ZW50cyBhbmQgYW4gZXh0ZXJuYWwgZWxlbWVudHMpXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBSZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgYW4gZXZlbnQgb3IgZXh0ZXJuYWwgZWxlbWVudCBiZWluZyBkcmFnZ2VkLlxuXHQvLyBgZHJvcExvY2F0aW9uYCBjb250YWlucyBoeXBvdGhldGljYWwgc3RhcnQvZW5kL2FsbERheSB2YWx1ZXMgdGhlIGV2ZW50IHdvdWxkIGhhdmUgaWYgZHJvcHBlZC4gZW5kIGNhbiBiZSBudWxsLlxuXHQvLyBgc2VnYCBpcyB0aGUgaW50ZXJuYWwgc2VnbWVudCBvYmplY3QgdGhhdCBpcyBiZWluZyBkcmFnZ2VkLiBJZiBkcmFnZ2luZyBhbiBleHRlcm5hbCBlbGVtZW50LCBgc2VnYCBpcyBudWxsLlxuXHQvLyBBIHRydXRoeSByZXR1cm5lZCB2YWx1ZSBpbmRpY2F0ZXMgdGhpcyBtZXRob2QgaGFzIHJlbmRlcmVkIGEgaGVscGVyIGVsZW1lbnQuXG5cdC8vIE11c3QgcmV0dXJuIGVsZW1lbnRzIHVzZWQgZm9yIGFueSBtb2NrIGV2ZW50cy5cblx0cmVuZGVyRHJhZzogZnVuY3Rpb24oZHJvcExvY2F0aW9uLCBzZWcpIHtcblx0XHQvLyBzdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50XG5cdH0sXG5cblxuXHQvLyBVbnJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhbiBldmVudCBvciBleHRlcm5hbCBlbGVtZW50IGJlaW5nIGRyYWdnZWRcblx0dW5yZW5kZXJEcmFnOiBmdW5jdGlvbigpIHtcblx0XHQvLyBzdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50XG5cdH0sXG5cblxuXHQvKiBSZXNpemluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gQ3JlYXRlcyBhIGxpc3RlbmVyIHRoYXQgdHJhY2tzIHRoZSB1c2VyIGFzIHRoZXkgcmVzaXplIGFuIGV2ZW50IHNlZ21lbnQuXG5cdC8vIEdlbmVyaWMgZW5vdWdoIHRvIHdvcmsgd2l0aCBhbnkgdHlwZSBvZiBHcmlkLlxuXHRidWlsZFNlZ1Jlc2l6ZUxpc3RlbmVyOiBmdW5jdGlvbihzZWcsIGlzU3RhcnQpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXHRcdHZhciBjYWxlbmRhciA9IHZpZXcuY2FsZW5kYXI7XG5cdFx0dmFyIGVsID0gc2VnLmVsO1xuXHRcdHZhciBldmVudCA9IHNlZy5ldmVudDtcblx0XHR2YXIgZXZlbnRFbmQgPSBjYWxlbmRhci5nZXRFdmVudEVuZChldmVudCk7XG5cdFx0dmFyIGlzRHJhZ2dpbmc7XG5cdFx0dmFyIHJlc2l6ZUxvY2F0aW9uOyAvLyB6b25lZCBldmVudCBkYXRlIHByb3BlcnRpZXMuIGZhbHN5IGlmIGludmFsaWQgcmVzaXplXG5cblx0XHQvLyBUcmFja3MgbW91c2UgbW92ZW1lbnQgb3ZlciB0aGUgKmdyaWQncyogY29vcmRpbmF0ZSBtYXBcblx0XHR2YXIgZHJhZ0xpc3RlbmVyID0gdGhpcy5zZWdSZXNpemVMaXN0ZW5lciA9IG5ldyBIaXREcmFnTGlzdGVuZXIodGhpcywge1xuXHRcdFx0c2Nyb2xsOiB2aWV3Lm9wdCgnZHJhZ1Njcm9sbCcpLFxuXHRcdFx0c3ViamVjdEVsOiBlbCxcblx0XHRcdGludGVyYWN0aW9uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpc0RyYWdnaW5nID0gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0ZHJhZ1N0YXJ0OiBmdW5jdGlvbihldikge1xuXHRcdFx0XHRpc0RyYWdnaW5nID0gdHJ1ZTtcblx0XHRcdFx0X3RoaXMuaGFuZGxlU2VnTW91c2VvdXQoc2VnLCBldik7IC8vIGVuc3VyZSBhIG1vdXNlb3V0IG9uIHRoZSBtYW5pcHVsYXRlZCBldmVudCBoYXMgYmVlbiByZXBvcnRlZFxuXHRcdFx0XHRfdGhpcy5zZWdSZXNpemVTdGFydChzZWcsIGV2KTtcblx0XHRcdH0sXG5cdFx0XHRoaXRPdmVyOiBmdW5jdGlvbihoaXQsIGlzT3JpZywgb3JpZ0hpdCkge1xuXHRcdFx0XHR2YXIgb3JpZ0hpdFNwYW4gPSBfdGhpcy5nZXRIaXRTcGFuKG9yaWdIaXQpO1xuXHRcdFx0XHR2YXIgaGl0U3BhbiA9IF90aGlzLmdldEhpdFNwYW4oaGl0KTtcblxuXHRcdFx0XHRyZXNpemVMb2NhdGlvbiA9IGlzU3RhcnQgP1xuXHRcdFx0XHRcdF90aGlzLmNvbXB1dGVFdmVudFN0YXJ0UmVzaXplKG9yaWdIaXRTcGFuLCBoaXRTcGFuLCBldmVudCkgOlxuXHRcdFx0XHRcdF90aGlzLmNvbXB1dGVFdmVudEVuZFJlc2l6ZShvcmlnSGl0U3BhbiwgaGl0U3BhbiwgZXZlbnQpO1xuXG5cdFx0XHRcdGlmIChyZXNpemVMb2NhdGlvbikge1xuXHRcdFx0XHRcdGlmICghY2FsZW5kYXIuaXNFdmVudFNwYW5BbGxvd2VkKF90aGlzLmV2ZW50VG9TcGFuKHJlc2l6ZUxvY2F0aW9uKSwgZXZlbnQpKSB7XG5cdFx0XHRcdFx0XHRkaXNhYmxlQ3Vyc29yKCk7XG5cdFx0XHRcdFx0XHRyZXNpemVMb2NhdGlvbiA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIG5vIGNoYW5nZT8gKEZZSSwgZXZlbnQgZGF0ZXMgbWlnaHQgaGF2ZSB6b25lcylcblx0XHRcdFx0XHRlbHNlIGlmIChcblx0XHRcdFx0XHRcdHJlc2l6ZUxvY2F0aW9uLnN0YXJ0LmlzU2FtZShldmVudC5zdGFydC5jbG9uZSgpLnN0cmlwWm9uZSgpKSAmJlxuXHRcdFx0XHRcdFx0cmVzaXplTG9jYXRpb24uZW5kLmlzU2FtZShldmVudEVuZC5jbG9uZSgpLnN0cmlwWm9uZSgpKVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0cmVzaXplTG9jYXRpb24gPSBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChyZXNpemVMb2NhdGlvbikge1xuXHRcdFx0XHRcdHZpZXcuaGlkZUV2ZW50KGV2ZW50KTtcblx0XHRcdFx0XHRfdGhpcy5yZW5kZXJFdmVudFJlc2l6ZShyZXNpemVMb2NhdGlvbiwgc2VnKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGhpdE91dDogZnVuY3Rpb24oKSB7IC8vIGNhbGxlZCBiZWZvcmUgbW91c2UgbW92ZXMgdG8gYSBkaWZmZXJlbnQgaGl0IE9SIG1vdmVkIG91dCBvZiBhbGwgaGl0c1xuXHRcdFx0XHRyZXNpemVMb2NhdGlvbiA9IG51bGw7XG5cdFx0XHR9LFxuXHRcdFx0aGl0RG9uZTogZnVuY3Rpb24oKSB7IC8vIHJlc2V0cyB0aGUgcmVuZGVyaW5nIHRvIHNob3cgdGhlIG9yaWdpbmFsIGV2ZW50XG5cdFx0XHRcdF90aGlzLnVucmVuZGVyRXZlbnRSZXNpemUoKTtcblx0XHRcdFx0dmlldy5zaG93RXZlbnQoZXZlbnQpO1xuXHRcdFx0XHRlbmFibGVDdXJzb3IoKTtcblx0XHRcdH0sXG5cdFx0XHRpbnRlcmFjdGlvbkVuZDogZnVuY3Rpb24oZXYpIHtcblx0XHRcdFx0aWYgKGlzRHJhZ2dpbmcpIHtcblx0XHRcdFx0XHRfdGhpcy5zZWdSZXNpemVTdG9wKHNlZywgZXYpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChyZXNpemVMb2NhdGlvbikgeyAvLyB2YWxpZCBkYXRlIHRvIHJlc2l6ZSB0bz9cblx0XHRcdFx0XHR2aWV3LnJlcG9ydEV2ZW50UmVzaXplKGV2ZW50LCByZXNpemVMb2NhdGlvbiwgdGhpcy5sYXJnZVVuaXQsIGVsLCBldik7XG5cdFx0XHRcdH1cblx0XHRcdFx0X3RoaXMuc2VnUmVzaXplTGlzdGVuZXIgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGRyYWdMaXN0ZW5lcjtcblx0fSxcblxuXG5cdC8vIENhbGxlZCBiZWZvcmUgZXZlbnQgc2VnbWVudCByZXNpemluZyBzdGFydHNcblx0c2VnUmVzaXplU3RhcnQ6IGZ1bmN0aW9uKHNlZywgZXYpIHtcblx0XHR0aGlzLmlzUmVzaXppbmdTZWcgPSB0cnVlO1xuXHRcdHRoaXMudmlldy50cmlnZ2VyKCdldmVudFJlc2l6ZVN0YXJ0Jywgc2VnLmVsWzBdLCBzZWcuZXZlbnQsIGV2LCB7fSk7IC8vIGxhc3QgYXJndW1lbnQgaXMganF1aSBkdW1teVxuXHR9LFxuXG5cblx0Ly8gQ2FsbGVkIGFmdGVyIGV2ZW50IHNlZ21lbnQgcmVzaXppbmcgc3RvcHNcblx0c2VnUmVzaXplU3RvcDogZnVuY3Rpb24oc2VnLCBldikge1xuXHRcdHRoaXMuaXNSZXNpemluZ1NlZyA9IGZhbHNlO1xuXHRcdHRoaXMudmlldy50cmlnZ2VyKCdldmVudFJlc2l6ZVN0b3AnLCBzZWcuZWxbMF0sIHNlZy5ldmVudCwgZXYsIHt9KTsgLy8gbGFzdCBhcmd1bWVudCBpcyBqcXVpIGR1bW15XG5cdH0sXG5cblxuXHQvLyBSZXR1cm5zIG5ldyBkYXRlLWluZm9ybWF0aW9uIGZvciBhbiBldmVudCBzZWdtZW50IGJlaW5nIHJlc2l6ZWQgZnJvbSBpdHMgc3RhcnRcblx0Y29tcHV0ZUV2ZW50U3RhcnRSZXNpemU6IGZ1bmN0aW9uKHN0YXJ0U3BhbiwgZW5kU3BhbiwgZXZlbnQpIHtcblx0XHRyZXR1cm4gdGhpcy5jb21wdXRlRXZlbnRSZXNpemUoJ3N0YXJ0Jywgc3RhcnRTcGFuLCBlbmRTcGFuLCBldmVudCk7XG5cdH0sXG5cblxuXHQvLyBSZXR1cm5zIG5ldyBkYXRlLWluZm9ybWF0aW9uIGZvciBhbiBldmVudCBzZWdtZW50IGJlaW5nIHJlc2l6ZWQgZnJvbSBpdHMgZW5kXG5cdGNvbXB1dGVFdmVudEVuZFJlc2l6ZTogZnVuY3Rpb24oc3RhcnRTcGFuLCBlbmRTcGFuLCBldmVudCkge1xuXHRcdHJldHVybiB0aGlzLmNvbXB1dGVFdmVudFJlc2l6ZSgnZW5kJywgc3RhcnRTcGFuLCBlbmRTcGFuLCBldmVudCk7XG5cdH0sXG5cblxuXHQvLyBSZXR1cm5zIG5ldyB6b25lZCBkYXRlIGluZm9ybWF0aW9uIGZvciBhbiBldmVudCBzZWdtZW50IGJlaW5nIHJlc2l6ZWQgZnJvbSBpdHMgc3RhcnQgT1IgZW5kXG5cdC8vIGB0eXBlYCBpcyBlaXRoZXIgJ3N0YXJ0JyBvciAnZW5kJy5cblx0Ly8gRE9FUyBOT1QgY29uc2lkZXIgb3ZlcmxhcC9jb25zdHJhaW50LlxuXHRjb21wdXRlRXZlbnRSZXNpemU6IGZ1bmN0aW9uKHR5cGUsIHN0YXJ0U3BhbiwgZW5kU3BhbiwgZXZlbnQpIHtcblx0XHR2YXIgY2FsZW5kYXIgPSB0aGlzLnZpZXcuY2FsZW5kYXI7XG5cdFx0dmFyIGRlbHRhID0gdGhpcy5kaWZmRGF0ZXMoZW5kU3Bhblt0eXBlXSwgc3RhcnRTcGFuW3R5cGVdKTtcblx0XHR2YXIgcmVzaXplTG9jYXRpb247IC8vIHpvbmVkIGV2ZW50IGRhdGUgcHJvcGVydGllc1xuXHRcdHZhciBkZWZhdWx0RHVyYXRpb247XG5cblx0XHQvLyBidWlsZCBvcmlnaW5hbCB2YWx1ZXMgdG8gd29yayBmcm9tLCBndWFyYW50ZWVpbmcgYSBzdGFydCBhbmQgZW5kXG5cdFx0cmVzaXplTG9jYXRpb24gPSB7XG5cdFx0XHRzdGFydDogZXZlbnQuc3RhcnQuY2xvbmUoKSxcblx0XHRcdGVuZDogY2FsZW5kYXIuZ2V0RXZlbnRFbmQoZXZlbnQpLFxuXHRcdFx0YWxsRGF5OiBldmVudC5hbGxEYXlcblx0XHR9O1xuXG5cdFx0Ly8gaWYgYW4gYWxsLWRheSBldmVudCB3YXMgaW4gYSB0aW1lZCBhcmVhIGFuZCB3YXMgcmVzaXplZCB0byBhIHRpbWUsIGFkanVzdCBzdGFydC9lbmQgdG8gaGF2ZSB0aW1lc1xuXHRcdGlmIChyZXNpemVMb2NhdGlvbi5hbGxEYXkgJiYgZHVyYXRpb25IYXNUaW1lKGRlbHRhKSkge1xuXHRcdFx0cmVzaXplTG9jYXRpb24uYWxsRGF5ID0gZmFsc2U7XG5cdFx0XHRjYWxlbmRhci5ub3JtYWxpemVFdmVudFRpbWVzKHJlc2l6ZUxvY2F0aW9uKTtcblx0XHR9XG5cblx0XHRyZXNpemVMb2NhdGlvblt0eXBlXS5hZGQoZGVsdGEpOyAvLyBhcHBseSBkZWx0YSB0byBzdGFydCBvciBlbmRcblxuXHRcdC8vIGlmIHRoZSBldmVudCB3YXMgY29tcHJlc3NlZCB0b28gc21hbGwsIGZpbmQgYSBuZXcgcmVhc29uYWJsZSBkdXJhdGlvbiBmb3IgaXRcblx0XHRpZiAoIXJlc2l6ZUxvY2F0aW9uLnN0YXJ0LmlzQmVmb3JlKHJlc2l6ZUxvY2F0aW9uLmVuZCkpIHtcblxuXHRcdFx0ZGVmYXVsdER1cmF0aW9uID1cblx0XHRcdFx0dGhpcy5taW5SZXNpemVEdXJhdGlvbiB8fCAvLyBUT0RPOiBoYWNrXG5cdFx0XHRcdChldmVudC5hbGxEYXkgP1xuXHRcdFx0XHRcdGNhbGVuZGFyLmRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uIDpcblx0XHRcdFx0XHRjYWxlbmRhci5kZWZhdWx0VGltZWRFdmVudER1cmF0aW9uKTtcblxuXHRcdFx0aWYgKHR5cGUgPT0gJ3N0YXJ0JykgeyAvLyByZXNpemluZyB0aGUgc3RhcnQ/XG5cdFx0XHRcdHJlc2l6ZUxvY2F0aW9uLnN0YXJ0ID0gcmVzaXplTG9jYXRpb24uZW5kLmNsb25lKCkuc3VidHJhY3QoZGVmYXVsdER1cmF0aW9uKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgeyAvLyByZXNpemluZyB0aGUgZW5kP1xuXHRcdFx0XHRyZXNpemVMb2NhdGlvbi5lbmQgPSByZXNpemVMb2NhdGlvbi5zdGFydC5jbG9uZSgpLmFkZChkZWZhdWx0RHVyYXRpb24pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXNpemVMb2NhdGlvbjtcblx0fSxcblxuXG5cdC8vIFJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhbiBldmVudCBiZWluZyByZXNpemVkLlxuXHQvLyBgcmFuZ2VgIGhhcyB0aGUgdXBkYXRlZCBkYXRlcyBvZiB0aGUgZXZlbnQuIGBzZWdgIGlzIHRoZSBvcmlnaW5hbCBzZWdtZW50IG9iamVjdCBpbnZvbHZlZCBpbiB0aGUgZHJhZy5cblx0Ly8gTXVzdCByZXR1cm4gZWxlbWVudHMgdXNlZCBmb3IgYW55IG1vY2sgZXZlbnRzLlxuXHRyZW5kZXJFdmVudFJlc2l6ZTogZnVuY3Rpb24ocmFuZ2UsIHNlZykge1xuXHRcdC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IGJlaW5nIHJlc2l6ZWQuXG5cdHVucmVuZGVyRXZlbnRSZXNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8qIFJlbmRlcmluZyBVdGlsc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gQ29tcHV0ZSB0aGUgdGV4dCB0aGF0IHNob3VsZCBiZSBkaXNwbGF5ZWQgb24gYW4gZXZlbnQncyBlbGVtZW50LlxuXHQvLyBgcmFuZ2VgIGNhbiBiZSB0aGUgRXZlbnQgb2JqZWN0IGl0c2VsZiwgb3Igc29tZXRoaW5nIHJhbmdlLWxpa2UsIHdpdGggYXQgbGVhc3QgYSBgc3RhcnRgLlxuXHQvLyBJZiBldmVudCB0aW1lcyBhcmUgZGlzYWJsZWQsIG9yIHRoZSBldmVudCBoYXMgbm8gdGltZSwgd2lsbCByZXR1cm4gYSBibGFuayBzdHJpbmcuXG5cdC8vIElmIG5vdCBzcGVjaWZpZWQsIGZvcm1hdFN0ciB3aWxsIGRlZmF1bHQgdG8gdGhlIGV2ZW50VGltZUZvcm1hdCBzZXR0aW5nLFxuXHQvLyBhbmQgZGlzcGxheUVuZCB3aWxsIGRlZmF1bHQgdG8gdGhlIGRpc3BsYXlFdmVudEVuZCBzZXR0aW5nLlxuXHRnZXRFdmVudFRpbWVUZXh0OiBmdW5jdGlvbihyYW5nZSwgZm9ybWF0U3RyLCBkaXNwbGF5RW5kKSB7XG5cblx0XHRpZiAoZm9ybWF0U3RyID09IG51bGwpIHtcblx0XHRcdGZvcm1hdFN0ciA9IHRoaXMuZXZlbnRUaW1lRm9ybWF0O1xuXHRcdH1cblxuXHRcdGlmIChkaXNwbGF5RW5kID09IG51bGwpIHtcblx0XHRcdGRpc3BsYXlFbmQgPSB0aGlzLmRpc3BsYXlFdmVudEVuZDtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5kaXNwbGF5RXZlbnRUaW1lICYmIHJhbmdlLnN0YXJ0Lmhhc1RpbWUoKSkge1xuXHRcdFx0aWYgKGRpc3BsYXlFbmQgJiYgcmFuZ2UuZW5kKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnZpZXcuZm9ybWF0UmFuZ2UocmFuZ2UsIGZvcm1hdFN0cik7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHJhbmdlLnN0YXJ0LmZvcm1hdChmb3JtYXRTdHIpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiAnJztcblx0fSxcblxuXG5cdC8vIEdlbmVyaWMgdXRpbGl0eSBmb3IgZ2VuZXJhdGluZyB0aGUgSFRNTCBjbGFzc05hbWVzIGZvciBhbiBldmVudCBzZWdtZW50J3MgZWxlbWVudFxuXHRnZXRTZWdDbGFzc2VzOiBmdW5jdGlvbihzZWcsIGlzRHJhZ2dhYmxlLCBpc1Jlc2l6YWJsZSkge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXHRcdHZhciBjbGFzc2VzID0gW1xuXHRcdFx0J2ZjLWV2ZW50Jyxcblx0XHRcdHNlZy5pc1N0YXJ0ID8gJ2ZjLXN0YXJ0JyA6ICdmYy1ub3Qtc3RhcnQnLFxuXHRcdFx0c2VnLmlzRW5kID8gJ2ZjLWVuZCcgOiAnZmMtbm90LWVuZCdcblx0XHRdLmNvbmNhdCh0aGlzLmdldFNlZ0N1c3RvbUNsYXNzZXMoc2VnKSk7XG5cblx0XHRpZiAoaXNEcmFnZ2FibGUpIHtcblx0XHRcdGNsYXNzZXMucHVzaCgnZmMtZHJhZ2dhYmxlJyk7XG5cdFx0fVxuXHRcdGlmIChpc1Jlc2l6YWJsZSkge1xuXHRcdFx0Y2xhc3Nlcy5wdXNoKCdmYy1yZXNpemFibGUnKTtcblx0XHR9XG5cblx0XHQvLyBldmVudCBpcyBjdXJyZW50bHkgc2VsZWN0ZWQ/IGF0dGFjaCBhIGNsYXNzTmFtZS5cblx0XHRpZiAodmlldy5pc0V2ZW50U2VsZWN0ZWQoc2VnLmV2ZW50KSkge1xuXHRcdFx0Y2xhc3Nlcy5wdXNoKCdmYy1zZWxlY3RlZCcpO1xuXHRcdH1cblxuXHRcdHJldHVybiBjbGFzc2VzO1xuXHR9LFxuXG5cblx0Ly8gTGlzdCBvZiBjbGFzc2VzIHRoYXQgd2VyZSBkZWZpbmVkIGJ5IHRoZSBjYWxsZXIgb2YgdGhlIEFQSSBpbiBzb21lIHdheVxuXHRnZXRTZWdDdXN0b21DbGFzc2VzOiBmdW5jdGlvbihzZWcpIHtcblx0XHR2YXIgZXZlbnQgPSBzZWcuZXZlbnQ7XG5cblx0XHRyZXR1cm4gW10uY29uY2F0KFxuXHRcdFx0ZXZlbnQuY2xhc3NOYW1lLCAvLyBndWFyYW50ZWVkIHRvIGJlIGFuIGFycmF5XG5cdFx0XHRldmVudC5zb3VyY2UgPyBldmVudC5zb3VyY2UuY2xhc3NOYW1lIDogW11cblx0XHQpO1xuXHR9LFxuXG5cblx0Ly8gVXRpbGl0eSBmb3IgZ2VuZXJhdGluZyBldmVudCBza2luLXJlbGF0ZWQgQ1NTIHByb3BlcnRpZXNcblx0Z2V0U2VnU2tpbkNzczogZnVuY3Rpb24oc2VnKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdCdiYWNrZ3JvdW5kLWNvbG9yJzogdGhpcy5nZXRTZWdCYWNrZ3JvdW5kQ29sb3Ioc2VnKSxcblx0XHRcdCdib3JkZXItY29sb3InOiB0aGlzLmdldFNlZ0JvcmRlckNvbG9yKHNlZyksXG5cdFx0XHRjb2xvcjogdGhpcy5nZXRTZWdUZXh0Q29sb3Ioc2VnKVxuXHRcdH07XG5cdH0sXG5cblxuXHQvLyBRdWVyaWVzIGZvciBjYWxsZXItc3BlY2lmaWVkIGNvbG9yLCB0aGVuIGZhbGxzIGJhY2sgdG8gZGVmYXVsdFxuXHRnZXRTZWdCYWNrZ3JvdW5kQ29sb3I6IGZ1bmN0aW9uKHNlZykge1xuXHRcdHJldHVybiBzZWcuZXZlbnQuYmFja2dyb3VuZENvbG9yIHx8XG5cdFx0XHRzZWcuZXZlbnQuY29sb3IgfHxcblx0XHRcdHRoaXMuZ2V0U2VnRGVmYXVsdEJhY2tncm91bmRDb2xvcihzZWcpO1xuXHR9LFxuXG5cblx0Z2V0U2VnRGVmYXVsdEJhY2tncm91bmRDb2xvcjogZnVuY3Rpb24oc2VnKSB7XG5cdFx0dmFyIHNvdXJjZSA9IHNlZy5ldmVudC5zb3VyY2UgfHwge307XG5cblx0XHRyZXR1cm4gc291cmNlLmJhY2tncm91bmRDb2xvciB8fFxuXHRcdFx0c291cmNlLmNvbG9yIHx8XG5cdFx0XHR0aGlzLnZpZXcub3B0KCdldmVudEJhY2tncm91bmRDb2xvcicpIHx8XG5cdFx0XHR0aGlzLnZpZXcub3B0KCdldmVudENvbG9yJyk7XG5cdH0sXG5cblxuXHQvLyBRdWVyaWVzIGZvciBjYWxsZXItc3BlY2lmaWVkIGNvbG9yLCB0aGVuIGZhbGxzIGJhY2sgdG8gZGVmYXVsdFxuXHRnZXRTZWdCb3JkZXJDb2xvcjogZnVuY3Rpb24oc2VnKSB7XG5cdFx0cmV0dXJuIHNlZy5ldmVudC5ib3JkZXJDb2xvciB8fFxuXHRcdFx0c2VnLmV2ZW50LmNvbG9yIHx8XG5cdFx0XHR0aGlzLmdldFNlZ0RlZmF1bHRCb3JkZXJDb2xvcihzZWcpO1xuXHR9LFxuXG5cblx0Z2V0U2VnRGVmYXVsdEJvcmRlckNvbG9yOiBmdW5jdGlvbihzZWcpIHtcblx0XHR2YXIgc291cmNlID0gc2VnLmV2ZW50LnNvdXJjZSB8fCB7fTtcblxuXHRcdHJldHVybiBzb3VyY2UuYm9yZGVyQ29sb3IgfHxcblx0XHRcdHNvdXJjZS5jb2xvciB8fFxuXHRcdFx0dGhpcy52aWV3Lm9wdCgnZXZlbnRCb3JkZXJDb2xvcicpIHx8XG5cdFx0XHR0aGlzLnZpZXcub3B0KCdldmVudENvbG9yJyk7XG5cdH0sXG5cblxuXHQvLyBRdWVyaWVzIGZvciBjYWxsZXItc3BlY2lmaWVkIGNvbG9yLCB0aGVuIGZhbGxzIGJhY2sgdG8gZGVmYXVsdFxuXHRnZXRTZWdUZXh0Q29sb3I6IGZ1bmN0aW9uKHNlZykge1xuXHRcdHJldHVybiBzZWcuZXZlbnQudGV4dENvbG9yIHx8XG5cdFx0XHR0aGlzLmdldFNlZ0RlZmF1bHRUZXh0Q29sb3Ioc2VnKTtcblx0fSxcblxuXG5cdGdldFNlZ0RlZmF1bHRUZXh0Q29sb3I6IGZ1bmN0aW9uKHNlZykge1xuXHRcdHZhciBzb3VyY2UgPSBzZWcuZXZlbnQuc291cmNlIHx8IHt9O1xuXG5cdFx0cmV0dXJuIHNvdXJjZS50ZXh0Q29sb3IgfHxcblx0XHRcdHRoaXMudmlldy5vcHQoJ2V2ZW50VGV4dENvbG9yJyk7XG5cdH0sXG5cblxuXHQvKiBDb252ZXJ0aW5nIGV2ZW50cyAtPiBldmVudFJhbmdlIC0+IGV2ZW50U3BhbiAtPiBldmVudFNlZ3Ncblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIEdlbmVyYXRlcyBhbiBhcnJheSBvZiBzZWdtZW50cyBmb3IgdGhlIGdpdmVuIHNpbmdsZSBldmVudFxuXHQvLyBDYW4gYWNjZXB0IGFuIGV2ZW50IFwibG9jYXRpb25cIiBhcyB3ZWxsICh3aGljaCBvbmx5IGhhcyBzdGFydC9lbmQgYW5kIG5vIGFsbERheSlcblx0ZXZlbnRUb1NlZ3M6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0cmV0dXJuIHRoaXMuZXZlbnRzVG9TZWdzKFsgZXZlbnQgXSk7XG5cdH0sXG5cblxuXHRldmVudFRvU3BhbjogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRyZXR1cm4gdGhpcy5ldmVudFRvU3BhbnMoZXZlbnQpWzBdO1xuXHR9LFxuXG5cblx0Ly8gR2VuZXJhdGVzIHNwYW5zIChhbHdheXMgdW56b25lZCkgZm9yIHRoZSBnaXZlbiBldmVudC5cblx0Ly8gRG9lcyBub3QgZG8gYW55IGludmVydGluZyBmb3IgaW52ZXJzZS1iYWNrZ3JvdW5kIGV2ZW50cy5cblx0Ly8gQ2FuIGFjY2VwdCBhbiBldmVudCBcImxvY2F0aW9uXCIgYXMgd2VsbCAod2hpY2ggb25seSBoYXMgc3RhcnQvZW5kIGFuZCBubyBhbGxEYXkpXG5cdGV2ZW50VG9TcGFuczogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgcmFuZ2UgPSB0aGlzLmV2ZW50VG9SYW5nZShldmVudCk7XG5cdFx0cmV0dXJuIHRoaXMuZXZlbnRSYW5nZVRvU3BhbnMocmFuZ2UsIGV2ZW50KTtcblx0fSxcblxuXG5cblx0Ly8gQ29udmVydHMgYW4gYXJyYXkgb2YgZXZlbnQgb2JqZWN0cyBpbnRvIGFuIGFycmF5IG9mIGV2ZW50IHNlZ21lbnQgb2JqZWN0cy5cblx0Ly8gQSBjdXN0b20gYHNlZ1NsaWNlRnVuY2AgbWF5IGJlIGdpdmVuIGZvciBhcmJpdHJhcmlseSBzbGljaW5nIHVwIGV2ZW50cy5cblx0Ly8gRG9lc24ndCBndWFyYW50ZWUgYW4gb3JkZXIgZm9yIHRoZSByZXN1bHRpbmcgYXJyYXkuXG5cdGV2ZW50c1RvU2VnczogZnVuY3Rpb24oYWxsRXZlbnRzLCBzZWdTbGljZUZ1bmMpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHZhciBldmVudHNCeUlkID0gZ3JvdXBFdmVudHNCeUlkKGFsbEV2ZW50cyk7XG5cdFx0dmFyIHNlZ3MgPSBbXTtcblxuXHRcdCQuZWFjaChldmVudHNCeUlkLCBmdW5jdGlvbihpZCwgZXZlbnRzKSB7XG5cdFx0XHR2YXIgcmFuZ2VzID0gW107XG5cdFx0XHR2YXIgaTtcblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRyYW5nZXMucHVzaChfdGhpcy5ldmVudFRvUmFuZ2UoZXZlbnRzW2ldKSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGludmVyc2UtYmFja2dyb3VuZCBldmVudHMgKHV0aWxpemUgb25seSB0aGUgZmlyc3QgZXZlbnQgaW4gY2FsY3VsYXRpb25zKVxuXHRcdFx0aWYgKGlzSW52ZXJzZUJnRXZlbnQoZXZlbnRzWzBdKSkge1xuXHRcdFx0XHRyYW5nZXMgPSBfdGhpcy5pbnZlcnRSYW5nZXMocmFuZ2VzKTtcblxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0c2Vncy5wdXNoLmFwcGx5KHNlZ3MsIC8vIGFwcGVuZCB0b1xuXHRcdFx0XHRcdFx0X3RoaXMuZXZlbnRSYW5nZVRvU2VncyhyYW5nZXNbaV0sIGV2ZW50c1swXSwgc2VnU2xpY2VGdW5jKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIG5vcm1hbCBldmVudCByYW5nZXNcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0c2Vncy5wdXNoLmFwcGx5KHNlZ3MsIC8vIGFwcGVuZCB0b1xuXHRcdFx0XHRcdFx0X3RoaXMuZXZlbnRSYW5nZVRvU2VncyhyYW5nZXNbaV0sIGV2ZW50c1tpXSwgc2VnU2xpY2VGdW5jKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiBzZWdzO1xuXHR9LFxuXG5cblx0Ly8gR2VuZXJhdGVzIHRoZSB1bnpvbmVkIHN0YXJ0L2VuZCBkYXRlcyBhbiBldmVudCBhcHBlYXJzIHRvIG9jY3VweVxuXHQvLyBDYW4gYWNjZXB0IGFuIGV2ZW50IFwibG9jYXRpb25cIiBhcyB3ZWxsICh3aGljaCBvbmx5IGhhcyBzdGFydC9lbmQgYW5kIG5vIGFsbERheSlcblx0ZXZlbnRUb1JhbmdlOiBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBjYWxlbmRhciA9IHRoaXMudmlldy5jYWxlbmRhcjtcblx0XHR2YXIgc3RhcnQgPSBldmVudC5zdGFydC5jbG9uZSgpLnN0cmlwWm9uZSgpO1xuXHRcdHZhciBlbmQgPSAoXG5cdFx0XHRcdGV2ZW50LmVuZCA/XG5cdFx0XHRcdFx0ZXZlbnQuZW5kLmNsb25lKCkgOlxuXHRcdFx0XHRcdC8vIGRlcml2ZSB0aGUgZW5kIGZyb20gdGhlIHN0YXJ0IGFuZCBhbGxEYXkuIGNvbXB1dGUgYWxsRGF5IGlmIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdGNhbGVuZGFyLmdldERlZmF1bHRFdmVudEVuZChcblx0XHRcdFx0XHRcdGV2ZW50LmFsbERheSAhPSBudWxsID9cblx0XHRcdFx0XHRcdFx0ZXZlbnQuYWxsRGF5IDpcblx0XHRcdFx0XHRcdFx0IWV2ZW50LnN0YXJ0Lmhhc1RpbWUoKSxcblx0XHRcdFx0XHRcdGV2ZW50LnN0YXJ0XG5cdFx0XHRcdFx0KVxuXHRcdFx0KS5zdHJpcFpvbmUoKTtcblxuXHRcdC8vIGhhY2s6IGR5bmFtaWMgbG9jYWxlIGNoYW5nZSBmb3JnZXRzIHRvIHVwYXRlIHN0b3JlZCBldmVudCBsb2NhbGVkXG5cdFx0Y2FsZW5kYXIubG9jYWxpemVNb21lbnQoc3RhcnQpO1xuXHRcdGNhbGVuZGFyLmxvY2FsaXplTW9tZW50KGVuZCk7XG5cblx0XHRyZXR1cm4geyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH07XG5cdH0sXG5cblxuXHQvLyBHaXZlbiBhbiBldmVudCdzIHJhbmdlICh1bnpvbmVkIHN0YXJ0L2VuZCksIGFuZCB0aGUgZXZlbnQgaXRzZWxmLFxuXHQvLyBzbGljZSBpbnRvIHNlZ21lbnRzICh1c2luZyB0aGUgc2VnU2xpY2VGdW5jIGZ1bmN0aW9uIGlmIHNwZWNpZmllZClcblx0ZXZlbnRSYW5nZVRvU2VnczogZnVuY3Rpb24ocmFuZ2UsIGV2ZW50LCBzZWdTbGljZUZ1bmMpIHtcblx0XHR2YXIgc3BhbnMgPSB0aGlzLmV2ZW50UmFuZ2VUb1NwYW5zKHJhbmdlLCBldmVudCk7XG5cdFx0dmFyIHNlZ3MgPSBbXTtcblx0XHR2YXIgaTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7IGkrKykge1xuXHRcdFx0c2Vncy5wdXNoLmFwcGx5KHNlZ3MsIC8vIGFwcGVuZCB0b1xuXHRcdFx0XHR0aGlzLmV2ZW50U3BhblRvU2VncyhzcGFuc1tpXSwgZXZlbnQsIHNlZ1NsaWNlRnVuYykpO1xuXHRcdH1cblxuXHRcdHJldHVybiBzZWdzO1xuXHR9LFxuXG5cblx0Ly8gR2l2ZW4gYW4gZXZlbnQncyB1bnpvbmVkIGRhdGUgcmFuZ2UsIHJldHVybiBhbiBhcnJheSBvZiBcInNwYW5cIiBvYmplY3RzLlxuXHQvLyBTdWJjbGFzc2VzIGNhbiBvdmVycmlkZS5cblx0ZXZlbnRSYW5nZVRvU3BhbnM6IGZ1bmN0aW9uKHJhbmdlLCBldmVudCkge1xuXHRcdHJldHVybiBbICQuZXh0ZW5kKHt9LCByYW5nZSkgXTsgLy8gY29weSBpbnRvIGEgc2luZ2xlLWl0ZW0gYXJyYXlcblx0fSxcblxuXG5cdC8vIEdpdmVuIGFuIGV2ZW50J3Mgc3BhbiAodW56b25lZCBzdGFydC9lbmQgYW5kIG90aGVyIG1pc2MgZGF0YSksIGFuZCB0aGUgZXZlbnQgaXRzZWxmLFxuXHQvLyBzbGljZXMgaW50byBzZWdtZW50cyBhbmQgYXR0YWNoZXMgZXZlbnQtZGVyaXZlZCBwcm9wZXJ0aWVzIHRvIHRoZW0uXG5cdGV2ZW50U3BhblRvU2VnczogZnVuY3Rpb24oc3BhbiwgZXZlbnQsIHNlZ1NsaWNlRnVuYykge1xuXHRcdHZhciBzZWdzID0gc2VnU2xpY2VGdW5jID8gc2VnU2xpY2VGdW5jKHNwYW4pIDogdGhpcy5zcGFuVG9TZWdzKHNwYW4pO1xuXHRcdHZhciBpLCBzZWc7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0c2VnID0gc2Vnc1tpXTtcblx0XHRcdHNlZy5ldmVudCA9IGV2ZW50O1xuXHRcdFx0c2VnLmV2ZW50U3RhcnRNUyA9ICtzcGFuLnN0YXJ0OyAvLyBUT0RPOiBub3QgdGhlIGJlc3QgbmFtZSBhZnRlciBtYWtpbmcgc3BhbnMgdW56b25lZFxuXHRcdFx0c2VnLmV2ZW50RHVyYXRpb25NUyA9IHNwYW4uZW5kIC0gc3Bhbi5zdGFydDtcblx0XHR9XG5cblx0XHRyZXR1cm4gc2Vncztcblx0fSxcblxuXG5cdC8vIFByb2R1Y2VzIGEgbmV3IGFycmF5IG9mIHJhbmdlIG9iamVjdHMgdGhhdCB3aWxsIGNvdmVyIGFsbCB0aGUgdGltZSBOT1QgY292ZXJlZCBieSB0aGUgZ2l2ZW4gcmFuZ2VzLlxuXHQvLyBTSURFIEVGRkVDVDogd2lsbCBtdXRhdGUgdGhlIGdpdmVuIGFycmF5IGFuZCB3aWxsIHVzZSBpdHMgZGF0ZSByZWZlcmVuY2VzLlxuXHRpbnZlcnRSYW5nZXM6IGZ1bmN0aW9uKHJhbmdlcykge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXHRcdHZhciB2aWV3U3RhcnQgPSB2aWV3LnN0YXJ0LmNsb25lKCk7IC8vIG5lZWQgYSBjb3B5XG5cdFx0dmFyIHZpZXdFbmQgPSB2aWV3LmVuZC5jbG9uZSgpOyAvLyBuZWVkIGEgY29weVxuXHRcdHZhciBpbnZlcnNlUmFuZ2VzID0gW107XG5cdFx0dmFyIHN0YXJ0ID0gdmlld1N0YXJ0OyAvLyB0aGUgZW5kIG9mIHRoZSBwcmV2aW91cyByYW5nZS4gdGhlIHN0YXJ0IG9mIHRoZSBuZXcgcmFuZ2Vcblx0XHR2YXIgaSwgcmFuZ2U7XG5cblx0XHQvLyByYW5nZXMgbmVlZCB0byBiZSBpbiBvcmRlci4gcmVxdWlyZWQgZm9yIG91ciBkYXRlLXdhbGtpbmcgYWxnb3JpdGhtXG5cdFx0cmFuZ2VzLnNvcnQoY29tcGFyZVJhbmdlcyk7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRyYW5nZSA9IHJhbmdlc1tpXTtcblxuXHRcdFx0Ly8gYWRkIHRoZSBzcGFuIG9mIHRpbWUgYmVmb3JlIHRoZSBldmVudCAoaWYgdGhlcmUgaXMgYW55KVxuXHRcdFx0aWYgKHJhbmdlLnN0YXJ0ID4gc3RhcnQpIHsgLy8gY29tcGFyZSBtaWxsaXNlY29uZCB0aW1lIChza2lwIGFueSBhbWJpZyBsb2dpYylcblx0XHRcdFx0aW52ZXJzZVJhbmdlcy5wdXNoKHtcblx0XHRcdFx0XHRzdGFydDogc3RhcnQsXG5cdFx0XHRcdFx0ZW5kOiByYW5nZS5zdGFydFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0c3RhcnQgPSByYW5nZS5lbmQ7XG5cdFx0fVxuXG5cdFx0Ly8gYWRkIHRoZSBzcGFuIG9mIHRpbWUgYWZ0ZXIgdGhlIGxhc3QgZXZlbnQgKGlmIHRoZXJlIGlzIGFueSlcblx0XHRpZiAoc3RhcnQgPCB2aWV3RW5kKSB7IC8vIGNvbXBhcmUgbWlsbGlzZWNvbmQgdGltZSAoc2tpcCBhbnkgYW1iaWcgbG9naWMpXG5cdFx0XHRpbnZlcnNlUmFuZ2VzLnB1c2goe1xuXHRcdFx0XHRzdGFydDogc3RhcnQsXG5cdFx0XHRcdGVuZDogdmlld0VuZFxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGludmVyc2VSYW5nZXM7XG5cdH0sXG5cblxuXHRzb3J0RXZlbnRTZWdzOiBmdW5jdGlvbihzZWdzKSB7XG5cdFx0c2Vncy5zb3J0KHByb3h5KHRoaXMsICdjb21wYXJlRXZlbnRTZWdzJykpO1xuXHR9LFxuXG5cblx0Ly8gQSBjbXAgZnVuY3Rpb24gZm9yIGRldGVybWluaW5nIHdoaWNoIHNlZ21lbnRzIHNob3VsZCB0YWtlIHZpc3VhbCBwcmlvcml0eVxuXHRjb21wYXJlRXZlbnRTZWdzOiBmdW5jdGlvbihzZWcxLCBzZWcyKSB7XG5cdFx0cmV0dXJuIHNlZzEuZXZlbnRTdGFydE1TIC0gc2VnMi5ldmVudFN0YXJ0TVMgfHwgLy8gZWFybGllciBldmVudHMgZ28gZmlyc3Rcblx0XHRcdHNlZzIuZXZlbnREdXJhdGlvbk1TIC0gc2VnMS5ldmVudER1cmF0aW9uTVMgfHwgLy8gdGllPyBsb25nZXIgZXZlbnRzIGdvIGZpcnN0XG5cdFx0XHRzZWcyLmV2ZW50LmFsbERheSAtIHNlZzEuZXZlbnQuYWxsRGF5IHx8IC8vIHRpZT8gcHV0IGFsbC1kYXkgZXZlbnRzIGZpcnN0IChib29sZWFucyBjYXN0IHRvIDAvMSlcblx0XHRcdGNvbXBhcmVCeUZpZWxkU3BlY3Moc2VnMS5ldmVudCwgc2VnMi5ldmVudCwgdGhpcy52aWV3LmV2ZW50T3JkZXJTcGVjcyk7XG5cdH1cblxufSk7XG5cblxuLyogVXRpbGl0aWVzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5mdW5jdGlvbiBwbHVja0V2ZW50RGF0ZVByb3BzKGV2ZW50KSB7XG5cdHJldHVybiB7XG5cdFx0c3RhcnQ6IGV2ZW50LnN0YXJ0LmNsb25lKCksXG5cdFx0ZW5kOiBldmVudC5lbmQgPyBldmVudC5lbmQuY2xvbmUoKSA6IG51bGwsXG5cdFx0YWxsRGF5OiBldmVudC5hbGxEYXkgLy8ga2VlcCBpdCB0aGUgc2FtZVxuXHR9O1xufVxuRkMucGx1Y2tFdmVudERhdGVQcm9wcyA9IHBsdWNrRXZlbnREYXRlUHJvcHM7XG5cblxuZnVuY3Rpb24gaXNCZ0V2ZW50KGV2ZW50KSB7IC8vIHJldHVybnMgdHJ1ZSBpZiBiYWNrZ3JvdW5kIE9SIGludmVyc2UtYmFja2dyb3VuZFxuXHR2YXIgcmVuZGVyaW5nID0gZ2V0RXZlbnRSZW5kZXJpbmcoZXZlbnQpO1xuXHRyZXR1cm4gcmVuZGVyaW5nID09PSAnYmFja2dyb3VuZCcgfHwgcmVuZGVyaW5nID09PSAnaW52ZXJzZS1iYWNrZ3JvdW5kJztcbn1cbkZDLmlzQmdFdmVudCA9IGlzQmdFdmVudDsgLy8gZXhwb3J0XG5cblxuZnVuY3Rpb24gaXNJbnZlcnNlQmdFdmVudChldmVudCkge1xuXHRyZXR1cm4gZ2V0RXZlbnRSZW5kZXJpbmcoZXZlbnQpID09PSAnaW52ZXJzZS1iYWNrZ3JvdW5kJztcbn1cblxuXG5mdW5jdGlvbiBnZXRFdmVudFJlbmRlcmluZyhldmVudCkge1xuXHRyZXR1cm4gZmlyc3REZWZpbmVkKChldmVudC5zb3VyY2UgfHwge30pLnJlbmRlcmluZywgZXZlbnQucmVuZGVyaW5nKTtcbn1cblxuXG5mdW5jdGlvbiBncm91cEV2ZW50c0J5SWQoZXZlbnRzKSB7XG5cdHZhciBldmVudHNCeUlkID0ge307XG5cdHZhciBpLCBldmVudDtcblxuXHRmb3IgKGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0ZXZlbnQgPSBldmVudHNbaV07XG5cdFx0KGV2ZW50c0J5SWRbZXZlbnQuX2lkXSB8fCAoZXZlbnRzQnlJZFtldmVudC5faWRdID0gW10pKS5wdXNoKGV2ZW50KTtcblx0fVxuXG5cdHJldHVybiBldmVudHNCeUlkO1xufVxuXG5cbi8vIEEgY21wIGZ1bmN0aW9uIGZvciBkZXRlcm1pbmluZyB3aGljaCBub24taW52ZXJ0ZWQgXCJyYW5nZXNcIiAoc2VlIGFib3ZlKSBoYXBwZW4gZWFybGllclxuZnVuY3Rpb24gY29tcGFyZVJhbmdlcyhyYW5nZTEsIHJhbmdlMikge1xuXHRyZXR1cm4gcmFuZ2UxLnN0YXJ0IC0gcmFuZ2UyLnN0YXJ0OyAvLyBlYXJsaWVyIHJhbmdlcyBnbyBmaXJzdFxufVxuXG5cbi8qIEV4dGVybmFsLURyYWdnaW5nLUVsZW1lbnQgRGF0YVxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbi8vIFJlcXVpcmUgYWxsIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVzIHVzZWQgYnkgRnVsbENhbGVuZGFyIHRvIGhhdmUgdGhpcyBwcmVmaXguXG4vLyBBIHZhbHVlIG9mICcnIHdpbGwgcXVlcnkgYXR0cmlidXRlcyBsaWtlIGRhdGEtZXZlbnQuIEEgdmFsdWUgb2YgJ2ZjJyB3aWxsIHF1ZXJ5IGF0dHJpYnV0ZXMgbGlrZSBkYXRhLWZjLWV2ZW50LlxuRkMuZGF0YUF0dHJQcmVmaXggPSAnJztcblxuLy8gR2l2ZW4gYSBqUXVlcnkgZWxlbWVudCB0aGF0IG1pZ2h0IHJlcHJlc2VudCBhIGRyYWdnZWQgRnVsbENhbGVuZGFyIGV2ZW50LCByZXR1cm5zIGFuIGludGVybWVkaWF0ZSBkYXRhIHN0cnVjdHVyZVxuLy8gdG8gYmUgdXNlZCBmb3IgRXZlbnQgT2JqZWN0IGNyZWF0aW9uLlxuLy8gQSBkZWZpbmVkIGAuZXZlbnRQcm9wc2AsIGV2ZW4gd2hlbiBlbXB0eSwgaW5kaWNhdGVzIHRoYXQgYW4gZXZlbnQgc2hvdWxkIGJlIGNyZWF0ZWQuXG5mdW5jdGlvbiBnZXREcmFnZ2VkRWxNZXRhKGVsKSB7XG5cdHZhciBwcmVmaXggPSBGQy5kYXRhQXR0clByZWZpeDtcblx0dmFyIGV2ZW50UHJvcHM7IC8vIHByb3BlcnRpZXMgZm9yIGNyZWF0aW5nIHRoZSBldmVudCwgbm90IHJlbGF0ZWQgdG8gZGF0ZS90aW1lXG5cdHZhciBzdGFydFRpbWU7IC8vIGEgRHVyYXRpb25cblx0dmFyIGR1cmF0aW9uO1xuXHR2YXIgc3RpY2s7XG5cblx0aWYgKHByZWZpeCkgeyBwcmVmaXggKz0gJy0nOyB9XG5cdGV2ZW50UHJvcHMgPSBlbC5kYXRhKHByZWZpeCArICdldmVudCcpIHx8IG51bGw7XG5cblx0aWYgKGV2ZW50UHJvcHMpIHtcblx0XHRpZiAodHlwZW9mIGV2ZW50UHJvcHMgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRldmVudFByb3BzID0gJC5leHRlbmQoe30sIGV2ZW50UHJvcHMpOyAvLyBtYWtlIGEgY29weVxuXHRcdH1cblx0XHRlbHNlIHsgLy8gc29tZXRoaW5nIGxpa2UgMSBvciB0cnVlLiBzdGlsbCBzaWduYWwgZXZlbnQgY3JlYXRpb25cblx0XHRcdGV2ZW50UHJvcHMgPSB7fTtcblx0XHR9XG5cblx0XHQvLyBwbHVjayBzcGVjaWFsLWNhc2VkIGRhdGUvdGltZSBwcm9wZXJ0aWVzXG5cdFx0c3RhcnRUaW1lID0gZXZlbnRQcm9wcy5zdGFydDtcblx0XHRpZiAoc3RhcnRUaW1lID09IG51bGwpIHsgc3RhcnRUaW1lID0gZXZlbnRQcm9wcy50aW1lOyB9IC8vIGFjY2VwdCAndGltZScgYXMgd2VsbFxuXHRcdGR1cmF0aW9uID0gZXZlbnRQcm9wcy5kdXJhdGlvbjtcblx0XHRzdGljayA9IGV2ZW50UHJvcHMuc3RpY2s7XG5cdFx0ZGVsZXRlIGV2ZW50UHJvcHMuc3RhcnQ7XG5cdFx0ZGVsZXRlIGV2ZW50UHJvcHMudGltZTtcblx0XHRkZWxldGUgZXZlbnRQcm9wcy5kdXJhdGlvbjtcblx0XHRkZWxldGUgZXZlbnRQcm9wcy5zdGljaztcblx0fVxuXG5cdC8vIGZhbGxiYWNrIHRvIHN0YW5kYWxvbmUgYXR0cmlidXRlIHZhbHVlcyBmb3IgZWFjaCBvZiB0aGUgZGF0ZS90aW1lIHByb3BlcnRpZXNcblx0aWYgKHN0YXJ0VGltZSA9PSBudWxsKSB7IHN0YXJ0VGltZSA9IGVsLmRhdGEocHJlZml4ICsgJ3N0YXJ0Jyk7IH1cblx0aWYgKHN0YXJ0VGltZSA9PSBudWxsKSB7IHN0YXJ0VGltZSA9IGVsLmRhdGEocHJlZml4ICsgJ3RpbWUnKTsgfSAvLyBhY2NlcHQgJ3RpbWUnIGFzIHdlbGxcblx0aWYgKGR1cmF0aW9uID09IG51bGwpIHsgZHVyYXRpb24gPSBlbC5kYXRhKHByZWZpeCArICdkdXJhdGlvbicpOyB9XG5cdGlmIChzdGljayA9PSBudWxsKSB7IHN0aWNrID0gZWwuZGF0YShwcmVmaXggKyAnc3RpY2snKTsgfVxuXG5cdC8vIG1hc3NhZ2UgaW50byBjb3JyZWN0IGRhdGEgdHlwZXNcblx0c3RhcnRUaW1lID0gc3RhcnRUaW1lICE9IG51bGwgPyBtb21lbnQuZHVyYXRpb24oc3RhcnRUaW1lKSA6IG51bGw7XG5cdGR1cmF0aW9uID0gZHVyYXRpb24gIT0gbnVsbCA/IG1vbWVudC5kdXJhdGlvbihkdXJhdGlvbikgOiBudWxsO1xuXHRzdGljayA9IEJvb2xlYW4oc3RpY2spO1xuXG5cdHJldHVybiB7IGV2ZW50UHJvcHM6IGV2ZW50UHJvcHMsIHN0YXJ0VGltZTogc3RhcnRUaW1lLCBkdXJhdGlvbjogZHVyYXRpb24sIHN0aWNrOiBzdGljayB9O1xufVxuXG5cbjs7XG5cbi8qXG5BIHNldCBvZiByZW5kZXJpbmcgYW5kIGRhdGUtcmVsYXRlZCBtZXRob2RzIGZvciBhIHZpc3VhbCBjb21wb25lbnQgY29tcHJpc2VkIG9mIG9uZSBvciBtb3JlIHJvd3Mgb2YgZGF5IGNvbHVtbnMuXG5QcmVyZXF1aXNpdGU6IHRoZSBvYmplY3QgYmVpbmcgbWl4ZWQgaW50byBuZWVkcyB0byBiZSBhICpHcmlkKlxuKi9cbnZhciBEYXlUYWJsZU1peGluID0gRkMuRGF5VGFibGVNaXhpbiA9IHtcblxuXHRicmVha09uV2Vla3M6IGZhbHNlLCAvLyBzaG91bGQgY3JlYXRlIGEgbmV3IHJvdyBmb3IgZWFjaCB3ZWVrP1xuXHRkYXlEYXRlczogbnVsbCwgLy8gd2hvbGUtZGF5IGRhdGVzIGZvciBlYWNoIGNvbHVtbi4gbGVmdCB0byByaWdodFxuXHRkYXlJbmRpY2VzOiBudWxsLCAvLyBmb3IgZWFjaCBkYXkgZnJvbSBzdGFydCwgdGhlIG9mZnNldFxuXHRkYXlzUGVyUm93OiBudWxsLFxuXHRyb3dDbnQ6IG51bGwsXG5cdGNvbENudDogbnVsbCxcblx0Y29sSGVhZEZvcm1hdDogbnVsbCxcblxuXG5cdC8vIFBvcHVsYXRlcyBpbnRlcm5hbCB2YXJpYWJsZXMgdXNlZCBmb3IgZGF0ZSBjYWxjdWxhdGlvbiBhbmQgcmVuZGVyaW5nXG5cdHVwZGF0ZURheVRhYmxlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblx0XHR2YXIgZGF0ZSA9IHRoaXMuc3RhcnQuY2xvbmUoKTtcblx0XHR2YXIgZGF5SW5kZXggPSAtMTtcblx0XHR2YXIgZGF5SW5kaWNlcyA9IFtdO1xuXHRcdHZhciBkYXlEYXRlcyA9IFtdO1xuXHRcdHZhciBkYXlzUGVyUm93O1xuXHRcdHZhciBmaXJzdERheTtcblx0XHR2YXIgcm93Q250O1xuXG5cdFx0d2hpbGUgKGRhdGUuaXNCZWZvcmUodGhpcy5lbmQpKSB7IC8vIGxvb3AgZWFjaCBkYXkgZnJvbSBzdGFydCB0byBlbmRcblx0XHRcdGlmICh2aWV3LmlzSGlkZGVuRGF5KGRhdGUpKSB7XG5cdFx0XHRcdGRheUluZGljZXMucHVzaChkYXlJbmRleCArIDAuNSk7IC8vIG1hcmsgdGhhdCBpdCdzIGJldHdlZW4gaW5kaWNlc1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGRheUluZGV4Kys7XG5cdFx0XHRcdGRheUluZGljZXMucHVzaChkYXlJbmRleCk7XG5cdFx0XHRcdGRheURhdGVzLnB1c2goZGF0ZS5jbG9uZSgpKTtcblx0XHRcdH1cblx0XHRcdGRhdGUuYWRkKDEsICdkYXlzJyk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuYnJlYWtPbldlZWtzKSB7XG5cdFx0XHQvLyBjb3VudCBjb2x1bW5zIHVudGlsIHRoZSBkYXktb2Ytd2VlayByZXBlYXRzXG5cdFx0XHRmaXJzdERheSA9IGRheURhdGVzWzBdLmRheSgpO1xuXHRcdFx0Zm9yIChkYXlzUGVyUm93ID0gMTsgZGF5c1BlclJvdyA8IGRheURhdGVzLmxlbmd0aDsgZGF5c1BlclJvdysrKSB7XG5cdFx0XHRcdGlmIChkYXlEYXRlc1tkYXlzUGVyUm93XS5kYXkoKSA9PSBmaXJzdERheSkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyb3dDbnQgPSBNYXRoLmNlaWwoZGF5RGF0ZXMubGVuZ3RoIC8gZGF5c1BlclJvdyk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cm93Q250ID0gMTtcblx0XHRcdGRheXNQZXJSb3cgPSBkYXlEYXRlcy5sZW5ndGg7XG5cdFx0fVxuXG5cdFx0dGhpcy5kYXlEYXRlcyA9IGRheURhdGVzO1xuXHRcdHRoaXMuZGF5SW5kaWNlcyA9IGRheUluZGljZXM7XG5cdFx0dGhpcy5kYXlzUGVyUm93ID0gZGF5c1BlclJvdztcblx0XHR0aGlzLnJvd0NudCA9IHJvd0NudDtcblx0XHRcblx0XHR0aGlzLnVwZGF0ZURheVRhYmxlQ29scygpO1xuXHR9LFxuXG5cblx0Ly8gQ29tcHV0ZXMgYW5kIGFzc2lnbmVkIHRoZSBjb2xDbnQgcHJvcGVydHkgYW5kIHVwZGF0ZXMgYW55IG9wdGlvbnMgdGhhdCBtYXkgYmUgY29tcHV0ZWQgZnJvbSBpdFxuXHR1cGRhdGVEYXlUYWJsZUNvbHM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuY29sQ250ID0gdGhpcy5jb21wdXRlQ29sQ250KCk7XG5cdFx0dGhpcy5jb2xIZWFkRm9ybWF0ID0gdGhpcy52aWV3Lm9wdCgnY29sdW1uRm9ybWF0JykgfHwgdGhpcy5jb21wdXRlQ29sSGVhZEZvcm1hdCgpO1xuXHR9LFxuXG5cblx0Ly8gRGV0ZXJtaW5lcyBob3cgbWFueSBjb2x1bW5zIHRoZXJlIHNob3VsZCBiZSBpbiB0aGUgdGFibGVcblx0Y29tcHV0ZUNvbENudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF5c1BlclJvdztcblx0fSxcblxuXG5cdC8vIENvbXB1dGVzIHRoZSBhbWJpZ3VvdXNseS10aW1lZCBtb21lbnQgZm9yIHRoZSBnaXZlbiBjZWxsXG5cdGdldENlbGxEYXRlOiBmdW5jdGlvbihyb3csIGNvbCkge1xuXHRcdHJldHVybiB0aGlzLmRheURhdGVzW1xuXHRcdFx0XHR0aGlzLmdldENlbGxEYXlJbmRleChyb3csIGNvbClcblx0XHRcdF0uY2xvbmUoKTtcblx0fSxcblxuXG5cdC8vIENvbXB1dGVzIHRoZSBhbWJpZ3VvdXNseS10aW1lZCBkYXRlIHJhbmdlIGZvciB0aGUgZ2l2ZW4gY2VsbFxuXHRnZXRDZWxsUmFuZ2U6IGZ1bmN0aW9uKHJvdywgY29sKSB7XG5cdFx0dmFyIHN0YXJ0ID0gdGhpcy5nZXRDZWxsRGF0ZShyb3csIGNvbCk7XG5cdFx0dmFyIGVuZCA9IHN0YXJ0LmNsb25lKCkuYWRkKDEsICdkYXlzJyk7XG5cblx0XHRyZXR1cm4geyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH07XG5cdH0sXG5cblxuXHQvLyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZGF5IGNlbGxzLCBjaHJvbm9sb2dpY2FsbHksIGZyb20gdGhlIGZpcnN0IG9mIHRoZSBncmlkICgwLWJhc2VkKVxuXHRnZXRDZWxsRGF5SW5kZXg6IGZ1bmN0aW9uKHJvdywgY29sKSB7XG5cdFx0cmV0dXJuIHJvdyAqIHRoaXMuZGF5c1BlclJvdyArIHRoaXMuZ2V0Q29sRGF5SW5kZXgoY29sKTtcblx0fSxcblxuXG5cdC8vIFJldHVybnMgdGhlIG51bW5lciBvZiBkYXkgY2VsbHMsIGNocm9ub2xvZ2ljYWxseSwgZnJvbSB0aGUgZmlyc3QgY2VsbCBpbiAqYW55IGdpdmVuIHJvdypcblx0Z2V0Q29sRGF5SW5kZXg6IGZ1bmN0aW9uKGNvbCkge1xuXHRcdGlmICh0aGlzLmlzUlRMKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jb2xDbnQgLSAxIC0gY29sO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHJldHVybiBjb2w7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gR2l2ZW4gYSBkYXRlLCByZXR1cm5zIGl0cyBjaHJvbm9sb2NpYWwgY2VsbC1pbmRleCBmcm9tIHRoZSBmaXJzdCBjZWxsIG9mIHRoZSBncmlkLlxuXHQvLyBJZiB0aGUgZGF0ZSBsaWVzIGJldHdlZW4gY2VsbHMgKGJlY2F1c2Ugb2YgaGlkZGVuRGF5cyksIHJldHVybnMgYSBmbG9hdGluZy1wb2ludCB2YWx1ZSBiZXR3ZWVuIG9mZnNldHMuXG5cdC8vIElmIGJlZm9yZSB0aGUgZmlyc3Qgb2Zmc2V0LCByZXR1cm5zIGEgbmVnYXRpdmUgbnVtYmVyLlxuXHQvLyBJZiBhZnRlciB0aGUgbGFzdCBvZmZzZXQsIHJldHVybnMgYW4gb2Zmc2V0IHBhc3QgdGhlIGxhc3QgY2VsbCBvZmZzZXQuXG5cdC8vIE9ubHkgd29ya3MgZm9yICpzdGFydCogZGF0ZXMgb2YgY2VsbHMuIFdpbGwgbm90IHdvcmsgZm9yIGV4Y2x1c2l2ZSBlbmQgZGF0ZXMgZm9yIGNlbGxzLlxuXHRnZXREYXRlRGF5SW5kZXg6IGZ1bmN0aW9uKGRhdGUpIHtcblx0XHR2YXIgZGF5SW5kaWNlcyA9IHRoaXMuZGF5SW5kaWNlcztcblx0XHR2YXIgZGF5T2Zmc2V0ID0gZGF0ZS5kaWZmKHRoaXMuc3RhcnQsICdkYXlzJyk7XG5cblx0XHRpZiAoZGF5T2Zmc2V0IDwgMCkge1xuXHRcdFx0cmV0dXJuIGRheUluZGljZXNbMF0gLSAxO1xuXHRcdH1cblx0XHRlbHNlIGlmIChkYXlPZmZzZXQgPj0gZGF5SW5kaWNlcy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBkYXlJbmRpY2VzW2RheUluZGljZXMubGVuZ3RoIC0gMV0gKyAxO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHJldHVybiBkYXlJbmRpY2VzW2RheU9mZnNldF07XG5cdFx0fVxuXHR9LFxuXG5cblx0LyogT3B0aW9uc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gQ29tcHV0ZXMgYSBkZWZhdWx0IGNvbHVtbiBoZWFkZXIgZm9ybWF0dGluZyBzdHJpbmcgaWYgYGNvbEZvcm1hdGAgaXMgbm90IGV4cGxpY2l0bHkgZGVmaW5lZFxuXHRjb21wdXRlQ29sSGVhZEZvcm1hdDogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gaWYgbW9yZSB0aGFuIG9uZSB3ZWVrIHJvdywgb3IgaWYgdGhlcmUgYXJlIGEgbG90IG9mIGNvbHVtbnMgd2l0aCBub3QgbXVjaCBzcGFjZSxcblx0XHQvLyBwdXQganVzdCB0aGUgZGF5IG51bWJlcnMgd2lsbCBiZSBpbiBlYWNoIGNlbGxcblx0XHRpZiAodGhpcy5yb3dDbnQgPiAxIHx8IHRoaXMuY29sQ250ID4gMTApIHtcblx0XHRcdHJldHVybiAnZGRkJzsgLy8gXCJTYXRcIlxuXHRcdH1cblx0XHQvLyBtdWx0aXBsZSBkYXlzLCBzbyBmdWxsIHNpbmdsZSBkYXRlIHN0cmluZyBXT04nVCBiZSBpbiB0aXRsZSB0ZXh0XG5cdFx0ZWxzZSBpZiAodGhpcy5jb2xDbnQgPiAxKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy52aWV3Lm9wdCgnZGF5T2ZNb250aEZvcm1hdCcpOyAvLyBcIlNhdCAxMi8xMFwiXG5cdFx0fVxuXHRcdC8vIHNpbmdsZSBkYXksIHNvIGZ1bGwgc2luZ2xlIGRhdGUgc3RyaW5nIHdpbGwgcHJvYmFibHkgYmUgaW4gdGl0bGUgdGV4dFxuXHRcdGVsc2Uge1xuXHRcdFx0cmV0dXJuICdkZGRkJzsgLy8gXCJTYXR1cmRheVwiXG5cdFx0fVxuXHR9LFxuXG5cblx0LyogU2xpY2luZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gU2xpY2VzIHVwIGEgZGF0ZSByYW5nZSBpbnRvIGEgc2VnbWVudCBmb3IgZXZlcnkgd2Vlay1yb3cgaXQgaW50ZXJzZWN0cyB3aXRoXG5cdHNsaWNlUmFuZ2VCeVJvdzogZnVuY3Rpb24ocmFuZ2UpIHtcblx0XHR2YXIgZGF5c1BlclJvdyA9IHRoaXMuZGF5c1BlclJvdztcblx0XHR2YXIgbm9ybWFsUmFuZ2UgPSB0aGlzLnZpZXcuY29tcHV0ZURheVJhbmdlKHJhbmdlKTsgLy8gbWFrZSB3aG9sZS1kYXkgcmFuZ2UsIGNvbnNpZGVyaW5nIG5leHREYXlUaHJlc2hvbGRcblx0XHR2YXIgcmFuZ2VGaXJzdCA9IHRoaXMuZ2V0RGF0ZURheUluZGV4KG5vcm1hbFJhbmdlLnN0YXJ0KTsgLy8gaW5jbHVzaXZlIGZpcnN0IGluZGV4XG5cdFx0dmFyIHJhbmdlTGFzdCA9IHRoaXMuZ2V0RGF0ZURheUluZGV4KG5vcm1hbFJhbmdlLmVuZC5jbG9uZSgpLnN1YnRyYWN0KDEsICdkYXlzJykpOyAvLyBpbmNsdXNpdmUgbGFzdCBpbmRleFxuXHRcdHZhciBzZWdzID0gW107XG5cdFx0dmFyIHJvdztcblx0XHR2YXIgcm93Rmlyc3QsIHJvd0xhc3Q7IC8vIGluY2x1c2l2ZSBkYXktaW5kZXggcmFuZ2UgZm9yIGN1cnJlbnQgcm93XG5cdFx0dmFyIHNlZ0ZpcnN0LCBzZWdMYXN0OyAvLyBpbmNsdXNpdmUgZGF5LWluZGV4IHJhbmdlIGZvciBzZWdtZW50XG5cblx0XHRmb3IgKHJvdyA9IDA7IHJvdyA8IHRoaXMucm93Q250OyByb3crKykge1xuXHRcdFx0cm93Rmlyc3QgPSByb3cgKiBkYXlzUGVyUm93O1xuXHRcdFx0cm93TGFzdCA9IHJvd0ZpcnN0ICsgZGF5c1BlclJvdyAtIDE7XG5cblx0XHRcdC8vIGludGVyc2VjdCBzZWdtZW50J3Mgb2Zmc2V0IHJhbmdlIHdpdGggdGhlIHJvdydzXG5cdFx0XHRzZWdGaXJzdCA9IE1hdGgubWF4KHJhbmdlRmlyc3QsIHJvd0ZpcnN0KTtcblx0XHRcdHNlZ0xhc3QgPSBNYXRoLm1pbihyYW5nZUxhc3QsIHJvd0xhc3QpO1xuXG5cdFx0XHQvLyBkZWFsIHdpdGggaW4tYmV0d2VlbiBpbmRpY2VzXG5cdFx0XHRzZWdGaXJzdCA9IE1hdGguY2VpbChzZWdGaXJzdCk7IC8vIGluLWJldHdlZW4gc3RhcnRzIHJvdW5kIHRvIG5leHQgY2VsbFxuXHRcdFx0c2VnTGFzdCA9IE1hdGguZmxvb3Ioc2VnTGFzdCk7IC8vIGluLWJldHdlZW4gZW5kcyByb3VuZCB0byBwcmV2IGNlbGxcblxuXHRcdFx0aWYgKHNlZ0ZpcnN0IDw9IHNlZ0xhc3QpIHsgLy8gd2FzIHRoZXJlIGFueSBpbnRlcnNlY3Rpb24gd2l0aCB0aGUgY3VycmVudCByb3c/XG5cdFx0XHRcdHNlZ3MucHVzaCh7XG5cdFx0XHRcdFx0cm93OiByb3csXG5cblx0XHRcdFx0XHQvLyBub3JtYWxpemUgdG8gc3RhcnQgb2Ygcm93XG5cdFx0XHRcdFx0Zmlyc3RSb3dEYXlJbmRleDogc2VnRmlyc3QgLSByb3dGaXJzdCxcblx0XHRcdFx0XHRsYXN0Um93RGF5SW5kZXg6IHNlZ0xhc3QgLSByb3dGaXJzdCxcblxuXHRcdFx0XHRcdC8vIG11c3QgYmUgbWF0Y2hpbmcgaW50ZWdlcnMgdG8gYmUgdGhlIHNlZ21lbnQncyBzdGFydC9lbmRcblx0XHRcdFx0XHRpc1N0YXJ0OiBzZWdGaXJzdCA9PT0gcmFuZ2VGaXJzdCxcblx0XHRcdFx0XHRpc0VuZDogc2VnTGFzdCA9PT0gcmFuZ2VMYXN0XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBzZWdzO1xuXHR9LFxuXG5cblx0Ly8gU2xpY2VzIHVwIGEgZGF0ZSByYW5nZSBpbnRvIGEgc2VnbWVudCBmb3IgZXZlcnkgZGF5LWNlbGwgaXQgaW50ZXJzZWN0cyB3aXRoLlxuXHQvLyBUT0RPOiBtYWtlIG1vcmUgRFJZIHdpdGggc2xpY2VSYW5nZUJ5Um93IHNvbWVob3cuXG5cdHNsaWNlUmFuZ2VCeURheTogZnVuY3Rpb24ocmFuZ2UpIHtcblx0XHR2YXIgZGF5c1BlclJvdyA9IHRoaXMuZGF5c1BlclJvdztcblx0XHR2YXIgbm9ybWFsUmFuZ2UgPSB0aGlzLnZpZXcuY29tcHV0ZURheVJhbmdlKHJhbmdlKTsgLy8gbWFrZSB3aG9sZS1kYXkgcmFuZ2UsIGNvbnNpZGVyaW5nIG5leHREYXlUaHJlc2hvbGRcblx0XHR2YXIgcmFuZ2VGaXJzdCA9IHRoaXMuZ2V0RGF0ZURheUluZGV4KG5vcm1hbFJhbmdlLnN0YXJ0KTsgLy8gaW5jbHVzaXZlIGZpcnN0IGluZGV4XG5cdFx0dmFyIHJhbmdlTGFzdCA9IHRoaXMuZ2V0RGF0ZURheUluZGV4KG5vcm1hbFJhbmdlLmVuZC5jbG9uZSgpLnN1YnRyYWN0KDEsICdkYXlzJykpOyAvLyBpbmNsdXNpdmUgbGFzdCBpbmRleFxuXHRcdHZhciBzZWdzID0gW107XG5cdFx0dmFyIHJvdztcblx0XHR2YXIgcm93Rmlyc3QsIHJvd0xhc3Q7IC8vIGluY2x1c2l2ZSBkYXktaW5kZXggcmFuZ2UgZm9yIGN1cnJlbnQgcm93XG5cdFx0dmFyIGk7XG5cdFx0dmFyIHNlZ0ZpcnN0LCBzZWdMYXN0OyAvLyBpbmNsdXNpdmUgZGF5LWluZGV4IHJhbmdlIGZvciBzZWdtZW50XG5cblx0XHRmb3IgKHJvdyA9IDA7IHJvdyA8IHRoaXMucm93Q250OyByb3crKykge1xuXHRcdFx0cm93Rmlyc3QgPSByb3cgKiBkYXlzUGVyUm93O1xuXHRcdFx0cm93TGFzdCA9IHJvd0ZpcnN0ICsgZGF5c1BlclJvdyAtIDE7XG5cblx0XHRcdGZvciAoaSA9IHJvd0ZpcnN0OyBpIDw9IHJvd0xhc3Q7IGkrKykge1xuXG5cdFx0XHRcdC8vIGludGVyc2VjdCBzZWdtZW50J3Mgb2Zmc2V0IHJhbmdlIHdpdGggdGhlIHJvdydzXG5cdFx0XHRcdHNlZ0ZpcnN0ID0gTWF0aC5tYXgocmFuZ2VGaXJzdCwgaSk7XG5cdFx0XHRcdHNlZ0xhc3QgPSBNYXRoLm1pbihyYW5nZUxhc3QsIGkpO1xuXG5cdFx0XHRcdC8vIGRlYWwgd2l0aCBpbi1iZXR3ZWVuIGluZGljZXNcblx0XHRcdFx0c2VnRmlyc3QgPSBNYXRoLmNlaWwoc2VnRmlyc3QpOyAvLyBpbi1iZXR3ZWVuIHN0YXJ0cyByb3VuZCB0byBuZXh0IGNlbGxcblx0XHRcdFx0c2VnTGFzdCA9IE1hdGguZmxvb3Ioc2VnTGFzdCk7IC8vIGluLWJldHdlZW4gZW5kcyByb3VuZCB0byBwcmV2IGNlbGxcblxuXHRcdFx0XHRpZiAoc2VnRmlyc3QgPD0gc2VnTGFzdCkgeyAvLyB3YXMgdGhlcmUgYW55IGludGVyc2VjdGlvbiB3aXRoIHRoZSBjdXJyZW50IHJvdz9cblx0XHRcdFx0XHRzZWdzLnB1c2goe1xuXHRcdFx0XHRcdFx0cm93OiByb3csXG5cblx0XHRcdFx0XHRcdC8vIG5vcm1hbGl6ZSB0byBzdGFydCBvZiByb3dcblx0XHRcdFx0XHRcdGZpcnN0Um93RGF5SW5kZXg6IHNlZ0ZpcnN0IC0gcm93Rmlyc3QsXG5cdFx0XHRcdFx0XHRsYXN0Um93RGF5SW5kZXg6IHNlZ0xhc3QgLSByb3dGaXJzdCxcblxuXHRcdFx0XHRcdFx0Ly8gbXVzdCBiZSBtYXRjaGluZyBpbnRlZ2VycyB0byBiZSB0aGUgc2VnbWVudCdzIHN0YXJ0L2VuZFxuXHRcdFx0XHRcdFx0aXNTdGFydDogc2VnRmlyc3QgPT09IHJhbmdlRmlyc3QsXG5cdFx0XHRcdFx0XHRpc0VuZDogc2VnTGFzdCA9PT0gcmFuZ2VMYXN0XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gc2Vncztcblx0fSxcblxuXG5cdC8qIEhlYWRlciBSZW5kZXJpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdHJlbmRlckhlYWRIdG1sOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblxuXHRcdHJldHVybiAnJyArXG5cdFx0XHQnPGRpdiBjbGFzcz1cImZjLXJvdyAnICsgdmlldy53aWRnZXRIZWFkZXJDbGFzcyArICdcIj4nICtcblx0XHRcdFx0Jzx0YWJsZT4nICtcblx0XHRcdFx0XHQnPHRoZWFkPicgK1xuXHRcdFx0XHRcdFx0dGhpcy5yZW5kZXJIZWFkVHJIdG1sKCkgK1xuXHRcdFx0XHRcdCc8L3RoZWFkPicgK1xuXHRcdFx0XHQnPC90YWJsZT4nICtcblx0XHRcdCc8L2Rpdj4nO1xuXHR9LFxuXG5cblx0cmVuZGVySGVhZEludHJvSHRtbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVuZGVySW50cm9IdG1sKCk7IC8vIGZhbGwgYmFjayB0byBnZW5lcmljXG5cdH0sXG5cblxuXHRyZW5kZXJIZWFkVHJIdG1sOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gJycgK1xuXHRcdFx0Jzx0cj4nICtcblx0XHRcdFx0KHRoaXMuaXNSVEwgPyAnJyA6IHRoaXMucmVuZGVySGVhZEludHJvSHRtbCgpKSArXG5cdFx0XHRcdHRoaXMucmVuZGVySGVhZERhdGVDZWxsc0h0bWwoKSArXG5cdFx0XHRcdCh0aGlzLmlzUlRMID8gdGhpcy5yZW5kZXJIZWFkSW50cm9IdG1sKCkgOiAnJykgK1xuXHRcdFx0JzwvdHI+Jztcblx0fSxcblxuXG5cdHJlbmRlckhlYWREYXRlQ2VsbHNIdG1sOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaHRtbHMgPSBbXTtcblx0XHR2YXIgY29sLCBkYXRlO1xuXG5cdFx0Zm9yIChjb2wgPSAwOyBjb2wgPCB0aGlzLmNvbENudDsgY29sKyspIHtcblx0XHRcdGRhdGUgPSB0aGlzLmdldENlbGxEYXRlKDAsIGNvbCk7XG5cdFx0XHRodG1scy5wdXNoKHRoaXMucmVuZGVySGVhZERhdGVDZWxsSHRtbChkYXRlKSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGh0bWxzLmpvaW4oJycpO1xuXHR9LFxuXG5cblx0Ly8gVE9ETzogd2hlbiBpbnRlcm5hbEFwaVZlcnNpb24sIGFjY2VwdCBhbiBvYmplY3QgZm9yIEhUTUwgYXR0cmlidXRlc1xuXHQvLyAoY29sc3BhbiBzaG91bGQgYmUgbm8gZGlmZmVyZW50KVxuXHRyZW5kZXJIZWFkRGF0ZUNlbGxIdG1sOiBmdW5jdGlvbihkYXRlLCBjb2xzcGFuLCBvdGhlckF0dHJzKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cblx0XHRyZXR1cm4gJycgK1xuXHRcdFx0Jzx0aCBjbGFzcz1cImZjLWRheS1oZWFkZXIgJyArIHZpZXcud2lkZ2V0SGVhZGVyQ2xhc3MgKyAnIGZjLScgKyBkYXlJRHNbZGF0ZS5kYXkoKV0gKyAnXCInICtcblx0XHRcdFx0KHRoaXMucm93Q250ID09PSAxID9cblx0XHRcdFx0XHQnIGRhdGEtZGF0ZT1cIicgKyBkYXRlLmZvcm1hdCgnWVlZWS1NTS1ERCcpICsgJ1wiJyA6XG5cdFx0XHRcdFx0JycpICtcblx0XHRcdFx0KGNvbHNwYW4gPiAxID9cblx0XHRcdFx0XHQnIGNvbHNwYW49XCInICsgY29sc3BhbiArICdcIicgOlxuXHRcdFx0XHRcdCcnKSArXG5cdFx0XHRcdChvdGhlckF0dHJzID9cblx0XHRcdFx0XHQnICcgKyBvdGhlckF0dHJzIDpcblx0XHRcdFx0XHQnJykgK1xuXHRcdFx0XHQnPicgK1xuXHRcdFx0XHQvLyBkb24ndCBtYWtlIGEgbGluayBpZiB0aGUgaGVhZGluZyBjb3VsZCByZXByZXNlbnQgbXVsdGlwbGUgZGF5cywgb3IgaWYgdGhlcmUncyBvbmx5IG9uZSBkYXkgKGZvcmNlT2ZmKVxuXHRcdFx0XHR2aWV3LmJ1aWxkR290b0FuY2hvckh0bWwoXG5cdFx0XHRcdFx0eyBkYXRlOiBkYXRlLCBmb3JjZU9mZjogdGhpcy5yb3dDbnQgPiAxIHx8IHRoaXMuY29sQ250ID09PSAxIH0sXG5cdFx0XHRcdFx0aHRtbEVzY2FwZShkYXRlLmZvcm1hdCh0aGlzLmNvbEhlYWRGb3JtYXQpKSAvLyBpbm5lciBIVE1MXG5cdFx0XHRcdCkgK1xuXHRcdFx0JzwvdGg+Jztcblx0fSxcblxuXG5cdC8qIEJhY2tncm91bmQgUmVuZGVyaW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHRyZW5kZXJCZ1RySHRtbDogZnVuY3Rpb24ocm93KSB7XG5cdFx0cmV0dXJuICcnICtcblx0XHRcdCc8dHI+JyArXG5cdFx0XHRcdCh0aGlzLmlzUlRMID8gJycgOiB0aGlzLnJlbmRlckJnSW50cm9IdG1sKHJvdykpICtcblx0XHRcdFx0dGhpcy5yZW5kZXJCZ0NlbGxzSHRtbChyb3cpICtcblx0XHRcdFx0KHRoaXMuaXNSVEwgPyB0aGlzLnJlbmRlckJnSW50cm9IdG1sKHJvdykgOiAnJykgK1xuXHRcdFx0JzwvdHI+Jztcblx0fSxcblxuXG5cdHJlbmRlckJnSW50cm9IdG1sOiBmdW5jdGlvbihyb3cpIHtcblx0XHRyZXR1cm4gdGhpcy5yZW5kZXJJbnRyb0h0bWwoKTsgLy8gZmFsbCBiYWNrIHRvIGdlbmVyaWNcblx0fSxcblxuXG5cdHJlbmRlckJnQ2VsbHNIdG1sOiBmdW5jdGlvbihyb3cpIHtcblx0XHR2YXIgaHRtbHMgPSBbXTtcblx0XHR2YXIgY29sLCBkYXRlO1xuXG5cdFx0Zm9yIChjb2wgPSAwOyBjb2wgPCB0aGlzLmNvbENudDsgY29sKyspIHtcblx0XHRcdGRhdGUgPSB0aGlzLmdldENlbGxEYXRlKHJvdywgY29sKTtcblx0XHRcdGh0bWxzLnB1c2godGhpcy5yZW5kZXJCZ0NlbGxIdG1sKGRhdGUpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaHRtbHMuam9pbignJyk7XG5cdH0sXG5cblxuXHRyZW5kZXJCZ0NlbGxIdG1sOiBmdW5jdGlvbihkYXRlLCBvdGhlckF0dHJzKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIGNsYXNzZXMgPSB0aGlzLmdldERheUNsYXNzZXMoZGF0ZSk7XG5cblx0XHRjbGFzc2VzLnVuc2hpZnQoJ2ZjLWRheScsIHZpZXcud2lkZ2V0Q29udGVudENsYXNzKTtcblxuXHRcdHJldHVybiAnPHRkIGNsYXNzPVwiJyArIGNsYXNzZXMuam9pbignICcpICsgJ1wiJyArXG5cdFx0XHQnIGRhdGEtZGF0ZT1cIicgKyBkYXRlLmZvcm1hdCgnWVlZWS1NTS1ERCcpICsgJ1wiJyArIC8vIGlmIGRhdGUgaGFzIGEgdGltZSwgd29uJ3QgZm9ybWF0IGl0XG5cdFx0XHQob3RoZXJBdHRycyA/XG5cdFx0XHRcdCcgJyArIG90aGVyQXR0cnMgOlxuXHRcdFx0XHQnJykgK1xuXHRcdFx0Jz48L3RkPic7XG5cdH0sXG5cblxuXHQvKiBHZW5lcmljXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBHZW5lcmF0ZXMgdGhlIGRlZmF1bHQgSFRNTCBpbnRybyBmb3IgYW55IHJvdy4gVXNlciBjbGFzc2VzIHNob3VsZCBvdmVycmlkZVxuXHRyZW5kZXJJbnRyb0h0bWw6IGZ1bmN0aW9uKCkge1xuXHR9LFxuXG5cblx0Ly8gVE9ETzogYSBnZW5lcmljIG1ldGhvZCBmb3IgZGVhbGluZyB3aXRoIDx0cj4sIFJUTCwgaW50cm9cblx0Ly8gd2hlbiBpbmNyZW1lbnQgaW50ZXJuYWxBcGlWZXJzaW9uXG5cdC8vIHdyYXBUciAoc2NoZWR1bGVyKVxuXG5cblx0LyogVXRpbHNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIEFwcGxpZXMgdGhlIGdlbmVyaWMgXCJpbnRyb1wiIGFuZCBcIm91dHJvXCIgSFRNTCB0byB0aGUgZ2l2ZW4gY2VsbHMuXG5cdC8vIEludHJvIG1lYW5zIHRoZSBsZWZ0bW9zdCBjZWxsIHdoZW4gdGhlIGNhbGVuZGFyIGlzIExUUiBhbmQgdGhlIHJpZ2h0bW9zdCBjZWxsIHdoZW4gUlRMLiBWaWNlLXZlcnNhIGZvciBvdXRyby5cblx0Ym9va2VuZENlbGxzOiBmdW5jdGlvbih0ckVsKSB7XG5cdFx0dmFyIGludHJvSHRtbCA9IHRoaXMucmVuZGVySW50cm9IdG1sKCk7XG5cblx0XHRpZiAoaW50cm9IdG1sKSB7XG5cdFx0XHRpZiAodGhpcy5pc1JUTCkge1xuXHRcdFx0XHR0ckVsLmFwcGVuZChpbnRyb0h0bWwpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHRyRWwucHJlcGVuZChpbnRyb0h0bWwpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG59O1xuXG47O1xuXG4vKiBBIGNvbXBvbmVudCB0aGF0IHJlbmRlcnMgYSBncmlkIG9mIHdob2xlLWRheXMgdGhhdCBydW5zIGhvcml6b250YWxseS4gVGhlcmUgY2FuIGJlIG11bHRpcGxlIHJvd3MsIG9uZSBwZXIgd2Vlay5cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG52YXIgRGF5R3JpZCA9IEZDLkRheUdyaWQgPSBHcmlkLmV4dGVuZChEYXlUYWJsZU1peGluLCB7XG5cblx0bnVtYmVyc1Zpc2libGU6IGZhbHNlLCAvLyBzaG91bGQgcmVuZGVyIGEgcm93IGZvciBkYXkvd2VlayBudW1iZXJzPyBzZXQgYnkgb3V0c2lkZSB2aWV3LiBUT0RPOiBtYWtlIGludGVybmFsXG5cdGJvdHRvbUNvb3JkUGFkZGluZzogMCwgLy8gaGFjayBmb3IgZXh0ZW5kaW5nIHRoZSBoaXQgYXJlYSBmb3IgdGhlIGxhc3Qgcm93IG9mIHRoZSBjb29yZGluYXRlIGdyaWRcblxuXHRyb3dFbHM6IG51bGwsIC8vIHNldCBvZiBmYWtlIHJvdyBlbGVtZW50c1xuXHRjZWxsRWxzOiBudWxsLCAvLyBzZXQgb2Ygd2hvbGUtZGF5IGVsZW1lbnRzIGNvbXByaXNpbmcgdGhlIHJvdydzIGJhY2tncm91bmRcblx0aGVscGVyRWxzOiBudWxsLCAvLyBzZXQgb2YgY2VsbCBza2VsZXRvbiBlbGVtZW50cyBmb3IgcmVuZGVyaW5nIHRoZSBtb2NrIGV2ZW50IFwiaGVscGVyXCJcblxuXHRyb3dDb29yZENhY2hlOiBudWxsLFxuXHRjb2xDb29yZENhY2hlOiBudWxsLFxuXG5cblx0Ly8gUmVuZGVycyB0aGUgcm93cyBhbmQgY29sdW1ucyBpbnRvIHRoZSBjb21wb25lbnQncyBgdGhpcy5lbGAsIHdoaWNoIHNob3VsZCBhbHJlYWR5IGJlIGFzc2lnbmVkLlxuXHQvLyBpc1JpZ2lkIGRldGVybWlucyB3aGV0aGVyIHRoZSBpbmRpdmlkdWFsIHJvd3Mgc2hvdWxkIGlnbm9yZSB0aGUgY29udGVudHMgYW5kIGJlIGEgY29uc3RhbnQgaGVpZ2h0LlxuXHQvLyBSZWxpZXMgb24gdGhlIHZpZXcncyBjb2xDbnQgYW5kIHJvd0NudC4gSW4gdGhlIGZ1dHVyZSwgdGhpcyBjb21wb25lbnQgc2hvdWxkIHByb2JhYmx5IGJlIHNlbGYtc3VmZmljaWVudC5cblx0cmVuZGVyRGF0ZXM6IGZ1bmN0aW9uKGlzUmlnaWQpIHtcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblx0XHR2YXIgcm93Q250ID0gdGhpcy5yb3dDbnQ7XG5cdFx0dmFyIGNvbENudCA9IHRoaXMuY29sQ250O1xuXHRcdHZhciBodG1sID0gJyc7XG5cdFx0dmFyIHJvdztcblx0XHR2YXIgY29sO1xuXG5cdFx0Zm9yIChyb3cgPSAwOyByb3cgPCByb3dDbnQ7IHJvdysrKSB7XG5cdFx0XHRodG1sICs9IHRoaXMucmVuZGVyRGF5Um93SHRtbChyb3csIGlzUmlnaWQpO1xuXHRcdH1cblx0XHR0aGlzLmVsLmh0bWwoaHRtbCk7XG5cblx0XHR0aGlzLnJvd0VscyA9IHRoaXMuZWwuZmluZCgnLmZjLXJvdycpO1xuXHRcdHRoaXMuY2VsbEVscyA9IHRoaXMuZWwuZmluZCgnLmZjLWRheScpO1xuXG5cdFx0dGhpcy5yb3dDb29yZENhY2hlID0gbmV3IENvb3JkQ2FjaGUoe1xuXHRcdFx0ZWxzOiB0aGlzLnJvd0Vscyxcblx0XHRcdGlzVmVydGljYWw6IHRydWVcblx0XHR9KTtcblx0XHR0aGlzLmNvbENvb3JkQ2FjaGUgPSBuZXcgQ29vcmRDYWNoZSh7XG5cdFx0XHRlbHM6IHRoaXMuY2VsbEVscy5zbGljZSgwLCB0aGlzLmNvbENudCksIC8vIG9ubHkgdGhlIGZpcnN0IHJvd1xuXHRcdFx0aXNIb3Jpem9udGFsOiB0cnVlXG5cdFx0fSk7XG5cblx0XHQvLyB0cmlnZ2VyIGRheVJlbmRlciB3aXRoIGVhY2ggY2VsbCdzIGVsZW1lbnRcblx0XHRmb3IgKHJvdyA9IDA7IHJvdyA8IHJvd0NudDsgcm93KyspIHtcblx0XHRcdGZvciAoY29sID0gMDsgY29sIDwgY29sQ250OyBjb2wrKykge1xuXHRcdFx0XHR2aWV3LnRyaWdnZXIoXG5cdFx0XHRcdFx0J2RheVJlbmRlcicsXG5cdFx0XHRcdFx0bnVsbCxcblx0XHRcdFx0XHR0aGlzLmdldENlbGxEYXRlKHJvdywgY29sKSxcblx0XHRcdFx0XHR0aGlzLmdldENlbGxFbChyb3csIGNvbClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblxuXHR1bnJlbmRlckRhdGVzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnJlbW92ZVNlZ1BvcG92ZXIoKTtcblx0fSxcblxuXG5cdHJlbmRlckJ1c2luZXNzSG91cnM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWdzID0gdGhpcy5idWlsZEJ1c2luZXNzSG91clNlZ3ModHJ1ZSk7IC8vIHdob2xlRGF5PXRydWVcblx0XHR0aGlzLnJlbmRlckZpbGwoJ2J1c2luZXNzSG91cnMnLCBzZWdzLCAnYmdldmVudCcpO1xuXHR9LFxuXG5cblx0dW5yZW5kZXJCdXNpbmVzc0hvdXJzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnVucmVuZGVyRmlsbCgnYnVzaW5lc3NIb3VycycpO1xuXHR9LFxuXG5cblx0Ly8gR2VuZXJhdGVzIHRoZSBIVE1MIGZvciBhIHNpbmdsZSByb3csIHdoaWNoIGlzIGEgZGl2IHRoYXQgd3JhcHMgYSB0YWJsZS5cblx0Ly8gYHJvd2AgaXMgdGhlIHJvdyBudW1iZXIuXG5cdHJlbmRlckRheVJvd0h0bWw6IGZ1bmN0aW9uKHJvdywgaXNSaWdpZCkge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXHRcdHZhciBjbGFzc2VzID0gWyAnZmMtcm93JywgJ2ZjLXdlZWsnLCB2aWV3LndpZGdldENvbnRlbnRDbGFzcyBdO1xuXG5cdFx0aWYgKGlzUmlnaWQpIHtcblx0XHRcdGNsYXNzZXMucHVzaCgnZmMtcmlnaWQnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gJycgK1xuXHRcdFx0JzxkaXYgY2xhc3M9XCInICsgY2xhc3Nlcy5qb2luKCcgJykgKyAnXCI+JyArXG5cdFx0XHRcdCc8ZGl2IGNsYXNzPVwiZmMtYmdcIj4nICtcblx0XHRcdFx0XHQnPHRhYmxlPicgK1xuXHRcdFx0XHRcdFx0dGhpcy5yZW5kZXJCZ1RySHRtbChyb3cpICtcblx0XHRcdFx0XHQnPC90YWJsZT4nICtcblx0XHRcdFx0JzwvZGl2PicgK1xuXHRcdFx0XHQnPGRpdiBjbGFzcz1cImZjLWNvbnRlbnQtc2tlbGV0b25cIj4nICtcblx0XHRcdFx0XHQnPHRhYmxlPicgK1xuXHRcdFx0XHRcdFx0KHRoaXMubnVtYmVyc1Zpc2libGUgP1xuXHRcdFx0XHRcdFx0XHQnPHRoZWFkPicgK1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMucmVuZGVyTnVtYmVyVHJIdG1sKHJvdykgK1xuXHRcdFx0XHRcdFx0XHQnPC90aGVhZD4nIDpcblx0XHRcdFx0XHRcdFx0Jydcblx0XHRcdFx0XHRcdFx0KSArXG5cdFx0XHRcdFx0JzwvdGFibGU+JyArXG5cdFx0XHRcdCc8L2Rpdj4nICtcblx0XHRcdCc8L2Rpdj4nO1xuXHR9LFxuXG5cblx0LyogR3JpZCBOdW1iZXIgUmVuZGVyaW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHRyZW5kZXJOdW1iZXJUckh0bWw6IGZ1bmN0aW9uKHJvdykge1xuXHRcdHJldHVybiAnJyArXG5cdFx0XHQnPHRyPicgK1xuXHRcdFx0XHQodGhpcy5pc1JUTCA/ICcnIDogdGhpcy5yZW5kZXJOdW1iZXJJbnRyb0h0bWwocm93KSkgK1xuXHRcdFx0XHR0aGlzLnJlbmRlck51bWJlckNlbGxzSHRtbChyb3cpICtcblx0XHRcdFx0KHRoaXMuaXNSVEwgPyB0aGlzLnJlbmRlck51bWJlckludHJvSHRtbChyb3cpIDogJycpICtcblx0XHRcdCc8L3RyPic7XG5cdH0sXG5cblxuXHRyZW5kZXJOdW1iZXJJbnRyb0h0bWw6IGZ1bmN0aW9uKHJvdykge1xuXHRcdHJldHVybiB0aGlzLnJlbmRlckludHJvSHRtbCgpO1xuXHR9LFxuXG5cblx0cmVuZGVyTnVtYmVyQ2VsbHNIdG1sOiBmdW5jdGlvbihyb3cpIHtcblx0XHR2YXIgaHRtbHMgPSBbXTtcblx0XHR2YXIgY29sLCBkYXRlO1xuXG5cdFx0Zm9yIChjb2wgPSAwOyBjb2wgPCB0aGlzLmNvbENudDsgY29sKyspIHtcblx0XHRcdGRhdGUgPSB0aGlzLmdldENlbGxEYXRlKHJvdywgY29sKTtcblx0XHRcdGh0bWxzLnB1c2godGhpcy5yZW5kZXJOdW1iZXJDZWxsSHRtbChkYXRlKSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGh0bWxzLmpvaW4oJycpO1xuXHR9LFxuXG5cblx0Ly8gR2VuZXJhdGVzIHRoZSBIVE1MIGZvciB0aGUgPHRkPnMgb2YgdGhlIFwibnVtYmVyXCIgcm93IGluIHRoZSBEYXlHcmlkJ3MgY29udGVudCBza2VsZXRvbi5cblx0Ly8gVGhlIG51bWJlciByb3cgd2lsbCBvbmx5IGV4aXN0IGlmIGVpdGhlciBkYXkgbnVtYmVycyBvciB3ZWVrIG51bWJlcnMgYXJlIHR1cm5lZCBvbi5cblx0cmVuZGVyTnVtYmVyQ2VsbEh0bWw6IGZ1bmN0aW9uKGRhdGUpIHtcblx0XHR2YXIgaHRtbCA9ICcnO1xuXHRcdHZhciBjbGFzc2VzO1xuXHRcdHZhciB3ZWVrQ2FsY0ZpcnN0RG9XO1xuXG5cdFx0aWYgKCF0aGlzLnZpZXcuZGF5TnVtYmVyc1Zpc2libGUgJiYgIXRoaXMudmlldy5jZWxsV2Vla051bWJlcnNWaXNpYmxlKSB7XG5cdFx0XHQvLyBubyBudW1iZXJzIGluIGRheSBjZWxsICh3ZWVrIG51bWJlciBtdXN0IGJlIGFsb25nIHRoZSBzaWRlKVxuXHRcdFx0cmV0dXJuICc8dGQvPic7IC8vICB3aWxsIGNyZWF0ZSBhbiBlbXB0eSBzcGFjZSBhYm92ZSBldmVudHMgOihcblx0XHR9XG5cblx0XHRjbGFzc2VzID0gdGhpcy5nZXREYXlDbGFzc2VzKGRhdGUpO1xuXHRcdGNsYXNzZXMudW5zaGlmdCgnZmMtZGF5LXRvcCcpO1xuXG5cdFx0aWYgKHRoaXMudmlldy5jZWxsV2Vla051bWJlcnNWaXNpYmxlKSB7XG5cdFx0XHQvLyBUbyBkZXRlcm1pbmUgdGhlIGRheSBvZiB3ZWVrIG51bWJlciBjaGFuZ2UgdW5kZXIgSVNPLCB3ZSBjYW5ub3Rcblx0XHRcdC8vIHJlbHkgb24gbW9tZW50LmpzIG1ldGhvZHMgc3VjaCBhcyBmaXJzdERheU9mV2VlaygpIG9yIHdlZWtkYXkoKSxcblx0XHRcdC8vIGJlY2F1c2UgdGhleSByZWx5IG9uIHRoZSBsb2NhbGUncyBkb3cgKHBvc3NpYmx5IG92ZXJyaWRkZW4gYnlcblx0XHRcdC8vIG91ciBmaXJzdERheSBvcHRpb24pLCB3aGljaCBtYXkgbm90IGJlIE1vbmRheS4gV2UgY2Fubm90IGNoYW5nZVxuXHRcdFx0Ly8gZG93LCBiZWNhdXNlIHRoYXQgd291bGQgYWZmZWN0IHRoZSBjYWxlbmRhciBzdGFydCBkYXkgYXMgd2VsbC5cblx0XHRcdGlmIChkYXRlLl9sb2NhbGUuX2Z1bGxDYWxlbmRhcl93ZWVrQ2FsYyA9PT0gJ0lTTycpIHtcblx0XHRcdFx0d2Vla0NhbGNGaXJzdERvVyA9IDE7ICAvLyBNb25kYXkgYnkgSVNPIDg2MDEgZGVmaW5pdGlvblxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHdlZWtDYWxjRmlyc3REb1cgPSBkYXRlLl9sb2NhbGUuZmlyc3REYXlPZldlZWsoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRodG1sICs9ICc8dGQgY2xhc3M9XCInICsgY2xhc3Nlcy5qb2luKCcgJykgKyAnXCIgZGF0YS1kYXRlPVwiJyArIGRhdGUuZm9ybWF0KCkgKyAnXCI+JztcblxuXHRcdGlmICh0aGlzLnZpZXcuY2VsbFdlZWtOdW1iZXJzVmlzaWJsZSAmJiAoZGF0ZS5kYXkoKSA9PSB3ZWVrQ2FsY0ZpcnN0RG9XKSkge1xuXHRcdFx0aHRtbCArPSB0aGlzLnZpZXcuYnVpbGRHb3RvQW5jaG9ySHRtbChcblx0XHRcdFx0eyBkYXRlOiBkYXRlLCB0eXBlOiAnd2VlaycgfSxcblx0XHRcdFx0eyAnY2xhc3MnOiAnZmMtd2Vlay1udW1iZXInIH0sXG5cdFx0XHRcdGRhdGUuZm9ybWF0KCd3JykgLy8gaW5uZXIgSFRNTFxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy52aWV3LmRheU51bWJlcnNWaXNpYmxlKSB7XG5cdFx0XHRodG1sICs9IHRoaXMudmlldy5idWlsZEdvdG9BbmNob3JIdG1sKFxuXHRcdFx0XHRkYXRlLFxuXHRcdFx0XHR7ICdjbGFzcyc6ICdmYy1kYXktbnVtYmVyJyB9LFxuXHRcdFx0XHRkYXRlLmRhdGUoKSAvLyBpbm5lciBIVE1MXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGh0bWwgKz0gJzwvdGQ+JztcblxuXHRcdHJldHVybiBodG1sO1xuXHR9LFxuXG5cblx0LyogT3B0aW9uc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gQ29tcHV0ZXMgYSBkZWZhdWx0IGV2ZW50IHRpbWUgZm9ybWF0dGluZyBzdHJpbmcgaWYgYHRpbWVGb3JtYXRgIGlzIG5vdCBleHBsaWNpdGx5IGRlZmluZWRcblx0Y29tcHV0ZUV2ZW50VGltZUZvcm1hdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMudmlldy5vcHQoJ2V4dHJhU21hbGxUaW1lRm9ybWF0Jyk7IC8vIGxpa2UgXCI2cFwiIG9yIFwiNjozMHBcIlxuXHR9LFxuXG5cblx0Ly8gQ29tcHV0ZXMgYSBkZWZhdWx0IGBkaXNwbGF5RXZlbnRFbmRgIHZhbHVlIGlmIG9uZSBpcyBub3QgZXhwbGljbHR5IGRlZmluZWRcblx0Y29tcHV0ZURpc3BsYXlFdmVudEVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29sQ250ID09IDE7IC8vIHdlJ2xsIGxpa2VseSBoYXZlIHNwYWNlIGlmIHRoZXJlJ3Mgb25seSBvbmUgZGF5XG5cdH0sXG5cblxuXHQvKiBEYXRlc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0cmFuZ2VVcGRhdGVkOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnVwZGF0ZURheVRhYmxlKCk7XG5cdH0sXG5cblxuXHQvLyBTbGljZXMgdXAgdGhlIGdpdmVuIHNwYW4gKHVuem9uZWQgc3RhcnQvZW5kIHdpdGggb3RoZXIgbWlzYyBkYXRhKSBpbnRvIGFuIGFycmF5IG9mIHNlZ21lbnRzXG5cdHNwYW5Ub1NlZ3M6IGZ1bmN0aW9uKHNwYW4pIHtcblx0XHR2YXIgc2VncyA9IHRoaXMuc2xpY2VSYW5nZUJ5Um93KHNwYW4pO1xuXHRcdHZhciBpLCBzZWc7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0c2VnID0gc2Vnc1tpXTtcblx0XHRcdGlmICh0aGlzLmlzUlRMKSB7XG5cdFx0XHRcdHNlZy5sZWZ0Q29sID0gdGhpcy5kYXlzUGVyUm93IC0gMSAtIHNlZy5sYXN0Um93RGF5SW5kZXg7XG5cdFx0XHRcdHNlZy5yaWdodENvbCA9IHRoaXMuZGF5c1BlclJvdyAtIDEgLSBzZWcuZmlyc3RSb3dEYXlJbmRleDtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRzZWcubGVmdENvbCA9IHNlZy5maXJzdFJvd0RheUluZGV4O1xuXHRcdFx0XHRzZWcucmlnaHRDb2wgPSBzZWcubGFzdFJvd0RheUluZGV4O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBzZWdzO1xuXHR9LFxuXG5cblx0LyogSGl0IFN5c3RlbVxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0cHJlcGFyZUhpdHM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuY29sQ29vcmRDYWNoZS5idWlsZCgpO1xuXHRcdHRoaXMucm93Q29vcmRDYWNoZS5idWlsZCgpO1xuXHRcdHRoaXMucm93Q29vcmRDYWNoZS5ib3R0b21zW3RoaXMucm93Q250IC0gMV0gKz0gdGhpcy5ib3R0b21Db29yZFBhZGRpbmc7IC8vIGhhY2tcblx0fSxcblxuXG5cdHJlbGVhc2VIaXRzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmNvbENvb3JkQ2FjaGUuY2xlYXIoKTtcblx0XHR0aGlzLnJvd0Nvb3JkQ2FjaGUuY2xlYXIoKTtcblx0fSxcblxuXG5cdHF1ZXJ5SGl0OiBmdW5jdGlvbihsZWZ0T2Zmc2V0LCB0b3BPZmZzZXQpIHtcblx0XHRpZiAodGhpcy5jb2xDb29yZENhY2hlLmlzTGVmdEluQm91bmRzKGxlZnRPZmZzZXQpICYmIHRoaXMucm93Q29vcmRDYWNoZS5pc1RvcEluQm91bmRzKHRvcE9mZnNldCkpIHtcblx0XHRcdHZhciBjb2wgPSB0aGlzLmNvbENvb3JkQ2FjaGUuZ2V0SG9yaXpvbnRhbEluZGV4KGxlZnRPZmZzZXQpO1xuXHRcdFx0dmFyIHJvdyA9IHRoaXMucm93Q29vcmRDYWNoZS5nZXRWZXJ0aWNhbEluZGV4KHRvcE9mZnNldCk7XG5cblx0XHRcdGlmIChyb3cgIT0gbnVsbCAmJiBjb2wgIT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRDZWxsSGl0KHJvdywgY29sKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblxuXHRnZXRIaXRTcGFuOiBmdW5jdGlvbihoaXQpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRDZWxsUmFuZ2UoaGl0LnJvdywgaGl0LmNvbCk7XG5cdH0sXG5cblxuXHRnZXRIaXRFbDogZnVuY3Rpb24oaGl0KSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q2VsbEVsKGhpdC5yb3csIGhpdC5jb2wpO1xuXHR9LFxuXG5cblx0LyogQ2VsbCBTeXN0ZW1cblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblx0Ly8gRllJOiB0aGUgZmlyc3QgY29sdW1uIGlzIHRoZSBsZWZ0bW9zdCBjb2x1bW4sIHJlZ2FyZGxlc3Mgb2YgZGF0ZVxuXG5cblx0Z2V0Q2VsbEhpdDogZnVuY3Rpb24ocm93LCBjb2wpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0cm93OiByb3csXG5cdFx0XHRjb2w6IGNvbCxcblx0XHRcdGNvbXBvbmVudDogdGhpcywgLy8gbmVlZGVkIHVuZm9ydHVuYXRlbHkgOihcblx0XHRcdGxlZnQ6IHRoaXMuY29sQ29vcmRDYWNoZS5nZXRMZWZ0T2Zmc2V0KGNvbCksXG5cdFx0XHRyaWdodDogdGhpcy5jb2xDb29yZENhY2hlLmdldFJpZ2h0T2Zmc2V0KGNvbCksXG5cdFx0XHR0b3A6IHRoaXMucm93Q29vcmRDYWNoZS5nZXRUb3BPZmZzZXQocm93KSxcblx0XHRcdGJvdHRvbTogdGhpcy5yb3dDb29yZENhY2hlLmdldEJvdHRvbU9mZnNldChyb3cpXG5cdFx0fTtcblx0fSxcblxuXG5cdGdldENlbGxFbDogZnVuY3Rpb24ocm93LCBjb2wpIHtcblx0XHRyZXR1cm4gdGhpcy5jZWxsRWxzLmVxKHJvdyAqIHRoaXMuY29sQ250ICsgY29sKTtcblx0fSxcblxuXG5cdC8qIEV2ZW50IERyYWcgVmlzdWFsaXphdGlvblxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHQvLyBUT0RPOiBtb3ZlIHRvIERheUdyaWQuZXZlbnQsIHNpbWlsYXIgdG8gd2hhdCB3ZSBkaWQgd2l0aCBHcmlkJ3MgZHJhZyBtZXRob2RzXG5cblxuXHQvLyBSZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgYW4gZXZlbnQgb3IgZXh0ZXJuYWwgZWxlbWVudCBiZWluZyBkcmFnZ2VkLlxuXHQvLyBgZXZlbnRMb2NhdGlvbmAgaGFzIHpvbmVkIHN0YXJ0IGFuZCBlbmQgKG9wdGlvbmFsKVxuXHRyZW5kZXJEcmFnOiBmdW5jdGlvbihldmVudExvY2F0aW9uLCBzZWcpIHtcblxuXHRcdC8vIGFsd2F5cyByZW5kZXIgYSBoaWdobGlnaHQgdW5kZXJuZWF0aFxuXHRcdHRoaXMucmVuZGVySGlnaGxpZ2h0KHRoaXMuZXZlbnRUb1NwYW4oZXZlbnRMb2NhdGlvbikpO1xuXG5cdFx0Ly8gaWYgYSBzZWdtZW50IGZyb20gdGhlIHNhbWUgY2FsZW5kYXIgYnV0IGFub3RoZXIgY29tcG9uZW50IGlzIGJlaW5nIGRyYWdnZWQsIHJlbmRlciBhIGhlbHBlciBldmVudFxuXHRcdGlmIChzZWcgJiYgc2VnLmNvbXBvbmVudCAhPT0gdGhpcykge1xuXHRcdFx0cmV0dXJuIHRoaXMucmVuZGVyRXZlbnRMb2NhdGlvbkhlbHBlcihldmVudExvY2F0aW9uLCBzZWcpOyAvLyByZXR1cm5zIG1vY2sgZXZlbnQgZWxlbWVudHNcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBVbnJlbmRlcnMgYW55IHZpc3VhbCBpbmRpY2F0aW9uIG9mIGEgaG92ZXJpbmcgZXZlbnRcblx0dW5yZW5kZXJEcmFnOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnVucmVuZGVySGlnaGxpZ2h0KCk7XG5cdFx0dGhpcy51bnJlbmRlckhlbHBlcigpO1xuXHR9LFxuXG5cblx0LyogRXZlbnQgUmVzaXplIFZpc3VhbGl6YXRpb25cblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIFJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhbiBldmVudCBiZWluZyByZXNpemVkXG5cdHJlbmRlckV2ZW50UmVzaXplOiBmdW5jdGlvbihldmVudExvY2F0aW9uLCBzZWcpIHtcblx0XHR0aGlzLnJlbmRlckhpZ2hsaWdodCh0aGlzLmV2ZW50VG9TcGFuKGV2ZW50TG9jYXRpb24pKTtcblx0XHRyZXR1cm4gdGhpcy5yZW5kZXJFdmVudExvY2F0aW9uSGVscGVyKGV2ZW50TG9jYXRpb24sIHNlZyk7IC8vIHJldHVybnMgbW9jayBldmVudCBlbGVtZW50c1xuXHR9LFxuXG5cblx0Ly8gVW5yZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgYW4gZXZlbnQgYmVpbmcgcmVzaXplZFxuXHR1bnJlbmRlckV2ZW50UmVzaXplOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnVucmVuZGVySGlnaGxpZ2h0KCk7XG5cdFx0dGhpcy51bnJlbmRlckhlbHBlcigpO1xuXHR9LFxuXG5cblx0LyogRXZlbnQgSGVscGVyXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBSZW5kZXJzIGEgbW9jayBcImhlbHBlclwiIGV2ZW50LiBgc291cmNlU2VnYCBpcyB0aGUgYXNzb2NpYXRlZCBpbnRlcm5hbCBzZWdtZW50IG9iamVjdC4gSXQgY2FuIGJlIG51bGwuXG5cdHJlbmRlckhlbHBlcjogZnVuY3Rpb24oZXZlbnQsIHNvdXJjZVNlZykge1xuXHRcdHZhciBoZWxwZXJOb2RlcyA9IFtdO1xuXHRcdHZhciBzZWdzID0gdGhpcy5ldmVudFRvU2VncyhldmVudCk7XG5cdFx0dmFyIHJvd1N0cnVjdHM7XG5cblx0XHRzZWdzID0gdGhpcy5yZW5kZXJGZ1NlZ0VscyhzZWdzKTsgLy8gYXNzaWducyBlYWNoIHNlZydzIGVsIGFuZCByZXR1cm5zIGEgc3Vic2V0IG9mIHNlZ3MgdGhhdCB3ZXJlIHJlbmRlcmVkXG5cdFx0cm93U3RydWN0cyA9IHRoaXMucmVuZGVyU2VnUm93cyhzZWdzKTtcblxuXHRcdC8vIGluamVjdCBlYWNoIG5ldyBldmVudCBza2VsZXRvbiBpbnRvIGVhY2ggYXNzb2NpYXRlZCByb3dcblx0XHR0aGlzLnJvd0Vscy5lYWNoKGZ1bmN0aW9uKHJvdywgcm93Tm9kZSkge1xuXHRcdFx0dmFyIHJvd0VsID0gJChyb3dOb2RlKTsgLy8gdGhlIC5mYy1yb3dcblx0XHRcdHZhciBza2VsZXRvbkVsID0gJCgnPGRpdiBjbGFzcz1cImZjLWhlbHBlci1za2VsZXRvblwiPjx0YWJsZS8+PC9kaXY+Jyk7IC8vIHdpbGwgYmUgYWJzb2x1dGVseSBwb3NpdGlvbmVkXG5cdFx0XHR2YXIgc2tlbGV0b25Ub3A7XG5cblx0XHRcdC8vIElmIHRoZXJlIGlzIGFuIG9yaWdpbmFsIHNlZ21lbnQsIG1hdGNoIHRoZSB0b3AgcG9zaXRpb24uIE90aGVyd2lzZSwgcHV0IGl0IGF0IHRoZSByb3cncyB0b3AgbGV2ZWxcblx0XHRcdGlmIChzb3VyY2VTZWcgJiYgc291cmNlU2VnLnJvdyA9PT0gcm93KSB7XG5cdFx0XHRcdHNrZWxldG9uVG9wID0gc291cmNlU2VnLmVsLnBvc2l0aW9uKCkudG9wO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHNrZWxldG9uVG9wID0gcm93RWwuZmluZCgnLmZjLWNvbnRlbnQtc2tlbGV0b24gdGJvZHknKS5wb3NpdGlvbigpLnRvcDtcblx0XHRcdH1cblxuXHRcdFx0c2tlbGV0b25FbC5jc3MoJ3RvcCcsIHNrZWxldG9uVG9wKVxuXHRcdFx0XHQuZmluZCgndGFibGUnKVxuXHRcdFx0XHRcdC5hcHBlbmQocm93U3RydWN0c1tyb3ddLnRib2R5RWwpO1xuXG5cdFx0XHRyb3dFbC5hcHBlbmQoc2tlbGV0b25FbCk7XG5cdFx0XHRoZWxwZXJOb2Rlcy5wdXNoKHNrZWxldG9uRWxbMF0pO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuICggLy8gbXVzdCByZXR1cm4gdGhlIGVsZW1lbnRzIHJlbmRlcmVkXG5cdFx0XHR0aGlzLmhlbHBlckVscyA9ICQoaGVscGVyTm9kZXMpIC8vIGFycmF5IC0+IGpRdWVyeSBzZXRcblx0XHQpO1xuXHR9LFxuXG5cblx0Ly8gVW5yZW5kZXJzIGFueSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhIG1vY2sgaGVscGVyIGV2ZW50XG5cdHVucmVuZGVySGVscGVyOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5oZWxwZXJFbHMpIHtcblx0XHRcdHRoaXMuaGVscGVyRWxzLnJlbW92ZSgpO1xuXHRcdFx0dGhpcy5oZWxwZXJFbHMgPSBudWxsO1xuXHRcdH1cblx0fSxcblxuXG5cdC8qIEZpbGwgU3lzdGVtIChoaWdobGlnaHQsIGJhY2tncm91bmQgZXZlbnRzLCBidXNpbmVzcyBob3Vycylcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdGZpbGxTZWdUYWc6ICd0ZCcsIC8vIG92ZXJyaWRlIHRoZSBkZWZhdWx0IHRhZyBuYW1lXG5cblxuXHQvLyBSZW5kZXJzIGEgc2V0IG9mIHJlY3RhbmdsZXMgb3ZlciB0aGUgZ2l2ZW4gc2VnbWVudHMgb2YgZGF5cy5cblx0Ly8gT25seSByZXR1cm5zIHNlZ21lbnRzIHRoYXQgc3VjY2Vzc2Z1bGx5IHJlbmRlcmVkLlxuXHRyZW5kZXJGaWxsOiBmdW5jdGlvbih0eXBlLCBzZWdzLCBjbGFzc05hbWUpIHtcblx0XHR2YXIgbm9kZXMgPSBbXTtcblx0XHR2YXIgaSwgc2VnO1xuXHRcdHZhciBza2VsZXRvbkVsO1xuXG5cdFx0c2VncyA9IHRoaXMucmVuZGVyRmlsbFNlZ0Vscyh0eXBlLCBzZWdzKTsgLy8gYXNzaWduZXMgYC5lbGAgdG8gZWFjaCBzZWcuIHJldHVybnMgc3VjY2Vzc2Z1bGx5IHJlbmRlcmVkIHNlZ3NcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRzZWcgPSBzZWdzW2ldO1xuXHRcdFx0c2tlbGV0b25FbCA9IHRoaXMucmVuZGVyRmlsbFJvdyh0eXBlLCBzZWcsIGNsYXNzTmFtZSk7XG5cdFx0XHR0aGlzLnJvd0Vscy5lcShzZWcucm93KS5hcHBlbmQoc2tlbGV0b25FbCk7XG5cdFx0XHRub2Rlcy5wdXNoKHNrZWxldG9uRWxbMF0pO1xuXHRcdH1cblxuXHRcdHRoaXMuZWxzQnlGaWxsW3R5cGVdID0gJChub2Rlcyk7XG5cblx0XHRyZXR1cm4gc2Vncztcblx0fSxcblxuXG5cdC8vIEdlbmVyYXRlcyB0aGUgSFRNTCBuZWVkZWQgZm9yIG9uZSByb3cgb2YgYSBmaWxsLiBSZXF1aXJlcyB0aGUgc2VnJ3MgZWwgdG8gYmUgcmVuZGVyZWQuXG5cdHJlbmRlckZpbGxSb3c6IGZ1bmN0aW9uKHR5cGUsIHNlZywgY2xhc3NOYW1lKSB7XG5cdFx0dmFyIGNvbENudCA9IHRoaXMuY29sQ250O1xuXHRcdHZhciBzdGFydENvbCA9IHNlZy5sZWZ0Q29sO1xuXHRcdHZhciBlbmRDb2wgPSBzZWcucmlnaHRDb2wgKyAxO1xuXHRcdHZhciBza2VsZXRvbkVsO1xuXHRcdHZhciB0ckVsO1xuXG5cdFx0Y2xhc3NOYW1lID0gY2xhc3NOYW1lIHx8IHR5cGUudG9Mb3dlckNhc2UoKTtcblxuXHRcdHNrZWxldG9uRWwgPSAkKFxuXHRcdFx0JzxkaXYgY2xhc3M9XCJmYy0nICsgY2xhc3NOYW1lICsgJy1za2VsZXRvblwiPicgK1xuXHRcdFx0XHQnPHRhYmxlPjx0ci8+PC90YWJsZT4nICtcblx0XHRcdCc8L2Rpdj4nXG5cdFx0KTtcblx0XHR0ckVsID0gc2tlbGV0b25FbC5maW5kKCd0cicpO1xuXG5cdFx0aWYgKHN0YXJ0Q29sID4gMCkge1xuXHRcdFx0dHJFbC5hcHBlbmQoJzx0ZCBjb2xzcGFuPVwiJyArIHN0YXJ0Q29sICsgJ1wiLz4nKTtcblx0XHR9XG5cblx0XHR0ckVsLmFwcGVuZChcblx0XHRcdHNlZy5lbC5hdHRyKCdjb2xzcGFuJywgZW5kQ29sIC0gc3RhcnRDb2wpXG5cdFx0KTtcblxuXHRcdGlmIChlbmRDb2wgPCBjb2xDbnQpIHtcblx0XHRcdHRyRWwuYXBwZW5kKCc8dGQgY29sc3Bhbj1cIicgKyAoY29sQ250IC0gZW5kQ29sKSArICdcIi8+Jyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5ib29rZW5kQ2VsbHModHJFbCk7XG5cblx0XHRyZXR1cm4gc2tlbGV0b25FbDtcblx0fVxuXG59KTtcblxuOztcblxuLyogRXZlbnQtcmVuZGVyaW5nIG1ldGhvZHMgZm9yIHRoZSBEYXlHcmlkIGNsYXNzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuRGF5R3JpZC5taXhpbih7XG5cblx0cm93U3RydWN0czogbnVsbCwgLy8gYW4gYXJyYXkgb2Ygb2JqZWN0cywgZWFjaCBob2xkaW5nIGluZm9ybWF0aW9uIGFib3V0IGEgcm93J3MgZm9yZWdyb3VuZCBldmVudC1yZW5kZXJpbmdcblxuXG5cdC8vIFVucmVuZGVycyBhbGwgZXZlbnRzIGN1cnJlbnRseSByZW5kZXJlZCBvbiB0aGUgZ3JpZFxuXHR1bnJlbmRlckV2ZW50czogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5yZW1vdmVTZWdQb3BvdmVyKCk7IC8vIHJlbW92ZXMgdGhlIFwibW9yZS4uXCIgZXZlbnRzIHBvcG92ZXJcblx0XHRHcmlkLnByb3RvdHlwZS51bnJlbmRlckV2ZW50cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBjYWxscyB0aGUgc3VwZXItbWV0aG9kXG5cdH0sXG5cblxuXHQvLyBSZXRyaWV2ZXMgYWxsIHJlbmRlcmVkIHNlZ21lbnQgb2JqZWN0cyBjdXJyZW50bHkgcmVuZGVyZWQgb24gdGhlIGdyaWRcblx0Z2V0RXZlbnRTZWdzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gR3JpZC5wcm90b3R5cGUuZ2V0RXZlbnRTZWdzLmNhbGwodGhpcykgLy8gZ2V0IHRoZSBzZWdtZW50cyBmcm9tIHRoZSBzdXBlci1tZXRob2Rcblx0XHRcdC5jb25jYXQodGhpcy5wb3BvdmVyU2VncyB8fCBbXSk7IC8vIGFwcGVuZCB0aGUgc2VnbWVudHMgZnJvbSB0aGUgXCJtb3JlLi4uXCIgcG9wb3ZlclxuXHR9LFxuXG5cblx0Ly8gUmVuZGVycyB0aGUgZ2l2ZW4gYmFja2dyb3VuZCBldmVudCBzZWdtZW50cyBvbnRvIHRoZSBncmlkXG5cdHJlbmRlckJnU2VnczogZnVuY3Rpb24oc2Vncykge1xuXG5cdFx0Ly8gZG9uJ3QgcmVuZGVyIHRpbWVkIGJhY2tncm91bmQgZXZlbnRzXG5cdFx0dmFyIGFsbERheVNlZ3MgPSAkLmdyZXAoc2VncywgZnVuY3Rpb24oc2VnKSB7XG5cdFx0XHRyZXR1cm4gc2VnLmV2ZW50LmFsbERheTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBHcmlkLnByb3RvdHlwZS5yZW5kZXJCZ1NlZ3MuY2FsbCh0aGlzLCBhbGxEYXlTZWdzKTsgLy8gY2FsbCB0aGUgc3VwZXItbWV0aG9kXG5cdH0sXG5cblxuXHQvLyBSZW5kZXJzIHRoZSBnaXZlbiBmb3JlZ3JvdW5kIGV2ZW50IHNlZ21lbnRzIG9udG8gdGhlIGdyaWRcblx0cmVuZGVyRmdTZWdzOiBmdW5jdGlvbihzZWdzKSB7XG5cdFx0dmFyIHJvd1N0cnVjdHM7XG5cblx0XHQvLyByZW5kZXIgYW4gYC5lbGAgb24gZWFjaCBzZWdcblx0XHQvLyByZXR1cm5zIGEgc3Vic2V0IG9mIHRoZSBzZWdzLiBzZWdzIHRoYXQgd2VyZSBhY3R1YWxseSByZW5kZXJlZFxuXHRcdHNlZ3MgPSB0aGlzLnJlbmRlckZnU2VnRWxzKHNlZ3MpO1xuXG5cdFx0cm93U3RydWN0cyA9IHRoaXMucm93U3RydWN0cyA9IHRoaXMucmVuZGVyU2VnUm93cyhzZWdzKTtcblxuXHRcdC8vIGFwcGVuZCB0byBlYWNoIHJvdydzIGNvbnRlbnQgc2tlbGV0b25cblx0XHR0aGlzLnJvd0Vscy5lYWNoKGZ1bmN0aW9uKGksIHJvd05vZGUpIHtcblx0XHRcdCQocm93Tm9kZSkuZmluZCgnLmZjLWNvbnRlbnQtc2tlbGV0b24gPiB0YWJsZScpLmFwcGVuZChcblx0XHRcdFx0cm93U3RydWN0c1tpXS50Ym9keUVsXG5cdFx0XHQpO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHNlZ3M7IC8vIHJldHVybiBvbmx5IHRoZSBzZWdzIHRoYXQgd2VyZSBhY3R1YWxseSByZW5kZXJlZFxuXHR9LFxuXG5cblx0Ly8gVW5yZW5kZXJzIGFsbCBjdXJyZW50bHkgcmVuZGVyZWQgZm9yZWdyb3VuZCBldmVudCBzZWdtZW50c1xuXHR1bnJlbmRlckZnU2VnczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJvd1N0cnVjdHMgPSB0aGlzLnJvd1N0cnVjdHMgfHwgW107XG5cdFx0dmFyIHJvd1N0cnVjdDtcblxuXHRcdHdoaWxlICgocm93U3RydWN0ID0gcm93U3RydWN0cy5wb3AoKSkpIHtcblx0XHRcdHJvd1N0cnVjdC50Ym9keUVsLnJlbW92ZSgpO1xuXHRcdH1cblxuXHRcdHRoaXMucm93U3RydWN0cyA9IG51bGw7XG5cdH0sXG5cblxuXHQvLyBVc2VzIHRoZSBnaXZlbiBldmVudHMgYXJyYXkgdG8gZ2VuZXJhdGUgPHRib2R5PiBlbGVtZW50cyB0aGF0IHNob3VsZCBiZSBhcHBlbmRlZCB0byBlYWNoIHJvdydzIGNvbnRlbnQgc2tlbGV0b24uXG5cdC8vIFJldHVybnMgYW4gYXJyYXkgb2Ygcm93U3RydWN0IG9iamVjdHMgKHNlZSB0aGUgYm90dG9tIG9mIGByZW5kZXJTZWdSb3dgKS5cblx0Ly8gUFJFQ09ORElUSU9OOiBlYWNoIHNlZ21lbnQgc2hvdWQgYWxyZWFkeSBoYXZlIGEgcmVuZGVyZWQgYW5kIGFzc2lnbmVkIGAuZWxgXG5cdHJlbmRlclNlZ1Jvd3M6IGZ1bmN0aW9uKHNlZ3MpIHtcblx0XHR2YXIgcm93U3RydWN0cyA9IFtdO1xuXHRcdHZhciBzZWdSb3dzO1xuXHRcdHZhciByb3c7XG5cblx0XHRzZWdSb3dzID0gdGhpcy5ncm91cFNlZ1Jvd3Moc2Vncyk7IC8vIGdyb3VwIGludG8gbmVzdGVkIGFycmF5c1xuXG5cdFx0Ly8gaXRlcmF0ZSBlYWNoIHJvdyBvZiBzZWdtZW50IGdyb3VwaW5nc1xuXHRcdGZvciAocm93ID0gMDsgcm93IDwgc2VnUm93cy5sZW5ndGg7IHJvdysrKSB7XG5cdFx0XHRyb3dTdHJ1Y3RzLnB1c2goXG5cdFx0XHRcdHRoaXMucmVuZGVyU2VnUm93KHJvdywgc2VnUm93c1tyb3ddKVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcm93U3RydWN0cztcblx0fSxcblxuXG5cdC8vIEJ1aWxkcyB0aGUgSFRNTCB0byBiZSB1c2VkIGZvciB0aGUgZGVmYXVsdCBlbGVtZW50IGZvciBhbiBpbmRpdmlkdWFsIHNlZ21lbnRcblx0ZmdTZWdIdG1sOiBmdW5jdGlvbihzZWcsIGRpc2FibGVSZXNpemluZykge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXHRcdHZhciBldmVudCA9IHNlZy5ldmVudDtcblx0XHR2YXIgaXNEcmFnZ2FibGUgPSB2aWV3LmlzRXZlbnREcmFnZ2FibGUoZXZlbnQpO1xuXHRcdHZhciBpc1Jlc2l6YWJsZUZyb21TdGFydCA9ICFkaXNhYmxlUmVzaXppbmcgJiYgZXZlbnQuYWxsRGF5ICYmXG5cdFx0XHRzZWcuaXNTdGFydCAmJiB2aWV3LmlzRXZlbnRSZXNpemFibGVGcm9tU3RhcnQoZXZlbnQpO1xuXHRcdHZhciBpc1Jlc2l6YWJsZUZyb21FbmQgPSAhZGlzYWJsZVJlc2l6aW5nICYmIGV2ZW50LmFsbERheSAmJlxuXHRcdFx0c2VnLmlzRW5kICYmIHZpZXcuaXNFdmVudFJlc2l6YWJsZUZyb21FbmQoZXZlbnQpO1xuXHRcdHZhciBjbGFzc2VzID0gdGhpcy5nZXRTZWdDbGFzc2VzKHNlZywgaXNEcmFnZ2FibGUsIGlzUmVzaXphYmxlRnJvbVN0YXJ0IHx8IGlzUmVzaXphYmxlRnJvbUVuZCk7XG5cdFx0dmFyIHNraW5Dc3MgPSBjc3NUb1N0cih0aGlzLmdldFNlZ1NraW5Dc3Moc2VnKSk7XG5cdFx0dmFyIHRpbWVIdG1sID0gJyc7XG5cdFx0dmFyIHRpbWVUZXh0O1xuXHRcdHZhciB0aXRsZUh0bWw7XG5cblx0XHRjbGFzc2VzLnVuc2hpZnQoJ2ZjLWRheS1ncmlkLWV2ZW50JywgJ2ZjLWgtZXZlbnQnKTtcblxuXHRcdC8vIE9ubHkgZGlzcGxheSBhIHRpbWVkIGV2ZW50cyB0aW1lIGlmIGl0IGlzIHRoZSBzdGFydGluZyBzZWdtZW50XG5cdFx0aWYgKHNlZy5pc1N0YXJ0KSB7XG5cdFx0XHR0aW1lVGV4dCA9IHRoaXMuZ2V0RXZlbnRUaW1lVGV4dChldmVudCk7XG5cdFx0XHRpZiAodGltZVRleHQpIHtcblx0XHRcdFx0dGltZUh0bWwgPSAnPHNwYW4gY2xhc3M9XCJmYy10aW1lXCI+JyArIGh0bWxFc2NhcGUodGltZVRleHQpICsgJzwvc3Bhbj4nO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRpdGxlSHRtbCA9XG5cdFx0XHQnPHNwYW4gY2xhc3M9XCJmYy10aXRsZVwiPicgK1xuXHRcdFx0XHQoaHRtbEVzY2FwZShldmVudC50aXRsZSB8fCAnJykgfHwgJyZuYnNwOycpICsgLy8gd2UgYWx3YXlzIHdhbnQgb25lIGxpbmUgb2YgaGVpZ2h0XG5cdFx0XHQnPC9zcGFuPic7XG5cdFx0XG5cdFx0cmV0dXJuICc8YSBjbGFzcz1cIicgKyBjbGFzc2VzLmpvaW4oJyAnKSArICdcIicgK1xuXHRcdFx0XHQoZXZlbnQudXJsID9cblx0XHRcdFx0XHQnIGhyZWY9XCInICsgaHRtbEVzY2FwZShldmVudC51cmwpICsgJ1wiJyA6XG5cdFx0XHRcdFx0Jydcblx0XHRcdFx0XHQpICtcblx0XHRcdFx0KHNraW5Dc3MgP1xuXHRcdFx0XHRcdCcgc3R5bGU9XCInICsgc2tpbkNzcyArICdcIicgOlxuXHRcdFx0XHRcdCcnXG5cdFx0XHRcdFx0KSArXG5cdFx0XHQnPicgK1xuXHRcdFx0XHQnPGRpdiBjbGFzcz1cImZjLWNvbnRlbnRcIj4nICtcblx0XHRcdFx0XHQodGhpcy5pc1JUTCA/XG5cdFx0XHRcdFx0XHR0aXRsZUh0bWwgKyAnICcgKyB0aW1lSHRtbCA6IC8vIHB1dCBhIG5hdHVyYWwgc3BhY2UgaW4gYmV0d2VlblxuXHRcdFx0XHRcdFx0dGltZUh0bWwgKyAnICcgKyB0aXRsZUh0bWwgICAvL1xuXHRcdFx0XHRcdFx0KSArXG5cdFx0XHRcdCc8L2Rpdj4nICtcblx0XHRcdFx0KGlzUmVzaXphYmxlRnJvbVN0YXJ0ID9cblx0XHRcdFx0XHQnPGRpdiBjbGFzcz1cImZjLXJlc2l6ZXIgZmMtc3RhcnQtcmVzaXplclwiIC8+JyA6XG5cdFx0XHRcdFx0Jydcblx0XHRcdFx0XHQpICtcblx0XHRcdFx0KGlzUmVzaXphYmxlRnJvbUVuZCA/XG5cdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCJmYy1yZXNpemVyIGZjLWVuZC1yZXNpemVyXCIgLz4nIDpcblx0XHRcdFx0XHQnJ1xuXHRcdFx0XHRcdCkgK1xuXHRcdFx0JzwvYT4nO1xuXHR9LFxuXG5cblx0Ly8gR2l2ZW4gYSByb3cgIyBhbmQgYW4gYXJyYXkgb2Ygc2VnbWVudHMgYWxsIGluIHRoZSBzYW1lIHJvdywgcmVuZGVyIGEgPHRib2R5PiBlbGVtZW50LCBhIHNrZWxldG9uIHRoYXQgY29udGFpbnNcblx0Ly8gdGhlIHNlZ21lbnRzLiBSZXR1cm5zIG9iamVjdCB3aXRoIGEgYnVuY2ggb2YgaW50ZXJuYWwgZGF0YSBhYm91dCBob3cgdGhlIHJlbmRlciB3YXMgY2FsY3VsYXRlZC5cblx0Ly8gTk9URTogbW9kaWZpZXMgcm93U2Vnc1xuXHRyZW5kZXJTZWdSb3c6IGZ1bmN0aW9uKHJvdywgcm93U2Vncykge1xuXHRcdHZhciBjb2xDbnQgPSB0aGlzLmNvbENudDtcblx0XHR2YXIgc2VnTGV2ZWxzID0gdGhpcy5idWlsZFNlZ0xldmVscyhyb3dTZWdzKTsgLy8gZ3JvdXAgaW50byBzdWItYXJyYXlzIG9mIGxldmVsc1xuXHRcdHZhciBsZXZlbENudCA9IE1hdGgubWF4KDEsIHNlZ0xldmVscy5sZW5ndGgpOyAvLyBlbnN1cmUgYXQgbGVhc3Qgb25lIGxldmVsXG5cdFx0dmFyIHRib2R5ID0gJCgnPHRib2R5Lz4nKTtcblx0XHR2YXIgc2VnTWF0cml4ID0gW107IC8vIGxvb2t1cCBmb3Igd2hpY2ggc2VnbWVudHMgYXJlIHJlbmRlcmVkIGludG8gd2hpY2ggbGV2ZWwrY29sIGNlbGxzXG5cdFx0dmFyIGNlbGxNYXRyaXggPSBbXTsgLy8gbG9va3VwIGZvciBhbGwgPHRkPiBlbGVtZW50cyBvZiB0aGUgbGV2ZWwrY29sIG1hdHJpeFxuXHRcdHZhciBsb25lQ2VsbE1hdHJpeCA9IFtdOyAvLyBsb29rdXAgZm9yIDx0ZD4gZWxlbWVudHMgdGhhdCBvbmx5IHRha2UgdXAgYSBzaW5nbGUgY29sdW1uXG5cdFx0dmFyIGksIGxldmVsU2Vncztcblx0XHR2YXIgY29sO1xuXHRcdHZhciB0cjtcblx0XHR2YXIgaiwgc2VnO1xuXHRcdHZhciB0ZDtcblxuXHRcdC8vIHBvcHVsYXRlcyBlbXB0eSBjZWxscyBmcm9tIHRoZSBjdXJyZW50IGNvbHVtbiAoYGNvbGApIHRvIGBlbmRDb2xgXG5cdFx0ZnVuY3Rpb24gZW1wdHlDZWxsc1VudGlsKGVuZENvbCkge1xuXHRcdFx0d2hpbGUgKGNvbCA8IGVuZENvbCkge1xuXHRcdFx0XHQvLyB0cnkgdG8gZ3JhYiBhIGNlbGwgZnJvbSB0aGUgbGV2ZWwgYWJvdmUgYW5kIGV4dGVuZCBpdHMgcm93c3Bhbi4gb3RoZXJ3aXNlLCBjcmVhdGUgYSBmcmVzaCBjZWxsXG5cdFx0XHRcdHRkID0gKGxvbmVDZWxsTWF0cml4W2kgLSAxXSB8fCBbXSlbY29sXTtcblx0XHRcdFx0aWYgKHRkKSB7XG5cdFx0XHRcdFx0dGQuYXR0cihcblx0XHRcdFx0XHRcdCdyb3dzcGFuJyxcblx0XHRcdFx0XHRcdHBhcnNlSW50KHRkLmF0dHIoJ3Jvd3NwYW4nKSB8fCAxLCAxMCkgKyAxXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR0ZCA9ICQoJzx0ZC8+Jyk7XG5cdFx0XHRcdFx0dHIuYXBwZW5kKHRkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjZWxsTWF0cml4W2ldW2NvbF0gPSB0ZDtcblx0XHRcdFx0bG9uZUNlbGxNYXRyaXhbaV1bY29sXSA9IHRkO1xuXHRcdFx0XHRjb2wrKztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgbGV2ZWxDbnQ7IGkrKykgeyAvLyBpdGVyYXRlIHRocm91Z2ggYWxsIGxldmVsc1xuXHRcdFx0bGV2ZWxTZWdzID0gc2VnTGV2ZWxzW2ldO1xuXHRcdFx0Y29sID0gMDtcblx0XHRcdHRyID0gJCgnPHRyLz4nKTtcblxuXHRcdFx0c2VnTWF0cml4LnB1c2goW10pO1xuXHRcdFx0Y2VsbE1hdHJpeC5wdXNoKFtdKTtcblx0XHRcdGxvbmVDZWxsTWF0cml4LnB1c2goW10pO1xuXG5cdFx0XHQvLyBsZXZlbENudCBtaWdodCBiZSAxIGV2ZW4gdGhvdWdoIHRoZXJlIGFyZSBubyBhY3R1YWwgbGV2ZWxzLiBwcm90ZWN0IGFnYWluc3QgdGhpcy5cblx0XHRcdC8vIHRoaXMgc2luZ2xlIGVtcHR5IHJvdyBpcyB1c2VmdWwgZm9yIHN0eWxpbmcuXG5cdFx0XHRpZiAobGV2ZWxTZWdzKSB7XG5cdFx0XHRcdGZvciAoaiA9IDA7IGogPCBsZXZlbFNlZ3MubGVuZ3RoOyBqKyspIHsgLy8gaXRlcmF0ZSB0aHJvdWdoIHNlZ21lbnRzIGluIGxldmVsXG5cdFx0XHRcdFx0c2VnID0gbGV2ZWxTZWdzW2pdO1xuXG5cdFx0XHRcdFx0ZW1wdHlDZWxsc1VudGlsKHNlZy5sZWZ0Q29sKTtcblxuXHRcdFx0XHRcdC8vIGNyZWF0ZSBhIGNvbnRhaW5lciB0aGF0IG9jY3VwaWVzIG9yIG1vcmUgY29sdW1ucy4gYXBwZW5kIHRoZSBldmVudCBlbGVtZW50LlxuXHRcdFx0XHRcdHRkID0gJCgnPHRkIGNsYXNzPVwiZmMtZXZlbnQtY29udGFpbmVyXCIvPicpLmFwcGVuZChzZWcuZWwpO1xuXHRcdFx0XHRcdGlmIChzZWcubGVmdENvbCAhPSBzZWcucmlnaHRDb2wpIHtcblx0XHRcdFx0XHRcdHRkLmF0dHIoJ2NvbHNwYW4nLCBzZWcucmlnaHRDb2wgLSBzZWcubGVmdENvbCArIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHsgLy8gYSBzaW5nbGUtY29sdW1uIHNlZ21lbnRcblx0XHRcdFx0XHRcdGxvbmVDZWxsTWF0cml4W2ldW2NvbF0gPSB0ZDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR3aGlsZSAoY29sIDw9IHNlZy5yaWdodENvbCkge1xuXHRcdFx0XHRcdFx0Y2VsbE1hdHJpeFtpXVtjb2xdID0gdGQ7XG5cdFx0XHRcdFx0XHRzZWdNYXRyaXhbaV1bY29sXSA9IHNlZztcblx0XHRcdFx0XHRcdGNvbCsrO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRyLmFwcGVuZCh0ZCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZW1wdHlDZWxsc1VudGlsKGNvbENudCk7IC8vIGZpbmlzaCBvZmYgdGhlIHJvd1xuXHRcdFx0dGhpcy5ib29rZW5kQ2VsbHModHIpO1xuXHRcdFx0dGJvZHkuYXBwZW5kKHRyKTtcblx0XHR9XG5cblx0XHRyZXR1cm4geyAvLyBhIFwicm93U3RydWN0XCJcblx0XHRcdHJvdzogcm93LCAvLyB0aGUgcm93IG51bWJlclxuXHRcdFx0dGJvZHlFbDogdGJvZHksXG5cdFx0XHRjZWxsTWF0cml4OiBjZWxsTWF0cml4LFxuXHRcdFx0c2VnTWF0cml4OiBzZWdNYXRyaXgsXG5cdFx0XHRzZWdMZXZlbHM6IHNlZ0xldmVscyxcblx0XHRcdHNlZ3M6IHJvd1NlZ3Ncblx0XHR9O1xuXHR9LFxuXG5cblx0Ly8gU3RhY2tzIGEgZmxhdCBhcnJheSBvZiBzZWdtZW50cywgd2hpY2ggYXJlIGFsbCBhc3N1bWVkIHRvIGJlIGluIHRoZSBzYW1lIHJvdywgaW50byBzdWJhcnJheXMgb2YgdmVydGljYWwgbGV2ZWxzLlxuXHQvLyBOT1RFOiBtb2RpZmllcyBzZWdzXG5cdGJ1aWxkU2VnTGV2ZWxzOiBmdW5jdGlvbihzZWdzKSB7XG5cdFx0dmFyIGxldmVscyA9IFtdO1xuXHRcdHZhciBpLCBzZWc7XG5cdFx0dmFyIGo7XG5cblx0XHQvLyBHaXZlIHByZWZlcmVuY2UgdG8gZWxlbWVudHMgd2l0aCBjZXJ0YWluIGNyaXRlcmlhLCBzbyB0aGV5IGhhdmVcblx0XHQvLyBhIGNoYW5jZSB0byBiZSBjbG9zZXIgdG8gdGhlIHRvcC5cblx0XHR0aGlzLnNvcnRFdmVudFNlZ3Moc2Vncyk7XG5cdFx0XG5cdFx0Zm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdHNlZyA9IHNlZ3NbaV07XG5cblx0XHRcdC8vIGxvb3AgdGhyb3VnaCBsZXZlbHMsIHN0YXJ0aW5nIHdpdGggdGhlIHRvcG1vc3QsIHVudGlsIHRoZSBzZWdtZW50IGRvZXNuJ3QgY29sbGlkZSB3aXRoIG90aGVyIHNlZ21lbnRzXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgbGV2ZWxzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGlmICghaXNEYXlTZWdDb2xsaXNpb24oc2VnLCBsZXZlbHNbal0pKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIGBqYCBub3cgaG9sZHMgdGhlIGRlc2lyZWQgc3Vicm93IGluZGV4XG5cdFx0XHRzZWcubGV2ZWwgPSBqO1xuXG5cdFx0XHQvLyBjcmVhdGUgbmV3IGxldmVsIGFycmF5IGlmIG5lZWRlZCBhbmQgYXBwZW5kIHNlZ21lbnRcblx0XHRcdChsZXZlbHNbal0gfHwgKGxldmVsc1tqXSA9IFtdKSkucHVzaChzZWcpO1xuXHRcdH1cblxuXHRcdC8vIG9yZGVyIHNlZ21lbnRzIGxlZnQtdG8tcmlnaHQuIHZlcnkgaW1wb3J0YW50IGlmIGNhbGVuZGFyIGlzIFJUTFxuXHRcdGZvciAoaiA9IDA7IGogPCBsZXZlbHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdGxldmVsc1tqXS5zb3J0KGNvbXBhcmVEYXlTZWdDb2xzKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbGV2ZWxzO1xuXHR9LFxuXG5cblx0Ly8gR2l2ZW4gYSBmbGF0IGFycmF5IG9mIHNlZ21lbnRzLCByZXR1cm4gYW4gYXJyYXkgb2Ygc3ViLWFycmF5cywgZ3JvdXBlZCBieSBlYWNoIHNlZ21lbnQncyByb3dcblx0Z3JvdXBTZWdSb3dzOiBmdW5jdGlvbihzZWdzKSB7XG5cdFx0dmFyIHNlZ1Jvd3MgPSBbXTtcblx0XHR2YXIgaTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCB0aGlzLnJvd0NudDsgaSsrKSB7XG5cdFx0XHRzZWdSb3dzLnB1c2goW10pO1xuXHRcdH1cblxuXHRcdGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRzZWdSb3dzW3NlZ3NbaV0ucm93XS5wdXNoKHNlZ3NbaV0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBzZWdSb3dzO1xuXHR9XG5cbn0pO1xuXG5cbi8vIENvbXB1dGVzIHdoZXRoZXIgdHdvIHNlZ21lbnRzJyBjb2x1bW5zIGNvbGxpZGUuIFRoZXkgYXJlIGFzc3VtZWQgdG8gYmUgaW4gdGhlIHNhbWUgcm93LlxuZnVuY3Rpb24gaXNEYXlTZWdDb2xsaXNpb24oc2VnLCBvdGhlclNlZ3MpIHtcblx0dmFyIGksIG90aGVyU2VnO1xuXG5cdGZvciAoaSA9IDA7IGkgPCBvdGhlclNlZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRvdGhlclNlZyA9IG90aGVyU2Vnc1tpXTtcblxuXHRcdGlmIChcblx0XHRcdG90aGVyU2VnLmxlZnRDb2wgPD0gc2VnLnJpZ2h0Q29sICYmXG5cdFx0XHRvdGhlclNlZy5yaWdodENvbCA+PSBzZWcubGVmdENvbFxuXHRcdCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZhbHNlO1xufVxuXG5cbi8vIEEgY21wIGZ1bmN0aW9uIGZvciBkZXRlcm1pbmluZyB0aGUgbGVmdG1vc3QgZXZlbnRcbmZ1bmN0aW9uIGNvbXBhcmVEYXlTZWdDb2xzKGEsIGIpIHtcblx0cmV0dXJuIGEubGVmdENvbCAtIGIubGVmdENvbDtcbn1cblxuOztcblxuLyogTWV0aG9kcyByZWxhdGUgdG8gbGltaXRpbmcgdGhlIG51bWJlciBldmVudHMgZm9yIGEgZ2l2ZW4gZGF5IG9uIGEgRGF5R3JpZFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vLyBOT1RFOiBhbGwgdGhlIHNlZ3MgYmVpbmcgcGFzc2VkIGFyb3VuZCBpbiBoZXJlIGFyZSBmb3JlZ3JvdW5kIHNlZ3NcblxuRGF5R3JpZC5taXhpbih7XG5cblx0c2VnUG9wb3ZlcjogbnVsbCwgLy8gdGhlIFBvcG92ZXIgdGhhdCBob2xkcyBldmVudHMgdGhhdCBjYW4ndCBmaXQgaW4gYSBjZWxsLiBudWxsIHdoZW4gbm90IHZpc2libGVcblx0cG9wb3ZlclNlZ3M6IG51bGwsIC8vIGFuIGFycmF5IG9mIHNlZ21lbnQgb2JqZWN0cyB0aGF0IHRoZSBzZWdQb3BvdmVyIGhvbGRzLiBudWxsIHdoZW4gbm90IHZpc2libGVcblxuXG5cdHJlbW92ZVNlZ1BvcG92ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLnNlZ1BvcG92ZXIpIHtcblx0XHRcdHRoaXMuc2VnUG9wb3Zlci5oaWRlKCk7IC8vIGluIGhhbmRsZXIsIHdpbGwgY2FsbCBzZWdQb3BvdmVyJ3MgcmVtb3ZlRWxlbWVudFxuXHRcdH1cblx0fSxcblxuXG5cdC8vIExpbWl0cyB0aGUgbnVtYmVyIG9mIFwibGV2ZWxzXCIgKHZlcnRpY2FsbHkgc3RhY2tpbmcgbGF5ZXJzIG9mIGV2ZW50cykgZm9yIGVhY2ggcm93IG9mIHRoZSBncmlkLlxuXHQvLyBgbGV2ZWxMaW1pdGAgY2FuIGJlIGZhbHNlIChkb24ndCBsaW1pdCksIGEgbnVtYmVyLCBvciB0cnVlIChzaG91bGQgYmUgY29tcHV0ZWQpLlxuXHRsaW1pdFJvd3M6IGZ1bmN0aW9uKGxldmVsTGltaXQpIHtcblx0XHR2YXIgcm93U3RydWN0cyA9IHRoaXMucm93U3RydWN0cyB8fCBbXTtcblx0XHR2YXIgcm93OyAvLyByb3cgI1xuXHRcdHZhciByb3dMZXZlbExpbWl0O1xuXG5cdFx0Zm9yIChyb3cgPSAwOyByb3cgPCByb3dTdHJ1Y3RzLmxlbmd0aDsgcm93KyspIHtcblx0XHRcdHRoaXMudW5saW1pdFJvdyhyb3cpO1xuXG5cdFx0XHRpZiAoIWxldmVsTGltaXQpIHtcblx0XHRcdFx0cm93TGV2ZWxMaW1pdCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAodHlwZW9mIGxldmVsTGltaXQgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdHJvd0xldmVsTGltaXQgPSBsZXZlbExpbWl0O1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHJvd0xldmVsTGltaXQgPSB0aGlzLmNvbXB1dGVSb3dMZXZlbExpbWl0KHJvdyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChyb3dMZXZlbExpbWl0ICE9PSBmYWxzZSkge1xuXHRcdFx0XHR0aGlzLmxpbWl0Um93KHJvdywgcm93TGV2ZWxMaW1pdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gQ29tcHV0ZXMgdGhlIG51bWJlciBvZiBsZXZlbHMgYSByb3cgd2lsbCBhY2NvbW9kYXRlIHdpdGhvdXQgZ29pbmcgb3V0c2lkZSBpdHMgYm91bmRzLlxuXHQvLyBBc3N1bWVzIHRoZSByb3cgaXMgXCJyaWdpZFwiIChtYWludGFpbnMgYSBjb25zdGFudCBoZWlnaHQgcmVnYXJkbGVzcyBvZiB3aGF0IGlzIGluc2lkZSkuXG5cdC8vIGByb3dgIGlzIHRoZSByb3cgbnVtYmVyLlxuXHRjb21wdXRlUm93TGV2ZWxMaW1pdDogZnVuY3Rpb24ocm93KSB7XG5cdFx0dmFyIHJvd0VsID0gdGhpcy5yb3dFbHMuZXEocm93KTsgLy8gdGhlIGNvbnRhaW5pbmcgXCJmYWtlXCIgcm93IGRpdlxuXHRcdHZhciByb3dIZWlnaHQgPSByb3dFbC5oZWlnaHQoKTsgLy8gVE9ETzogY2FjaGUgc29tZWhvdz9cblx0XHR2YXIgdHJFbHMgPSB0aGlzLnJvd1N0cnVjdHNbcm93XS50Ym9keUVsLmNoaWxkcmVuKCk7XG5cdFx0dmFyIGksIHRyRWw7XG5cdFx0dmFyIHRySGVpZ2h0O1xuXG5cdFx0ZnVuY3Rpb24gaXRlcklubmVySGVpZ2h0cyhpLCBjaGlsZE5vZGUpIHtcblx0XHRcdHRySGVpZ2h0ID0gTWF0aC5tYXgodHJIZWlnaHQsICQoY2hpbGROb2RlKS5vdXRlckhlaWdodCgpKTtcblx0XHR9XG5cblx0XHQvLyBSZXZlYWwgb25lIGxldmVsIDx0cj4gYXQgYSB0aW1lIGFuZCBzdG9wIHdoZW4gd2UgZmluZCBvbmUgb3V0IG9mIGJvdW5kc1xuXHRcdGZvciAoaSA9IDA7IGkgPCB0ckVscy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dHJFbCA9IHRyRWxzLmVxKGkpLnJlbW92ZUNsYXNzKCdmYy1saW1pdGVkJyk7IC8vIHJlc2V0IHRvIG9yaWdpbmFsIHN0YXRlIChyZXZlYWwpXG5cblx0XHRcdC8vIHdpdGggcm93c3BhbnM+MSBhbmQgSUU4LCB0ckVsLm91dGVySGVpZ2h0KCkgd291bGQgcmV0dXJuIHRoZSBoZWlnaHQgb2YgdGhlIGxhcmdlc3QgY2VsbCxcblx0XHRcdC8vIHNvIGluc3RlYWQsIGZpbmQgdGhlIHRhbGxlc3QgaW5uZXIgY29udGVudCBlbGVtZW50LlxuXHRcdFx0dHJIZWlnaHQgPSAwO1xuXHRcdFx0dHJFbC5maW5kKCc+IHRkID4gOmZpcnN0LWNoaWxkJykuZWFjaChpdGVySW5uZXJIZWlnaHRzKTtcblxuXHRcdFx0aWYgKHRyRWwucG9zaXRpb24oKS50b3AgKyB0ckhlaWdodCA+IHJvd0hlaWdodCkge1xuXHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7IC8vIHNob3VsZCBub3QgbGltaXQgYXQgYWxsXG5cdH0sXG5cblxuXHQvLyBMaW1pdHMgdGhlIGdpdmVuIGdyaWQgcm93IHRvIHRoZSBtYXhpbXVtIG51bWJlciBvZiBsZXZlbHMgYW5kIGluamVjdHMgXCJtb3JlXCIgbGlua3MgaWYgbmVjZXNzYXJ5LlxuXHQvLyBgcm93YCBpcyB0aGUgcm93IG51bWJlci5cblx0Ly8gYGxldmVsTGltaXRgIGlzIGEgbnVtYmVyIGZvciB0aGUgbWF4aW11bSAoaW5jbHVzaXZlKSBudW1iZXIgb2YgbGV2ZWxzIGFsbG93ZWQuXG5cdGxpbWl0Um93OiBmdW5jdGlvbihyb3csIGxldmVsTGltaXQpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHZhciByb3dTdHJ1Y3QgPSB0aGlzLnJvd1N0cnVjdHNbcm93XTtcblx0XHR2YXIgbW9yZU5vZGVzID0gW107IC8vIGFycmF5IG9mIFwibW9yZVwiIDxhPiBsaW5rcyBhbmQgPHRkPiBET00gbm9kZXNcblx0XHR2YXIgY29sID0gMDsgLy8gY29sICMsIGxlZnQtdG8tcmlnaHQgKG5vdCBjaHJvbm9sb2dpY2FsbHkpXG5cdFx0dmFyIGxldmVsU2VnczsgLy8gYXJyYXkgb2Ygc2VnbWVudCBvYmplY3RzIGluIHRoZSBsYXN0IGFsbG93YWJsZSBsZXZlbCwgb3JkZXJlZCBsZWZ0LXRvLXJpZ2h0XG5cdFx0dmFyIGNlbGxNYXRyaXg7IC8vIGEgbWF0cml4IChieSBsZXZlbCwgdGhlbiBjb2x1bW4pIG9mIGFsbCA8dGQ+IGpRdWVyeSBlbGVtZW50cyBpbiB0aGUgcm93XG5cdFx0dmFyIGxpbWl0ZWROb2RlczsgLy8gYXJyYXkgb2YgdGVtcG9yYXJpbHkgaGlkZGVuIGxldmVsIDx0cj4gYW5kIHNlZ21lbnQgPHRkPiBET00gbm9kZXNcblx0XHR2YXIgaSwgc2VnO1xuXHRcdHZhciBzZWdzQmVsb3c7IC8vIGFycmF5IG9mIHNlZ21lbnQgb2JqZWN0cyBiZWxvdyBgc2VnYCBpbiB0aGUgY3VycmVudCBgY29sYFxuXHRcdHZhciB0b3RhbFNlZ3NCZWxvdzsgLy8gdG90YWwgbnVtYmVyIG9mIHNlZ21lbnRzIGJlbG93IGBzZWdgIGluIGFueSBvZiB0aGUgY29sdW1ucyBgc2VnYCBvY2N1cGllc1xuXHRcdHZhciBjb2xTZWdzQmVsb3c7IC8vIGFycmF5IG9mIHNlZ21lbnQgYXJyYXlzLCBiZWxvdyBzZWcsIG9uZSBmb3IgZWFjaCBjb2x1bW4gKG9mZnNldCBmcm9tIHNlZ3MncyBmaXJzdCBjb2x1bW4pXG5cdFx0dmFyIHRkLCByb3dzcGFuO1xuXHRcdHZhciBzZWdNb3JlTm9kZXM7IC8vIGFycmF5IG9mIFwibW9yZVwiIDx0ZD4gY2VsbHMgdGhhdCB3aWxsIHN0YW5kLWluIGZvciB0aGUgY3VycmVudCBzZWcncyBjZWxsXG5cdFx0dmFyIGo7XG5cdFx0dmFyIG1vcmVUZCwgbW9yZVdyYXAsIG1vcmVMaW5rO1xuXG5cdFx0Ly8gSXRlcmF0ZXMgdGhyb3VnaCBlbXB0eSBsZXZlbCBjZWxscyBhbmQgcGxhY2VzIFwibW9yZVwiIGxpbmtzIGluc2lkZSBpZiBuZWVkIGJlXG5cdFx0ZnVuY3Rpb24gZW1wdHlDZWxsc1VudGlsKGVuZENvbCkgeyAvLyBnb2VzIGZyb20gY3VycmVudCBgY29sYCB0byBgZW5kQ29sYFxuXHRcdFx0d2hpbGUgKGNvbCA8IGVuZENvbCkge1xuXHRcdFx0XHRzZWdzQmVsb3cgPSBfdGhpcy5nZXRDZWxsU2Vncyhyb3csIGNvbCwgbGV2ZWxMaW1pdCk7XG5cdFx0XHRcdGlmIChzZWdzQmVsb3cubGVuZ3RoKSB7XG5cdFx0XHRcdFx0dGQgPSBjZWxsTWF0cml4W2xldmVsTGltaXQgLSAxXVtjb2xdO1xuXHRcdFx0XHRcdG1vcmVMaW5rID0gX3RoaXMucmVuZGVyTW9yZUxpbmsocm93LCBjb2wsIHNlZ3NCZWxvdyk7XG5cdFx0XHRcdFx0bW9yZVdyYXAgPSAkKCc8ZGl2Lz4nKS5hcHBlbmQobW9yZUxpbmspO1xuXHRcdFx0XHRcdHRkLmFwcGVuZChtb3JlV3JhcCk7XG5cdFx0XHRcdFx0bW9yZU5vZGVzLnB1c2gobW9yZVdyYXBbMF0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbCsrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChsZXZlbExpbWl0ICYmIGxldmVsTGltaXQgPCByb3dTdHJ1Y3Quc2VnTGV2ZWxzLmxlbmd0aCkgeyAvLyBpcyBpdCBhY3R1YWxseSBvdmVyIHRoZSBsaW1pdD9cblx0XHRcdGxldmVsU2VncyA9IHJvd1N0cnVjdC5zZWdMZXZlbHNbbGV2ZWxMaW1pdCAtIDFdO1xuXHRcdFx0Y2VsbE1hdHJpeCA9IHJvd1N0cnVjdC5jZWxsTWF0cml4O1xuXG5cdFx0XHRsaW1pdGVkTm9kZXMgPSByb3dTdHJ1Y3QudGJvZHlFbC5jaGlsZHJlbigpLnNsaWNlKGxldmVsTGltaXQpIC8vIGdldCBsZXZlbCA8dHI+IGVsZW1lbnRzIHBhc3QgdGhlIGxpbWl0XG5cdFx0XHRcdC5hZGRDbGFzcygnZmMtbGltaXRlZCcpLmdldCgpOyAvLyBoaWRlIGVsZW1lbnRzIGFuZCBnZXQgYSBzaW1wbGUgRE9NLW5vZGVzIGFycmF5XG5cblx0XHRcdC8vIGl0ZXJhdGUgdGhvdWdoIHNlZ21lbnRzIGluIHRoZSBsYXN0IGFsbG93YWJsZSBsZXZlbFxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxldmVsU2Vncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRzZWcgPSBsZXZlbFNlZ3NbaV07XG5cdFx0XHRcdGVtcHR5Q2VsbHNVbnRpbChzZWcubGVmdENvbCk7IC8vIHByb2Nlc3MgZW1wdHkgY2VsbHMgYmVmb3JlIHRoZSBzZWdtZW50XG5cblx0XHRcdFx0Ly8gZGV0ZXJtaW5lICphbGwqIHNlZ21lbnRzIGJlbG93IGBzZWdgIHRoYXQgb2NjdXB5IHRoZSBzYW1lIGNvbHVtbnNcblx0XHRcdFx0Y29sU2Vnc0JlbG93ID0gW107XG5cdFx0XHRcdHRvdGFsU2Vnc0JlbG93ID0gMDtcblx0XHRcdFx0d2hpbGUgKGNvbCA8PSBzZWcucmlnaHRDb2wpIHtcblx0XHRcdFx0XHRzZWdzQmVsb3cgPSB0aGlzLmdldENlbGxTZWdzKHJvdywgY29sLCBsZXZlbExpbWl0KTtcblx0XHRcdFx0XHRjb2xTZWdzQmVsb3cucHVzaChzZWdzQmVsb3cpO1xuXHRcdFx0XHRcdHRvdGFsU2Vnc0JlbG93ICs9IHNlZ3NCZWxvdy5sZW5ndGg7XG5cdFx0XHRcdFx0Y29sKys7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodG90YWxTZWdzQmVsb3cpIHsgLy8gZG8gd2UgbmVlZCB0byByZXBsYWNlIHRoaXMgc2VnbWVudCB3aXRoIG9uZSBvciBtYW55IFwibW9yZVwiIGxpbmtzP1xuXHRcdFx0XHRcdHRkID0gY2VsbE1hdHJpeFtsZXZlbExpbWl0IC0gMV1bc2VnLmxlZnRDb2xdOyAvLyB0aGUgc2VnbWVudCdzIHBhcmVudCBjZWxsXG5cdFx0XHRcdFx0cm93c3BhbiA9IHRkLmF0dHIoJ3Jvd3NwYW4nKSB8fCAxO1xuXHRcdFx0XHRcdHNlZ01vcmVOb2RlcyA9IFtdO1xuXG5cdFx0XHRcdFx0Ly8gbWFrZSBhIHJlcGxhY2VtZW50IDx0ZD4gZm9yIGVhY2ggY29sdW1uIHRoZSBzZWdtZW50IG9jY3VwaWVzLiB3aWxsIGJlIG9uZSBmb3IgZWFjaCBjb2xzcGFuXG5cdFx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IGNvbFNlZ3NCZWxvdy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdFx0bW9yZVRkID0gJCgnPHRkIGNsYXNzPVwiZmMtbW9yZS1jZWxsXCIvPicpLmF0dHIoJ3Jvd3NwYW4nLCByb3dzcGFuKTtcblx0XHRcdFx0XHRcdHNlZ3NCZWxvdyA9IGNvbFNlZ3NCZWxvd1tqXTtcblx0XHRcdFx0XHRcdG1vcmVMaW5rID0gdGhpcy5yZW5kZXJNb3JlTGluayhcblx0XHRcdFx0XHRcdFx0cm93LFxuXHRcdFx0XHRcdFx0XHRzZWcubGVmdENvbCArIGosXG5cdFx0XHRcdFx0XHRcdFsgc2VnIF0uY29uY2F0KHNlZ3NCZWxvdykgLy8gY291bnQgc2VnIGFzIGhpZGRlbiB0b29cblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRtb3JlV3JhcCA9ICQoJzxkaXYvPicpLmFwcGVuZChtb3JlTGluayk7XG5cdFx0XHRcdFx0XHRtb3JlVGQuYXBwZW5kKG1vcmVXcmFwKTtcblx0XHRcdFx0XHRcdHNlZ01vcmVOb2Rlcy5wdXNoKG1vcmVUZFswXSk7XG5cdFx0XHRcdFx0XHRtb3JlTm9kZXMucHVzaChtb3JlVGRbMF0pO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRkLmFkZENsYXNzKCdmYy1saW1pdGVkJykuYWZ0ZXIoJChzZWdNb3JlTm9kZXMpKTsgLy8gaGlkZSBvcmlnaW5hbCA8dGQ+IGFuZCBpbmplY3QgcmVwbGFjZW1lbnRzXG5cdFx0XHRcdFx0bGltaXRlZE5vZGVzLnB1c2godGRbMF0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGVtcHR5Q2VsbHNVbnRpbCh0aGlzLmNvbENudCk7IC8vIGZpbmlzaCBvZmYgdGhlIGxldmVsXG5cdFx0XHRyb3dTdHJ1Y3QubW9yZUVscyA9ICQobW9yZU5vZGVzKTsgLy8gZm9yIGVhc3kgdW5kb2luZyBsYXRlclxuXHRcdFx0cm93U3RydWN0LmxpbWl0ZWRFbHMgPSAkKGxpbWl0ZWROb2Rlcyk7IC8vIGZvciBlYXN5IHVuZG9pbmcgbGF0ZXJcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBSZXZlYWxzIGFsbCBsZXZlbHMgYW5kIHJlbW92ZXMgYWxsIFwibW9yZVwiLXJlbGF0ZWQgZWxlbWVudHMgZm9yIGEgZ3JpZCdzIHJvdy5cblx0Ly8gYHJvd2AgaXMgYSByb3cgbnVtYmVyLlxuXHR1bmxpbWl0Um93OiBmdW5jdGlvbihyb3cpIHtcblx0XHR2YXIgcm93U3RydWN0ID0gdGhpcy5yb3dTdHJ1Y3RzW3Jvd107XG5cblx0XHRpZiAocm93U3RydWN0Lm1vcmVFbHMpIHtcblx0XHRcdHJvd1N0cnVjdC5tb3JlRWxzLnJlbW92ZSgpO1xuXHRcdFx0cm93U3RydWN0Lm1vcmVFbHMgPSBudWxsO1xuXHRcdH1cblxuXHRcdGlmIChyb3dTdHJ1Y3QubGltaXRlZEVscykge1xuXHRcdFx0cm93U3RydWN0LmxpbWl0ZWRFbHMucmVtb3ZlQ2xhc3MoJ2ZjLWxpbWl0ZWQnKTtcblx0XHRcdHJvd1N0cnVjdC5saW1pdGVkRWxzID0gbnVsbDtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBSZW5kZXJzIGFuIDxhPiBlbGVtZW50IHRoYXQgcmVwcmVzZW50cyBoaWRkZW4gZXZlbnQgZWxlbWVudCBmb3IgYSBjZWxsLlxuXHQvLyBSZXNwb25zaWJsZSBmb3IgYXR0YWNoaW5nIGNsaWNrIGhhbmRsZXIgYXMgd2VsbC5cblx0cmVuZGVyTW9yZUxpbms6IGZ1bmN0aW9uKHJvdywgY29sLCBoaWRkZW5TZWdzKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblxuXHRcdHJldHVybiAkKCc8YSBjbGFzcz1cImZjLW1vcmVcIi8+Jylcblx0XHRcdC50ZXh0KFxuXHRcdFx0XHR0aGlzLmdldE1vcmVMaW5rVGV4dChoaWRkZW5TZWdzLmxlbmd0aClcblx0XHRcdClcblx0XHRcdC5vbignY2xpY2snLCBmdW5jdGlvbihldikge1xuXHRcdFx0XHR2YXIgY2xpY2tPcHRpb24gPSB2aWV3Lm9wdCgnZXZlbnRMaW1pdENsaWNrJyk7XG5cdFx0XHRcdHZhciBkYXRlID0gX3RoaXMuZ2V0Q2VsbERhdGUocm93LCBjb2wpO1xuXHRcdFx0XHR2YXIgbW9yZUVsID0gJCh0aGlzKTtcblx0XHRcdFx0dmFyIGRheUVsID0gX3RoaXMuZ2V0Q2VsbEVsKHJvdywgY29sKTtcblx0XHRcdFx0dmFyIGFsbFNlZ3MgPSBfdGhpcy5nZXRDZWxsU2Vncyhyb3csIGNvbCk7XG5cblx0XHRcdFx0Ly8gcmVzY29wZSB0aGUgc2VnbWVudHMgdG8gYmUgd2l0aGluIHRoZSBjZWxsJ3MgZGF0ZVxuXHRcdFx0XHR2YXIgcmVzbGljZWRBbGxTZWdzID0gX3RoaXMucmVzbGljZURheVNlZ3MoYWxsU2VncywgZGF0ZSk7XG5cdFx0XHRcdHZhciByZXNsaWNlZEhpZGRlblNlZ3MgPSBfdGhpcy5yZXNsaWNlRGF5U2VncyhoaWRkZW5TZWdzLCBkYXRlKTtcblxuXHRcdFx0XHRpZiAodHlwZW9mIGNsaWNrT3B0aW9uID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0Ly8gdGhlIHJldHVybmVkIHZhbHVlIGNhbiBiZSBhbiBhdG9taWMgb3B0aW9uXG5cdFx0XHRcdFx0Y2xpY2tPcHRpb24gPSB2aWV3LnRyaWdnZXIoJ2V2ZW50TGltaXRDbGljaycsIG51bGwsIHtcblx0XHRcdFx0XHRcdGRhdGU6IGRhdGUsXG5cdFx0XHRcdFx0XHRkYXlFbDogZGF5RWwsXG5cdFx0XHRcdFx0XHRtb3JlRWw6IG1vcmVFbCxcblx0XHRcdFx0XHRcdHNlZ3M6IHJlc2xpY2VkQWxsU2Vncyxcblx0XHRcdFx0XHRcdGhpZGRlblNlZ3M6IHJlc2xpY2VkSGlkZGVuU2Vnc1xuXHRcdFx0XHRcdH0sIGV2KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjbGlja09wdGlvbiA9PT0gJ3BvcG92ZXInKSB7XG5cdFx0XHRcdFx0X3RoaXMuc2hvd1NlZ1BvcG92ZXIocm93LCBjb2wsIG1vcmVFbCwgcmVzbGljZWRBbGxTZWdzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICh0eXBlb2YgY2xpY2tPcHRpb24gPT09ICdzdHJpbmcnKSB7IC8vIGEgdmlldyBuYW1lXG5cdFx0XHRcdFx0dmlldy5jYWxlbmRhci56b29tVG8oZGF0ZSwgY2xpY2tPcHRpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0fSxcblxuXG5cdC8vIFJldmVhbHMgdGhlIHBvcG92ZXIgdGhhdCBkaXNwbGF5cyBhbGwgZXZlbnRzIHdpdGhpbiBhIGNlbGxcblx0c2hvd1NlZ1BvcG92ZXI6IGZ1bmN0aW9uKHJvdywgY29sLCBtb3JlTGluaywgc2Vncykge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIG1vcmVXcmFwID0gbW9yZUxpbmsucGFyZW50KCk7IC8vIHRoZSA8ZGl2PiB3cmFwcGVyIGFyb3VuZCB0aGUgPGE+XG5cdFx0dmFyIHRvcEVsOyAvLyB0aGUgZWxlbWVudCB3ZSB3YW50IHRvIG1hdGNoIHRoZSB0b3AgY29vcmRpbmF0ZSBvZlxuXHRcdHZhciBvcHRpb25zO1xuXG5cdFx0aWYgKHRoaXMucm93Q250ID09IDEpIHtcblx0XHRcdHRvcEVsID0gdmlldy5lbDsgLy8gd2lsbCBjYXVzZSB0aGUgcG9wb3ZlciB0byBjb3ZlciBhbnkgc29ydCBvZiBoZWFkZXJcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR0b3BFbCA9IHRoaXMucm93RWxzLmVxKHJvdyk7IC8vIHdpbGwgYWxpZ24gd2l0aCB0b3Agb2Ygcm93XG5cdFx0fVxuXG5cdFx0b3B0aW9ucyA9IHtcblx0XHRcdGNsYXNzTmFtZTogJ2ZjLW1vcmUtcG9wb3ZlcicsXG5cdFx0XHRjb250ZW50OiB0aGlzLnJlbmRlclNlZ1BvcG92ZXJDb250ZW50KHJvdywgY29sLCBzZWdzKSxcblx0XHRcdHBhcmVudEVsOiB0aGlzLnZpZXcuZWwsIC8vIGF0dGFjaCB0byByb290IG9mIHZpZXcuIGd1YXJhbnRlZXMgb3V0c2lkZSBvZiBzY3JvbGxiYXJzLlxuXHRcdFx0dG9wOiB0b3BFbC5vZmZzZXQoKS50b3AsXG5cdFx0XHRhdXRvSGlkZTogdHJ1ZSwgLy8gd2hlbiB0aGUgdXNlciBjbGlja3MgZWxzZXdoZXJlLCBoaWRlIHRoZSBwb3BvdmVyXG5cdFx0XHR2aWV3cG9ydENvbnN0cmFpbjogdmlldy5vcHQoJ3BvcG92ZXJWaWV3cG9ydENvbnN0cmFpbicpLFxuXHRcdFx0aGlkZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIGtpbGwgZXZlcnl0aGluZyB3aGVuIHRoZSBwb3BvdmVyIGlzIGhpZGRlblxuXHRcdFx0XHRfdGhpcy5zZWdQb3BvdmVyLnJlbW92ZUVsZW1lbnQoKTtcblx0XHRcdFx0X3RoaXMuc2VnUG9wb3ZlciA9IG51bGw7XG5cdFx0XHRcdF90aGlzLnBvcG92ZXJTZWdzID0gbnVsbDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIGhvcml6b250YWwgY29vcmRpbmF0ZS5cblx0XHQvLyBXZSB1c2UgdGhlIG1vcmVXcmFwIGluc3RlYWQgb2YgdGhlIDx0ZD4gdG8gYXZvaWQgYm9yZGVyIGNvbmZ1c2lvbi5cblx0XHRpZiAodGhpcy5pc1JUTCkge1xuXHRcdFx0b3B0aW9ucy5yaWdodCA9IG1vcmVXcmFwLm9mZnNldCgpLmxlZnQgKyBtb3JlV3JhcC5vdXRlcldpZHRoKCkgKyAxOyAvLyArMSB0byBiZSBvdmVyIGNlbGwgYm9yZGVyXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0b3B0aW9ucy5sZWZ0ID0gbW9yZVdyYXAub2Zmc2V0KCkubGVmdCAtIDE7IC8vIC0xIHRvIGJlIG92ZXIgY2VsbCBib3JkZXJcblx0XHR9XG5cblx0XHR0aGlzLnNlZ1BvcG92ZXIgPSBuZXcgUG9wb3ZlcihvcHRpb25zKTtcblx0XHR0aGlzLnNlZ1BvcG92ZXIuc2hvdygpO1xuXG5cdFx0Ly8gdGhlIHBvcG92ZXIgZG9lc24ndCBsaXZlIHdpdGhpbiB0aGUgZ3JpZCdzIGNvbnRhaW5lciBlbGVtZW50LCBhbmQgdGh1cyB3b24ndCBnZXQgdGhlIGV2ZW50XG5cdFx0Ly8gZGVsZWdhdGVkLWhhbmRsZXJzIGZvciBmcmVlLiBhdHRhY2ggZXZlbnQtcmVsYXRlZCBoYW5kbGVycyB0byB0aGUgcG9wb3Zlci5cblx0XHR0aGlzLmJpbmRTZWdIYW5kbGVyc1RvRWwodGhpcy5zZWdQb3BvdmVyLmVsKTtcblx0fSxcblxuXG5cdC8vIEJ1aWxkcyB0aGUgaW5uZXIgRE9NIGNvbnRlbnRzIG9mIHRoZSBzZWdtZW50IHBvcG92ZXJcblx0cmVuZGVyU2VnUG9wb3ZlckNvbnRlbnQ6IGZ1bmN0aW9uKHJvdywgY29sLCBzZWdzKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIGlzVGhlbWUgPSB2aWV3Lm9wdCgndGhlbWUnKTtcblx0XHR2YXIgdGl0bGUgPSB0aGlzLmdldENlbGxEYXRlKHJvdywgY29sKS5mb3JtYXQodmlldy5vcHQoJ2RheVBvcG92ZXJGb3JtYXQnKSk7XG5cdFx0dmFyIGNvbnRlbnQgPSAkKFxuXHRcdFx0JzxkaXYgY2xhc3M9XCJmYy1oZWFkZXIgJyArIHZpZXcud2lkZ2V0SGVhZGVyQ2xhc3MgKyAnXCI+JyArXG5cdFx0XHRcdCc8c3BhbiBjbGFzcz1cImZjLWNsb3NlICcgK1xuXHRcdFx0XHRcdChpc1RoZW1lID8gJ3VpLWljb24gdWktaWNvbi1jbG9zZXRoaWNrJyA6ICdmYy1pY29uIGZjLWljb24teCcpICtcblx0XHRcdFx0J1wiPjwvc3Bhbj4nICtcblx0XHRcdFx0JzxzcGFuIGNsYXNzPVwiZmMtdGl0bGVcIj4nICtcblx0XHRcdFx0XHRodG1sRXNjYXBlKHRpdGxlKSArXG5cdFx0XHRcdCc8L3NwYW4+JyArXG5cdFx0XHRcdCc8ZGl2IGNsYXNzPVwiZmMtY2xlYXJcIi8+JyArXG5cdFx0XHQnPC9kaXY+JyArXG5cdFx0XHQnPGRpdiBjbGFzcz1cImZjLWJvZHkgJyArIHZpZXcud2lkZ2V0Q29udGVudENsYXNzICsgJ1wiPicgK1xuXHRcdFx0XHQnPGRpdiBjbGFzcz1cImZjLWV2ZW50LWNvbnRhaW5lclwiPjwvZGl2PicgK1xuXHRcdFx0JzwvZGl2Pidcblx0XHQpO1xuXHRcdHZhciBzZWdDb250YWluZXIgPSBjb250ZW50LmZpbmQoJy5mYy1ldmVudC1jb250YWluZXInKTtcblx0XHR2YXIgaTtcblxuXHRcdC8vIHJlbmRlciBlYWNoIHNlZydzIGBlbGAgYW5kIG9ubHkgcmV0dXJuIHRoZSB2aXNpYmxlIHNlZ3Ncblx0XHRzZWdzID0gdGhpcy5yZW5kZXJGZ1NlZ0VscyhzZWdzLCB0cnVlKTsgLy8gZGlzYWJsZVJlc2l6aW5nPXRydWVcblx0XHR0aGlzLnBvcG92ZXJTZWdzID0gc2VncztcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XG5cblx0XHRcdC8vIGJlY2F1c2Ugc2VnbWVudHMgaW4gdGhlIHBvcG92ZXIgYXJlIG5vdCBwYXJ0IG9mIGEgZ3JpZCBjb29yZGluYXRlIHN5c3RlbSwgcHJvdmlkZSBhIGhpbnQgdG8gYW55XG5cdFx0XHQvLyBncmlkcyB0aGF0IHdhbnQgdG8gZG8gZHJhZy1uLWRyb3AgYWJvdXQgd2hpY2ggY2VsbCBpdCBjYW1lIGZyb21cblx0XHRcdHRoaXMucHJlcGFyZUhpdHMoKTtcblx0XHRcdHNlZ3NbaV0uaGl0ID0gdGhpcy5nZXRDZWxsSGl0KHJvdywgY29sKTtcblx0XHRcdHRoaXMucmVsZWFzZUhpdHMoKTtcblxuXHRcdFx0c2VnQ29udGFpbmVyLmFwcGVuZChzZWdzW2ldLmVsKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29udGVudDtcblx0fSxcblxuXG5cdC8vIEdpdmVuIHRoZSBldmVudHMgd2l0aGluIGFuIGFycmF5IG9mIHNlZ21lbnQgb2JqZWN0cywgcmVzbGljZSB0aGVtIHRvIGJlIGluIGEgc2luZ2xlIGRheVxuXHRyZXNsaWNlRGF5U2VnczogZnVuY3Rpb24oc2VncywgZGF5RGF0ZSkge1xuXG5cdFx0Ly8gYnVpbGQgYW4gYXJyYXkgb2YgdGhlIG9yaWdpbmFsIGV2ZW50c1xuXHRcdHZhciBldmVudHMgPSAkLm1hcChzZWdzLCBmdW5jdGlvbihzZWcpIHtcblx0XHRcdHJldHVybiBzZWcuZXZlbnQ7XG5cdFx0fSk7XG5cblx0XHR2YXIgZGF5U3RhcnQgPSBkYXlEYXRlLmNsb25lKCk7XG5cdFx0dmFyIGRheUVuZCA9IGRheVN0YXJ0LmNsb25lKCkuYWRkKDEsICdkYXlzJyk7XG5cdFx0dmFyIGRheVJhbmdlID0geyBzdGFydDogZGF5U3RhcnQsIGVuZDogZGF5RW5kIH07XG5cblx0XHQvLyBzbGljZSB0aGUgZXZlbnRzIHdpdGggYSBjdXN0b20gc2xpY2luZyBmdW5jdGlvblxuXHRcdHNlZ3MgPSB0aGlzLmV2ZW50c1RvU2Vncyhcblx0XHRcdGV2ZW50cyxcblx0XHRcdGZ1bmN0aW9uKHJhbmdlKSB7XG5cdFx0XHRcdHZhciBzZWcgPSBpbnRlcnNlY3RSYW5nZXMocmFuZ2UsIGRheVJhbmdlKTsgLy8gdW5kZWZpbmQgaWYgbm8gaW50ZXJzZWN0aW9uXG5cdFx0XHRcdHJldHVybiBzZWcgPyBbIHNlZyBdIDogW107IC8vIG11c3QgcmV0dXJuIGFuIGFycmF5IG9mIHNlZ21lbnRzXG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdC8vIGZvcmNlIGFuIG9yZGVyIGJlY2F1c2UgZXZlbnRzVG9TZWdzIGRvZXNuJ3QgZ3VhcmFudGVlIG9uZVxuXHRcdHRoaXMuc29ydEV2ZW50U2VncyhzZWdzKTtcblxuXHRcdHJldHVybiBzZWdzO1xuXHR9LFxuXG5cblx0Ly8gR2VuZXJhdGVzIHRoZSB0ZXh0IHRoYXQgc2hvdWxkIGJlIGluc2lkZSBhIFwibW9yZVwiIGxpbmssIGdpdmVuIHRoZSBudW1iZXIgb2YgZXZlbnRzIGl0IHJlcHJlc2VudHNcblx0Z2V0TW9yZUxpbmtUZXh0OiBmdW5jdGlvbihudW0pIHtcblx0XHR2YXIgb3B0ID0gdGhpcy52aWV3Lm9wdCgnZXZlbnRMaW1pdFRleHQnKTtcblxuXHRcdGlmICh0eXBlb2Ygb3B0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRyZXR1cm4gb3B0KG51bSk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmV0dXJuICcrJyArIG51bSArICcgJyArIG9wdDtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBSZXR1cm5zIHNlZ21lbnRzIHdpdGhpbiBhIGdpdmVuIGNlbGwuXG5cdC8vIElmIGBzdGFydExldmVsYCBpcyBzcGVjaWZpZWQsIHJldHVybnMgb25seSBldmVudHMgaW5jbHVkaW5nIGFuZCBiZWxvdyB0aGF0IGxldmVsLiBPdGhlcndpc2UgcmV0dXJucyBhbGwgc2Vncy5cblx0Z2V0Q2VsbFNlZ3M6IGZ1bmN0aW9uKHJvdywgY29sLCBzdGFydExldmVsKSB7XG5cdFx0dmFyIHNlZ01hdHJpeCA9IHRoaXMucm93U3RydWN0c1tyb3ddLnNlZ01hdHJpeDtcblx0XHR2YXIgbGV2ZWwgPSBzdGFydExldmVsIHx8IDA7XG5cdFx0dmFyIHNlZ3MgPSBbXTtcblx0XHR2YXIgc2VnO1xuXG5cdFx0d2hpbGUgKGxldmVsIDwgc2VnTWF0cml4Lmxlbmd0aCkge1xuXHRcdFx0c2VnID0gc2VnTWF0cml4W2xldmVsXVtjb2xdO1xuXHRcdFx0aWYgKHNlZykge1xuXHRcdFx0XHRzZWdzLnB1c2goc2VnKTtcblx0XHRcdH1cblx0XHRcdGxldmVsKys7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNlZ3M7XG5cdH1cblxufSk7XG5cbjs7XG5cbi8qIEEgY29tcG9uZW50IHRoYXQgcmVuZGVycyBvbmUgb3IgbW9yZSBjb2x1bW5zIG9mIHZlcnRpY2FsIHRpbWUgc2xvdHNcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLy8gV2UgbWl4aW4gRGF5VGFibGUsIGV2ZW4gdGhvdWdoIHRoZXJlIGlzIG9ubHkgYSBzaW5nbGUgcm93IG9mIGRheXNcblxudmFyIFRpbWVHcmlkID0gRkMuVGltZUdyaWQgPSBHcmlkLmV4dGVuZChEYXlUYWJsZU1peGluLCB7XG5cblx0c2xvdER1cmF0aW9uOiBudWxsLCAvLyBkdXJhdGlvbiBvZiBhIFwic2xvdFwiLCBhIGRpc3RpbmN0IHRpbWUgc2VnbWVudCBvbiBnaXZlbiBkYXksIHZpc3VhbGl6ZWQgYnkgbGluZXNcblx0c25hcER1cmF0aW9uOiBudWxsLCAvLyBncmFudWxhcml0eSBvZiB0aW1lIGZvciBkcmFnZ2luZyBhbmQgc2VsZWN0aW5nXG5cdHNuYXBzUGVyU2xvdDogbnVsbCxcblx0bWluVGltZTogbnVsbCwgLy8gRHVyYXRpb24gb2JqZWN0IHRoYXQgZGVub3RlcyB0aGUgZmlyc3QgdmlzaWJsZSB0aW1lIG9mIGFueSBnaXZlbiBkYXlcblx0bWF4VGltZTogbnVsbCwgLy8gRHVyYXRpb24gb2JqZWN0IHRoYXQgZGVub3RlcyB0aGUgZXhjbHVzaXZlIHZpc2libGUgZW5kIHRpbWUgb2YgYW55IGdpdmVuIGRheVxuXHRsYWJlbEZvcm1hdDogbnVsbCwgLy8gZm9ybWF0dGluZyBzdHJpbmcgZm9yIHRpbWVzIHJ1bm5pbmcgYWxvbmcgdmVydGljYWwgYXhpc1xuXHRsYWJlbEludGVydmFsOiBudWxsLCAvLyBkdXJhdGlvbiBvZiBob3cgb2Z0ZW4gYSBsYWJlbCBzaG91bGQgYmUgZGlzcGxheWVkIGZvciBhIHNsb3RcblxuXHRjb2xFbHM6IG51bGwsIC8vIGNlbGxzIGVsZW1lbnRzIGluIHRoZSBkYXktcm93IGJhY2tncm91bmRcblx0c2xhdENvbnRhaW5lckVsOiBudWxsLCAvLyBkaXYgdGhhdCB3cmFwcyBhbGwgdGhlIHNsYXQgcm93c1xuXHRzbGF0RWxzOiBudWxsLCAvLyBlbGVtZW50cyBydW5uaW5nIGhvcml6b250YWxseSBhY3Jvc3MgYWxsIGNvbHVtbnNcblx0bm93SW5kaWNhdG9yRWxzOiBudWxsLFxuXG5cdGNvbENvb3JkQ2FjaGU6IG51bGwsXG5cdHNsYXRDb29yZENhY2hlOiBudWxsLFxuXG5cblx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uKCkge1xuXHRcdEdyaWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gY2FsbCB0aGUgc3VwZXItY29uc3RydWN0b3JcblxuXHRcdHRoaXMucHJvY2Vzc09wdGlvbnMoKTtcblx0fSxcblxuXG5cdC8vIFJlbmRlcnMgdGhlIHRpbWUgZ3JpZCBpbnRvIGB0aGlzLmVsYCwgd2hpY2ggc2hvdWxkIGFscmVhZHkgYmUgYXNzaWduZWQuXG5cdC8vIFJlbGllcyBvbiB0aGUgdmlldydzIGNvbENudC4gSW4gdGhlIGZ1dHVyZSwgdGhpcyBjb21wb25lbnQgc2hvdWxkIHByb2JhYmx5IGJlIHNlbGYtc3VmZmljaWVudC5cblx0cmVuZGVyRGF0ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZWwuaHRtbCh0aGlzLnJlbmRlckh0bWwoKSk7XG5cdFx0dGhpcy5jb2xFbHMgPSB0aGlzLmVsLmZpbmQoJy5mYy1kYXknKTtcblx0XHR0aGlzLnNsYXRDb250YWluZXJFbCA9IHRoaXMuZWwuZmluZCgnLmZjLXNsYXRzJyk7XG5cdFx0dGhpcy5zbGF0RWxzID0gdGhpcy5zbGF0Q29udGFpbmVyRWwuZmluZCgndHInKTtcblxuXHRcdHRoaXMuY29sQ29vcmRDYWNoZSA9IG5ldyBDb29yZENhY2hlKHtcblx0XHRcdGVsczogdGhpcy5jb2xFbHMsXG5cdFx0XHRpc0hvcml6b250YWw6IHRydWVcblx0XHR9KTtcblx0XHR0aGlzLnNsYXRDb29yZENhY2hlID0gbmV3IENvb3JkQ2FjaGUoe1xuXHRcdFx0ZWxzOiB0aGlzLnNsYXRFbHMsXG5cdFx0XHRpc1ZlcnRpY2FsOiB0cnVlXG5cdFx0fSk7XG5cblx0XHR0aGlzLnJlbmRlckNvbnRlbnRTa2VsZXRvbigpO1xuXHR9LFxuXG5cblx0Ly8gUmVuZGVycyB0aGUgYmFzaWMgSFRNTCBza2VsZXRvbiBmb3IgdGhlIGdyaWRcblx0cmVuZGVySHRtbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICcnICtcblx0XHRcdCc8ZGl2IGNsYXNzPVwiZmMtYmdcIj4nICtcblx0XHRcdFx0Jzx0YWJsZT4nICtcblx0XHRcdFx0XHR0aGlzLnJlbmRlckJnVHJIdG1sKDApICsgLy8gcm93PTBcblx0XHRcdFx0JzwvdGFibGU+JyArXG5cdFx0XHQnPC9kaXY+JyArXG5cdFx0XHQnPGRpdiBjbGFzcz1cImZjLXNsYXRzXCI+JyArXG5cdFx0XHRcdCc8dGFibGU+JyArXG5cdFx0XHRcdFx0dGhpcy5yZW5kZXJTbGF0Um93SHRtbCgpICtcblx0XHRcdFx0JzwvdGFibGU+JyArXG5cdFx0XHQnPC9kaXY+Jztcblx0fSxcblxuXG5cdC8vIEdlbmVyYXRlcyB0aGUgSFRNTCBmb3IgdGhlIGhvcml6b250YWwgXCJzbGF0c1wiIHRoYXQgcnVuIHdpZHRoLXdpc2UuIEhhcyBhIHRpbWUgYXhpcyBvbiBhIHNpZGUuIERlcGVuZHMgb24gUlRMLlxuXHRyZW5kZXJTbGF0Um93SHRtbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIGlzUlRMID0gdGhpcy5pc1JUTDtcblx0XHR2YXIgaHRtbCA9ICcnO1xuXHRcdHZhciBzbG90VGltZSA9IG1vbWVudC5kdXJhdGlvbigrdGhpcy5taW5UaW1lKTsgLy8gd2lzaCB0aGVyZSB3YXMgLmNsb25lKCkgZm9yIGR1cmF0aW9uc1xuXHRcdHZhciBzbG90RGF0ZTsgLy8gd2lsbCBiZSBvbiB0aGUgdmlldydzIGZpcnN0IGRheSwgYnV0IHdlIG9ubHkgY2FyZSBhYm91dCBpdHMgdGltZVxuXHRcdHZhciBpc0xhYmVsZWQ7XG5cdFx0dmFyIGF4aXNIdG1sO1xuXG5cdFx0Ly8gQ2FsY3VsYXRlIHRoZSB0aW1lIGZvciBlYWNoIHNsb3Rcblx0XHR3aGlsZSAoc2xvdFRpbWUgPCB0aGlzLm1heFRpbWUpIHtcblx0XHRcdHNsb3REYXRlID0gdGhpcy5zdGFydC5jbG9uZSgpLnRpbWUoc2xvdFRpbWUpO1xuXHRcdFx0aXNMYWJlbGVkID0gaXNJbnQoZGl2aWRlRHVyYXRpb25CeUR1cmF0aW9uKHNsb3RUaW1lLCB0aGlzLmxhYmVsSW50ZXJ2YWwpKTtcblxuXHRcdFx0YXhpc0h0bWwgPVxuXHRcdFx0XHQnPHRkIGNsYXNzPVwiZmMtYXhpcyBmYy10aW1lICcgKyB2aWV3LndpZGdldENvbnRlbnRDbGFzcyArICdcIiAnICsgdmlldy5heGlzU3R5bGVBdHRyKCkgKyAnPicgK1xuXHRcdFx0XHRcdChpc0xhYmVsZWQgP1xuXHRcdFx0XHRcdFx0JzxzcGFuPicgKyAvLyBmb3IgbWF0Y2hDZWxsV2lkdGhzXG5cdFx0XHRcdFx0XHRcdGh0bWxFc2NhcGUoc2xvdERhdGUuZm9ybWF0KHRoaXMubGFiZWxGb3JtYXQpKSArXG5cdFx0XHRcdFx0XHQnPC9zcGFuPicgOlxuXHRcdFx0XHRcdFx0Jydcblx0XHRcdFx0XHRcdCkgK1xuXHRcdFx0XHQnPC90ZD4nO1xuXG5cdFx0XHRodG1sICs9XG5cdFx0XHRcdCc8dHIgZGF0YS10aW1lPVwiJyArIHNsb3REYXRlLmZvcm1hdCgnSEg6bW06c3MnKSArICdcIicgK1xuXHRcdFx0XHRcdChpc0xhYmVsZWQgPyAnJyA6ICcgY2xhc3M9XCJmYy1taW5vclwiJykgK1xuXHRcdFx0XHRcdCc+JyArXG5cdFx0XHRcdFx0KCFpc1JUTCA/IGF4aXNIdG1sIDogJycpICtcblx0XHRcdFx0XHQnPHRkIGNsYXNzPVwiJyArIHZpZXcud2lkZ2V0Q29udGVudENsYXNzICsgJ1wiLz4nICtcblx0XHRcdFx0XHQoaXNSVEwgPyBheGlzSHRtbCA6ICcnKSArXG5cdFx0XHRcdFwiPC90cj5cIjtcblxuXHRcdFx0c2xvdFRpbWUuYWRkKHRoaXMuc2xvdER1cmF0aW9uKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaHRtbDtcblx0fSxcblxuXG5cdC8qIE9wdGlvbnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIFBhcnNlcyB2YXJpb3VzIG9wdGlvbnMgaW50byBwcm9wZXJ0aWVzIG9mIHRoaXMgb2JqZWN0XG5cdHByb2Nlc3NPcHRpb25zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblx0XHR2YXIgc2xvdER1cmF0aW9uID0gdmlldy5vcHQoJ3Nsb3REdXJhdGlvbicpO1xuXHRcdHZhciBzbmFwRHVyYXRpb24gPSB2aWV3Lm9wdCgnc25hcER1cmF0aW9uJyk7XG5cdFx0dmFyIGlucHV0O1xuXG5cdFx0c2xvdER1cmF0aW9uID0gbW9tZW50LmR1cmF0aW9uKHNsb3REdXJhdGlvbik7XG5cdFx0c25hcER1cmF0aW9uID0gc25hcER1cmF0aW9uID8gbW9tZW50LmR1cmF0aW9uKHNuYXBEdXJhdGlvbikgOiBzbG90RHVyYXRpb247XG5cblx0XHR0aGlzLnNsb3REdXJhdGlvbiA9IHNsb3REdXJhdGlvbjtcblx0XHR0aGlzLnNuYXBEdXJhdGlvbiA9IHNuYXBEdXJhdGlvbjtcblx0XHR0aGlzLnNuYXBzUGVyU2xvdCA9IHNsb3REdXJhdGlvbiAvIHNuYXBEdXJhdGlvbjsgLy8gVE9ETzogZW5zdXJlIGFuIGludGVnZXIgbXVsdGlwbGU/XG5cblx0XHR0aGlzLm1pblJlc2l6ZUR1cmF0aW9uID0gc25hcER1cmF0aW9uOyAvLyBoYWNrXG5cblx0XHR0aGlzLm1pblRpbWUgPSBtb21lbnQuZHVyYXRpb24odmlldy5vcHQoJ21pblRpbWUnKSk7XG5cdFx0dGhpcy5tYXhUaW1lID0gbW9tZW50LmR1cmF0aW9uKHZpZXcub3B0KCdtYXhUaW1lJykpO1xuXG5cdFx0Ly8gbWlnaHQgYmUgYW4gYXJyYXkgdmFsdWUgKGZvciBUaW1lbGluZVZpZXcpLlxuXHRcdC8vIGlmIHNvLCBnZXR0aW5nIHRoZSBtb3N0IGdyYW51bGFyIGVudHJ5ICh0aGUgbGFzdCBvbmUgcHJvYmFibHkpLlxuXHRcdGlucHV0ID0gdmlldy5vcHQoJ3Nsb3RMYWJlbEZvcm1hdCcpO1xuXHRcdGlmICgkLmlzQXJyYXkoaW5wdXQpKSB7XG5cdFx0XHRpbnB1dCA9IGlucHV0W2lucHV0Lmxlbmd0aCAtIDFdO1xuXHRcdH1cblxuXHRcdHRoaXMubGFiZWxGb3JtYXQgPVxuXHRcdFx0aW5wdXQgfHxcblx0XHRcdHZpZXcub3B0KCdzbWFsbFRpbWVGb3JtYXQnKTsgLy8gdGhlIGNvbXB1dGVkIGRlZmF1bHRcblxuXHRcdGlucHV0ID0gdmlldy5vcHQoJ3Nsb3RMYWJlbEludGVydmFsJyk7XG5cdFx0dGhpcy5sYWJlbEludGVydmFsID0gaW5wdXQgP1xuXHRcdFx0bW9tZW50LmR1cmF0aW9uKGlucHV0KSA6XG5cdFx0XHR0aGlzLmNvbXB1dGVMYWJlbEludGVydmFsKHNsb3REdXJhdGlvbik7XG5cdH0sXG5cblxuXHQvLyBDb21wdXRlcyBhbiBhdXRvbWF0aWMgdmFsdWUgZm9yIHNsb3RMYWJlbEludGVydmFsXG5cdGNvbXB1dGVMYWJlbEludGVydmFsOiBmdW5jdGlvbihzbG90RHVyYXRpb24pIHtcblx0XHR2YXIgaTtcblx0XHR2YXIgbGFiZWxJbnRlcnZhbDtcblx0XHR2YXIgc2xvdHNQZXJMYWJlbDtcblxuXHRcdC8vIGZpbmQgdGhlIHNtYWxsZXN0IHN0b2NrIGxhYmVsIGludGVydmFsIHRoYXQgcmVzdWx0cyBpbiBtb3JlIHRoYW4gb25lIHNsb3RzLXBlci1sYWJlbFxuXHRcdGZvciAoaSA9IEFHRU5EQV9TVE9DS19TVUJfRFVSQVRJT05TLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRsYWJlbEludGVydmFsID0gbW9tZW50LmR1cmF0aW9uKEFHRU5EQV9TVE9DS19TVUJfRFVSQVRJT05TW2ldKTtcblx0XHRcdHNsb3RzUGVyTGFiZWwgPSBkaXZpZGVEdXJhdGlvbkJ5RHVyYXRpb24obGFiZWxJbnRlcnZhbCwgc2xvdER1cmF0aW9uKTtcblx0XHRcdGlmIChpc0ludChzbG90c1BlckxhYmVsKSAmJiBzbG90c1BlckxhYmVsID4gMSkge1xuXHRcdFx0XHRyZXR1cm4gbGFiZWxJbnRlcnZhbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbW9tZW50LmR1cmF0aW9uKHNsb3REdXJhdGlvbik7IC8vIGZhbGwgYmFjay4gY2xvbmVcblx0fSxcblxuXG5cdC8vIENvbXB1dGVzIGEgZGVmYXVsdCBldmVudCB0aW1lIGZvcm1hdHRpbmcgc3RyaW5nIGlmIGB0aW1lRm9ybWF0YCBpcyBub3QgZXhwbGljaXRseSBkZWZpbmVkXG5cdGNvbXB1dGVFdmVudFRpbWVGb3JtYXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnZpZXcub3B0KCdub01lcmlkaWVtVGltZUZvcm1hdCcpOyAvLyBsaWtlIFwiNjozMFwiIChubyBBTS9QTSlcblx0fSxcblxuXG5cdC8vIENvbXB1dGVzIGEgZGVmYXVsdCBgZGlzcGxheUV2ZW50RW5kYCB2YWx1ZSBpZiBvbmUgaXMgbm90IGV4cGxpY2x0eSBkZWZpbmVkXG5cdGNvbXB1dGVEaXNwbGF5RXZlbnRFbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cblx0LyogSGl0IFN5c3RlbVxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0cHJlcGFyZUhpdHM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuY29sQ29vcmRDYWNoZS5idWlsZCgpO1xuXHRcdHRoaXMuc2xhdENvb3JkQ2FjaGUuYnVpbGQoKTtcblx0fSxcblxuXG5cdHJlbGVhc2VIaXRzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmNvbENvb3JkQ2FjaGUuY2xlYXIoKTtcblx0XHQvLyBOT1RFOiBkb24ndCBjbGVhciBzbGF0Q29vcmRDYWNoZSBiZWNhdXNlIHdlIHJlbHkgb24gaXQgZm9yIGNvbXB1dGVUaW1lVG9wXG5cdH0sXG5cblxuXHRxdWVyeUhpdDogZnVuY3Rpb24obGVmdE9mZnNldCwgdG9wT2Zmc2V0KSB7XG5cdFx0dmFyIHNuYXBzUGVyU2xvdCA9IHRoaXMuc25hcHNQZXJTbG90O1xuXHRcdHZhciBjb2xDb29yZENhY2hlID0gdGhpcy5jb2xDb29yZENhY2hlO1xuXHRcdHZhciBzbGF0Q29vcmRDYWNoZSA9IHRoaXMuc2xhdENvb3JkQ2FjaGU7XG5cblx0XHRpZiAoY29sQ29vcmRDYWNoZS5pc0xlZnRJbkJvdW5kcyhsZWZ0T2Zmc2V0KSAmJiBzbGF0Q29vcmRDYWNoZS5pc1RvcEluQm91bmRzKHRvcE9mZnNldCkpIHtcblx0XHRcdHZhciBjb2xJbmRleCA9IGNvbENvb3JkQ2FjaGUuZ2V0SG9yaXpvbnRhbEluZGV4KGxlZnRPZmZzZXQpO1xuXHRcdFx0dmFyIHNsYXRJbmRleCA9IHNsYXRDb29yZENhY2hlLmdldFZlcnRpY2FsSW5kZXgodG9wT2Zmc2V0KTtcblxuXHRcdFx0aWYgKGNvbEluZGV4ICE9IG51bGwgJiYgc2xhdEluZGV4ICE9IG51bGwpIHtcblx0XHRcdFx0dmFyIHNsYXRUb3AgPSBzbGF0Q29vcmRDYWNoZS5nZXRUb3BPZmZzZXQoc2xhdEluZGV4KTtcblx0XHRcdFx0dmFyIHNsYXRIZWlnaHQgPSBzbGF0Q29vcmRDYWNoZS5nZXRIZWlnaHQoc2xhdEluZGV4KTtcblx0XHRcdFx0dmFyIHBhcnRpYWwgPSAodG9wT2Zmc2V0IC0gc2xhdFRvcCkgLyBzbGF0SGVpZ2h0OyAvLyBmbG9hdGluZyBwb2ludCBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG5cdFx0XHRcdHZhciBsb2NhbFNuYXBJbmRleCA9IE1hdGguZmxvb3IocGFydGlhbCAqIHNuYXBzUGVyU2xvdCk7IC8vIHRoZSBzbmFwICMgcmVsYXRpdmUgdG8gc3RhcnQgb2Ygc2xhdFxuXHRcdFx0XHR2YXIgc25hcEluZGV4ID0gc2xhdEluZGV4ICogc25hcHNQZXJTbG90ICsgbG9jYWxTbmFwSW5kZXg7XG5cdFx0XHRcdHZhciBzbmFwVG9wID0gc2xhdFRvcCArIChsb2NhbFNuYXBJbmRleCAvIHNuYXBzUGVyU2xvdCkgKiBzbGF0SGVpZ2h0O1xuXHRcdFx0XHR2YXIgc25hcEJvdHRvbSA9IHNsYXRUb3AgKyAoKGxvY2FsU25hcEluZGV4ICsgMSkgLyBzbmFwc1BlclNsb3QpICogc2xhdEhlaWdodDtcblxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGNvbDogY29sSW5kZXgsXG5cdFx0XHRcdFx0c25hcDogc25hcEluZGV4LFxuXHRcdFx0XHRcdGNvbXBvbmVudDogdGhpcywgLy8gbmVlZGVkIHVuZm9ydHVuYXRlbHkgOihcblx0XHRcdFx0XHRsZWZ0OiBjb2xDb29yZENhY2hlLmdldExlZnRPZmZzZXQoY29sSW5kZXgpLFxuXHRcdFx0XHRcdHJpZ2h0OiBjb2xDb29yZENhY2hlLmdldFJpZ2h0T2Zmc2V0KGNvbEluZGV4KSxcblx0XHRcdFx0XHR0b3A6IHNuYXBUb3AsXG5cdFx0XHRcdFx0Ym90dG9tOiBzbmFwQm90dG9tXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cblx0Z2V0SGl0U3BhbjogZnVuY3Rpb24oaGl0KSB7XG5cdFx0dmFyIHN0YXJ0ID0gdGhpcy5nZXRDZWxsRGF0ZSgwLCBoaXQuY29sKTsgLy8gcm93PTBcblx0XHR2YXIgdGltZSA9IHRoaXMuY29tcHV0ZVNuYXBUaW1lKGhpdC5zbmFwKTsgLy8gcGFzcyBpbiB0aGUgc25hcC1pbmRleFxuXHRcdHZhciBlbmQ7XG5cblx0XHRzdGFydC50aW1lKHRpbWUpO1xuXHRcdGVuZCA9IHN0YXJ0LmNsb25lKCkuYWRkKHRoaXMuc25hcER1cmF0aW9uKTtcblxuXHRcdHJldHVybiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcblx0fSxcblxuXG5cdGdldEhpdEVsOiBmdW5jdGlvbihoaXQpIHtcblx0XHRyZXR1cm4gdGhpcy5jb2xFbHMuZXEoaGl0LmNvbCk7XG5cdH0sXG5cblxuXHQvKiBEYXRlc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0cmFuZ2VVcGRhdGVkOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnVwZGF0ZURheVRhYmxlKCk7XG5cdH0sXG5cblxuXHQvLyBHaXZlbiBhIHJvdyBudW1iZXIgb2YgdGhlIGdyaWQsIHJlcHJlc2VudGluZyBhIFwic25hcFwiLCByZXR1cm5zIGEgdGltZSAoRHVyYXRpb24pIGZyb20gaXRzIHN0YXJ0LW9mLWRheVxuXHRjb21wdXRlU25hcFRpbWU6IGZ1bmN0aW9uKHNuYXBJbmRleCkge1xuXHRcdHJldHVybiBtb21lbnQuZHVyYXRpb24odGhpcy5taW5UaW1lICsgdGhpcy5zbmFwRHVyYXRpb24gKiBzbmFwSW5kZXgpO1xuXHR9LFxuXG5cblx0Ly8gU2xpY2VzIHVwIHRoZSBnaXZlbiBzcGFuICh1bnpvbmVkIHN0YXJ0L2VuZCB3aXRoIG90aGVyIG1pc2MgZGF0YSkgaW50byBhbiBhcnJheSBvZiBzZWdtZW50c1xuXHRzcGFuVG9TZWdzOiBmdW5jdGlvbihzcGFuKSB7XG5cdFx0dmFyIHNlZ3MgPSB0aGlzLnNsaWNlUmFuZ2VCeVRpbWVzKHNwYW4pO1xuXHRcdHZhciBpO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICh0aGlzLmlzUlRMKSB7XG5cdFx0XHRcdHNlZ3NbaV0uY29sID0gdGhpcy5kYXlzUGVyUm93IC0gMSAtIHNlZ3NbaV0uZGF5SW5kZXg7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0c2Vnc1tpXS5jb2wgPSBzZWdzW2ldLmRheUluZGV4O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBzZWdzO1xuXHR9LFxuXG5cblx0c2xpY2VSYW5nZUJ5VGltZXM6IGZ1bmN0aW9uKHJhbmdlKSB7XG5cdFx0dmFyIHNlZ3MgPSBbXTtcblx0XHR2YXIgc2VnO1xuXHRcdHZhciBkYXlJbmRleDtcblx0XHR2YXIgZGF5RGF0ZTtcblx0XHR2YXIgZGF5UmFuZ2U7XG5cblx0XHRmb3IgKGRheUluZGV4ID0gMDsgZGF5SW5kZXggPCB0aGlzLmRheXNQZXJSb3c7IGRheUluZGV4KyspIHtcblx0XHRcdGRheURhdGUgPSB0aGlzLmRheURhdGVzW2RheUluZGV4XS5jbG9uZSgpOyAvLyBUT0RPOiBiZXR0ZXIgQVBJIGZvciB0aGlzP1xuXHRcdFx0ZGF5UmFuZ2UgPSB7XG5cdFx0XHRcdHN0YXJ0OiBkYXlEYXRlLmNsb25lKCkudGltZSh0aGlzLm1pblRpbWUpLFxuXHRcdFx0XHRlbmQ6IGRheURhdGUuY2xvbmUoKS50aW1lKHRoaXMubWF4VGltZSlcblx0XHRcdH07XG5cdFx0XHRzZWcgPSBpbnRlcnNlY3RSYW5nZXMocmFuZ2UsIGRheVJhbmdlKTsgLy8gYm90aCB3aWxsIGJlIGFtYmlnIHRpbWV6b25lXG5cdFx0XHRpZiAoc2VnKSB7XG5cdFx0XHRcdHNlZy5kYXlJbmRleCA9IGRheUluZGV4O1xuXHRcdFx0XHRzZWdzLnB1c2goc2VnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gc2Vncztcblx0fSxcblxuXG5cdC8qIENvb3JkaW5hdGVzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHR1cGRhdGVTaXplOiBmdW5jdGlvbihpc1Jlc2l6ZSkgeyAvLyBOT1QgYSBzdGFuZGFyZCBHcmlkIG1ldGhvZFxuXHRcdHRoaXMuc2xhdENvb3JkQ2FjaGUuYnVpbGQoKTtcblxuXHRcdGlmIChpc1Jlc2l6ZSkge1xuXHRcdFx0dGhpcy51cGRhdGVTZWdWZXJ0aWNhbHMoXG5cdFx0XHRcdFtdLmNvbmNhdCh0aGlzLmZnU2VncyB8fCBbXSwgdGhpcy5iZ1NlZ3MgfHwgW10sIHRoaXMuYnVzaW5lc3NTZWdzIHx8IFtdKVxuXHRcdFx0KTtcblx0XHR9XG5cdH0sXG5cblxuXHRnZXRUb3RhbFNsYXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnNsYXRDb250YWluZXJFbC5vdXRlckhlaWdodCgpO1xuXHR9LFxuXG5cblx0Ly8gQ29tcHV0ZXMgdGhlIHRvcCBjb29yZGluYXRlLCByZWxhdGl2ZSB0byB0aGUgYm91bmRzIG9mIHRoZSBncmlkLCBvZiB0aGUgZ2l2ZW4gZGF0ZS5cblx0Ly8gQSBgc3RhcnRPZkRheURhdGVgIG11c3QgYmUgZ2l2ZW4gZm9yIGF2b2lkaW5nIGFtYmlndWl0eSBvdmVyIGhvdyB0byB0cmVhdCBtaWRuaWdodC5cblx0Y29tcHV0ZURhdGVUb3A6IGZ1bmN0aW9uKGRhdGUsIHN0YXJ0T2ZEYXlEYXRlKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29tcHV0ZVRpbWVUb3AoXG5cdFx0XHRtb21lbnQuZHVyYXRpb24oXG5cdFx0XHRcdGRhdGUgLSBzdGFydE9mRGF5RGF0ZS5jbG9uZSgpLnN0cmlwVGltZSgpXG5cdFx0XHQpXG5cdFx0KTtcblx0fSxcblxuXG5cdC8vIENvbXB1dGVzIHRoZSB0b3AgY29vcmRpbmF0ZSwgcmVsYXRpdmUgdG8gdGhlIGJvdW5kcyBvZiB0aGUgZ3JpZCwgb2YgdGhlIGdpdmVuIHRpbWUgKGEgRHVyYXRpb24pLlxuXHRjb21wdXRlVGltZVRvcDogZnVuY3Rpb24odGltZSkge1xuXHRcdHZhciBsZW4gPSB0aGlzLnNsYXRFbHMubGVuZ3RoO1xuXHRcdHZhciBzbGF0Q292ZXJhZ2UgPSAodGltZSAtIHRoaXMubWluVGltZSkgLyB0aGlzLnNsb3REdXJhdGlvbjsgLy8gZmxvYXRpbmctcG9pbnQgdmFsdWUgb2YgIyBvZiBzbG90cyBjb3ZlcmVkXG5cdFx0dmFyIHNsYXRJbmRleDtcblx0XHR2YXIgc2xhdFJlbWFpbmRlcjtcblxuXHRcdC8vIGNvbXB1dGUgYSBmbG9hdGluZy1wb2ludCBudW1iZXIgZm9yIGhvdyBtYW55IHNsYXRzIHNob3VsZCBiZSBwcm9ncmVzc2VkIHRocm91Z2guXG5cdFx0Ly8gZnJvbSAwIHRvIG51bWJlciBvZiBzbGF0cyAoaW5jbHVzaXZlKVxuXHRcdC8vIGNvbnN0cmFpbmVkIGJlY2F1c2UgbWluVGltZS9tYXhUaW1lIG1pZ2h0IGJlIGN1c3RvbWl6ZWQuXG5cdFx0c2xhdENvdmVyYWdlID0gTWF0aC5tYXgoMCwgc2xhdENvdmVyYWdlKTtcblx0XHRzbGF0Q292ZXJhZ2UgPSBNYXRoLm1pbihsZW4sIHNsYXRDb3ZlcmFnZSk7XG5cblx0XHQvLyBhbiBpbnRlZ2VyIGluZGV4IG9mIHRoZSBmdXJ0aGVzdCB3aG9sZSBzbGF0XG5cdFx0Ly8gZnJvbSAwIHRvIG51bWJlciBzbGF0cyAoKmV4Y2x1c2l2ZSosIHNvIGxlbi0xKVxuXHRcdHNsYXRJbmRleCA9IE1hdGguZmxvb3Ioc2xhdENvdmVyYWdlKTtcblx0XHRzbGF0SW5kZXggPSBNYXRoLm1pbihzbGF0SW5kZXgsIGxlbiAtIDEpO1xuXG5cdFx0Ly8gaG93IG11Y2ggZnVydGhlciB0aHJvdWdoIHRoZSBzbGF0SW5kZXggc2xhdCAoZnJvbSAwLjAtMS4wKSBtdXN0IGJlIGNvdmVyZWQgaW4gYWRkaXRpb24uXG5cdFx0Ly8gY291bGQgYmUgMS4wIGlmIHNsYXRDb3ZlcmFnZSBpcyBjb3ZlcmluZyAqYWxsKiB0aGUgc2xvdHNcblx0XHRzbGF0UmVtYWluZGVyID0gc2xhdENvdmVyYWdlIC0gc2xhdEluZGV4O1xuXG5cdFx0cmV0dXJuIHRoaXMuc2xhdENvb3JkQ2FjaGUuZ2V0VG9wUG9zaXRpb24oc2xhdEluZGV4KSArXG5cdFx0XHR0aGlzLnNsYXRDb29yZENhY2hlLmdldEhlaWdodChzbGF0SW5kZXgpICogc2xhdFJlbWFpbmRlcjtcblx0fSxcblxuXG5cblx0LyogRXZlbnQgRHJhZyBWaXN1YWxpemF0aW9uXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBSZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgYW4gZXZlbnQgYmVpbmcgZHJhZ2dlZCBvdmVyIHRoZSBzcGVjaWZpZWQgZGF0ZShzKS5cblx0Ly8gQSByZXR1cm5lZCB2YWx1ZSBvZiBgdHJ1ZWAgc2lnbmFscyB0aGF0IGEgbW9jayBcImhlbHBlclwiIGV2ZW50IGhhcyBiZWVuIHJlbmRlcmVkLlxuXHRyZW5kZXJEcmFnOiBmdW5jdGlvbihldmVudExvY2F0aW9uLCBzZWcpIHtcblxuXHRcdGlmIChzZWcpIHsgLy8gaWYgdGhlcmUgaXMgZXZlbnQgaW5mb3JtYXRpb24gZm9yIHRoaXMgZHJhZywgcmVuZGVyIGEgaGVscGVyIGV2ZW50XG5cblx0XHRcdC8vIHJldHVybnMgbW9jayBldmVudCBlbGVtZW50c1xuXHRcdFx0Ly8gc2lnbmFsIHRoYXQgYSBoZWxwZXIgaGFzIGJlZW4gcmVuZGVyZWRcblx0XHRcdHJldHVybiB0aGlzLnJlbmRlckV2ZW50TG9jYXRpb25IZWxwZXIoZXZlbnRMb2NhdGlvbiwgc2VnKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBvdGhlcndpc2UsIGp1c3QgcmVuZGVyIGEgaGlnaGxpZ2h0XG5cdFx0XHR0aGlzLnJlbmRlckhpZ2hsaWdodCh0aGlzLmV2ZW50VG9TcGFuKGV2ZW50TG9jYXRpb24pKTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBVbnJlbmRlcnMgYW55IHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IGJlaW5nIGRyYWdnZWRcblx0dW5yZW5kZXJEcmFnOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnVucmVuZGVySGVscGVyKCk7XG5cdFx0dGhpcy51bnJlbmRlckhpZ2hsaWdodCgpO1xuXHR9LFxuXG5cblx0LyogRXZlbnQgUmVzaXplIFZpc3VhbGl6YXRpb25cblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIFJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhbiBldmVudCBiZWluZyByZXNpemVkXG5cdHJlbmRlckV2ZW50UmVzaXplOiBmdW5jdGlvbihldmVudExvY2F0aW9uLCBzZWcpIHtcblx0XHRyZXR1cm4gdGhpcy5yZW5kZXJFdmVudExvY2F0aW9uSGVscGVyKGV2ZW50TG9jYXRpb24sIHNlZyk7IC8vIHJldHVybnMgbW9jayBldmVudCBlbGVtZW50c1xuXHR9LFxuXG5cblx0Ly8gVW5yZW5kZXJzIGFueSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhbiBldmVudCBiZWluZyByZXNpemVkXG5cdHVucmVuZGVyRXZlbnRSZXNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudW5yZW5kZXJIZWxwZXIoKTtcblx0fSxcblxuXG5cdC8qIEV2ZW50IEhlbHBlclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gUmVuZGVycyBhIG1vY2sgXCJoZWxwZXJcIiBldmVudC4gYHNvdXJjZVNlZ2AgaXMgdGhlIG9yaWdpbmFsIHNlZ21lbnQgb2JqZWN0IGFuZCBtaWdodCBiZSBudWxsIChhbiBleHRlcm5hbCBkcmFnKVxuXHRyZW5kZXJIZWxwZXI6IGZ1bmN0aW9uKGV2ZW50LCBzb3VyY2VTZWcpIHtcblx0XHRyZXR1cm4gdGhpcy5yZW5kZXJIZWxwZXJTZWdzKHRoaXMuZXZlbnRUb1NlZ3MoZXZlbnQpLCBzb3VyY2VTZWcpOyAvLyByZXR1cm5zIG1vY2sgZXZlbnQgZWxlbWVudHNcblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyBhbnkgbW9jayBoZWxwZXIgZXZlbnRcblx0dW5yZW5kZXJIZWxwZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudW5yZW5kZXJIZWxwZXJTZWdzKCk7XG5cdH0sXG5cblxuXHQvKiBCdXNpbmVzcyBIb3Vyc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0cmVuZGVyQnVzaW5lc3NIb3VyczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5yZW5kZXJCdXNpbmVzc1NlZ3MoXG5cdFx0XHR0aGlzLmJ1aWxkQnVzaW5lc3NIb3VyU2VncygpXG5cdFx0KTtcblx0fSxcblxuXG5cdHVucmVuZGVyQnVzaW5lc3NIb3VyczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51bnJlbmRlckJ1c2luZXNzU2VncygpO1xuXHR9LFxuXG5cblx0LyogTm93IEluZGljYXRvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Z2V0Tm93SW5kaWNhdG9yVW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICdtaW51dGUnOyAvLyB3aWxsIHJlZnJlc2ggb24gdGhlIG1pbnV0ZVxuXHR9LFxuXG5cblx0cmVuZGVyTm93SW5kaWNhdG9yOiBmdW5jdGlvbihkYXRlKSB7XG5cdFx0Ly8gc2VnIHN5c3RlbSBtaWdodCBiZSBvdmVya2lsbCwgYnV0IGl0IGhhbmRsZXMgc2NlbmFyaW8gd2hlcmUgbGluZSBuZWVkcyB0byBiZSByZW5kZXJlZFxuXHRcdC8vICBtb3JlIHRoYW4gb25jZSBiZWNhdXNlIG9mIGNvbHVtbnMgd2l0aCB0aGUgc2FtZSBkYXRlIChyZXNvdXJjZXMgY29sdW1ucyBmb3IgZXhhbXBsZSlcblx0XHR2YXIgc2VncyA9IHRoaXMuc3BhblRvU2Vncyh7IHN0YXJ0OiBkYXRlLCBlbmQ6IGRhdGUgfSk7XG5cdFx0dmFyIHRvcCA9IHRoaXMuY29tcHV0ZURhdGVUb3AoZGF0ZSwgZGF0ZSk7XG5cdFx0dmFyIG5vZGVzID0gW107XG5cdFx0dmFyIGk7XG5cblx0XHQvLyByZW5kZXIgbGluZXMgd2l0aGluIHRoZSBjb2x1bW5zXG5cdFx0Zm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdG5vZGVzLnB1c2goJCgnPGRpdiBjbGFzcz1cImZjLW5vdy1pbmRpY2F0b3IgZmMtbm93LWluZGljYXRvci1saW5lXCI+PC9kaXY+Jylcblx0XHRcdFx0LmNzcygndG9wJywgdG9wKVxuXHRcdFx0XHQuYXBwZW5kVG8odGhpcy5jb2xDb250YWluZXJFbHMuZXEoc2Vnc1tpXS5jb2wpKVswXSk7XG5cdFx0fVxuXG5cdFx0Ly8gcmVuZGVyIGFuIGFycm93IG92ZXIgdGhlIGF4aXNcblx0XHRpZiAoc2Vncy5sZW5ndGggPiAwKSB7IC8vIGlzIHRoZSBjdXJyZW50IHRpbWUgaW4gdmlldz9cblx0XHRcdG5vZGVzLnB1c2goJCgnPGRpdiBjbGFzcz1cImZjLW5vdy1pbmRpY2F0b3IgZmMtbm93LWluZGljYXRvci1hcnJvd1wiPjwvZGl2PicpXG5cdFx0XHRcdC5jc3MoJ3RvcCcsIHRvcClcblx0XHRcdFx0LmFwcGVuZFRvKHRoaXMuZWwuZmluZCgnLmZjLWNvbnRlbnQtc2tlbGV0b24nKSlbMF0pO1xuXHRcdH1cblxuXHRcdHRoaXMubm93SW5kaWNhdG9yRWxzID0gJChub2Rlcyk7XG5cdH0sXG5cblxuXHR1bnJlbmRlck5vd0luZGljYXRvcjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMubm93SW5kaWNhdG9yRWxzKSB7XG5cdFx0XHR0aGlzLm5vd0luZGljYXRvckVscy5yZW1vdmUoKTtcblx0XHRcdHRoaXMubm93SW5kaWNhdG9yRWxzID0gbnVsbDtcblx0XHR9XG5cdH0sXG5cblxuXHQvKiBTZWxlY3Rpb25cblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIFJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhIHNlbGVjdGlvbi4gT3ZlcnJpZGVzIHRoZSBkZWZhdWx0LCB3aGljaCB3YXMgdG8gc2ltcGx5IHJlbmRlciBhIGhpZ2hsaWdodC5cblx0cmVuZGVyU2VsZWN0aW9uOiBmdW5jdGlvbihzcGFuKSB7XG5cdFx0aWYgKHRoaXMudmlldy5vcHQoJ3NlbGVjdEhlbHBlcicpKSB7IC8vIHRoaXMgc2V0dGluZyBzaWduYWxzIHRoYXQgYSBtb2NrIGhlbHBlciBldmVudCBzaG91bGQgYmUgcmVuZGVyZWRcblxuXHRcdFx0Ly8gbm9ybWFsbHkgYWNjZXBzIGFuIGV2ZW50TG9jYXRpb24sIHNwYW4gaGFzIGEgc3RhcnQvZW5kLCB3aGljaCBpcyBnb29kIGVub3VnaFxuXHRcdFx0dGhpcy5yZW5kZXJFdmVudExvY2F0aW9uSGVscGVyKHNwYW4pO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHRoaXMucmVuZGVySGlnaGxpZ2h0KHNwYW4pO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyBhbnkgdmlzdWFsIGluZGljYXRpb24gb2YgYSBzZWxlY3Rpb25cblx0dW5yZW5kZXJTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudW5yZW5kZXJIZWxwZXIoKTtcblx0XHR0aGlzLnVucmVuZGVySGlnaGxpZ2h0KCk7XG5cdH0sXG5cblxuXHQvKiBIaWdobGlnaHRcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdHJlbmRlckhpZ2hsaWdodDogZnVuY3Rpb24oc3Bhbikge1xuXHRcdHRoaXMucmVuZGVySGlnaGxpZ2h0U2Vncyh0aGlzLnNwYW5Ub1NlZ3Moc3BhbikpO1xuXHR9LFxuXG5cblx0dW5yZW5kZXJIaWdobGlnaHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudW5yZW5kZXJIaWdobGlnaHRTZWdzKCk7XG5cdH1cblxufSk7XG5cbjs7XG5cbi8qIE1ldGhvZHMgZm9yIHJlbmRlcmluZyBTRUdNRU5UUywgcGllY2VzIG9mIGNvbnRlbnQgdGhhdCBsaXZlIG9uIHRoZSB2aWV3XG4gKCB0aGlzIGZpbGUgaXMgbm8gbG9uZ2VyIGp1c3QgZm9yIGV2ZW50cyApXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuVGltZUdyaWQubWl4aW4oe1xuXG5cdGNvbENvbnRhaW5lckVsczogbnVsbCwgLy8gY29udGFpbmVycyBmb3IgZWFjaCBjb2x1bW5cblxuXHQvLyBpbm5lci1jb250YWluZXJzIGZvciBlYWNoIGNvbHVtbiB3aGVyZSBkaWZmZXJlbnQgdHlwZXMgb2Ygc2VncyBsaXZlXG5cdGZnQ29udGFpbmVyRWxzOiBudWxsLFxuXHRiZ0NvbnRhaW5lckVsczogbnVsbCxcblx0aGVscGVyQ29udGFpbmVyRWxzOiBudWxsLFxuXHRoaWdobGlnaHRDb250YWluZXJFbHM6IG51bGwsXG5cdGJ1c2luZXNzQ29udGFpbmVyRWxzOiBudWxsLFxuXG5cdC8vIGFycmF5cyBvZiBkaWZmZXJlbnQgdHlwZXMgb2YgZGlzcGxheWVkIHNlZ21lbnRzXG5cdGZnU2VnczogbnVsbCxcblx0YmdTZWdzOiBudWxsLFxuXHRoZWxwZXJTZWdzOiBudWxsLFxuXHRoaWdobGlnaHRTZWdzOiBudWxsLFxuXHRidXNpbmVzc1NlZ3M6IG51bGwsXG5cblxuXHQvLyBSZW5kZXJzIHRoZSBET00gdGhhdCB0aGUgdmlldydzIGNvbnRlbnQgd2lsbCBsaXZlIGluXG5cdHJlbmRlckNvbnRlbnRTa2VsZXRvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNlbGxIdG1sID0gJyc7XG5cdFx0dmFyIGk7XG5cdFx0dmFyIHNrZWxldG9uRWw7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5jb2xDbnQ7IGkrKykge1xuXHRcdFx0Y2VsbEh0bWwgKz1cblx0XHRcdFx0Jzx0ZD4nICtcblx0XHRcdFx0XHQnPGRpdiBjbGFzcz1cImZjLWNvbnRlbnQtY29sXCI+JyArXG5cdFx0XHRcdFx0XHQnPGRpdiBjbGFzcz1cImZjLWV2ZW50LWNvbnRhaW5lciBmYy1oZWxwZXItY29udGFpbmVyXCI+PC9kaXY+JyArXG5cdFx0XHRcdFx0XHQnPGRpdiBjbGFzcz1cImZjLWV2ZW50LWNvbnRhaW5lclwiPjwvZGl2PicgK1xuXHRcdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCJmYy1oaWdobGlnaHQtY29udGFpbmVyXCI+PC9kaXY+JyArXG5cdFx0XHRcdFx0XHQnPGRpdiBjbGFzcz1cImZjLWJnZXZlbnQtY29udGFpbmVyXCI+PC9kaXY+JyArXG5cdFx0XHRcdFx0XHQnPGRpdiBjbGFzcz1cImZjLWJ1c2luZXNzLWNvbnRhaW5lclwiPjwvZGl2PicgK1xuXHRcdFx0XHRcdCc8L2Rpdj4nICtcblx0XHRcdFx0JzwvdGQ+Jztcblx0XHR9XG5cblx0XHRza2VsZXRvbkVsID0gJChcblx0XHRcdCc8ZGl2IGNsYXNzPVwiZmMtY29udGVudC1za2VsZXRvblwiPicgK1xuXHRcdFx0XHQnPHRhYmxlPicgK1xuXHRcdFx0XHRcdCc8dHI+JyArIGNlbGxIdG1sICsgJzwvdHI+JyArXG5cdFx0XHRcdCc8L3RhYmxlPicgK1xuXHRcdFx0JzwvZGl2Pidcblx0XHQpO1xuXG5cdFx0dGhpcy5jb2xDb250YWluZXJFbHMgPSBza2VsZXRvbkVsLmZpbmQoJy5mYy1jb250ZW50LWNvbCcpO1xuXHRcdHRoaXMuaGVscGVyQ29udGFpbmVyRWxzID0gc2tlbGV0b25FbC5maW5kKCcuZmMtaGVscGVyLWNvbnRhaW5lcicpO1xuXHRcdHRoaXMuZmdDb250YWluZXJFbHMgPSBza2VsZXRvbkVsLmZpbmQoJy5mYy1ldmVudC1jb250YWluZXI6bm90KC5mYy1oZWxwZXItY29udGFpbmVyKScpO1xuXHRcdHRoaXMuYmdDb250YWluZXJFbHMgPSBza2VsZXRvbkVsLmZpbmQoJy5mYy1iZ2V2ZW50LWNvbnRhaW5lcicpO1xuXHRcdHRoaXMuaGlnaGxpZ2h0Q29udGFpbmVyRWxzID0gc2tlbGV0b25FbC5maW5kKCcuZmMtaGlnaGxpZ2h0LWNvbnRhaW5lcicpO1xuXHRcdHRoaXMuYnVzaW5lc3NDb250YWluZXJFbHMgPSBza2VsZXRvbkVsLmZpbmQoJy5mYy1idXNpbmVzcy1jb250YWluZXInKTtcblxuXHRcdHRoaXMuYm9va2VuZENlbGxzKHNrZWxldG9uRWwuZmluZCgndHInKSk7IC8vIFRPRE86IGRvIHRoaXMgb24gc3RyaW5nIGxldmVsXG5cdFx0dGhpcy5lbC5hcHBlbmQoc2tlbGV0b25FbCk7XG5cdH0sXG5cblxuXHQvKiBGb3JlZ3JvdW5kIEV2ZW50c1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0cmVuZGVyRmdTZWdzOiBmdW5jdGlvbihzZWdzKSB7XG5cdFx0c2VncyA9IHRoaXMucmVuZGVyRmdTZWdzSW50b0NvbnRhaW5lcnMoc2VncywgdGhpcy5mZ0NvbnRhaW5lckVscyk7XG5cdFx0dGhpcy5mZ1NlZ3MgPSBzZWdzO1xuXHRcdHJldHVybiBzZWdzOyAvLyBuZWVkZWQgZm9yIEdyaWQ6OnJlbmRlckV2ZW50c1xuXHR9LFxuXG5cblx0dW5yZW5kZXJGZ1NlZ3M6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudW5yZW5kZXJOYW1lZFNlZ3MoJ2ZnU2VncycpO1xuXHR9LFxuXG5cblx0LyogRm9yZWdyb3VuZCBIZWxwZXIgRXZlbnRzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHRyZW5kZXJIZWxwZXJTZWdzOiBmdW5jdGlvbihzZWdzLCBzb3VyY2VTZWcpIHtcblx0XHR2YXIgaGVscGVyRWxzID0gW107XG5cdFx0dmFyIGksIHNlZztcblx0XHR2YXIgc291cmNlRWw7XG5cblx0XHRzZWdzID0gdGhpcy5yZW5kZXJGZ1NlZ3NJbnRvQ29udGFpbmVycyhzZWdzLCB0aGlzLmhlbHBlckNvbnRhaW5lckVscyk7XG5cblx0XHQvLyBUcnkgdG8gbWFrZSB0aGUgc2VnbWVudCB0aGF0IGlzIGluIHRoZSBzYW1lIHJvdyBhcyBzb3VyY2VTZWcgbG9vayB0aGUgc2FtZVxuXHRcdGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRzZWcgPSBzZWdzW2ldO1xuXHRcdFx0aWYgKHNvdXJjZVNlZyAmJiBzb3VyY2VTZWcuY29sID09PSBzZWcuY29sKSB7XG5cdFx0XHRcdHNvdXJjZUVsID0gc291cmNlU2VnLmVsO1xuXHRcdFx0XHRzZWcuZWwuY3NzKHtcblx0XHRcdFx0XHRsZWZ0OiBzb3VyY2VFbC5jc3MoJ2xlZnQnKSxcblx0XHRcdFx0XHRyaWdodDogc291cmNlRWwuY3NzKCdyaWdodCcpLFxuXHRcdFx0XHRcdCdtYXJnaW4tbGVmdCc6IHNvdXJjZUVsLmNzcygnbWFyZ2luLWxlZnQnKSxcblx0XHRcdFx0XHQnbWFyZ2luLXJpZ2h0Jzogc291cmNlRWwuY3NzKCdtYXJnaW4tcmlnaHQnKVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdGhlbHBlckVscy5wdXNoKHNlZy5lbFswXSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5oZWxwZXJTZWdzID0gc2VncztcblxuXHRcdHJldHVybiAkKGhlbHBlckVscyk7IC8vIG11c3QgcmV0dXJuIHJlbmRlcmVkIGhlbHBlcnNcblx0fSxcblxuXG5cdHVucmVuZGVySGVscGVyU2VnczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51bnJlbmRlck5hbWVkU2VncygnaGVscGVyU2VncycpO1xuXHR9LFxuXG5cblx0LyogQmFja2dyb3VuZCBFdmVudHNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdHJlbmRlckJnU2VnczogZnVuY3Rpb24oc2Vncykge1xuXHRcdHNlZ3MgPSB0aGlzLnJlbmRlckZpbGxTZWdFbHMoJ2JnRXZlbnQnLCBzZWdzKTsgLy8gVE9ETzogb2xkIGZpbGwgc3lzdGVtXG5cdFx0dGhpcy51cGRhdGVTZWdWZXJ0aWNhbHMoc2Vncyk7XG5cdFx0dGhpcy5hdHRhY2hTZWdzQnlDb2wodGhpcy5ncm91cFNlZ3NCeUNvbChzZWdzKSwgdGhpcy5iZ0NvbnRhaW5lckVscyk7XG5cdFx0dGhpcy5iZ1NlZ3MgPSBzZWdzO1xuXHRcdHJldHVybiBzZWdzOyAvLyBuZWVkZWQgZm9yIEdyaWQ6OnJlbmRlckV2ZW50c1xuXHR9LFxuXG5cblx0dW5yZW5kZXJCZ1NlZ3M6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudW5yZW5kZXJOYW1lZFNlZ3MoJ2JnU2VncycpO1xuXHR9LFxuXG5cblx0LyogSGlnaGxpZ2h0XG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHRyZW5kZXJIaWdobGlnaHRTZWdzOiBmdW5jdGlvbihzZWdzKSB7XG5cdFx0c2VncyA9IHRoaXMucmVuZGVyRmlsbFNlZ0VscygnaGlnaGxpZ2h0Jywgc2Vncyk7IC8vIFRPRE86IG9sZCBmaWxsIHN5c3RlbVxuXHRcdHRoaXMudXBkYXRlU2VnVmVydGljYWxzKHNlZ3MpO1xuXHRcdHRoaXMuYXR0YWNoU2Vnc0J5Q29sKHRoaXMuZ3JvdXBTZWdzQnlDb2woc2VncyksIHRoaXMuaGlnaGxpZ2h0Q29udGFpbmVyRWxzKTtcblx0XHR0aGlzLmhpZ2hsaWdodFNlZ3MgPSBzZWdzO1xuXHR9LFxuXG5cblx0dW5yZW5kZXJIaWdobGlnaHRTZWdzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnVucmVuZGVyTmFtZWRTZWdzKCdoaWdobGlnaHRTZWdzJyk7XG5cdH0sXG5cblxuXHQvKiBCdXNpbmVzcyBIb3Vyc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0cmVuZGVyQnVzaW5lc3NTZWdzOiBmdW5jdGlvbihzZWdzKSB7XG5cdFx0c2VncyA9IHRoaXMucmVuZGVyRmlsbFNlZ0VscygnYnVzaW5lc3NIb3VycycsIHNlZ3MpOyAvLyBUT0RPOiBvbGQgZmlsbCBzeXN0ZW1cblx0XHR0aGlzLnVwZGF0ZVNlZ1ZlcnRpY2FscyhzZWdzKTtcblx0XHR0aGlzLmF0dGFjaFNlZ3NCeUNvbCh0aGlzLmdyb3VwU2Vnc0J5Q29sKHNlZ3MpLCB0aGlzLmJ1c2luZXNzQ29udGFpbmVyRWxzKTtcblx0XHR0aGlzLmJ1c2luZXNzU2VncyA9IHNlZ3M7XG5cdH0sXG5cblxuXHR1bnJlbmRlckJ1c2luZXNzU2VnczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51bnJlbmRlck5hbWVkU2VncygnYnVzaW5lc3NTZWdzJyk7XG5cdH0sXG5cblxuXHQvKiBTZWcgUmVuZGVyaW5nIFV0aWxzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBHaXZlbiBhIGZsYXQgYXJyYXkgb2Ygc2VnbWVudHMsIHJldHVybiBhbiBhcnJheSBvZiBzdWItYXJyYXlzLCBncm91cGVkIGJ5IGVhY2ggc2VnbWVudCdzIGNvbFxuXHRncm91cFNlZ3NCeUNvbDogZnVuY3Rpb24oc2Vncykge1xuXHRcdHZhciBzZWdzQnlDb2wgPSBbXTtcblx0XHR2YXIgaTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCB0aGlzLmNvbENudDsgaSsrKSB7XG5cdFx0XHRzZWdzQnlDb2wucHVzaChbXSk7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdHNlZ3NCeUNvbFtzZWdzW2ldLmNvbF0ucHVzaChzZWdzW2ldKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc2Vnc0J5Q29sO1xuXHR9LFxuXG5cblx0Ly8gR2l2ZW4gc2VnbWVudHMgZ3JvdXBlZCBieSBjb2x1bW4sIGluc2VydCB0aGUgc2VnbWVudHMnIGVsZW1lbnRzIGludG8gYSBwYXJhbGxlbCBhcnJheSBvZiBjb250YWluZXJcblx0Ly8gZWxlbWVudHMsIGVhY2ggbGl2aW5nIHdpdGhpbiBhIGNvbHVtbi5cblx0YXR0YWNoU2Vnc0J5Q29sOiBmdW5jdGlvbihzZWdzQnlDb2wsIGNvbnRhaW5lckVscykge1xuXHRcdHZhciBjb2w7XG5cdFx0dmFyIHNlZ3M7XG5cdFx0dmFyIGk7XG5cblx0XHRmb3IgKGNvbCA9IDA7IGNvbCA8IHRoaXMuY29sQ250OyBjb2wrKykgeyAvLyBpdGVyYXRlIGVhY2ggY29sdW1uIGdyb3VwaW5nXG5cdFx0XHRzZWdzID0gc2Vnc0J5Q29sW2NvbF07XG5cblx0XHRcdGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNvbnRhaW5lckVscy5lcShjb2wpLmFwcGVuZChzZWdzW2ldLmVsKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblxuXHQvLyBHaXZlbiB0aGUgbmFtZSBvZiBhIHByb3BlcnR5IG9mIGB0aGlzYCBvYmplY3QsIGFzc3VtZWQgdG8gYmUgYW4gYXJyYXkgb2Ygc2VnbWVudHMsXG5cdC8vIGxvb3BzIHRocm91Z2ggZWFjaCBzZWdtZW50IGFuZCByZW1vdmVzIGZyb20gRE9NLiBXaWxsIG51bGwtb3V0IHRoZSBwcm9wZXJ0eSBhZnRlcndhcmRzLlxuXHR1bnJlbmRlck5hbWVkU2VnczogZnVuY3Rpb24ocHJvcE5hbWUpIHtcblx0XHR2YXIgc2VncyA9IHRoaXNbcHJvcE5hbWVdO1xuXHRcdHZhciBpO1xuXG5cdFx0aWYgKHNlZ3MpIHtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHNlZ3NbaV0uZWwucmVtb3ZlKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzW3Byb3BOYW1lXSA9IG51bGw7XG5cdFx0fVxuXHR9LFxuXG5cblxuXHQvKiBGb3JlZ3JvdW5kIEV2ZW50IFJlbmRlcmluZyBVdGlsc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gR2l2ZW4gYW4gYXJyYXkgb2YgZm9yZWdyb3VuZCBzZWdtZW50cywgcmVuZGVyIGEgRE9NIGVsZW1lbnQgZm9yIGVhY2gsIGNvbXB1dGVzIHBvc2l0aW9uLFxuXHQvLyBhbmQgYXR0YWNoZXMgdG8gdGhlIGNvbHVtbiBpbm5lci1jb250YWluZXIgZWxlbWVudHMuXG5cdHJlbmRlckZnU2Vnc0ludG9Db250YWluZXJzOiBmdW5jdGlvbihzZWdzLCBjb250YWluZXJFbHMpIHtcblx0XHR2YXIgc2Vnc0J5Q29sO1xuXHRcdHZhciBjb2w7XG5cblx0XHRzZWdzID0gdGhpcy5yZW5kZXJGZ1NlZ0VscyhzZWdzKTsgLy8gd2lsbCBjYWxsIGZnU2VnSHRtbFxuXHRcdHNlZ3NCeUNvbCA9IHRoaXMuZ3JvdXBTZWdzQnlDb2woc2Vncyk7XG5cblx0XHRmb3IgKGNvbCA9IDA7IGNvbCA8IHRoaXMuY29sQ250OyBjb2wrKykge1xuXHRcdFx0dGhpcy51cGRhdGVGZ1NlZ0Nvb3JkcyhzZWdzQnlDb2xbY29sXSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5hdHRhY2hTZWdzQnlDb2woc2Vnc0J5Q29sLCBjb250YWluZXJFbHMpO1xuXG5cdFx0cmV0dXJuIHNlZ3M7XG5cdH0sXG5cblxuXHQvLyBSZW5kZXJzIHRoZSBIVE1MIGZvciBhIHNpbmdsZSBldmVudCBzZWdtZW50J3MgZGVmYXVsdCByZW5kZXJpbmdcblx0ZmdTZWdIdG1sOiBmdW5jdGlvbihzZWcsIGRpc2FibGVSZXNpemluZykge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXHRcdHZhciBldmVudCA9IHNlZy5ldmVudDtcblx0XHR2YXIgaXNEcmFnZ2FibGUgPSB2aWV3LmlzRXZlbnREcmFnZ2FibGUoZXZlbnQpO1xuXHRcdHZhciBpc1Jlc2l6YWJsZUZyb21TdGFydCA9ICFkaXNhYmxlUmVzaXppbmcgJiYgc2VnLmlzU3RhcnQgJiYgdmlldy5pc0V2ZW50UmVzaXphYmxlRnJvbVN0YXJ0KGV2ZW50KTtcblx0XHR2YXIgaXNSZXNpemFibGVGcm9tRW5kID0gIWRpc2FibGVSZXNpemluZyAmJiBzZWcuaXNFbmQgJiYgdmlldy5pc0V2ZW50UmVzaXphYmxlRnJvbUVuZChldmVudCk7XG5cdFx0dmFyIGNsYXNzZXMgPSB0aGlzLmdldFNlZ0NsYXNzZXMoc2VnLCBpc0RyYWdnYWJsZSwgaXNSZXNpemFibGVGcm9tU3RhcnQgfHwgaXNSZXNpemFibGVGcm9tRW5kKTtcblx0XHR2YXIgc2tpbkNzcyA9IGNzc1RvU3RyKHRoaXMuZ2V0U2VnU2tpbkNzcyhzZWcpKTtcblx0XHR2YXIgdGltZVRleHQ7XG5cdFx0dmFyIGZ1bGxUaW1lVGV4dDsgLy8gbW9yZSB2ZXJib3NlIHRpbWUgdGV4dC4gZm9yIHRoZSBwcmludCBzdHlsZXNoZWV0XG5cdFx0dmFyIHN0YXJ0VGltZVRleHQ7IC8vIGp1c3QgdGhlIHN0YXJ0IHRpbWUgdGV4dFxuXG5cdFx0Y2xhc3Nlcy51bnNoaWZ0KCdmYy10aW1lLWdyaWQtZXZlbnQnLCAnZmMtdi1ldmVudCcpO1xuXG5cdFx0aWYgKHZpZXcuaXNNdWx0aURheUV2ZW50KGV2ZW50KSkgeyAvLyBpZiB0aGUgZXZlbnQgYXBwZWFycyB0byBzcGFuIG1vcmUgdGhhbiBvbmUgZGF5Li4uXG5cdFx0XHQvLyBEb24ndCBkaXNwbGF5IHRpbWUgdGV4dCBvbiBzZWdtZW50cyB0aGF0IHJ1biBlbnRpcmVseSB0aHJvdWdoIGEgZGF5LlxuXHRcdFx0Ly8gVGhhdCB3b3VsZCBhcHBlYXIgYXMgbWlkbmlnaHQtbWlkbmlnaHQgYW5kIHdvdWxkIGxvb2sgZHVtYi5cblx0XHRcdC8vIE90aGVyd2lzZSwgZGlzcGxheSB0aGUgdGltZSB0ZXh0IGZvciB0aGUgKnNlZ21lbnQncyogdGltZXMgKGxpa2UgNnBtLW1pZG5pZ2h0IG9yIG1pZG5pZ2h0LTEwYW0pXG5cdFx0XHRpZiAoc2VnLmlzU3RhcnQgfHwgc2VnLmlzRW5kKSB7XG5cdFx0XHRcdHRpbWVUZXh0ID0gdGhpcy5nZXRFdmVudFRpbWVUZXh0KHNlZyk7XG5cdFx0XHRcdGZ1bGxUaW1lVGV4dCA9IHRoaXMuZ2V0RXZlbnRUaW1lVGV4dChzZWcsICdMVCcpO1xuXHRcdFx0XHRzdGFydFRpbWVUZXh0ID0gdGhpcy5nZXRFdmVudFRpbWVUZXh0KHNlZywgbnVsbCwgZmFsc2UpOyAvLyBkaXNwbGF5RW5kPWZhbHNlXG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIERpc3BsYXkgdGhlIG5vcm1hbCB0aW1lIHRleHQgZm9yIHRoZSAqZXZlbnQncyogdGltZXNcblx0XHRcdHRpbWVUZXh0ID0gdGhpcy5nZXRFdmVudFRpbWVUZXh0KGV2ZW50KTtcblx0XHRcdGZ1bGxUaW1lVGV4dCA9IHRoaXMuZ2V0RXZlbnRUaW1lVGV4dChldmVudCwgJ0xUJyk7XG5cdFx0XHRzdGFydFRpbWVUZXh0ID0gdGhpcy5nZXRFdmVudFRpbWVUZXh0KGV2ZW50LCBudWxsLCBmYWxzZSk7IC8vIGRpc3BsYXlFbmQ9ZmFsc2Vcblx0XHR9XG5cblx0XHRyZXR1cm4gJzxhIGNsYXNzPVwiJyArIGNsYXNzZXMuam9pbignICcpICsgJ1wiJyArXG5cdFx0XHQoZXZlbnQudXJsID9cblx0XHRcdFx0JyBocmVmPVwiJyArIGh0bWxFc2NhcGUoZXZlbnQudXJsKSArICdcIicgOlxuXHRcdFx0XHQnJ1xuXHRcdFx0XHQpICtcblx0XHRcdChza2luQ3NzID9cblx0XHRcdFx0JyBzdHlsZT1cIicgKyBza2luQ3NzICsgJ1wiJyA6XG5cdFx0XHRcdCcnXG5cdFx0XHRcdCkgK1xuXHRcdFx0Jz4nICtcblx0XHRcdFx0JzxkaXYgY2xhc3M9XCJmYy1jb250ZW50XCI+JyArXG5cdFx0XHRcdFx0KHRpbWVUZXh0ID9cblx0XHRcdFx0XHRcdCc8ZGl2IGNsYXNzPVwiZmMtdGltZVwiJyArXG5cdFx0XHRcdFx0XHQnIGRhdGEtc3RhcnQ9XCInICsgaHRtbEVzY2FwZShzdGFydFRpbWVUZXh0KSArICdcIicgK1xuXHRcdFx0XHRcdFx0JyBkYXRhLWZ1bGw9XCInICsgaHRtbEVzY2FwZShmdWxsVGltZVRleHQpICsgJ1wiJyArXG5cdFx0XHRcdFx0XHQnPicgK1xuXHRcdFx0XHRcdFx0XHQnPHNwYW4+JyArIGh0bWxFc2NhcGUodGltZVRleHQpICsgJzwvc3Bhbj4nICtcblx0XHRcdFx0XHRcdCc8L2Rpdj4nIDpcblx0XHRcdFx0XHRcdCcnXG5cdFx0XHRcdFx0XHQpICtcblx0XHRcdFx0XHQoZXZlbnQudGl0bGUgP1xuXHRcdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCJmYy10aXRsZVwiPicgK1xuXHRcdFx0XHRcdFx0XHRodG1sRXNjYXBlKGV2ZW50LnRpdGxlKSArXG5cdFx0XHRcdFx0XHQnPC9kaXY+JyA6XG5cdFx0XHRcdFx0XHQnJ1xuXHRcdFx0XHRcdFx0KSArXG5cdFx0XHRcdCc8L2Rpdj4nICtcblx0XHRcdFx0JzxkaXYgY2xhc3M9XCJmYy1iZ1wiLz4nICtcblx0XHRcdFx0LyogVE9ETzogd3JpdGUgQ1NTIGZvciB0aGlzXG5cdFx0XHRcdChpc1Jlc2l6YWJsZUZyb21TdGFydCA/XG5cdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCJmYy1yZXNpemVyIGZjLXN0YXJ0LXJlc2l6ZXJcIiAvPicgOlxuXHRcdFx0XHRcdCcnXG5cdFx0XHRcdFx0KSArXG5cdFx0XHRcdCovXG5cdFx0XHRcdChpc1Jlc2l6YWJsZUZyb21FbmQgP1xuXHRcdFx0XHRcdCc8ZGl2IGNsYXNzPVwiZmMtcmVzaXplciBmYy1lbmQtcmVzaXplclwiIC8+JyA6XG5cdFx0XHRcdFx0Jydcblx0XHRcdFx0XHQpICtcblx0XHRcdCc8L2E+Jztcblx0fSxcblxuXG5cdC8qIFNlZyBQb3NpdGlvbiBVdGlsc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gUmVmcmVzaGVzIHRoZSBDU1MgdG9wL2JvdHRvbSBjb29yZGluYXRlcyBmb3IgZWFjaCBzZWdtZW50IGVsZW1lbnQuXG5cdC8vIFdvcmtzIHdoZW4gY2FsbGVkIGFmdGVyIGluaXRpYWwgcmVuZGVyLCBhZnRlciBhIHdpbmRvdyByZXNpemUvem9vbSBmb3IgZXhhbXBsZS5cblx0dXBkYXRlU2VnVmVydGljYWxzOiBmdW5jdGlvbihzZWdzKSB7XG5cdFx0dGhpcy5jb21wdXRlU2VnVmVydGljYWxzKHNlZ3MpO1xuXHRcdHRoaXMuYXNzaWduU2VnVmVydGljYWxzKHNlZ3MpO1xuXHR9LFxuXG5cblx0Ly8gRm9yIGVhY2ggc2VnbWVudCBpbiBhbiBhcnJheSwgY29tcHV0ZXMgYW5kIGFzc2lnbnMgaXRzIHRvcCBhbmQgYm90dG9tIHByb3BlcnRpZXNcblx0Y29tcHV0ZVNlZ1ZlcnRpY2FsczogZnVuY3Rpb24oc2Vncykge1xuXHRcdHZhciBpLCBzZWc7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0c2VnID0gc2Vnc1tpXTtcblx0XHRcdHNlZy50b3AgPSB0aGlzLmNvbXB1dGVEYXRlVG9wKHNlZy5zdGFydCwgc2VnLnN0YXJ0KTtcblx0XHRcdHNlZy5ib3R0b20gPSB0aGlzLmNvbXB1dGVEYXRlVG9wKHNlZy5lbmQsIHNlZy5zdGFydCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gR2l2ZW4gc2VnbWVudHMgdGhhdCBhbHJlYWR5IGhhdmUgdGhlaXIgdG9wL2JvdHRvbSBwcm9wZXJ0aWVzIGNvbXB1dGVkLCBhcHBsaWVzIHRob3NlIHZhbHVlcyB0b1xuXHQvLyB0aGUgc2VnbWVudHMnIGVsZW1lbnRzLlxuXHRhc3NpZ25TZWdWZXJ0aWNhbHM6IGZ1bmN0aW9uKHNlZ3MpIHtcblx0XHR2YXIgaSwgc2VnO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdHNlZyA9IHNlZ3NbaV07XG5cdFx0XHRzZWcuZWwuY3NzKHRoaXMuZ2VuZXJhdGVTZWdWZXJ0aWNhbENzcyhzZWcpKTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBHZW5lcmF0ZXMgYW4gb2JqZWN0IHdpdGggQ1NTIHByb3BlcnRpZXMgZm9yIHRoZSB0b3AvYm90dG9tIGNvb3JkaW5hdGVzIG9mIGEgc2VnbWVudCBlbGVtZW50XG5cdGdlbmVyYXRlU2VnVmVydGljYWxDc3M6IGZ1bmN0aW9uKHNlZykge1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IHNlZy50b3AsXG5cdFx0XHRib3R0b206IC1zZWcuYm90dG9tIC8vIGZsaXBwZWQgYmVjYXVzZSBuZWVkcyB0byBiZSBzcGFjZSBiZXlvbmQgYm90dG9tIGVkZ2Ugb2YgZXZlbnQgY29udGFpbmVyXG5cdFx0fTtcblx0fSxcblxuXG5cdC8qIEZvcmVncm91bmQgRXZlbnQgUG9zaXRpb25pbmcgVXRpbHNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIEdpdmVuIHNlZ21lbnRzIHRoYXQgYXJlIGFzc3VtZWQgdG8gYWxsIGxpdmUgaW4gdGhlICpzYW1lIGNvbHVtbiosXG5cdC8vIGNvbXB1dGUgdGhlaXIgdmVyaWNhbC9ob3Jpem9udGFsIGNvb3JkaW5hdGVzIGFuZCBhc3NpZ24gdG8gdGhlaXIgZWxlbWVudHMuXG5cdHVwZGF0ZUZnU2VnQ29vcmRzOiBmdW5jdGlvbihzZWdzKSB7XG5cdFx0dGhpcy5jb21wdXRlU2VnVmVydGljYWxzKHNlZ3MpOyAvLyBob3Jpem9udGFscyByZWxpZXMgb24gdGhpc1xuXHRcdHRoaXMuY29tcHV0ZUZnU2VnSG9yaXpvbnRhbHMoc2Vncyk7IC8vIGNvbXB1dGUgaG9yaXpvbnRhbCBjb29yZGluYXRlcywgei1pbmRleCdzLCBhbmQgcmVvcmRlciB0aGUgYXJyYXlcblx0XHR0aGlzLmFzc2lnblNlZ1ZlcnRpY2FscyhzZWdzKTtcblx0XHR0aGlzLmFzc2lnbkZnU2VnSG9yaXpvbnRhbHMoc2Vncyk7XG5cdH0sXG5cblxuXHQvLyBHaXZlbiBhbiBhcnJheSBvZiBzZWdtZW50cyB0aGF0IGFyZSBhbGwgaW4gdGhlIHNhbWUgY29sdW1uLCBzZXRzIHRoZSBiYWNrd2FyZENvb3JkIGFuZCBmb3J3YXJkQ29vcmQgb24gZWFjaC5cblx0Ly8gTk9URTogQWxzbyByZW9yZGVycyB0aGUgZ2l2ZW4gYXJyYXkgYnkgZGF0ZSFcblx0Y29tcHV0ZUZnU2VnSG9yaXpvbnRhbHM6IGZ1bmN0aW9uKHNlZ3MpIHtcblx0XHR2YXIgbGV2ZWxzO1xuXHRcdHZhciBsZXZlbDA7XG5cdFx0dmFyIGk7XG5cblx0XHR0aGlzLnNvcnRFdmVudFNlZ3Moc2Vncyk7IC8vIG9yZGVyIGJ5IGNlcnRhaW4gY3JpdGVyaWFcblx0XHRsZXZlbHMgPSBidWlsZFNsb3RTZWdMZXZlbHMoc2Vncyk7XG5cdFx0Y29tcHV0ZUZvcndhcmRTbG90U2VncyhsZXZlbHMpO1xuXG5cdFx0aWYgKChsZXZlbDAgPSBsZXZlbHNbMF0pKSB7XG5cblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZXZlbDAubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Y29tcHV0ZVNsb3RTZWdQcmVzc3VyZXMobGV2ZWwwW2ldKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxldmVsMC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR0aGlzLmNvbXB1dGVGZ1NlZ0ZvcndhcmRCYWNrKGxldmVsMFtpXSwgMCwgMCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gQ2FsY3VsYXRlIHNlZy5mb3J3YXJkQ29vcmQgYW5kIHNlZy5iYWNrd2FyZENvb3JkIGZvciB0aGUgc2VnbWVudCwgd2hlcmUgYm90aCB2YWx1ZXMgcmFuZ2Vcblx0Ly8gZnJvbSAwIHRvIDEuIElmIHRoZSBjYWxlbmRhciBpcyBsZWZ0LXRvLXJpZ2h0LCB0aGUgc2VnLmJhY2t3YXJkQ29vcmQgbWFwcyB0byBcImxlZnRcIiBhbmRcblx0Ly8gc2VnLmZvcndhcmRDb29yZCBtYXBzIHRvIFwicmlnaHRcIiAodmlhIHBlcmNlbnRhZ2UpLiBWaWNlLXZlcnNhIGlmIHRoZSBjYWxlbmRhciBpcyByaWdodC10by1sZWZ0LlxuXHQvL1xuXHQvLyBUaGUgc2VnbWVudCBtaWdodCBiZSBwYXJ0IG9mIGEgXCJzZXJpZXNcIiwgd2hpY2ggbWVhbnMgY29uc2VjdXRpdmUgc2VnbWVudHMgd2l0aCB0aGUgc2FtZSBwcmVzc3VyZVxuXHQvLyB3aG8ncyB3aWR0aCBpcyB1bmtub3duIHVudGlsIGFuIGVkZ2UgaGFzIGJlZW4gaGl0LiBgc2VyaWVzQmFja3dhcmRQcmVzc3VyZWAgaXMgdGhlIG51bWJlciBvZlxuXHQvLyBzZWdtZW50cyBiZWhpbmQgdGhpcyBvbmUgaW4gdGhlIGN1cnJlbnQgc2VyaWVzLCBhbmQgYHNlcmllc0JhY2t3YXJkQ29vcmRgIGlzIHRoZSBzdGFydGluZ1xuXHQvLyBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBzZWdtZW50IGluIHRoZSBzZXJpZXMuXG5cdGNvbXB1dGVGZ1NlZ0ZvcndhcmRCYWNrOiBmdW5jdGlvbihzZWcsIHNlcmllc0JhY2t3YXJkUHJlc3N1cmUsIHNlcmllc0JhY2t3YXJkQ29vcmQpIHtcblx0XHR2YXIgZm9yd2FyZFNlZ3MgPSBzZWcuZm9yd2FyZFNlZ3M7XG5cdFx0dmFyIGk7XG5cblx0XHRpZiAoc2VnLmZvcndhcmRDb29yZCA9PT0gdW5kZWZpbmVkKSB7IC8vIG5vdCBhbHJlYWR5IGNvbXB1dGVkXG5cblx0XHRcdGlmICghZm9yd2FyZFNlZ3MubGVuZ3RoKSB7XG5cblx0XHRcdFx0Ly8gaWYgdGhlcmUgYXJlIG5vIGZvcndhcmQgc2VnbWVudHMsIHRoaXMgc2VnbWVudCBzaG91bGQgYnV0dCB1cCBhZ2FpbnN0IHRoZSBlZGdlXG5cdFx0XHRcdHNlZy5mb3J3YXJkQ29vcmQgPSAxO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cblx0XHRcdFx0Ly8gc29ydCBoaWdoZXN0IHByZXNzdXJlIGZpcnN0XG5cdFx0XHRcdHRoaXMuc29ydEZvcndhcmRTZWdzKGZvcndhcmRTZWdzKTtcblxuXHRcdFx0XHQvLyB0aGlzIHNlZ21lbnQncyBmb3J3YXJkQ29vcmQgd2lsbCBiZSBjYWxjdWxhdGVkIGZyb20gdGhlIGJhY2t3YXJkQ29vcmQgb2YgdGhlXG5cdFx0XHRcdC8vIGhpZ2hlc3QtcHJlc3N1cmUgZm9yd2FyZCBzZWdtZW50LlxuXHRcdFx0XHR0aGlzLmNvbXB1dGVGZ1NlZ0ZvcndhcmRCYWNrKGZvcndhcmRTZWdzWzBdLCBzZXJpZXNCYWNrd2FyZFByZXNzdXJlICsgMSwgc2VyaWVzQmFja3dhcmRDb29yZCk7XG5cdFx0XHRcdHNlZy5mb3J3YXJkQ29vcmQgPSBmb3J3YXJkU2Vnc1swXS5iYWNrd2FyZENvb3JkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjYWxjdWxhdGUgdGhlIGJhY2t3YXJkQ29vcmQgZnJvbSB0aGUgZm9yd2FyZENvb3JkLiBjb25zaWRlciB0aGUgc2VyaWVzXG5cdFx0XHRzZWcuYmFja3dhcmRDb29yZCA9IHNlZy5mb3J3YXJkQ29vcmQgLVxuXHRcdFx0XHQoc2VnLmZvcndhcmRDb29yZCAtIHNlcmllc0JhY2t3YXJkQ29vcmQpIC8gLy8gYXZhaWxhYmxlIHdpZHRoIGZvciBzZXJpZXNcblx0XHRcdFx0KHNlcmllc0JhY2t3YXJkUHJlc3N1cmUgKyAxKTsgLy8gIyBvZiBzZWdtZW50cyBpbiB0aGUgc2VyaWVzXG5cblx0XHRcdC8vIHVzZSB0aGlzIHNlZ21lbnQncyBjb29yZGluYXRlcyB0byBjb21wdXRlZCB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIGxlc3MtcHJlc3N1cml6ZWRcblx0XHRcdC8vIGZvcndhcmQgc2VnbWVudHNcblx0XHRcdGZvciAoaT0wOyBpPGZvcndhcmRTZWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuY29tcHV0ZUZnU2VnRm9yd2FyZEJhY2soZm9yd2FyZFNlZ3NbaV0sIDAsIHNlZy5mb3J3YXJkQ29vcmQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXG5cdHNvcnRGb3J3YXJkU2VnczogZnVuY3Rpb24oZm9yd2FyZFNlZ3MpIHtcblx0XHRmb3J3YXJkU2Vncy5zb3J0KHByb3h5KHRoaXMsICdjb21wYXJlRm9yd2FyZFNlZ3MnKSk7XG5cdH0sXG5cblxuXHQvLyBBIGNtcCBmdW5jdGlvbiBmb3IgZGV0ZXJtaW5pbmcgd2hpY2ggZm9yd2FyZCBzZWdtZW50IHRvIHJlbHkgb24gbW9yZSB3aGVuIGNvbXB1dGluZyBjb29yZGluYXRlcy5cblx0Y29tcGFyZUZvcndhcmRTZWdzOiBmdW5jdGlvbihzZWcxLCBzZWcyKSB7XG5cdFx0Ly8gcHV0IGhpZ2hlci1wcmVzc3VyZSBmaXJzdFxuXHRcdHJldHVybiBzZWcyLmZvcndhcmRQcmVzc3VyZSAtIHNlZzEuZm9yd2FyZFByZXNzdXJlIHx8XG5cdFx0XHQvLyBwdXQgc2VnbWVudHMgdGhhdCBhcmUgY2xvc2VyIHRvIGluaXRpYWwgZWRnZSBmaXJzdCAoYW5kIGZhdm9yIG9uZXMgd2l0aCBubyBjb29yZHMgeWV0KVxuXHRcdFx0KHNlZzEuYmFja3dhcmRDb29yZCB8fCAwKSAtIChzZWcyLmJhY2t3YXJkQ29vcmQgfHwgMCkgfHxcblx0XHRcdC8vIGRvIG5vcm1hbCBzb3J0aW5nLi4uXG5cdFx0XHR0aGlzLmNvbXBhcmVFdmVudFNlZ3Moc2VnMSwgc2VnMik7XG5cdH0sXG5cblxuXHQvLyBHaXZlbiBmb3JlZ3JvdW5kIGV2ZW50IHNlZ21lbnRzIHRoYXQgaGF2ZSBhbHJlYWR5IGhhZCB0aGVpciBwb3NpdGlvbiBjb29yZGluYXRlcyBjb21wdXRlZCxcblx0Ly8gYXNzaWducyBwb3NpdGlvbi1yZWxhdGVkIENTUyB2YWx1ZXMgdG8gdGhlaXIgZWxlbWVudHMuXG5cdGFzc2lnbkZnU2VnSG9yaXpvbnRhbHM6IGZ1bmN0aW9uKHNlZ3MpIHtcblx0XHR2YXIgaSwgc2VnO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdHNlZyA9IHNlZ3NbaV07XG5cdFx0XHRzZWcuZWwuY3NzKHRoaXMuZ2VuZXJhdGVGZ1NlZ0hvcml6b250YWxDc3Moc2VnKSk7XG5cblx0XHRcdC8vIGlmIHRoZSBoZWlnaHQgaXMgc2hvcnQsIGFkZCBhIGNsYXNzTmFtZSBmb3IgYWx0ZXJuYXRlIHN0eWxpbmdcblx0XHRcdGlmIChzZWcuYm90dG9tIC0gc2VnLnRvcCA8IDMwKSB7XG5cdFx0XHRcdHNlZy5lbC5hZGRDbGFzcygnZmMtc2hvcnQnKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblxuXHQvLyBHZW5lcmF0ZXMgYW4gb2JqZWN0IHdpdGggQ1NTIHByb3BlcnRpZXMvdmFsdWVzIHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQgdG8gYW4gZXZlbnQgc2VnbWVudCBlbGVtZW50LlxuXHQvLyBDb250YWlucyBpbXBvcnRhbnQgcG9zaXRpb25pbmctcmVsYXRlZCBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQgdG8gYW55IGV2ZW50IGVsZW1lbnQsIGN1c3RvbWl6ZWQgb3Igbm90LlxuXHRnZW5lcmF0ZUZnU2VnSG9yaXpvbnRhbENzczogZnVuY3Rpb24oc2VnKSB7XG5cdFx0dmFyIHNob3VsZE92ZXJsYXAgPSB0aGlzLnZpZXcub3B0KCdzbG90RXZlbnRPdmVybGFwJyk7XG5cdFx0dmFyIGJhY2t3YXJkQ29vcmQgPSBzZWcuYmFja3dhcmRDb29yZDsgLy8gdGhlIGxlZnQgc2lkZSBpZiBMVFIuIHRoZSByaWdodCBzaWRlIGlmIFJUTC4gZmxvYXRpbmctcG9pbnRcblx0XHR2YXIgZm9yd2FyZENvb3JkID0gc2VnLmZvcndhcmRDb29yZDsgLy8gdGhlIHJpZ2h0IHNpZGUgaWYgTFRSLiB0aGUgbGVmdCBzaWRlIGlmIFJUTC4gZmxvYXRpbmctcG9pbnRcblx0XHR2YXIgcHJvcHMgPSB0aGlzLmdlbmVyYXRlU2VnVmVydGljYWxDc3Moc2VnKTsgLy8gZ2V0IHRvcC9ib3R0b20gZmlyc3Rcblx0XHR2YXIgbGVmdDsgLy8gYW1vdW50IG9mIHNwYWNlIGZyb20gbGVmdCBlZGdlLCBhIGZyYWN0aW9uIG9mIHRoZSB0b3RhbCB3aWR0aFxuXHRcdHZhciByaWdodDsgLy8gYW1vdW50IG9mIHNwYWNlIGZyb20gcmlnaHQgZWRnZSwgYSBmcmFjdGlvbiBvZiB0aGUgdG90YWwgd2lkdGhcblxuXHRcdGlmIChzaG91bGRPdmVybGFwKSB7XG5cdFx0XHQvLyBkb3VibGUgdGhlIHdpZHRoLCBidXQgZG9uJ3QgZ28gYmV5b25kIHRoZSBtYXhpbXVtIGZvcndhcmQgY29vcmRpbmF0ZSAoMS4wKVxuXHRcdFx0Zm9yd2FyZENvb3JkID0gTWF0aC5taW4oMSwgYmFja3dhcmRDb29yZCArIChmb3J3YXJkQ29vcmQgLSBiYWNrd2FyZENvb3JkKSAqIDIpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLmlzUlRMKSB7XG5cdFx0XHRsZWZ0ID0gMSAtIGZvcndhcmRDb29yZDtcblx0XHRcdHJpZ2h0ID0gYmFja3dhcmRDb29yZDtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRsZWZ0ID0gYmFja3dhcmRDb29yZDtcblx0XHRcdHJpZ2h0ID0gMSAtIGZvcndhcmRDb29yZDtcblx0XHR9XG5cblx0XHRwcm9wcy56SW5kZXggPSBzZWcubGV2ZWwgKyAxOyAvLyBjb252ZXJ0IGZyb20gMC1iYXNlIHRvIDEtYmFzZWRcblx0XHRwcm9wcy5sZWZ0ID0gbGVmdCAqIDEwMCArICclJztcblx0XHRwcm9wcy5yaWdodCA9IHJpZ2h0ICogMTAwICsgJyUnO1xuXG5cdFx0aWYgKHNob3VsZE92ZXJsYXAgJiYgc2VnLmZvcndhcmRQcmVzc3VyZSkge1xuXHRcdFx0Ly8gYWRkIHBhZGRpbmcgdG8gdGhlIGVkZ2Ugc28gdGhhdCBmb3J3YXJkIHN0YWNrZWQgZXZlbnRzIGRvbid0IGNvdmVyIHRoZSByZXNpemVyJ3MgaWNvblxuXHRcdFx0cHJvcHNbdGhpcy5pc1JUTCA/ICdtYXJnaW5MZWZ0JyA6ICdtYXJnaW5SaWdodCddID0gMTAgKiAyOyAvLyAxMCBpcyBhIGd1ZXNzdGltYXRlIG9mIHRoZSBpY29uJ3Mgd2lkdGhcblx0XHR9XG5cblx0XHRyZXR1cm4gcHJvcHM7XG5cdH1cblxufSk7XG5cblxuLy8gQnVpbGRzIGFuIGFycmF5IG9mIHNlZ21lbnRzIFwibGV2ZWxzXCIuIFRoZSBmaXJzdCBsZXZlbCB3aWxsIGJlIHRoZSBsZWZ0bW9zdCB0aWVyIG9mIHNlZ21lbnRzIGlmIHRoZSBjYWxlbmRhciBpc1xuLy8gbGVmdC10by1yaWdodCwgb3IgdGhlIHJpZ2h0bW9zdCBpZiB0aGUgY2FsZW5kYXIgaXMgcmlnaHQtdG8tbGVmdC4gQXNzdW1lcyB0aGUgc2VnbWVudHMgYXJlIGFscmVhZHkgb3JkZXJlZCBieSBkYXRlLlxuZnVuY3Rpb24gYnVpbGRTbG90U2VnTGV2ZWxzKHNlZ3MpIHtcblx0dmFyIGxldmVscyA9IFtdO1xuXHR2YXIgaSwgc2VnO1xuXHR2YXIgajtcblxuXHRmb3IgKGk9MDsgaTxzZWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0c2VnID0gc2Vnc1tpXTtcblxuXHRcdC8vIGdvIHRocm91Z2ggYWxsIHRoZSBsZXZlbHMgYW5kIHN0b3Agb24gdGhlIGZpcnN0IGxldmVsIHdoZXJlIHRoZXJlIGFyZSBubyBjb2xsaXNpb25zXG5cdFx0Zm9yIChqPTA7IGo8bGV2ZWxzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRpZiAoIWNvbXB1dGVTbG90U2VnQ29sbGlzaW9ucyhzZWcsIGxldmVsc1tqXSkubGVuZ3RoKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHNlZy5sZXZlbCA9IGo7XG5cblx0XHQobGV2ZWxzW2pdIHx8IChsZXZlbHNbal0gPSBbXSkpLnB1c2goc2VnKTtcblx0fVxuXG5cdHJldHVybiBsZXZlbHM7XG59XG5cblxuLy8gRm9yIGV2ZXJ5IHNlZ21lbnQsIGZpZ3VyZSBvdXQgdGhlIG90aGVyIHNlZ21lbnRzIHRoYXQgYXJlIGluIHN1YnNlcXVlbnRcbi8vIGxldmVscyB0aGF0IGFsc28gb2NjdXB5IHRoZSBzYW1lIHZlcnRpY2FsIHNwYWNlLiBBY2N1bXVsYXRlIGluIHNlZy5mb3J3YXJkU2Vnc1xuZnVuY3Rpb24gY29tcHV0ZUZvcndhcmRTbG90U2VncyhsZXZlbHMpIHtcblx0dmFyIGksIGxldmVsO1xuXHR2YXIgaiwgc2VnO1xuXHR2YXIgaztcblxuXHRmb3IgKGk9MDsgaTxsZXZlbHMubGVuZ3RoOyBpKyspIHtcblx0XHRsZXZlbCA9IGxldmVsc1tpXTtcblxuXHRcdGZvciAoaj0wOyBqPGxldmVsLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRzZWcgPSBsZXZlbFtqXTtcblxuXHRcdFx0c2VnLmZvcndhcmRTZWdzID0gW107XG5cdFx0XHRmb3IgKGs9aSsxOyBrPGxldmVscy5sZW5ndGg7IGsrKykge1xuXHRcdFx0XHRjb21wdXRlU2xvdFNlZ0NvbGxpc2lvbnMoc2VnLCBsZXZlbHNba10sIHNlZy5mb3J3YXJkU2Vncyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cblxuLy8gRmlndXJlIG91dCB3aGljaCBwYXRoIGZvcndhcmQgKHZpYSBzZWcuZm9yd2FyZFNlZ3MpIHJlc3VsdHMgaW4gdGhlIGxvbmdlc3QgcGF0aCB1bnRpbFxuLy8gdGhlIGZ1cnRoZXN0IGVkZ2UgaXMgcmVhY2hlZC4gVGhlIG51bWJlciBvZiBzZWdtZW50cyBpbiB0aGlzIHBhdGggd2lsbCBiZSBzZWcuZm9yd2FyZFByZXNzdXJlXG5mdW5jdGlvbiBjb21wdXRlU2xvdFNlZ1ByZXNzdXJlcyhzZWcpIHtcblx0dmFyIGZvcndhcmRTZWdzID0gc2VnLmZvcndhcmRTZWdzO1xuXHR2YXIgZm9yd2FyZFByZXNzdXJlID0gMDtcblx0dmFyIGksIGZvcndhcmRTZWc7XG5cblx0aWYgKHNlZy5mb3J3YXJkUHJlc3N1cmUgPT09IHVuZGVmaW5lZCkgeyAvLyBub3QgYWxyZWFkeSBjb21wdXRlZFxuXG5cdFx0Zm9yIChpPTA7IGk8Zm9yd2FyZFNlZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdGZvcndhcmRTZWcgPSBmb3J3YXJkU2Vnc1tpXTtcblxuXHRcdFx0Ly8gZmlndXJlIG91dCB0aGUgY2hpbGQncyBtYXhpbXVtIGZvcndhcmQgcGF0aFxuXHRcdFx0Y29tcHV0ZVNsb3RTZWdQcmVzc3VyZXMoZm9yd2FyZFNlZyk7XG5cblx0XHRcdC8vIGVpdGhlciB1c2UgdGhlIGV4aXN0aW5nIG1heGltdW0sIG9yIHVzZSB0aGUgY2hpbGQncyBmb3J3YXJkIHByZXNzdXJlXG5cdFx0XHQvLyBwbHVzIG9uZSAoZm9yIHRoZSBmb3J3YXJkU2VnIGl0c2VsZilcblx0XHRcdGZvcndhcmRQcmVzc3VyZSA9IE1hdGgubWF4KFxuXHRcdFx0XHRmb3J3YXJkUHJlc3N1cmUsXG5cdFx0XHRcdDEgKyBmb3J3YXJkU2VnLmZvcndhcmRQcmVzc3VyZVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRzZWcuZm9yd2FyZFByZXNzdXJlID0gZm9yd2FyZFByZXNzdXJlO1xuXHR9XG59XG5cblxuLy8gRmluZCBhbGwgdGhlIHNlZ21lbnRzIGluIGBvdGhlclNlZ3NgIHRoYXQgdmVydGljYWxseSBjb2xsaWRlIHdpdGggYHNlZ2AuXG4vLyBBcHBlbmQgaW50byBhbiBvcHRpb25hbGx5LXN1cHBsaWVkIGByZXN1bHRzYCBhcnJheSBhbmQgcmV0dXJuLlxuZnVuY3Rpb24gY29tcHV0ZVNsb3RTZWdDb2xsaXNpb25zKHNlZywgb3RoZXJTZWdzLCByZXN1bHRzKSB7XG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdGZvciAodmFyIGk9MDsgaTxvdGhlclNlZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRpZiAoaXNTbG90U2VnQ29sbGlzaW9uKHNlZywgb3RoZXJTZWdzW2ldKSkge1xuXHRcdFx0cmVzdWx0cy5wdXNoKG90aGVyU2Vnc1tpXSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59XG5cblxuLy8gRG8gdGhlc2Ugc2VnbWVudHMgb2NjdXB5IHRoZSBzYW1lIHZlcnRpY2FsIHNwYWNlP1xuZnVuY3Rpb24gaXNTbG90U2VnQ29sbGlzaW9uKHNlZzEsIHNlZzIpIHtcblx0cmV0dXJuIHNlZzEuYm90dG9tID4gc2VnMi50b3AgJiYgc2VnMS50b3AgPCBzZWcyLmJvdHRvbTtcbn1cblxuOztcblxuLyogQW4gYWJzdHJhY3QgY2xhc3MgZnJvbSB3aGljaCBvdGhlciB2aWV3cyBpbmhlcml0IGZyb21cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG52YXIgVmlldyA9IEZDLlZpZXcgPSBDbGFzcy5leHRlbmQoRW1pdHRlck1peGluLCBMaXN0ZW5lck1peGluLCB7XG5cblx0dHlwZTogbnVsbCwgLy8gc3ViY2xhc3MnIHZpZXcgbmFtZSAoc3RyaW5nKVxuXHRuYW1lOiBudWxsLCAvLyBkZXByZWNhdGVkLiB1c2UgYHR5cGVgIGluc3RlYWRcblx0dGl0bGU6IG51bGwsIC8vIHRoZSB0ZXh0IHRoYXQgd2lsbCBiZSBkaXNwbGF5ZWQgaW4gdGhlIGhlYWRlcidzIHRpdGxlXG5cblx0Y2FsZW5kYXI6IG51bGwsIC8vIG93bmVyIENhbGVuZGFyIG9iamVjdFxuXHRvcHRpb25zOiBudWxsLCAvLyBoYXNoIGNvbnRhaW5pbmcgYWxsIG9wdGlvbnMuIGFscmVhZHkgbWVyZ2VkIHdpdGggdmlldy1zcGVjaWZpYy1vcHRpb25zXG5cdGVsOiBudWxsLCAvLyB0aGUgdmlldydzIGNvbnRhaW5pbmcgZWxlbWVudC4gc2V0IGJ5IENhbGVuZGFyXG5cblx0ZGlzcGxheWluZzogbnVsbCwgLy8gYSBwcm9taXNlIHJlcHJlc2VudGluZyB0aGUgc3RhdGUgb2YgcmVuZGVyaW5nLiBudWxsIGlmIG5vIHJlbmRlciByZXF1ZXN0ZWRcblx0aXNTa2VsZXRvblJlbmRlcmVkOiBmYWxzZSxcblx0aXNFdmVudHNSZW5kZXJlZDogZmFsc2UsXG5cblx0Ly8gcmFuZ2UgdGhlIHZpZXcgaXMgYWN0dWFsbHkgZGlzcGxheWluZyAobW9tZW50cylcblx0c3RhcnQ6IG51bGwsXG5cdGVuZDogbnVsbCwgLy8gZXhjbHVzaXZlXG5cblx0Ly8gcmFuZ2UgdGhlIHZpZXcgaXMgZm9ybWFsbHkgcmVzcG9uc2libGUgZm9yIChtb21lbnRzKVxuXHQvLyBtYXkgYmUgZGlmZmVyZW50IGZyb20gc3RhcnQvZW5kLiBmb3IgZXhhbXBsZSwgYSBtb250aCB2aWV3IG1pZ2h0IGhhdmUgMXN0LTMxc3QsIGV4Y2x1ZGluZyBwYWRkZWQgZGF0ZXNcblx0aW50ZXJ2YWxTdGFydDogbnVsbCxcblx0aW50ZXJ2YWxFbmQ6IG51bGwsIC8vIGV4Y2x1c2l2ZVxuXHRpbnRlcnZhbER1cmF0aW9uOiBudWxsLFxuXHRpbnRlcnZhbFVuaXQ6IG51bGwsIC8vIG5hbWUgb2YgbGFyZ2VzdCB1bml0IGJlaW5nIGRpc3BsYXllZCwgbGlrZSBcIm1vbnRoXCIgb3IgXCJ3ZWVrXCJcblxuXHRpc1JUTDogZmFsc2UsXG5cdGlzU2VsZWN0ZWQ6IGZhbHNlLCAvLyBib29sZWFuIHdoZXRoZXIgYSByYW5nZSBvZiB0aW1lIGlzIHVzZXItc2VsZWN0ZWQgb3Igbm90XG5cdHNlbGVjdGVkRXZlbnQ6IG51bGwsXG5cblx0ZXZlbnRPcmRlclNwZWNzOiBudWxsLCAvLyBjcml0ZXJpYSBmb3Igb3JkZXJpbmcgZXZlbnRzIHdoZW4gdGhleSBoYXZlIHNhbWUgZGF0ZS90aW1lXG5cblx0Ly8gY2xhc3NOYW1lcyBzdHlsZWQgYnkganF1aSB0aGVtZXNcblx0d2lkZ2V0SGVhZGVyQ2xhc3M6IG51bGwsXG5cdHdpZGdldENvbnRlbnRDbGFzczogbnVsbCxcblx0aGlnaGxpZ2h0U3RhdGVDbGFzczogbnVsbCxcblxuXHQvLyBmb3IgZGF0ZSB1dGlscywgY29tcHV0ZWQgZnJvbSBvcHRpb25zXG5cdG5leHREYXlUaHJlc2hvbGQ6IG51bGwsXG5cdGlzSGlkZGVuRGF5SGFzaDogbnVsbCxcblxuXHQvLyBub3cgaW5kaWNhdG9yXG5cdGlzTm93SW5kaWNhdG9yUmVuZGVyZWQ6IG51bGwsXG5cdGluaXRpYWxOb3dEYXRlOiBudWxsLCAvLyByZXN1bHQgZmlyc3QgZ2V0Tm93IGNhbGxcblx0aW5pdGlhbE5vd1F1ZXJpZWRNczogbnVsbCwgLy8gbXMgdGltZSB0aGUgZ2V0Tm93IHdhcyBjYWxsZWRcblx0bm93SW5kaWNhdG9yVGltZW91dElEOiBudWxsLCAvLyBmb3IgcmVmcmVzaCB0aW1pbmcgb2Ygbm93IGluZGljYXRvclxuXHRub3dJbmRpY2F0b3JJbnRlcnZhbElEOiBudWxsLCAvLyBcIlxuXG5cblx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uKGNhbGVuZGFyLCB0eXBlLCBvcHRpb25zLCBpbnRlcnZhbER1cmF0aW9uKSB7XG5cblx0XHR0aGlzLmNhbGVuZGFyID0gY2FsZW5kYXI7XG5cdFx0dGhpcy50eXBlID0gdGhpcy5uYW1lID0gdHlwZTsgLy8gLm5hbWUgaXMgZGVwcmVjYXRlZFxuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5pbnRlcnZhbER1cmF0aW9uID0gaW50ZXJ2YWxEdXJhdGlvbiB8fCBtb21lbnQuZHVyYXRpb24oMSwgJ2RheScpO1xuXG5cdFx0dGhpcy5uZXh0RGF5VGhyZXNob2xkID0gbW9tZW50LmR1cmF0aW9uKHRoaXMub3B0KCduZXh0RGF5VGhyZXNob2xkJykpO1xuXHRcdHRoaXMuaW5pdFRoZW1pbmdQcm9wcygpO1xuXHRcdHRoaXMuaW5pdEhpZGRlbkRheXMoKTtcblx0XHR0aGlzLmlzUlRMID0gdGhpcy5vcHQoJ2lzUlRMJyk7XG5cblx0XHR0aGlzLmV2ZW50T3JkZXJTcGVjcyA9IHBhcnNlRmllbGRTcGVjcyh0aGlzLm9wdCgnZXZlbnRPcmRlcicpKTtcblxuXHRcdHRoaXMuaW5pdGlhbGl6ZSgpO1xuXHR9LFxuXG5cblx0Ly8gQSBnb29kIHBsYWNlIGZvciBzdWJjbGFzc2VzIHRvIGluaXRpYWxpemUgbWVtYmVyIHZhcmlhYmxlc1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHQvLyBzdWJjbGFzc2VzIGNhbiBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8vIFJldHJpZXZlcyBhbiBvcHRpb24gd2l0aCB0aGUgZ2l2ZW4gbmFtZVxuXHRvcHQ6IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zW25hbWVdO1xuXHR9LFxuXG5cblx0Ly8gVHJpZ2dlcnMgaGFuZGxlcnMgdGhhdCBhcmUgdmlldy1yZWxhdGVkLiBNb2RpZmllcyBhcmdzIGJlZm9yZSBwYXNzaW5nIHRvIGNhbGVuZGFyLlxuXHR0cmlnZ2VyOiBmdW5jdGlvbihuYW1lLCB0aGlzT2JqKSB7IC8vIGFyZ3VtZW50cyBiZXlvbmQgdGhpc09iaiBhcmUgcGFzc2VkIGFsb25nXG5cdFx0dmFyIGNhbGVuZGFyID0gdGhpcy5jYWxlbmRhcjtcblxuXHRcdHJldHVybiBjYWxlbmRhci50cmlnZ2VyLmFwcGx5KFxuXHRcdFx0Y2FsZW5kYXIsXG5cdFx0XHRbbmFtZSwgdGhpc09iaiB8fCB0aGlzXS5jb25jYXQoXG5cdFx0XHRcdEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMiksIC8vIGFyZ3VtZW50cyBiZXlvbmQgdGhpc09ialxuXHRcdFx0XHRbIHRoaXMgXSAvLyBhbHdheXMgbWFrZSB0aGUgbGFzdCBhcmd1bWVudCBhIHJlZmVyZW5jZSB0byB0aGUgdmlldy4gVE9ETzogZGVwcmVjYXRlXG5cdFx0XHQpXG5cdFx0KTtcblx0fSxcblxuXG5cdC8qIERhdGVzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBVcGRhdGVzIGFsbCBpbnRlcm5hbCBkYXRlcyB0byBjZW50ZXIgYXJvdW5kIHRoZSBnaXZlbiBjdXJyZW50IHVuem9uZWQgZGF0ZS5cblx0c2V0RGF0ZTogZnVuY3Rpb24oZGF0ZSkge1xuXHRcdHRoaXMuc2V0UmFuZ2UodGhpcy5jb21wdXRlUmFuZ2UoZGF0ZSkpO1xuXHR9LFxuXG5cblx0Ly8gVXBkYXRlcyBhbGwgaW50ZXJuYWwgZGF0ZXMgZm9yIGRpc3BsYXlpbmcgdGhlIGdpdmVuIHVuem9uZWQgcmFuZ2UuXG5cdHNldFJhbmdlOiBmdW5jdGlvbihyYW5nZSkge1xuXHRcdCQuZXh0ZW5kKHRoaXMsIHJhbmdlKTsgLy8gYXNzaWducyBldmVyeSBwcm9wZXJ0eSB0byB0aGlzIG9iamVjdCdzIG1lbWJlciB2YXJpYWJsZXNcblx0XHR0aGlzLnVwZGF0ZVRpdGxlKCk7XG5cdH0sXG5cblxuXHQvLyBHaXZlbiBhIHNpbmdsZSBjdXJyZW50IHVuem9uZWQgZGF0ZSwgcHJvZHVjZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IHJhbmdlIHRvIGRpc3BsYXkuXG5cdC8vIFN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlLiBNdXN0IHJldHVybiBhbGwgcHJvcGVydGllcy5cblx0Y29tcHV0ZVJhbmdlOiBmdW5jdGlvbihkYXRlKSB7XG5cdFx0dmFyIGludGVydmFsVW5pdCA9IGNvbXB1dGVJbnRlcnZhbFVuaXQodGhpcy5pbnRlcnZhbER1cmF0aW9uKTtcblx0XHR2YXIgaW50ZXJ2YWxTdGFydCA9IGRhdGUuY2xvbmUoKS5zdGFydE9mKGludGVydmFsVW5pdCk7XG5cdFx0dmFyIGludGVydmFsRW5kID0gaW50ZXJ2YWxTdGFydC5jbG9uZSgpLmFkZCh0aGlzLmludGVydmFsRHVyYXRpb24pO1xuXHRcdHZhciBzdGFydCwgZW5kO1xuXG5cdFx0Ly8gbm9ybWFsaXplIHRoZSByYW5nZSdzIHRpbWUtYW1iaWd1aXR5XG5cdFx0aWYgKC95ZWFyfG1vbnRofHdlZWt8ZGF5Ly50ZXN0KGludGVydmFsVW5pdCkpIHsgLy8gd2hvbGUtZGF5cz9cblx0XHRcdGludGVydmFsU3RhcnQuc3RyaXBUaW1lKCk7XG5cdFx0XHRpbnRlcnZhbEVuZC5zdHJpcFRpbWUoKTtcblx0XHR9XG5cdFx0ZWxzZSB7IC8vIG5lZWRzIHRvIGhhdmUgYSB0aW1lP1xuXHRcdFx0aWYgKCFpbnRlcnZhbFN0YXJ0Lmhhc1RpbWUoKSkge1xuXHRcdFx0XHRpbnRlcnZhbFN0YXJ0ID0gdGhpcy5jYWxlbmRhci50aW1lKDApOyAvLyBnaXZlIDAwOjAwIHRpbWVcblx0XHRcdH1cblx0XHRcdGlmICghaW50ZXJ2YWxFbmQuaGFzVGltZSgpKSB7XG5cdFx0XHRcdGludGVydmFsRW5kID0gdGhpcy5jYWxlbmRhci50aW1lKDApOyAvLyBnaXZlIDAwOjAwIHRpbWVcblx0XHRcdH1cblx0XHR9XG5cblx0XHRzdGFydCA9IGludGVydmFsU3RhcnQuY2xvbmUoKTtcblx0XHRzdGFydCA9IHRoaXMuc2tpcEhpZGRlbkRheXMoc3RhcnQpO1xuXHRcdGVuZCA9IGludGVydmFsRW5kLmNsb25lKCk7XG5cdFx0ZW5kID0gdGhpcy5za2lwSGlkZGVuRGF5cyhlbmQsIC0xLCB0cnVlKTsgLy8gZXhjbHVzaXZlbHkgbW92ZSBiYWNrd2FyZHNcblxuXHRcdHJldHVybiB7XG5cdFx0XHRpbnRlcnZhbFVuaXQ6IGludGVydmFsVW5pdCxcblx0XHRcdGludGVydmFsU3RhcnQ6IGludGVydmFsU3RhcnQsXG5cdFx0XHRpbnRlcnZhbEVuZDogaW50ZXJ2YWxFbmQsXG5cdFx0XHRzdGFydDogc3RhcnQsXG5cdFx0XHRlbmQ6IGVuZFxuXHRcdH07XG5cdH0sXG5cblxuXHQvLyBDb21wdXRlcyB0aGUgbmV3IGRhdGUgd2hlbiB0aGUgdXNlciBoaXRzIHRoZSBwcmV2IGJ1dHRvbiwgZ2l2ZW4gdGhlIGN1cnJlbnQgZGF0ZVxuXHRjb21wdXRlUHJldkRhdGU6IGZ1bmN0aW9uKGRhdGUpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXNzYWdlQ3VycmVudERhdGUoXG5cdFx0XHRkYXRlLmNsb25lKCkuc3RhcnRPZih0aGlzLmludGVydmFsVW5pdCkuc3VidHJhY3QodGhpcy5pbnRlcnZhbER1cmF0aW9uKSwgLTFcblx0XHQpO1xuXHR9LFxuXG5cblx0Ly8gQ29tcHV0ZXMgdGhlIG5ldyBkYXRlIHdoZW4gdGhlIHVzZXIgaGl0cyB0aGUgbmV4dCBidXR0b24sIGdpdmVuIHRoZSBjdXJyZW50IGRhdGVcblx0Y29tcHV0ZU5leHREYXRlOiBmdW5jdGlvbihkYXRlKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFzc2FnZUN1cnJlbnREYXRlKFxuXHRcdFx0ZGF0ZS5jbG9uZSgpLnN0YXJ0T2YodGhpcy5pbnRlcnZhbFVuaXQpLmFkZCh0aGlzLmludGVydmFsRHVyYXRpb24pXG5cdFx0KTtcblx0fSxcblxuXG5cdC8vIEdpdmVuIGFuIGFyYml0cmFyaWx5IGNhbGN1bGF0ZWQgY3VycmVudCBkYXRlIG9mIHRoZSBjYWxlbmRhciwgcmV0dXJucyBhIGRhdGUgdGhhdCBpcyBlbnN1cmVkIHRvIGJlIGNvbXBsZXRlbHlcblx0Ly8gdmlzaWJsZS4gYGRpcmVjdGlvbmAgaXMgb3B0aW9uYWwgYW5kIGluZGljYXRlcyB3aGljaCBkaXJlY3Rpb24gdGhlIGN1cnJlbnQgZGF0ZSB3YXMgYmVpbmdcblx0Ly8gaW5jcmVtZW50ZWQgb3IgZGVjcmVtZW50ZWQgKDEgb3IgLTEpLlxuXHRtYXNzYWdlQ3VycmVudERhdGU6IGZ1bmN0aW9uKGRhdGUsIGRpcmVjdGlvbikge1xuXHRcdGlmICh0aGlzLmludGVydmFsRHVyYXRpb24uYXMoJ2RheXMnKSA8PSAxKSB7IC8vIGlmIHRoZSB2aWV3IGRpc3BsYXlzIGEgc2luZ2xlIGRheSBvciBzbWFsbGVyXG5cdFx0XHRpZiAodGhpcy5pc0hpZGRlbkRheShkYXRlKSkge1xuXHRcdFx0XHRkYXRlID0gdGhpcy5za2lwSGlkZGVuRGF5cyhkYXRlLCBkaXJlY3Rpb24pO1xuXHRcdFx0XHRkYXRlLnN0YXJ0T2YoJ2RheScpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBkYXRlO1xuXHR9LFxuXG5cblx0LyogVGl0bGUgYW5kIERhdGUgRm9ybWF0dGluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gU2V0cyB0aGUgdmlldydzIHRpdGxlIHByb3BlcnR5IHRvIHRoZSBtb3N0IHVwZGF0ZWQgY29tcHV0ZWQgdmFsdWVcblx0dXBkYXRlVGl0bGU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudGl0bGUgPSB0aGlzLmNvbXB1dGVUaXRsZSgpO1xuXHR9LFxuXG5cblx0Ly8gQ29tcHV0ZXMgd2hhdCB0aGUgdGl0bGUgYXQgdGhlIHRvcCBvZiB0aGUgY2FsZW5kYXIgc2hvdWxkIGJlIGZvciB0aGlzIHZpZXdcblx0Y29tcHV0ZVRpdGxlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5mb3JtYXRSYW5nZShcblx0XHRcdHtcblx0XHRcdFx0Ly8gaW4gY2FzZSBpbnRlcnZhbFN0YXJ0L0VuZCBoYXMgYSB0aW1lLCBtYWtlIHN1cmUgdGltZXpvbmUgaXMgY29ycmVjdFxuXHRcdFx0XHRzdGFydDogdGhpcy5jYWxlbmRhci5hcHBseVRpbWV6b25lKHRoaXMuaW50ZXJ2YWxTdGFydCksXG5cdFx0XHRcdGVuZDogdGhpcy5jYWxlbmRhci5hcHBseVRpbWV6b25lKHRoaXMuaW50ZXJ2YWxFbmQpXG5cdFx0XHR9LFxuXHRcdFx0dGhpcy5vcHQoJ3RpdGxlRm9ybWF0JykgfHwgdGhpcy5jb21wdXRlVGl0bGVGb3JtYXQoKSxcblx0XHRcdHRoaXMub3B0KCd0aXRsZVJhbmdlU2VwYXJhdG9yJylcblx0XHQpO1xuXHR9LFxuXG5cblx0Ly8gR2VuZXJhdGVzIHRoZSBmb3JtYXQgc3RyaW5nIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHRpdGxlIGZvciB0aGUgY3VycmVudCBkYXRlIHJhbmdlLlxuXHQvLyBBdHRlbXB0cyB0byBjb21wdXRlIHRoZSBtb3N0IGFwcHJvcHJpYXRlIGZvcm1hdCBpZiBub3QgZXhwbGljaXRseSBzcGVjaWZpZWQgd2l0aCBgdGl0bGVGb3JtYXRgLlxuXHRjb21wdXRlVGl0bGVGb3JtYXQ6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLmludGVydmFsVW5pdCA9PSAneWVhcicpIHtcblx0XHRcdHJldHVybiAnWVlZWSc7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHRoaXMuaW50ZXJ2YWxVbml0ID09ICdtb250aCcpIHtcblx0XHRcdHJldHVybiB0aGlzLm9wdCgnbW9udGhZZWFyRm9ybWF0Jyk7IC8vIGxpa2UgXCJTZXB0ZW1iZXIgMjAxNFwiXG5cdFx0fVxuXHRcdGVsc2UgaWYgKHRoaXMuaW50ZXJ2YWxEdXJhdGlvbi5hcygnZGF5cycpID4gMSkge1xuXHRcdFx0cmV0dXJuICdsbCc7IC8vIG11bHRpLWRheSByYW5nZS4gc2hvcnRlciwgbGlrZSBcIlNlcCA5IC0gMTAgMjAxNFwiXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmV0dXJuICdMTCc7IC8vIG9uZSBkYXkuIGxvbmdlciwgbGlrZSBcIlNlcHRlbWJlciA5IDIwMTRcIlxuXHRcdH1cblx0fSxcblxuXG5cdC8vIFV0aWxpdHkgZm9yIGZvcm1hdHRpbmcgYSByYW5nZS4gQWNjZXB0cyBhIHJhbmdlIG9iamVjdCwgZm9ybWF0dGluZyBzdHJpbmcsIGFuZCBvcHRpb25hbCBzZXBhcmF0b3IuXG5cdC8vIERpc3BsYXlzIGFsbC1kYXkgcmFuZ2VzIG5hdHVyYWxseSwgd2l0aCBhbiBpbmNsdXNpdmUgZW5kLiBUYWtlcyB0aGUgY3VycmVudCBpc1JUTCBpbnRvIGFjY291bnQuXG5cdC8vIFRoZSB0aW1lem9uZXMgb2YgdGhlIGRhdGVzIHdpdGhpbiBgcmFuZ2VgIHdpbGwgYmUgcmVzcGVjdGVkLlxuXHRmb3JtYXRSYW5nZTogZnVuY3Rpb24ocmFuZ2UsIGZvcm1hdFN0ciwgc2VwYXJhdG9yKSB7XG5cdFx0dmFyIGVuZCA9IHJhbmdlLmVuZDtcblxuXHRcdGlmICghZW5kLmhhc1RpbWUoKSkgeyAvLyBhbGwtZGF5P1xuXHRcdFx0ZW5kID0gZW5kLmNsb25lKCkuc3VidHJhY3QoMSk7IC8vIGNvbnZlcnQgdG8gaW5jbHVzaXZlLiBsYXN0IG1zIG9mIHByZXZpb3VzIGRheVxuXHRcdH1cblxuXHRcdHJldHVybiBmb3JtYXRSYW5nZShyYW5nZS5zdGFydCwgZW5kLCBmb3JtYXRTdHIsIHNlcGFyYXRvciwgdGhpcy5vcHQoJ2lzUlRMJykpO1xuXHR9LFxuXG5cblx0Z2V0QWxsRGF5SHRtbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMub3B0KCdhbGxEYXlIdG1sJykgfHwgaHRtbEVzY2FwZSh0aGlzLm9wdCgnYWxsRGF5VGV4dCcpKTtcblx0fSxcblxuXG5cdC8qIE5hdmlnYXRpb25cblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIEdlbmVyYXRlcyBIVE1MIGZvciBhbiBhbmNob3IgdG8gYW5vdGhlciB2aWV3IGludG8gdGhlIGNhbGVuZGFyLlxuXHQvLyBXaWxsIGVpdGhlciBnZW5lcmF0ZSBhbiA8YT4gdGFnIG9yIGEgbm9uLWNsaWNrYWJsZSA8c3Bhbj4gdGFnLCBkZXBlbmRpbmcgb24gZW5hYmxlZCBzZXR0aW5ncy5cblx0Ly8gYGdvdG9PcHRpb25zYCBjYW4gZWl0aGVyIGJlIGEgbW9tZW50IGlucHV0LCBvciBhbiBvYmplY3Qgd2l0aCB0aGUgZm9ybTpcblx0Ly8geyBkYXRlLCB0eXBlLCBmb3JjZU9mZiB9XG5cdC8vIGB0eXBlYCBpcyBhIHZpZXctdHlwZSBsaWtlIFwiZGF5XCIgb3IgXCJ3ZWVrXCIuIGRlZmF1bHQgdmFsdWUgaXMgXCJkYXlcIi5cblx0Ly8gYGF0dHJzYCBhbmQgYGlubmVySHRtbGAgYXJlIHVzZSB0byBnZW5lcmF0ZSB0aGUgcmVzdCBvZiB0aGUgSFRNTCB0YWcuXG5cdGJ1aWxkR290b0FuY2hvckh0bWw6IGZ1bmN0aW9uKGdvdG9PcHRpb25zLCBhdHRycywgaW5uZXJIdG1sKSB7XG5cdFx0dmFyIGRhdGUsIHR5cGUsIGZvcmNlT2ZmO1xuXHRcdHZhciBmaW5hbE9wdGlvbnM7XG5cblx0XHRpZiAoJC5pc1BsYWluT2JqZWN0KGdvdG9PcHRpb25zKSkge1xuXHRcdFx0ZGF0ZSA9IGdvdG9PcHRpb25zLmRhdGU7XG5cdFx0XHR0eXBlID0gZ290b09wdGlvbnMudHlwZTtcblx0XHRcdGZvcmNlT2ZmID0gZ290b09wdGlvbnMuZm9yY2VPZmY7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0ZGF0ZSA9IGdvdG9PcHRpb25zOyAvLyBhIHNpbmdsZSBtb21lbnQgaW5wdXRcblx0XHR9XG5cdFx0ZGF0ZSA9IEZDLm1vbWVudChkYXRlKTsgLy8gaWYgYSBzdHJpbmcsIHBhcnNlIGl0XG5cblx0XHRmaW5hbE9wdGlvbnMgPSB7IC8vIGZvciBzZXJpYWxpemF0aW9uIGludG8gdGhlIGxpbmtcblx0XHRcdGRhdGU6IGRhdGUuZm9ybWF0KCdZWVlZLU1NLUREJyksXG5cdFx0XHR0eXBlOiB0eXBlIHx8ICdkYXknXG5cdFx0fTtcblxuXHRcdGlmICh0eXBlb2YgYXR0cnMgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRpbm5lckh0bWwgPSBhdHRycztcblx0XHRcdGF0dHJzID0gbnVsbDtcblx0XHR9XG5cblx0XHRhdHRycyA9IGF0dHJzID8gJyAnICsgYXR0cnNUb1N0cihhdHRycykgOiAnJzsgLy8gd2lsbCBoYXZlIGEgbGVhZGluZyBzcGFjZVxuXHRcdGlubmVySHRtbCA9IGlubmVySHRtbCB8fCAnJztcblxuXHRcdGlmICghZm9yY2VPZmYgJiYgdGhpcy5vcHQoJ25hdkxpbmtzJykpIHtcblx0XHRcdHJldHVybiAnPGEnICsgYXR0cnMgK1xuXHRcdFx0XHQnIGRhdGEtZ290bz1cIicgKyBodG1sRXNjYXBlKEpTT04uc3RyaW5naWZ5KGZpbmFsT3B0aW9ucykpICsgJ1wiPicgK1xuXHRcdFx0XHRpbm5lckh0bWwgK1xuXHRcdFx0XHQnPC9hPic7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmV0dXJuICc8c3BhbicgKyBhdHRycyArICc+JyArXG5cdFx0XHRcdGlubmVySHRtbCArXG5cdFx0XHRcdCc8L3NwYW4+Jztcblx0XHR9XG5cdH0sXG5cblxuXHQvKiBSZW5kZXJpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIFNldHMgdGhlIGNvbnRhaW5lciBlbGVtZW50IHRoYXQgdGhlIHZpZXcgc2hvdWxkIHJlbmRlciBpbnNpZGUgb2YuXG5cdC8vIERvZXMgb3RoZXIgRE9NLXJlbGF0ZWQgaW5pdGlhbGl6YXRpb25zLlxuXHRzZXRFbGVtZW50OiBmdW5jdGlvbihlbCkge1xuXHRcdHRoaXMuZWwgPSBlbDtcblx0XHR0aGlzLmJpbmRHbG9iYWxIYW5kbGVycygpO1xuXHR9LFxuXG5cblx0Ly8gUmVtb3ZlcyB0aGUgdmlldydzIGNvbnRhaW5lciBlbGVtZW50IGZyb20gdGhlIERPTSwgY2xlYXJpbmcgYW55IGNvbnRlbnQgYmVmb3JlaGFuZC5cblx0Ly8gVW5kb2VzIGFueSBvdGhlciBET00tcmVsYXRlZCBhdHRhY2htZW50cy5cblx0cmVtb3ZlRWxlbWVudDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5jbGVhcigpOyAvLyBjbGVhcnMgYWxsIGNvbnRlbnRcblxuXHRcdC8vIGNsZWFuIHVwIHRoZSBza2VsZXRvblxuXHRcdGlmICh0aGlzLmlzU2tlbGV0b25SZW5kZXJlZCkge1xuXHRcdFx0dGhpcy51bnJlbmRlclNrZWxldG9uKCk7XG5cdFx0XHR0aGlzLmlzU2tlbGV0b25SZW5kZXJlZCA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdHRoaXMudW5iaW5kR2xvYmFsSGFuZGxlcnMoKTtcblxuXHRcdHRoaXMuZWwucmVtb3ZlKCk7XG5cblx0XHQvLyBOT1RFOiBkb24ndCBudWxsLW91dCB0aGlzLmVsIGluIGNhc2UgdGhlIFZpZXcgd2FzIGRlc3Ryb3llZCB3aXRoaW4gYW4gQVBJIGNhbGxiYWNrLlxuXHRcdC8vIFdlIGRvbid0IG51bGwtb3V0IHRoZSBWaWV3J3Mgb3RoZXIgalF1ZXJ5IGVsZW1lbnQgcmVmZXJlbmNlcyB1cG9uIGRlc3Ryb3ksXG5cdFx0Ly8gIHNvIHdlIHNob3VsZG4ndCBraWxsIHRoaXMuZWwgZWl0aGVyLlxuXHR9LFxuXG5cblx0Ly8gRG9lcyBldmVyeXRoaW5nIG5lY2Vzc2FyeSB0byBkaXNwbGF5IHRoZSB2aWV3IGNlbnRlcmVkIGFyb3VuZCB0aGUgZ2l2ZW4gdW56b25lZCBkYXRlLlxuXHQvLyBEb2VzIGV2ZXJ5IHR5cGUgb2YgcmVuZGVyaW5nIEVYQ0VQVCByZW5kZXJpbmcgZXZlbnRzLlxuXHQvLyBJcyBhc3ljaHJvbm91cyBhbmQgcmV0dXJucyBhIHByb21pc2UuXG5cdGRpc3BsYXk6IGZ1bmN0aW9uKGRhdGUsIGV4cGxpY2l0U2Nyb2xsU3RhdGUpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHZhciBwcmV2U2Nyb2xsU3RhdGUgPSBudWxsO1xuXG5cdFx0aWYgKGV4cGxpY2l0U2Nyb2xsU3RhdGUgIT0gbnVsbCAmJiB0aGlzLmRpc3BsYXlpbmcpIHsgLy8gZG9uJ3QgbmVlZCBwcmV2U2Nyb2xsU3RhdGUgaWYgZXhwbGljaXRTY3JvbGxTdGF0ZVxuXHRcdFx0cHJldlNjcm9sbFN0YXRlID0gdGhpcy5xdWVyeVNjcm9sbCgpO1xuXHRcdH1cblxuXHRcdHRoaXMuY2FsZW5kYXIuZnJlZXplQ29udGVudEhlaWdodCgpO1xuXG5cdFx0cmV0dXJuIHN5bmNUaGVuKHRoaXMuY2xlYXIoKSwgZnVuY3Rpb24oKSB7IC8vIGNsZWFyIHRoZSBjb250ZW50IGZpcnN0XG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRfdGhpcy5kaXNwbGF5aW5nID1cblx0XHRcdFx0XHRzeW5jVGhlbihfdGhpcy5kaXNwbGF5VmlldyhkYXRlKSwgZnVuY3Rpb24oKSB7IC8vIGRpc3BsYXlWaWV3IG1pZ2h0IHJldHVybiBhIHByb21pc2VcblxuXHRcdFx0XHRcdFx0Ly8gY2FsbGVyIG9mIGRpc3BsYXkoKSB3YW50cyBhIHNwZWNpZmljIHNjcm9sbCBzdGF0ZT9cblx0XHRcdFx0XHRcdGlmIChleHBsaWNpdFNjcm9sbFN0YXRlICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0Ly8gd2UgbWFrZSBhbiBhc3N1bXB0aW9uIHRoYXQgdGhpcyBpcyBOT1QgdGhlIGluaXRpYWwgcmVuZGVyLFxuXHRcdFx0XHRcdFx0XHQvLyBhbmQgdGh1cyBkb24ndCBuZWVkIGZvcmNlU2Nyb2xsIChpcyBpbmNvbnZlbmllbnRseSBhc3luY2hyb25vdXMpXG5cdFx0XHRcdFx0XHRcdF90aGlzLnNldFNjcm9sbChleHBsaWNpdFNjcm9sbFN0YXRlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRfdGhpcy5mb3JjZVNjcm9sbChfdGhpcy5jb21wdXRlSW5pdGlhbFNjcm9sbChwcmV2U2Nyb2xsU3RhdGUpKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0X3RoaXMuY2FsZW5kYXIudW5mcmVlemVDb250ZW50SGVpZ2h0KCk7XG5cdFx0XHRcdFx0XHRfdGhpcy50cmlnZ2VyUmVuZGVyKCk7XG5cdFx0XHRcdFx0fSlcblx0XHRcdCk7XG5cdFx0fSk7XG5cdH0sXG5cblxuXHQvLyBEb2VzIGV2ZXJ5dGhpbmcgbmVjZXNzYXJ5IHRvIGNsZWFyIHRoZSBjb250ZW50IG9mIHRoZSB2aWV3LlxuXHQvLyBDbGVhcnMgZGF0ZXMgYW5kIGV2ZW50cy4gRG9lcyBub3QgY2xlYXIgdGhlIHNrZWxldG9uLlxuXHQvLyBJcyBhc3ljaHJvbm91cyBhbmQgcmV0dXJucyBhIHByb21pc2UuXG5cdGNsZWFyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHZhciBkaXNwbGF5aW5nID0gdGhpcy5kaXNwbGF5aW5nO1xuXG5cdFx0aWYgKGRpc3BsYXlpbmcpIHsgLy8gcHJldmlvdXNseSBkaXNwbGF5ZWQsIG9yIGluIHRoZSBwcm9jZXNzIG9mIGJlaW5nIGRpc3BsYXllZD9cblx0XHRcdHJldHVybiBzeW5jVGhlbihkaXNwbGF5aW5nLCBmdW5jdGlvbigpIHsgLy8gd2FpdCBmb3IgdGhlIGRpc3BsYXkgdG8gZmluaXNoXG5cdFx0XHRcdF90aGlzLmRpc3BsYXlpbmcgPSBudWxsO1xuXHRcdFx0XHRfdGhpcy5jbGVhckV2ZW50cygpO1xuXHRcdFx0XHRyZXR1cm4gX3RoaXMuY2xlYXJWaWV3KCk7IC8vIG1pZ2h0IHJldHVybiBhIHByb21pc2UuIGNoYWluIGl0XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRyZXR1cm4gJC53aGVuKCk7IC8vIGFuIGltbWVkaWF0ZWx5LXJlc29sdmVkIHByb21pc2Vcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBEaXNwbGF5cyB0aGUgdmlldydzIG5vbi1ldmVudCBjb250ZW50LCBzdWNoIGFzIGRhdGUtcmVsYXRlZCBjb250ZW50IG9yIGFueXRoaW5nIHJlcXVpcmVkIGJ5IGV2ZW50cy5cblx0Ly8gUmVuZGVycyB0aGUgdmlldydzIG5vbi1jb250ZW50IHNrZWxldG9uIGlmIG5lY2Vzc2FyeS5cblx0Ly8gQ2FuIGJlIGFzeW5jaHJvbm91cyBhbmQgcmV0dXJuIGEgcHJvbWlzZS5cblx0ZGlzcGxheVZpZXc6IGZ1bmN0aW9uKGRhdGUpIHtcblx0XHRpZiAoIXRoaXMuaXNTa2VsZXRvblJlbmRlcmVkKSB7XG5cdFx0XHR0aGlzLnJlbmRlclNrZWxldG9uKCk7XG5cdFx0XHR0aGlzLmlzU2tlbGV0b25SZW5kZXJlZCA9IHRydWU7XG5cdFx0fVxuXHRcdGlmIChkYXRlKSB7XG5cdFx0XHR0aGlzLnNldERhdGUoZGF0ZSk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLnJlbmRlcikge1xuXHRcdFx0dGhpcy5yZW5kZXIoKTsgLy8gVE9ETzogZGVwcmVjYXRlXG5cdFx0fVxuXHRcdHRoaXMucmVuZGVyRGF0ZXMoKTtcblx0XHR0aGlzLnVwZGF0ZVNpemUoKTtcblx0XHR0aGlzLnJlbmRlckJ1c2luZXNzSG91cnMoKTsgLy8gbWlnaHQgbmVlZCBjb29yZGluYXRlcywgc28gc2hvdWxkIGdvIGFmdGVyIHVwZGF0ZVNpemUoKVxuXHRcdHRoaXMuc3RhcnROb3dJbmRpY2F0b3IoKTtcblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyB0aGUgdmlldyBjb250ZW50IHRoYXQgd2FzIHJlbmRlcmVkIGluIGRpc3BsYXlWaWV3LlxuXHQvLyBDYW4gYmUgYXN5bmNocm9ub3VzIGFuZCByZXR1cm4gYSBwcm9taXNlLlxuXHRjbGVhclZpZXc6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudW5zZWxlY3QoKTtcblx0XHR0aGlzLnN0b3BOb3dJbmRpY2F0b3IoKTtcblx0XHR0aGlzLnRyaWdnZXJVbnJlbmRlcigpO1xuXHRcdHRoaXMudW5yZW5kZXJCdXNpbmVzc0hvdXJzKCk7XG5cdFx0dGhpcy51bnJlbmRlckRhdGVzKCk7XG5cdFx0aWYgKHRoaXMuZGVzdHJveSkge1xuXHRcdFx0dGhpcy5kZXN0cm95KCk7IC8vIFRPRE86IGRlcHJlY2F0ZVxuXHRcdH1cblx0fSxcblxuXG5cdC8vIFJlbmRlcnMgdGhlIGJhc2ljIHN0cnVjdHVyZSBvZiB0aGUgdmlldyBiZWZvcmUgYW55IGNvbnRlbnQgaXMgcmVuZGVyZWRcblx0cmVuZGVyU2tlbGV0b246IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxuXHR9LFxuXG5cblx0Ly8gVW5yZW5kZXJzIHRoZSBiYXNpYyBzdHJ1Y3R1cmUgb2YgdGhlIHZpZXdcblx0dW5yZW5kZXJTa2VsZXRvbjogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gc3ViY2xhc3NlcyBzaG91bGQgaW1wbGVtZW50XG5cdH0sXG5cblxuXHQvLyBSZW5kZXJzIHRoZSB2aWV3J3MgZGF0ZS1yZWxhdGVkIGNvbnRlbnQuXG5cdC8vIEFzc3VtZXMgc2V0UmFuZ2UgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQgYW5kIHRoZSBza2VsZXRvbiBoYXMgYWxyZWFkeSBiZWVuIHJlbmRlcmVkLlxuXHRyZW5kZXJEYXRlczogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gc3ViY2xhc3NlcyBzaG91bGQgaW1wbGVtZW50XG5cdH0sXG5cblxuXHQvLyBVbnJlbmRlcnMgdGhlIHZpZXcncyBkYXRlLXJlbGF0ZWQgY29udGVudFxuXHR1bnJlbmRlckRhdGVzOiBmdW5jdGlvbigpIHtcblx0XHQvLyBzdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZVxuXHR9LFxuXG5cblx0Ly8gU2lnbmFscyB0aGF0IHRoZSB2aWV3J3MgY29udGVudCBoYXMgYmVlbiByZW5kZXJlZFxuXHR0cmlnZ2VyUmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnRyaWdnZXIoJ3ZpZXdSZW5kZXInLCB0aGlzLCB0aGlzLCB0aGlzLmVsKTtcblx0fSxcblxuXG5cdC8vIFNpZ25hbHMgdGhhdCB0aGUgdmlldydzIGNvbnRlbnQgaXMgYWJvdXQgdG8gYmUgdW5yZW5kZXJlZFxuXHR0cmlnZ2VyVW5yZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudHJpZ2dlcigndmlld0Rlc3Ryb3knLCB0aGlzLCB0aGlzLCB0aGlzLmVsKTtcblx0fSxcblxuXG5cdC8vIEJpbmRzIERPTSBoYW5kbGVycyB0byBlbGVtZW50cyB0aGF0IHJlc2lkZSBvdXRzaWRlIHRoZSB2aWV3IGNvbnRhaW5lciwgc3VjaCBhcyB0aGUgZG9jdW1lbnRcblx0YmluZEdsb2JhbEhhbmRsZXJzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmxpc3RlblRvKCQoZG9jdW1lbnQpLCAnbW91c2Vkb3duJywgdGhpcy5oYW5kbGVEb2N1bWVudE1vdXNlZG93bik7XG5cdFx0dGhpcy5saXN0ZW5UbygkKGRvY3VtZW50KSwgJ3RvdWNoc3RhcnQnLCB0aGlzLnByb2Nlc3NVbnNlbGVjdCk7XG5cdH0sXG5cblxuXHQvLyBVbmJpbmRzIERPTSBoYW5kbGVycyBmcm9tIGVsZW1lbnRzIHRoYXQgcmVzaWRlIG91dHNpZGUgdGhlIHZpZXcgY29udGFpbmVyXG5cdHVuYmluZEdsb2JhbEhhbmRsZXJzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnN0b3BMaXN0ZW5pbmdUbygkKGRvY3VtZW50KSk7XG5cdH0sXG5cblxuXHQvLyBJbml0aWFsaXplcyBpbnRlcm5hbCB2YXJpYWJsZXMgcmVsYXRlZCB0byB0aGVtaW5nXG5cdGluaXRUaGVtaW5nUHJvcHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0bSA9IHRoaXMub3B0KCd0aGVtZScpID8gJ3VpJyA6ICdmYyc7XG5cblx0XHR0aGlzLndpZGdldEhlYWRlckNsYXNzID0gdG0gKyAnLXdpZGdldC1oZWFkZXInO1xuXHRcdHRoaXMud2lkZ2V0Q29udGVudENsYXNzID0gdG0gKyAnLXdpZGdldC1jb250ZW50Jztcblx0XHR0aGlzLmhpZ2hsaWdodFN0YXRlQ2xhc3MgPSB0bSArICctc3RhdGUtaGlnaGxpZ2h0Jztcblx0fSxcblxuXG5cdC8qIEJ1c2luZXNzIEhvdXJzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBSZW5kZXJzIGJ1c2luZXNzLWhvdXJzIG9udG8gdGhlIHZpZXcuIEFzc3VtZXMgdXBkYXRlU2l6ZSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZC5cblx0cmVuZGVyQnVzaW5lc3NIb3VyczogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gc3ViY2xhc3NlcyBzaG91bGQgaW1wbGVtZW50XG5cdH0sXG5cblxuXHQvLyBVbnJlbmRlcnMgcHJldmlvdXNseS1yZW5kZXJlZCBidXNpbmVzcy1ob3Vyc1xuXHR1bnJlbmRlckJ1c2luZXNzSG91cnM6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxuXHR9LFxuXG5cblx0LyogTm93IEluZGljYXRvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gSW1tZWRpYXRlbHkgcmVuZGVyIHRoZSBjdXJyZW50IHRpbWUgaW5kaWNhdG9yIGFuZCBiZWdpbnMgcmUtcmVuZGVyaW5nIGl0IGF0IGFuIGludGVydmFsLFxuXHQvLyB3aGljaCBpcyBkZWZpbmVkIGJ5IHRoaXMuZ2V0Tm93SW5kaWNhdG9yVW5pdCgpLlxuXHQvLyBUT0RPOiBzb21laG93IGRvIHRoaXMgZm9yIHRoZSBjdXJyZW50IHdob2xlIGRheSdzIGJhY2tncm91bmQgdG9vXG5cdHN0YXJ0Tm93SW5kaWNhdG9yOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHZhciB1bml0O1xuXHRcdHZhciB1cGRhdGU7XG5cdFx0dmFyIGRlbGF5OyAvLyBtcyB3YWl0IHZhbHVlXG5cblx0XHRpZiAodGhpcy5vcHQoJ25vd0luZGljYXRvcicpKSB7XG5cdFx0XHR1bml0ID0gdGhpcy5nZXROb3dJbmRpY2F0b3JVbml0KCk7XG5cdFx0XHRpZiAodW5pdCkge1xuXHRcdFx0XHR1cGRhdGUgPSBwcm94eSh0aGlzLCAndXBkYXRlTm93SW5kaWNhdG9yJyk7IC8vIGJpbmQgdG8gYHRoaXNgXG5cblx0XHRcdFx0dGhpcy5pbml0aWFsTm93RGF0ZSA9IHRoaXMuY2FsZW5kYXIuZ2V0Tm93KCk7XG5cdFx0XHRcdHRoaXMuaW5pdGlhbE5vd1F1ZXJpZWRNcyA9ICtuZXcgRGF0ZSgpO1xuXHRcdFx0XHR0aGlzLnJlbmRlck5vd0luZGljYXRvcih0aGlzLmluaXRpYWxOb3dEYXRlKTtcblx0XHRcdFx0dGhpcy5pc05vd0luZGljYXRvclJlbmRlcmVkID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyB3YWl0IHVudGlsIHRoZSBiZWdpbm5pbmcgb2YgdGhlIG5leHQgaW50ZXJ2YWxcblx0XHRcdFx0ZGVsYXkgPSB0aGlzLmluaXRpYWxOb3dEYXRlLmNsb25lKCkuc3RhcnRPZih1bml0KS5hZGQoMSwgdW5pdCkgLSB0aGlzLmluaXRpYWxOb3dEYXRlO1xuXHRcdFx0XHR0aGlzLm5vd0luZGljYXRvclRpbWVvdXRJRCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0X3RoaXMubm93SW5kaWNhdG9yVGltZW91dElEID0gbnVsbDtcblx0XHRcdFx0XHR1cGRhdGUoKTtcblx0XHRcdFx0XHRkZWxheSA9ICttb21lbnQuZHVyYXRpb24oMSwgdW5pdCk7XG5cdFx0XHRcdFx0ZGVsYXkgPSBNYXRoLm1heCgxMDAsIGRlbGF5KTsgLy8gcHJldmVudCB0b28gZnJlcXVlbnRcblx0XHRcdFx0XHRfdGhpcy5ub3dJbmRpY2F0b3JJbnRlcnZhbElEID0gc2V0SW50ZXJ2YWwodXBkYXRlLCBkZWxheSk7IC8vIHVwZGF0ZSBldmVyeSBpbnRlcnZhbFxuXHRcdFx0XHR9LCBkZWxheSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gcmVyZW5kZXJzIHRoZSBub3cgaW5kaWNhdG9yLCBjb21wdXRpbmcgdGhlIG5ldyBjdXJyZW50IHRpbWUgZnJvbSB0aGUgYW1vdW50IG9mIHRpbWUgdGhhdCBoYXMgcGFzc2VkXG5cdC8vIHNpbmNlIHRoZSBpbml0aWFsIGdldE5vdyBjYWxsLlxuXHR1cGRhdGVOb3dJbmRpY2F0b3I6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLmlzTm93SW5kaWNhdG9yUmVuZGVyZWQpIHtcblx0XHRcdHRoaXMudW5yZW5kZXJOb3dJbmRpY2F0b3IoKTtcblx0XHRcdHRoaXMucmVuZGVyTm93SW5kaWNhdG9yKFxuXHRcdFx0XHR0aGlzLmluaXRpYWxOb3dEYXRlLmNsb25lKCkuYWRkKG5ldyBEYXRlKCkgLSB0aGlzLmluaXRpYWxOb3dRdWVyaWVkTXMpIC8vIGFkZCBtc1xuXHRcdFx0KTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBJbW1lZGlhdGVseSB1bnJlbmRlcnMgdGhlIHZpZXcncyBjdXJyZW50IHRpbWUgaW5kaWNhdG9yIGFuZCBzdG9wcyBhbnkgcmUtcmVuZGVyaW5nIHRpbWVycy5cblx0Ly8gV29uJ3QgY2F1c2Ugc2lkZSBlZmZlY3RzIGlmIGluZGljYXRvciBpc24ndCByZW5kZXJlZC5cblx0c3RvcE5vd0luZGljYXRvcjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuaXNOb3dJbmRpY2F0b3JSZW5kZXJlZCkge1xuXG5cdFx0XHRpZiAodGhpcy5ub3dJbmRpY2F0b3JUaW1lb3V0SUQpIHtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMubm93SW5kaWNhdG9yVGltZW91dElEKTtcblx0XHRcdFx0dGhpcy5ub3dJbmRpY2F0b3JUaW1lb3V0SUQgPSBudWxsO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMubm93SW5kaWNhdG9ySW50ZXJ2YWxJRCkge1xuXHRcdFx0XHRjbGVhclRpbWVvdXQodGhpcy5ub3dJbmRpY2F0b3JJbnRlcnZhbElEKTtcblx0XHRcdFx0dGhpcy5ub3dJbmRpY2F0b3JJbnRlcnZhbElEID0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy51bnJlbmRlck5vd0luZGljYXRvcigpO1xuXHRcdFx0dGhpcy5pc05vd0luZGljYXRvclJlbmRlcmVkID0gZmFsc2U7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gUmV0dXJucyBhIHN0cmluZyB1bml0LCBsaWtlICdzZWNvbmQnIG9yICdtaW51dGUnIHRoYXQgZGVmaW5lZCBob3cgb2Z0ZW4gdGhlIGN1cnJlbnQgdGltZSBpbmRpY2F0b3Jcblx0Ly8gc2hvdWxkIGJlIHJlZnJlc2hlZC4gSWYgc29tZXRoaW5nIGZhbHN5IGlzIHJldHVybmVkLCBubyB0aW1lIGluZGljYXRvciBpcyByZW5kZXJlZCBhdCBhbGwuXG5cdGdldE5vd0luZGljYXRvclVuaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxuXHR9LFxuXG5cblx0Ly8gUmVuZGVycyBhIGN1cnJlbnQgdGltZSBpbmRpY2F0b3IgYXQgdGhlIGdpdmVuIGRhdGV0aW1lXG5cdHJlbmRlck5vd0luZGljYXRvcjogZnVuY3Rpb24oZGF0ZSkge1xuXHRcdC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxuXHR9LFxuXG5cblx0Ly8gVW5kb2VzIHRoZSByZW5kZXJpbmcgYWN0aW9ucyBmcm9tIHJlbmRlck5vd0luZGljYXRvclxuXHR1bnJlbmRlck5vd0luZGljYXRvcjogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gc3ViY2xhc3NlcyBzaG91bGQgaW1wbGVtZW50XG5cdH0sXG5cblxuXHQvKiBEaW1lbnNpb25zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBSZWZyZXNoZXMgYW55dGhpbmcgZGVwZW5kYW50IHVwb24gc2l6aW5nIG9mIHRoZSBjb250YWluZXIgZWxlbWVudCBvZiB0aGUgZ3JpZFxuXHR1cGRhdGVTaXplOiBmdW5jdGlvbihpc1Jlc2l6ZSkge1xuXHRcdHZhciBzY3JvbGxTdGF0ZTtcblxuXHRcdGlmIChpc1Jlc2l6ZSkge1xuXHRcdFx0c2Nyb2xsU3RhdGUgPSB0aGlzLnF1ZXJ5U2Nyb2xsKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy51cGRhdGVIZWlnaHQoaXNSZXNpemUpO1xuXHRcdHRoaXMudXBkYXRlV2lkdGgoaXNSZXNpemUpO1xuXHRcdHRoaXMudXBkYXRlTm93SW5kaWNhdG9yKCk7XG5cblx0XHRpZiAoaXNSZXNpemUpIHtcblx0XHRcdHRoaXMuc2V0U2Nyb2xsKHNjcm9sbFN0YXRlKTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBSZWZyZXNoZXMgdGhlIGhvcml6b250YWwgZGltZW5zaW9ucyBvZiB0aGUgY2FsZW5kYXJcblx0dXBkYXRlV2lkdGg6IGZ1bmN0aW9uKGlzUmVzaXplKSB7XG5cdFx0Ly8gc3ViY2xhc3NlcyBzaG91bGQgaW1wbGVtZW50XG5cdH0sXG5cblxuXHQvLyBSZWZyZXNoZXMgdGhlIHZlcnRpY2FsIGRpbWVuc2lvbnMgb2YgdGhlIGNhbGVuZGFyXG5cdHVwZGF0ZUhlaWdodDogZnVuY3Rpb24oaXNSZXNpemUpIHtcblx0XHR2YXIgY2FsZW5kYXIgPSB0aGlzLmNhbGVuZGFyOyAvLyB3ZSBwb2xsIHRoZSBjYWxlbmRhciBmb3IgaGVpZ2h0IGluZm9ybWF0aW9uXG5cblx0XHR0aGlzLnNldEhlaWdodChcblx0XHRcdGNhbGVuZGFyLmdldFN1Z2dlc3RlZFZpZXdIZWlnaHQoKSxcblx0XHRcdGNhbGVuZGFyLmlzSGVpZ2h0QXV0bygpXG5cdFx0KTtcblx0fSxcblxuXG5cdC8vIFVwZGF0ZXMgdGhlIHZlcnRpY2FsIGRpbWVuc2lvbnMgb2YgdGhlIGNhbGVuZGFyIHRvIHRoZSBzcGVjaWZpZWQgaGVpZ2h0LlxuXHQvLyBpZiBgaXNBdXRvYCBpcyBzZXQgdG8gdHJ1ZSwgaGVpZ2h0IGJlY29tZXMgbWVyZWx5IGEgc3VnZ2VzdGlvbiBhbmQgdGhlIHZpZXcgc2hvdWxkIHVzZSBpdHMgXCJuYXR1cmFsXCIgaGVpZ2h0LlxuXHRzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCwgaXNBdXRvKSB7XG5cdFx0Ly8gc3ViY2xhc3NlcyBzaG91bGQgaW1wbGVtZW50XG5cdH0sXG5cblxuXHQvKiBTY3JvbGxlclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gQ29tcHV0ZXMgdGhlIGluaXRpYWwgcHJlLWNvbmZpZ3VyZWQgc2Nyb2xsIHN0YXRlIHByaW9yIHRvIGFsbG93aW5nIHRoZSB1c2VyIHRvIGNoYW5nZSBpdC5cblx0Ly8gR2l2ZW4gdGhlIHNjcm9sbCBzdGF0ZSBmcm9tIHRoZSBwcmV2aW91cyByZW5kZXJpbmcuIElmIGZpcnN0IHRpbWUgcmVuZGVyaW5nLCBnaXZlbiBudWxsLlxuXHRjb21wdXRlSW5pdGlhbFNjcm9sbDogZnVuY3Rpb24ocHJldmlvdXNTY3JvbGxTdGF0ZSkge1xuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cblx0Ly8gUmV0cmlldmVzIHRoZSB2aWV3J3MgY3VycmVudCBuYXR1cmFsIHNjcm9sbCBzdGF0ZS4gQ2FuIHJldHVybiBhbiBhcmJpdHJhcnkgZm9ybWF0LlxuXHRxdWVyeVNjcm9sbDogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gc3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudFxuXHR9LFxuXG5cblx0Ly8gU2V0cyB0aGUgdmlldydzIHNjcm9sbCBzdGF0ZS4gV2lsbCBhY2NlcHQgdGhlIHNhbWUgZm9ybWF0IGNvbXB1dGVJbml0aWFsU2Nyb2xsIGFuZCBxdWVyeVNjcm9sbCBwcm9kdWNlLlxuXHRzZXRTY3JvbGw6IGZ1bmN0aW9uKHNjcm9sbFN0YXRlKSB7XG5cdFx0Ly8gc3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudFxuXHR9LFxuXG5cblx0Ly8gU2V0cyB0aGUgc2Nyb2xsIHN0YXRlLCBtYWtpbmcgc3VyZSB0byBvdmVyY29tZSBhbnkgcHJlZGVmaW5lZCBzY3JvbGwgdmFsdWUgdGhlIGJyb3dzZXIgaGFzIGluIG1pbmRcblx0Zm9yY2VTY3JvbGw6IGZ1bmN0aW9uKHNjcm9sbFN0YXRlKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblxuXHRcdHRoaXMuc2V0U2Nyb2xsKHNjcm9sbFN0YXRlKTtcblx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0X3RoaXMuc2V0U2Nyb2xsKHNjcm9sbFN0YXRlKTtcblx0XHR9LCAwKTtcblx0fSxcblxuXG5cdC8qIEV2ZW50IEVsZW1lbnRzIC8gU2VnbWVudHNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIERvZXMgZXZlcnl0aGluZyBuZWNlc3NhcnkgdG8gZGlzcGxheSB0aGUgZ2l2ZW4gZXZlbnRzIG9udG8gdGhlIGN1cnJlbnQgdmlld1xuXHRkaXNwbGF5RXZlbnRzOiBmdW5jdGlvbihldmVudHMpIHtcblx0XHR2YXIgc2Nyb2xsU3RhdGUgPSB0aGlzLnF1ZXJ5U2Nyb2xsKCk7XG5cblx0XHR0aGlzLmNsZWFyRXZlbnRzKCk7XG5cdFx0dGhpcy5yZW5kZXJFdmVudHMoZXZlbnRzKTtcblx0XHR0aGlzLmlzRXZlbnRzUmVuZGVyZWQgPSB0cnVlO1xuXHRcdHRoaXMuc2V0U2Nyb2xsKHNjcm9sbFN0YXRlKTtcblx0XHR0aGlzLnRyaWdnZXJFdmVudFJlbmRlcigpO1xuXHR9LFxuXG5cblx0Ly8gRG9lcyBldmVyeXRoaW5nIG5lY2Vzc2FyeSB0byBjbGVhciB0aGUgdmlldydzIGN1cnJlbnRseS1yZW5kZXJlZCBldmVudHNcblx0Y2xlYXJFdmVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzY3JvbGxTdGF0ZTtcblxuXHRcdGlmICh0aGlzLmlzRXZlbnRzUmVuZGVyZWQpIHtcblxuXHRcdFx0Ly8gVE9ETzogb3B0aW1pemU6IGlmIHdlIGtub3cgdGhpcyBpcyBwYXJ0IG9mIGEgZGlzcGxheUV2ZW50cyBjYWxsLCBkb24ndCBxdWVyeVNjcm9sbC9zZXRTY3JvbGxcblx0XHRcdHNjcm9sbFN0YXRlID0gdGhpcy5xdWVyeVNjcm9sbCgpO1xuXG5cdFx0XHR0aGlzLnRyaWdnZXJFdmVudFVucmVuZGVyKCk7XG5cdFx0XHRpZiAodGhpcy5kZXN0cm95RXZlbnRzKSB7XG5cdFx0XHRcdHRoaXMuZGVzdHJveUV2ZW50cygpOyAvLyBUT0RPOiBkZXByZWNhdGVcblx0XHRcdH1cblx0XHRcdHRoaXMudW5yZW5kZXJFdmVudHMoKTtcblx0XHRcdHRoaXMuc2V0U2Nyb2xsKHNjcm9sbFN0YXRlKTtcblx0XHRcdHRoaXMuaXNFdmVudHNSZW5kZXJlZCA9IGZhbHNlO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIFJlbmRlcnMgdGhlIGV2ZW50cyBvbnRvIHRoZSB2aWV3LlxuXHRyZW5kZXJFdmVudHM6IGZ1bmN0aW9uKGV2ZW50cykge1xuXHRcdC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxuXHR9LFxuXG5cblx0Ly8gUmVtb3ZlcyBldmVudCBlbGVtZW50cyBmcm9tIHRoZSB2aWV3LlxuXHR1bnJlbmRlckV2ZW50czogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gc3ViY2xhc3NlcyBzaG91bGQgaW1wbGVtZW50XG5cdH0sXG5cblxuXHQvLyBTaWduYWxzIHRoYXQgYWxsIGV2ZW50cyBoYXZlIGJlZW4gcmVuZGVyZWRcblx0dHJpZ2dlckV2ZW50UmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnJlbmRlcmVkRXZlbnRTZWdFYWNoKGZ1bmN0aW9uKHNlZykge1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdldmVudEFmdGVyUmVuZGVyJywgc2VnLmV2ZW50LCBzZWcuZXZlbnQsIHNlZy5lbCk7XG5cdFx0fSk7XG5cdFx0dGhpcy50cmlnZ2VyKCdldmVudEFmdGVyQWxsUmVuZGVyJyk7XG5cdH0sXG5cblxuXHQvLyBTaWduYWxzIHRoYXQgYWxsIGV2ZW50IGVsZW1lbnRzIGFyZSBhYm91dCB0byBiZSByZW1vdmVkXG5cdHRyaWdnZXJFdmVudFVucmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnJlbmRlcmVkRXZlbnRTZWdFYWNoKGZ1bmN0aW9uKHNlZykge1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdldmVudERlc3Ryb3knLCBzZWcuZXZlbnQsIHNlZy5ldmVudCwgc2VnLmVsKTtcblx0XHR9KTtcblx0fSxcblxuXG5cdC8vIEdpdmVuIGFuIGV2ZW50IGFuZCB0aGUgZGVmYXVsdCBlbGVtZW50IHVzZWQgZm9yIHJlbmRlcmluZywgcmV0dXJucyB0aGUgZWxlbWVudCB0aGF0IHNob3VsZCBhY3R1YWxseSBiZSB1c2VkLlxuXHQvLyBCYXNpY2FsbHkgcnVucyBldmVudHMgYW5kIGVsZW1lbnRzIHRocm91Z2ggdGhlIGV2ZW50UmVuZGVyIGhvb2suXG5cdHJlc29sdmVFdmVudEVsOiBmdW5jdGlvbihldmVudCwgZWwpIHtcblx0XHR2YXIgY3VzdG9tID0gdGhpcy50cmlnZ2VyKCdldmVudFJlbmRlcicsIGV2ZW50LCBldmVudCwgZWwpO1xuXG5cdFx0aWYgKGN1c3RvbSA9PT0gZmFsc2UpIHsgLy8gbWVhbnMgZG9uJ3QgcmVuZGVyIGF0IGFsbFxuXHRcdFx0ZWwgPSBudWxsO1xuXHRcdH1cblx0XHRlbHNlIGlmIChjdXN0b20gJiYgY3VzdG9tICE9PSB0cnVlKSB7XG5cdFx0XHRlbCA9ICQoY3VzdG9tKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZWw7XG5cdH0sXG5cblxuXHQvLyBIaWRlcyBhbGwgcmVuZGVyZWQgZXZlbnQgc2VnbWVudHMgbGlua2VkIHRvIHRoZSBnaXZlbiBldmVudFxuXHRzaG93RXZlbnQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dGhpcy5yZW5kZXJlZEV2ZW50U2VnRWFjaChmdW5jdGlvbihzZWcpIHtcblx0XHRcdHNlZy5lbC5jc3MoJ3Zpc2liaWxpdHknLCAnJyk7XG5cdFx0fSwgZXZlbnQpO1xuXHR9LFxuXG5cblx0Ly8gU2hvd3MgYWxsIHJlbmRlcmVkIGV2ZW50IHNlZ21lbnRzIGxpbmtlZCB0byB0aGUgZ2l2ZW4gZXZlbnRcblx0aGlkZUV2ZW50OiBmdW5jdGlvbihldmVudCkge1xuXHRcdHRoaXMucmVuZGVyZWRFdmVudFNlZ0VhY2goZnVuY3Rpb24oc2VnKSB7XG5cdFx0XHRzZWcuZWwuY3NzKCd2aXNpYmlsaXR5JywgJ2hpZGRlbicpO1xuXHRcdH0sIGV2ZW50KTtcblx0fSxcblxuXG5cdC8vIEl0ZXJhdGVzIHRocm91Z2ggZXZlbnQgc2VnbWVudHMgdGhhdCBoYXZlIGJlZW4gcmVuZGVyZWQgKGhhdmUgYW4gZWwpLiBHb2VzIHRocm91Z2ggYWxsIGJ5IGRlZmF1bHQuXG5cdC8vIElmIHRoZSBvcHRpb25hbCBgZXZlbnRgIGFyZ3VtZW50IGlzIHNwZWNpZmllZCwgb25seSBpdGVyYXRlcyB0aHJvdWdoIHNlZ21lbnRzIGxpbmtlZCB0byB0aGF0IGV2ZW50LlxuXHQvLyBUaGUgYHRoaXNgIHZhbHVlIG9mIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aWxsIGJlIHRoZSB2aWV3LlxuXHRyZW5kZXJlZEV2ZW50U2VnRWFjaDogZnVuY3Rpb24oZnVuYywgZXZlbnQpIHtcblx0XHR2YXIgc2VncyA9IHRoaXMuZ2V0RXZlbnRTZWdzKCk7XG5cdFx0dmFyIGk7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKCFldmVudCB8fCBzZWdzW2ldLmV2ZW50Ll9pZCA9PT0gZXZlbnQuX2lkKSB7XG5cdFx0XHRcdGlmIChzZWdzW2ldLmVsKSB7XG5cdFx0XHRcdFx0ZnVuYy5jYWxsKHRoaXMsIHNlZ3NbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gUmV0cmlldmVzIGFsbCB0aGUgcmVuZGVyZWQgc2VnbWVudCBvYmplY3RzIGZvciB0aGUgdmlld1xuXHRnZXRFdmVudFNlZ3M6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcblx0XHRyZXR1cm4gW107XG5cdH0sXG5cblxuXHQvKiBFdmVudCBEcmFnLW4tRHJvcFxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gQ29tcHV0ZXMgaWYgdGhlIGdpdmVuIGV2ZW50IGlzIGFsbG93ZWQgdG8gYmUgZHJhZ2dlZCBieSB0aGUgdXNlclxuXHRpc0V2ZW50RHJhZ2dhYmxlOiBmdW5jdGlvbihldmVudCkge1xuXHRcdHJldHVybiB0aGlzLmlzRXZlbnRTdGFydEVkaXRhYmxlKGV2ZW50KTtcblx0fSxcblxuXG5cdGlzRXZlbnRTdGFydEVkaXRhYmxlOiBmdW5jdGlvbihldmVudCkge1xuXHRcdHJldHVybiBmaXJzdERlZmluZWQoXG5cdFx0XHRldmVudC5zdGFydEVkaXRhYmxlLFxuXHRcdFx0KGV2ZW50LnNvdXJjZSB8fCB7fSkuc3RhcnRFZGl0YWJsZSxcblx0XHRcdHRoaXMub3B0KCdldmVudFN0YXJ0RWRpdGFibGUnKSxcblx0XHRcdHRoaXMuaXNFdmVudEdlbmVyYWxseUVkaXRhYmxlKGV2ZW50KVxuXHRcdCk7XG5cdH0sXG5cblxuXHRpc0V2ZW50R2VuZXJhbGx5RWRpdGFibGU6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0cmV0dXJuIGZpcnN0RGVmaW5lZChcblx0XHRcdGV2ZW50LmVkaXRhYmxlLFxuXHRcdFx0KGV2ZW50LnNvdXJjZSB8fCB7fSkuZWRpdGFibGUsXG5cdFx0XHR0aGlzLm9wdCgnZWRpdGFibGUnKVxuXHRcdCk7XG5cdH0sXG5cblxuXHQvLyBNdXN0IGJlIGNhbGxlZCB3aGVuIGFuIGV2ZW50IGluIHRoZSB2aWV3IGlzIGRyb3BwZWQgb250byBuZXcgbG9jYXRpb24uXG5cdC8vIGBkcm9wTG9jYXRpb25gIGlzIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBuZXcgem9uZWQgc3RhcnQvZW5kL2FsbERheSB2YWx1ZXMgZm9yIHRoZSBldmVudC5cblx0cmVwb3J0RXZlbnREcm9wOiBmdW5jdGlvbihldmVudCwgZHJvcExvY2F0aW9uLCBsYXJnZVVuaXQsIGVsLCBldikge1xuXHRcdHZhciBjYWxlbmRhciA9IHRoaXMuY2FsZW5kYXI7XG5cdFx0dmFyIG11dGF0ZVJlc3VsdCA9IGNhbGVuZGFyLm11dGF0ZUV2ZW50KGV2ZW50LCBkcm9wTG9jYXRpb24sIGxhcmdlVW5pdCk7XG5cdFx0dmFyIHVuZG9GdW5jID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRtdXRhdGVSZXN1bHQudW5kbygpO1xuXHRcdFx0Y2FsZW5kYXIucmVwb3J0RXZlbnRDaGFuZ2UoKTtcblx0XHR9O1xuXG5cdFx0dGhpcy50cmlnZ2VyRXZlbnREcm9wKGV2ZW50LCBtdXRhdGVSZXN1bHQuZGF0ZURlbHRhLCB1bmRvRnVuYywgZWwsIGV2KTtcblx0XHRjYWxlbmRhci5yZXBvcnRFdmVudENoYW5nZSgpOyAvLyB3aWxsIHJlcmVuZGVyIGV2ZW50c1xuXHR9LFxuXG5cblx0Ly8gVHJpZ2dlcnMgZXZlbnQtZHJvcCBoYW5kbGVycyB0aGF0IGhhdmUgc3Vic2NyaWJlZCB2aWEgdGhlIEFQSVxuXHR0cmlnZ2VyRXZlbnREcm9wOiBmdW5jdGlvbihldmVudCwgZGF0ZURlbHRhLCB1bmRvRnVuYywgZWwsIGV2KSB7XG5cdFx0dGhpcy50cmlnZ2VyKCdldmVudERyb3AnLCBlbFswXSwgZXZlbnQsIGRhdGVEZWx0YSwgdW5kb0Z1bmMsIGV2LCB7fSk7IC8vIHt9ID0ganF1aSBkdW1teVxuXHR9LFxuXG5cblx0LyogRXh0ZXJuYWwgRWxlbWVudCBEcmFnLW4tRHJvcFxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gTXVzdCBiZSBjYWxsZWQgd2hlbiBhbiBleHRlcm5hbCBlbGVtZW50LCB2aWEgalF1ZXJ5IFVJLCBoYXMgYmVlbiBkcm9wcGVkIG9udG8gdGhlIGNhbGVuZGFyLlxuXHQvLyBgbWV0YWAgaXMgdGhlIHBhcnNlZCBkYXRhIHRoYXQgaGFzIGJlZW4gZW1iZWRkZWQgaW50byB0aGUgZHJhZ2dpbmcgZXZlbnQuXG5cdC8vIGBkcm9wTG9jYXRpb25gIGlzIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBuZXcgem9uZWQgc3RhcnQvZW5kL2FsbERheSB2YWx1ZXMgZm9yIHRoZSBldmVudC5cblx0cmVwb3J0RXh0ZXJuYWxEcm9wOiBmdW5jdGlvbihtZXRhLCBkcm9wTG9jYXRpb24sIGVsLCBldiwgdWkpIHtcblx0XHR2YXIgZXZlbnRQcm9wcyA9IG1ldGEuZXZlbnRQcm9wcztcblx0XHR2YXIgZXZlbnRJbnB1dDtcblx0XHR2YXIgZXZlbnQ7XG5cblx0XHQvLyBUcnkgdG8gYnVpbGQgYW4gZXZlbnQgb2JqZWN0IGFuZCByZW5kZXIgaXQuIFRPRE86IGRlY291cGxlIHRoZSB0d29cblx0XHRpZiAoZXZlbnRQcm9wcykge1xuXHRcdFx0ZXZlbnRJbnB1dCA9ICQuZXh0ZW5kKHt9LCBldmVudFByb3BzLCBkcm9wTG9jYXRpb24pO1xuXHRcdFx0ZXZlbnQgPSB0aGlzLmNhbGVuZGFyLnJlbmRlckV2ZW50KGV2ZW50SW5wdXQsIG1ldGEuc3RpY2spWzBdOyAvLyByZW5kZXJFdmVudCByZXR1cm5zIGFuIGFycmF5XG5cdFx0fVxuXG5cdFx0dGhpcy50cmlnZ2VyRXh0ZXJuYWxEcm9wKGV2ZW50LCBkcm9wTG9jYXRpb24sIGVsLCBldiwgdWkpO1xuXHR9LFxuXG5cblx0Ly8gVHJpZ2dlcnMgZXh0ZXJuYWwtZHJvcCBoYW5kbGVycyB0aGF0IGhhdmUgc3Vic2NyaWJlZCB2aWEgdGhlIEFQSVxuXHR0cmlnZ2VyRXh0ZXJuYWxEcm9wOiBmdW5jdGlvbihldmVudCwgZHJvcExvY2F0aW9uLCBlbCwgZXYsIHVpKSB7XG5cblx0XHQvLyB0cmlnZ2VyICdkcm9wJyByZWdhcmRsZXNzIG9mIHdoZXRoZXIgZWxlbWVudCByZXByZXNlbnRzIGFuIGV2ZW50XG5cdFx0dGhpcy50cmlnZ2VyKCdkcm9wJywgZWxbMF0sIGRyb3BMb2NhdGlvbi5zdGFydCwgZXYsIHVpKTtcblxuXHRcdGlmIChldmVudCkge1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdldmVudFJlY2VpdmUnLCBudWxsLCBldmVudCk7IC8vIHNpZ25hbCBhbiBleHRlcm5hbCBldmVudCBsYW5kZWRcblx0XHR9XG5cdH0sXG5cblxuXHQvKiBEcmFnLW4tRHJvcCBSZW5kZXJpbmcgKGZvciBib3RoIGV2ZW50cyBhbmQgZXh0ZXJuYWwgZWxlbWVudHMpXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBSZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgYSBldmVudCBvciBleHRlcm5hbC1lbGVtZW50IGRyYWcgb3ZlciB0aGUgZ2l2ZW4gZHJvcCB6b25lLlxuXHQvLyBJZiBhbiBleHRlcm5hbC1lbGVtZW50LCBzZWcgd2lsbCBiZSBgbnVsbGAuXG5cdC8vIE11c3QgcmV0dXJuIGVsZW1lbnRzIHVzZWQgZm9yIGFueSBtb2NrIGV2ZW50cy5cblx0cmVuZGVyRHJhZzogZnVuY3Rpb24oZHJvcExvY2F0aW9uLCBzZWcpIHtcblx0XHQvLyBzdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50XG5cdH0sXG5cblxuXHQvLyBVbnJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhbiBldmVudCBvciBleHRlcm5hbC1lbGVtZW50IGJlaW5nIGRyYWdnZWQuXG5cdHVucmVuZGVyRHJhZzogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gc3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudFxuXHR9LFxuXG5cblx0LyogRXZlbnQgUmVzaXppbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIENvbXB1dGVzIGlmIHRoZSBnaXZlbiBldmVudCBpcyBhbGxvd2VkIHRvIGJlIHJlc2l6ZWQgZnJvbSBpdHMgc3RhcnRpbmcgZWRnZVxuXHRpc0V2ZW50UmVzaXphYmxlRnJvbVN0YXJ0OiBmdW5jdGlvbihldmVudCkge1xuXHRcdHJldHVybiB0aGlzLm9wdCgnZXZlbnRSZXNpemFibGVGcm9tU3RhcnQnKSAmJiB0aGlzLmlzRXZlbnRSZXNpemFibGUoZXZlbnQpO1xuXHR9LFxuXG5cblx0Ly8gQ29tcHV0ZXMgaWYgdGhlIGdpdmVuIGV2ZW50IGlzIGFsbG93ZWQgdG8gYmUgcmVzaXplZCBmcm9tIGl0cyBlbmRpbmcgZWRnZVxuXHRpc0V2ZW50UmVzaXphYmxlRnJvbUVuZDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRyZXR1cm4gdGhpcy5pc0V2ZW50UmVzaXphYmxlKGV2ZW50KTtcblx0fSxcblxuXG5cdC8vIENvbXB1dGVzIGlmIHRoZSBnaXZlbiBldmVudCBpcyBhbGxvd2VkIHRvIGJlIHJlc2l6ZWQgYnkgdGhlIHVzZXIgYXQgYWxsXG5cdGlzRXZlbnRSZXNpemFibGU6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHNvdXJjZSA9IGV2ZW50LnNvdXJjZSB8fCB7fTtcblxuXHRcdHJldHVybiBmaXJzdERlZmluZWQoXG5cdFx0XHRldmVudC5kdXJhdGlvbkVkaXRhYmxlLFxuXHRcdFx0c291cmNlLmR1cmF0aW9uRWRpdGFibGUsXG5cdFx0XHR0aGlzLm9wdCgnZXZlbnREdXJhdGlvbkVkaXRhYmxlJyksXG5cdFx0XHRldmVudC5lZGl0YWJsZSxcblx0XHRcdHNvdXJjZS5lZGl0YWJsZSxcblx0XHRcdHRoaXMub3B0KCdlZGl0YWJsZScpXG5cdFx0KTtcblx0fSxcblxuXG5cdC8vIE11c3QgYmUgY2FsbGVkIHdoZW4gYW4gZXZlbnQgaW4gdGhlIHZpZXcgaGFzIGJlZW4gcmVzaXplZCB0byBhIG5ldyBsZW5ndGhcblx0cmVwb3J0RXZlbnRSZXNpemU6IGZ1bmN0aW9uKGV2ZW50LCByZXNpemVMb2NhdGlvbiwgbGFyZ2VVbml0LCBlbCwgZXYpIHtcblx0XHR2YXIgY2FsZW5kYXIgPSB0aGlzLmNhbGVuZGFyO1xuXHRcdHZhciBtdXRhdGVSZXN1bHQgPSBjYWxlbmRhci5tdXRhdGVFdmVudChldmVudCwgcmVzaXplTG9jYXRpb24sIGxhcmdlVW5pdCk7XG5cdFx0dmFyIHVuZG9GdW5jID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRtdXRhdGVSZXN1bHQudW5kbygpO1xuXHRcdFx0Y2FsZW5kYXIucmVwb3J0RXZlbnRDaGFuZ2UoKTtcblx0XHR9O1xuXG5cdFx0dGhpcy50cmlnZ2VyRXZlbnRSZXNpemUoZXZlbnQsIG11dGF0ZVJlc3VsdC5kdXJhdGlvbkRlbHRhLCB1bmRvRnVuYywgZWwsIGV2KTtcblx0XHRjYWxlbmRhci5yZXBvcnRFdmVudENoYW5nZSgpOyAvLyB3aWxsIHJlcmVuZGVyIGV2ZW50c1xuXHR9LFxuXG5cblx0Ly8gVHJpZ2dlcnMgZXZlbnQtcmVzaXplIGhhbmRsZXJzIHRoYXQgaGF2ZSBzdWJzY3JpYmVkIHZpYSB0aGUgQVBJXG5cdHRyaWdnZXJFdmVudFJlc2l6ZTogZnVuY3Rpb24oZXZlbnQsIGR1cmF0aW9uRGVsdGEsIHVuZG9GdW5jLCBlbCwgZXYpIHtcblx0XHR0aGlzLnRyaWdnZXIoJ2V2ZW50UmVzaXplJywgZWxbMF0sIGV2ZW50LCBkdXJhdGlvbkRlbHRhLCB1bmRvRnVuYywgZXYsIHt9KTsgLy8ge30gPSBqcXVpIGR1bW15XG5cdH0sXG5cblxuXHQvKiBTZWxlY3Rpb24gKHRpbWUgcmFuZ2UpXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBTZWxlY3RzIGEgZGF0ZSBzcGFuIG9uIHRoZSB2aWV3LiBgc3RhcnRgIGFuZCBgZW5kYCBhcmUgYm90aCBNb21lbnRzLlxuXHQvLyBgZXZgIGlzIHRoZSBuYXRpdmUgbW91c2UgZXZlbnQgdGhhdCBiZWdpbiB0aGUgaW50ZXJhY3Rpb24uXG5cdHNlbGVjdDogZnVuY3Rpb24oc3BhbiwgZXYpIHtcblx0XHR0aGlzLnVuc2VsZWN0KGV2KTtcblx0XHR0aGlzLnJlbmRlclNlbGVjdGlvbihzcGFuKTtcblx0XHR0aGlzLnJlcG9ydFNlbGVjdGlvbihzcGFuLCBldik7XG5cdH0sXG5cblxuXHQvLyBSZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgdGhlIHNlbGVjdGlvblxuXHRyZW5kZXJTZWxlY3Rpb246IGZ1bmN0aW9uKHNwYW4pIHtcblx0XHQvLyBzdWJjbGFzc2VzIHNob3VsZCBpbXBsZW1lbnRcblx0fSxcblxuXG5cdC8vIENhbGxlZCB3aGVuIGEgbmV3IHNlbGVjdGlvbiBpcyBtYWRlLiBVcGRhdGVzIGludGVybmFsIHN0YXRlIGFuZCB0cmlnZ2VycyBoYW5kbGVycy5cblx0cmVwb3J0U2VsZWN0aW9uOiBmdW5jdGlvbihzcGFuLCBldikge1xuXHRcdHRoaXMuaXNTZWxlY3RlZCA9IHRydWU7XG5cdFx0dGhpcy50cmlnZ2VyU2VsZWN0KHNwYW4sIGV2KTtcblx0fSxcblxuXG5cdC8vIFRyaWdnZXJzIGhhbmRsZXJzIHRvICdzZWxlY3QnXG5cdHRyaWdnZXJTZWxlY3Q6IGZ1bmN0aW9uKHNwYW4sIGV2KSB7XG5cdFx0dGhpcy50cmlnZ2VyKFxuXHRcdFx0J3NlbGVjdCcsXG5cdFx0XHRudWxsLFxuXHRcdFx0dGhpcy5jYWxlbmRhci5hcHBseVRpbWV6b25lKHNwYW4uc3RhcnQpLCAvLyBjb252ZXJ0IHRvIGNhbGVuZGFyJ3MgdHogZm9yIGV4dGVybmFsIEFQSVxuXHRcdFx0dGhpcy5jYWxlbmRhci5hcHBseVRpbWV6b25lKHNwYW4uZW5kKSwgLy8gXCJcblx0XHRcdGV2XG5cdFx0KTtcblx0fSxcblxuXG5cdC8vIFVuZG9lcyBhIHNlbGVjdGlvbi4gdXBkYXRlcyBpbiB0aGUgaW50ZXJuYWwgc3RhdGUgYW5kIHRyaWdnZXJzIGhhbmRsZXJzLlxuXHQvLyBgZXZgIGlzIHRoZSBuYXRpdmUgbW91c2UgZXZlbnQgdGhhdCBiZWdhbiB0aGUgaW50ZXJhY3Rpb24uXG5cdHVuc2VsZWN0OiBmdW5jdGlvbihldikge1xuXHRcdGlmICh0aGlzLmlzU2VsZWN0ZWQpIHtcblx0XHRcdHRoaXMuaXNTZWxlY3RlZCA9IGZhbHNlO1xuXHRcdFx0aWYgKHRoaXMuZGVzdHJveVNlbGVjdGlvbikge1xuXHRcdFx0XHR0aGlzLmRlc3Ryb3lTZWxlY3Rpb24oKTsgLy8gVE9ETzogZGVwcmVjYXRlXG5cdFx0XHR9XG5cdFx0XHR0aGlzLnVucmVuZGVyU2VsZWN0aW9uKCk7XG5cdFx0XHR0aGlzLnRyaWdnZXIoJ3Vuc2VsZWN0JywgbnVsbCwgZXYpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIHNlbGVjdGlvblxuXHR1bnJlbmRlclNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gc3ViY2xhc3NlcyBzaG91bGQgaW1wbGVtZW50XG5cdH0sXG5cblxuXHQvKiBFdmVudCBTZWxlY3Rpb25cblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdHNlbGVjdEV2ZW50OiBmdW5jdGlvbihldmVudCkge1xuXHRcdGlmICghdGhpcy5zZWxlY3RlZEV2ZW50IHx8IHRoaXMuc2VsZWN0ZWRFdmVudCAhPT0gZXZlbnQpIHtcblx0XHRcdHRoaXMudW5zZWxlY3RFdmVudCgpO1xuXHRcdFx0dGhpcy5yZW5kZXJlZEV2ZW50U2VnRWFjaChmdW5jdGlvbihzZWcpIHtcblx0XHRcdFx0c2VnLmVsLmFkZENsYXNzKCdmYy1zZWxlY3RlZCcpO1xuXHRcdFx0fSwgZXZlbnQpO1xuXHRcdFx0dGhpcy5zZWxlY3RlZEV2ZW50ID0gZXZlbnQ7XG5cdFx0fVxuXHR9LFxuXG5cblx0dW5zZWxlY3RFdmVudDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuc2VsZWN0ZWRFdmVudCkge1xuXHRcdFx0dGhpcy5yZW5kZXJlZEV2ZW50U2VnRWFjaChmdW5jdGlvbihzZWcpIHtcblx0XHRcdFx0c2VnLmVsLnJlbW92ZUNsYXNzKCdmYy1zZWxlY3RlZCcpO1xuXHRcdFx0fSwgdGhpcy5zZWxlY3RlZEV2ZW50KTtcblx0XHRcdHRoaXMuc2VsZWN0ZWRFdmVudCA9IG51bGw7XG5cdFx0fVxuXHR9LFxuXG5cblx0aXNFdmVudFNlbGVjdGVkOiBmdW5jdGlvbihldmVudCkge1xuXHRcdC8vIGV2ZW50IHJlZmVyZW5jZXMgbWlnaHQgY2hhbmdlIG9uIHJlZmV0Y2hFdmVudHMoKSwgd2hpbGUgc2VsZWN0ZWRFdmVudCBkb2Vzbid0LFxuXHRcdC8vIHNvIGNvbXBhcmUgSURzXG5cdFx0cmV0dXJuIHRoaXMuc2VsZWN0ZWRFdmVudCAmJiB0aGlzLnNlbGVjdGVkRXZlbnQuX2lkID09PSBldmVudC5faWQ7XG5cdH0sXG5cblxuXHQvKiBNb3VzZSAvIFRvdWNoIFVuc2VsZWN0aW5nICh0aW1lIHJhbmdlICYgZXZlbnQgdW5zZWxlY3Rpb24pXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cdC8vIFRPRE86IG1vdmUgY29uc2lzdGVudGx5IHRvIGRvd24vc3RhcnQgb3IgdXAvZW5kP1xuXHQvLyBUT0RPOiBkb24ndCBraWxsIHByZXZpb3VzIHNlbGVjdGlvbiBpZiB0b3VjaCBzY3JvbGxpbmdcblxuXG5cdGhhbmRsZURvY3VtZW50TW91c2Vkb3duOiBmdW5jdGlvbihldikge1xuXHRcdGlmIChpc1ByaW1hcnlNb3VzZUJ1dHRvbihldikpIHtcblx0XHRcdHRoaXMucHJvY2Vzc1Vuc2VsZWN0KGV2KTtcblx0XHR9XG5cdH0sXG5cblxuXHRwcm9jZXNzVW5zZWxlY3Q6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0dGhpcy5wcm9jZXNzUmFuZ2VVbnNlbGVjdChldik7XG5cdFx0dGhpcy5wcm9jZXNzRXZlbnRVbnNlbGVjdChldik7XG5cdH0sXG5cblxuXHRwcm9jZXNzUmFuZ2VVbnNlbGVjdDogZnVuY3Rpb24oZXYpIHtcblx0XHR2YXIgaWdub3JlO1xuXG5cdFx0Ly8gaXMgdGhlcmUgYSB0aW1lLXJhbmdlIHNlbGVjdGlvbj9cblx0XHRpZiAodGhpcy5pc1NlbGVjdGVkICYmIHRoaXMub3B0KCd1bnNlbGVjdEF1dG8nKSkge1xuXHRcdFx0Ly8gb25seSB1bnNlbGVjdCBpZiB0aGUgY2xpY2tlZCBlbGVtZW50IGlzIG5vdCBpZGVudGljYWwgdG8gb3IgaW5zaWRlIG9mIGFuICd1bnNlbGVjdENhbmNlbCcgZWxlbWVudFxuXHRcdFx0aWdub3JlID0gdGhpcy5vcHQoJ3Vuc2VsZWN0Q2FuY2VsJyk7XG5cdFx0XHRpZiAoIWlnbm9yZSB8fCAhJChldi50YXJnZXQpLmNsb3Nlc3QoaWdub3JlKS5sZW5ndGgpIHtcblx0XHRcdFx0dGhpcy51bnNlbGVjdChldik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cblx0cHJvY2Vzc0V2ZW50VW5zZWxlY3Q6IGZ1bmN0aW9uKGV2KSB7XG5cdFx0aWYgKHRoaXMuc2VsZWN0ZWRFdmVudCkge1xuXHRcdFx0aWYgKCEkKGV2LnRhcmdldCkuY2xvc2VzdCgnLmZjLXNlbGVjdGVkJykubGVuZ3RoKSB7XG5cdFx0XHRcdHRoaXMudW5zZWxlY3RFdmVudCgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXG5cdC8qIERheSBDbGlja1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gVHJpZ2dlcnMgaGFuZGxlcnMgdG8gJ2RheUNsaWNrJ1xuXHQvLyBTcGFuIGhhcyBzdGFydC9lbmQgb2YgdGhlIGNsaWNrZWQgYXJlYS4gT25seSB0aGUgc3RhcnQgaXMgdXNlZnVsLlxuXHR0cmlnZ2VyRGF5Q2xpY2s6IGZ1bmN0aW9uKHNwYW4sIGRheUVsLCBldikge1xuXHRcdHRoaXMudHJpZ2dlcihcblx0XHRcdCdkYXlDbGljaycsXG5cdFx0XHRkYXlFbCxcblx0XHRcdHRoaXMuY2FsZW5kYXIuYXBwbHlUaW1lem9uZShzcGFuLnN0YXJ0KSwgLy8gY29udmVydCB0byBjYWxlbmRhcidzIHRpbWV6b25lIGZvciBleHRlcm5hbCBBUElcblx0XHRcdGV2XG5cdFx0KTtcblx0fSxcblxuXG5cdC8qIERhdGUgVXRpbHNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIEluaXRpYWxpemVzIGludGVybmFsIHZhcmlhYmxlcyByZWxhdGVkIHRvIGNhbGN1bGF0aW5nIGhpZGRlbiBkYXlzLW9mLXdlZWtcblx0aW5pdEhpZGRlbkRheXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBoaWRkZW5EYXlzID0gdGhpcy5vcHQoJ2hpZGRlbkRheXMnKSB8fCBbXTsgLy8gYXJyYXkgb2YgZGF5LW9mLXdlZWsgaW5kaWNlcyB0aGF0IGFyZSBoaWRkZW5cblx0XHR2YXIgaXNIaWRkZW5EYXlIYXNoID0gW107IC8vIGlzIHRoZSBkYXktb2Ytd2VlayBoaWRkZW4/IChoYXNoIHdpdGggZGF5LW9mLXdlZWstaW5kZXggLT4gYm9vbClcblx0XHR2YXIgZGF5Q250ID0gMDtcblx0XHR2YXIgaTtcblxuXHRcdGlmICh0aGlzLm9wdCgnd2Vla2VuZHMnKSA9PT0gZmFsc2UpIHtcblx0XHRcdGhpZGRlbkRheXMucHVzaCgwLCA2KTsgLy8gMD1zdW5kYXksIDY9c2F0dXJkYXlcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdCEoaXNIaWRkZW5EYXlIYXNoW2ldID0gJC5pbkFycmF5KGksIGhpZGRlbkRheXMpICE9PSAtMSlcblx0XHRcdCkge1xuXHRcdFx0XHRkYXlDbnQrKztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIWRheUNudCkge1xuXHRcdFx0dGhyb3cgJ2ludmFsaWQgaGlkZGVuRGF5cyc7IC8vIGFsbCBkYXlzIHdlcmUgaGlkZGVuPyBiYWQuXG5cdFx0fVxuXG5cdFx0dGhpcy5pc0hpZGRlbkRheUhhc2ggPSBpc0hpZGRlbkRheUhhc2g7XG5cdH0sXG5cblxuXHQvLyBJcyB0aGUgY3VycmVudCBkYXkgaGlkZGVuP1xuXHQvLyBgZGF5YCBpcyBhIGRheS1vZi13ZWVrIGluZGV4ICgwLTYpLCBvciBhIE1vbWVudFxuXHRpc0hpZGRlbkRheTogZnVuY3Rpb24oZGF5KSB7XG5cdFx0aWYgKG1vbWVudC5pc01vbWVudChkYXkpKSB7XG5cdFx0XHRkYXkgPSBkYXkuZGF5KCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmlzSGlkZGVuRGF5SGFzaFtkYXldO1xuXHR9LFxuXG5cblx0Ly8gSW5jcmVtZW50aW5nIHRoZSBjdXJyZW50IGRheSB1bnRpbCBpdCBpcyBubyBsb25nZXIgYSBoaWRkZW4gZGF5LCByZXR1cm5pbmcgYSBjb3B5LlxuXHQvLyBJZiB0aGUgaW5pdGlhbCB2YWx1ZSBvZiBgZGF0ZWAgaXMgbm90IGEgaGlkZGVuIGRheSwgZG9uJ3QgZG8gYW55dGhpbmcuXG5cdC8vIFBhc3MgYGlzRXhjbHVzaXZlYCBhcyBgdHJ1ZWAgaWYgeW91IGFyZSBkZWFsaW5nIHdpdGggYW4gZW5kIGRhdGUuXG5cdC8vIGBpbmNgIGRlZmF1bHRzIHRvIGAxYCAoaW5jcmVtZW50IG9uZSBkYXkgZm9yd2FyZCBlYWNoIHRpbWUpXG5cdHNraXBIaWRkZW5EYXlzOiBmdW5jdGlvbihkYXRlLCBpbmMsIGlzRXhjbHVzaXZlKSB7XG5cdFx0dmFyIG91dCA9IGRhdGUuY2xvbmUoKTtcblx0XHRpbmMgPSBpbmMgfHwgMTtcblx0XHR3aGlsZSAoXG5cdFx0XHR0aGlzLmlzSGlkZGVuRGF5SGFzaFsob3V0LmRheSgpICsgKGlzRXhjbHVzaXZlID8gaW5jIDogMCkgKyA3KSAlIDddXG5cdFx0KSB7XG5cdFx0XHRvdXQuYWRkKGluYywgJ2RheXMnKTtcblx0XHR9XG5cdFx0cmV0dXJuIG91dDtcblx0fSxcblxuXG5cdC8vIFJldHVybnMgdGhlIGRhdGUgcmFuZ2Ugb2YgdGhlIGZ1bGwgZGF5cyB0aGUgZ2l2ZW4gcmFuZ2UgdmlzdWFsbHkgYXBwZWFycyB0byBvY2N1cHkuXG5cdC8vIFJldHVybnMgYSBuZXcgcmFuZ2Ugb2JqZWN0LlxuXHRjb21wdXRlRGF5UmFuZ2U6IGZ1bmN0aW9uKHJhbmdlKSB7XG5cdFx0dmFyIHN0YXJ0RGF5ID0gcmFuZ2Uuc3RhcnQuY2xvbmUoKS5zdHJpcFRpbWUoKTsgLy8gdGhlIGJlZ2lubmluZyBvZiB0aGUgZGF5IHRoZSByYW5nZSBzdGFydHNcblx0XHR2YXIgZW5kID0gcmFuZ2UuZW5kO1xuXHRcdHZhciBlbmREYXkgPSBudWxsO1xuXHRcdHZhciBlbmRUaW1lTVM7XG5cblx0XHRpZiAoZW5kKSB7XG5cdFx0XHRlbmREYXkgPSBlbmQuY2xvbmUoKS5zdHJpcFRpbWUoKTsgLy8gdGhlIGJlZ2lubmluZyBvZiB0aGUgZGF5IHRoZSByYW5nZSBleGNsdXNpdmVseSBlbmRzXG5cdFx0XHRlbmRUaW1lTVMgPSArZW5kLnRpbWUoKTsgLy8gIyBvZiBtaWxsaXNlY29uZHMgaW50byBgZW5kRGF5YFxuXG5cdFx0XHQvLyBJZiB0aGUgZW5kIHRpbWUgaXMgYWN0dWFsbHkgaW5jbHVzaXZlbHkgcGFydCBvZiB0aGUgbmV4dCBkYXkgYW5kIGlzIGVxdWFsIHRvIG9yXG5cdFx0XHQvLyBiZXlvbmQgdGhlIG5leHQgZGF5IHRocmVzaG9sZCwgYWRqdXN0IHRoZSBlbmQgdG8gYmUgdGhlIGV4Y2x1c2l2ZSBlbmQgb2YgYGVuZERheWAuXG5cdFx0XHQvLyBPdGhlcndpc2UsIGxlYXZpbmcgaXQgYXMgaW5jbHVzaXZlIHdpbGwgY2F1c2UgaXQgdG8gZXhjbHVkZSBgZW5kRGF5YC5cblx0XHRcdGlmIChlbmRUaW1lTVMgJiYgZW5kVGltZU1TID49IHRoaXMubmV4dERheVRocmVzaG9sZCkge1xuXHRcdFx0XHRlbmREYXkuYWRkKDEsICdkYXlzJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSWYgbm8gZW5kIHdhcyBzcGVjaWZpZWQsIG9yIGlmIGl0IGlzIHdpdGhpbiBgc3RhcnREYXlgIGJ1dCBub3QgcGFzdCBuZXh0RGF5VGhyZXNob2xkLFxuXHRcdC8vIGFzc2lnbiB0aGUgZGVmYXVsdCBkdXJhdGlvbiBvZiBvbmUgZGF5LlxuXHRcdGlmICghZW5kIHx8IGVuZERheSA8PSBzdGFydERheSkge1xuXHRcdFx0ZW5kRGF5ID0gc3RhcnREYXkuY2xvbmUoKS5hZGQoMSwgJ2RheXMnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4geyBzdGFydDogc3RhcnREYXksIGVuZDogZW5kRGF5IH07XG5cdH0sXG5cblxuXHQvLyBEb2VzIHRoZSBnaXZlbiBldmVudCB2aXN1YWxseSBhcHBlYXIgdG8gb2NjdXB5IG1vcmUgdGhhbiBvbmUgZGF5P1xuXHRpc011bHRpRGF5RXZlbnQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHJhbmdlID0gdGhpcy5jb21wdXRlRGF5UmFuZ2UoZXZlbnQpOyAvLyBldmVudCBpcyByYW5nZS1pc2hcblxuXHRcdHJldHVybiByYW5nZS5lbmQuZGlmZihyYW5nZS5zdGFydCwgJ2RheXMnKSA+IDE7XG5cdH1cblxufSk7XG5cbjs7XG5cbi8qXG5FbWJvZGllcyBhIGRpdiB0aGF0IGhhcyBwb3RlbnRpYWwgc2Nyb2xsYmFyc1xuKi9cbnZhciBTY3JvbGxlciA9IEZDLlNjcm9sbGVyID0gQ2xhc3MuZXh0ZW5kKHtcblxuXHRlbDogbnVsbCwgLy8gdGhlIGd1YXJhbnRlZWQgb3V0ZXIgZWxlbWVudFxuXHRzY3JvbGxFbDogbnVsbCwgLy8gdGhlIGVsZW1lbnQgd2l0aCB0aGUgc2Nyb2xsYmFyc1xuXHRvdmVyZmxvd1g6IG51bGwsXG5cdG92ZXJmbG93WTogbnVsbCxcblxuXG5cdGNvbnN0cnVjdG9yOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0dGhpcy5vdmVyZmxvd1ggPSBvcHRpb25zLm92ZXJmbG93WCB8fCBvcHRpb25zLm92ZXJmbG93IHx8ICdhdXRvJztcblx0XHR0aGlzLm92ZXJmbG93WSA9IG9wdGlvbnMub3ZlcmZsb3dZIHx8IG9wdGlvbnMub3ZlcmZsb3cgfHwgJ2F1dG8nO1xuXHR9LFxuXG5cblx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmVsID0gdGhpcy5yZW5kZXJFbCgpO1xuXHRcdHRoaXMuYXBwbHlPdmVyZmxvdygpO1xuXHR9LFxuXG5cblx0cmVuZGVyRWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAodGhpcy5zY3JvbGxFbCA9ICQoJzxkaXYgY2xhc3M9XCJmYy1zY3JvbGxlclwiPjwvZGl2PicpKTtcblx0fSxcblxuXG5cdC8vIHNldHMgdG8gbmF0dXJhbCBoZWlnaHQsIHVubG9ja3Mgb3ZlcmZsb3dcblx0Y2xlYXI6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuc2V0SGVpZ2h0KCdhdXRvJyk7XG5cdFx0dGhpcy5hcHBseU92ZXJmbG93KCk7XG5cdH0sXG5cblxuXHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmVsLnJlbW92ZSgpO1xuXHR9LFxuXG5cblx0Ly8gT3ZlcmZsb3dcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5cdGFwcGx5T3ZlcmZsb3c6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuc2Nyb2xsRWwuY3NzKHtcblx0XHRcdCdvdmVyZmxvdy14JzogdGhpcy5vdmVyZmxvd1gsXG5cdFx0XHQnb3ZlcmZsb3cteSc6IHRoaXMub3ZlcmZsb3dZXG5cdFx0fSk7XG5cdH0sXG5cblxuXHQvLyBDYXVzZXMgYW55ICdhdXRvJyBvdmVyZmxvdyB2YWx1ZXMgdG8gcmVzb2x2ZXMgdG8gJ3Njcm9sbCcgb3IgJ2hpZGRlbicuXG5cdC8vIFVzZWZ1bCBmb3IgcHJlc2VydmluZyBzY3JvbGxiYXIgd2lkdGhzIHJlZ2FyZGxlc3Mgb2YgZnV0dXJlIHJlc2l6ZXMuXG5cdC8vIENhbiBwYXNzIGluIHNjcm9sbGJhcldpZHRocyBmb3Igb3B0aW1pemF0aW9uLlxuXHRsb2NrT3ZlcmZsb3c6IGZ1bmN0aW9uKHNjcm9sbGJhcldpZHRocykge1xuXHRcdHZhciBvdmVyZmxvd1ggPSB0aGlzLm92ZXJmbG93WDtcblx0XHR2YXIgb3ZlcmZsb3dZID0gdGhpcy5vdmVyZmxvd1k7XG5cblx0XHRzY3JvbGxiYXJXaWR0aHMgPSBzY3JvbGxiYXJXaWR0aHMgfHwgdGhpcy5nZXRTY3JvbGxiYXJXaWR0aHMoKTtcblxuXHRcdGlmIChvdmVyZmxvd1ggPT09ICdhdXRvJykge1xuXHRcdFx0b3ZlcmZsb3dYID0gKFxuXHRcdFx0XHRcdHNjcm9sbGJhcldpZHRocy50b3AgfHwgc2Nyb2xsYmFyV2lkdGhzLmJvdHRvbSB8fCAvLyBob3Jpem9udGFsIHNjcm9sbGJhcnM/XG5cdFx0XHRcdFx0Ly8gT1Igc2Nyb2xsaW5nIHBhbmUgd2l0aCBtYXNzbGVzcyBzY3JvbGxiYXJzP1xuXHRcdFx0XHRcdHRoaXMuc2Nyb2xsRWxbMF0uc2Nyb2xsV2lkdGggLSAxID4gdGhpcy5zY3JvbGxFbFswXS5jbGllbnRXaWR0aFxuXHRcdFx0XHRcdFx0Ly8gc3VidHJhY3QgMSBiZWNhdXNlIG9mIElFIG9mZi1ieS1vbmUgaXNzdWVcblx0XHRcdFx0KSA/ICdzY3JvbGwnIDogJ2hpZGRlbic7XG5cdFx0fVxuXG5cdFx0aWYgKG92ZXJmbG93WSA9PT0gJ2F1dG8nKSB7XG5cdFx0XHRvdmVyZmxvd1kgPSAoXG5cdFx0XHRcdFx0c2Nyb2xsYmFyV2lkdGhzLmxlZnQgfHwgc2Nyb2xsYmFyV2lkdGhzLnJpZ2h0IHx8IC8vIHZlcnRpY2FsIHNjcm9sbGJhcnM/XG5cdFx0XHRcdFx0Ly8gT1Igc2Nyb2xsaW5nIHBhbmUgd2l0aCBtYXNzbGVzcyBzY3JvbGxiYXJzP1xuXHRcdFx0XHRcdHRoaXMuc2Nyb2xsRWxbMF0uc2Nyb2xsSGVpZ2h0IC0gMSA+IHRoaXMuc2Nyb2xsRWxbMF0uY2xpZW50SGVpZ2h0XG5cdFx0XHRcdFx0XHQvLyBzdWJ0cmFjdCAxIGJlY2F1c2Ugb2YgSUUgb2ZmLWJ5LW9uZSBpc3N1ZVxuXHRcdFx0XHQpID8gJ3Njcm9sbCcgOiAnaGlkZGVuJztcblx0XHR9XG5cblx0XHR0aGlzLnNjcm9sbEVsLmNzcyh7ICdvdmVyZmxvdy14Jzogb3ZlcmZsb3dYLCAnb3ZlcmZsb3cteSc6IG92ZXJmbG93WSB9KTtcblx0fSxcblxuXG5cdC8vIEdldHRlcnMgLyBTZXR0ZXJzXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuXHRzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuXHRcdHRoaXMuc2Nyb2xsRWwuaGVpZ2h0KGhlaWdodCk7XG5cdH0sXG5cblxuXHRnZXRTY3JvbGxUb3A6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnNjcm9sbEVsLnNjcm9sbFRvcCgpO1xuXHR9LFxuXG5cblx0c2V0U2Nyb2xsVG9wOiBmdW5jdGlvbih0b3ApIHtcblx0XHR0aGlzLnNjcm9sbEVsLnNjcm9sbFRvcCh0b3ApO1xuXHR9LFxuXG5cblx0Z2V0Q2xpZW50V2lkdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnNjcm9sbEVsWzBdLmNsaWVudFdpZHRoO1xuXHR9LFxuXG5cblx0Z2V0Q2xpZW50SGVpZ2h0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5zY3JvbGxFbFswXS5jbGllbnRIZWlnaHQ7XG5cdH0sXG5cblxuXHRnZXRTY3JvbGxiYXJXaWR0aHM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBnZXRTY3JvbGxiYXJXaWR0aHModGhpcy5zY3JvbGxFbCk7XG5cdH1cblxufSk7XG5cbjs7XG5cbnZhciBDYWxlbmRhciA9IEZDLkNhbGVuZGFyID0gQ2xhc3MuZXh0ZW5kKHtcblxuXHRkaXJEZWZhdWx0czogbnVsbCwgLy8gb3B0aW9uIGRlZmF1bHRzIHJlbGF0ZWQgdG8gTFRSIG9yIFJUTFxuXHRsb2NhbGVEZWZhdWx0czogbnVsbCwgLy8gb3B0aW9uIGRlZmF1bHRzIHJlbGF0ZWQgdG8gY3VycmVudCBsb2NhbGVcblx0b3ZlcnJpZGVzOiBudWxsLCAvLyBvcHRpb24gb3ZlcnJpZGVzIGdpdmVuIHRvIHRoZSBmdWxsQ2FsZW5kYXIgY29uc3RydWN0b3Jcblx0ZHluYW1pY092ZXJyaWRlczogbnVsbCwgLy8gb3B0aW9ucyBzZXQgd2l0aCBkeW5hbWljIHNldHRlciBtZXRob2QuIGhpZ2hlciBwcmVjZWRlbmNlIHRoYW4gdmlldyBvdmVycmlkZXMuXG5cdG9wdGlvbnM6IG51bGwsIC8vIGFsbCBkZWZhdWx0cyBjb21iaW5lZCB3aXRoIG92ZXJyaWRlc1xuXHR2aWV3U3BlY0NhY2hlOiBudWxsLCAvLyBjYWNoZSBvZiB2aWV3IGRlZmluaXRpb25zXG5cdHZpZXc6IG51bGwsIC8vIGN1cnJlbnQgVmlldyBvYmplY3Rcblx0aGVhZGVyOiBudWxsLFxuXHRsb2FkaW5nTGV2ZWw6IDAsIC8vIG51bWJlciBvZiBzaW11bHRhbmVvdXMgbG9hZGluZyB0YXNrc1xuXG5cblx0Ly8gYSBsb3Qgb2YgdGhpcyBjbGFzcycgT09QIGxvZ2ljIGlzIHNjb3BlZCB3aXRoaW4gdGhpcyBjb25zdHJ1Y3RvciBmdW5jdGlvbixcblx0Ly8gYnV0IGluIHRoZSBmdXR1cmUsIHdyaXRlIGluZGl2aWR1YWwgbWV0aG9kcyBvbiB0aGUgcHJvdG90eXBlLlxuXHRjb25zdHJ1Y3RvcjogQ2FsZW5kYXJfY29uc3RydWN0b3IsXG5cblxuXHQvLyBTdWJjbGFzc2VzIGNhbiBvdmVycmlkZSB0aGlzIGZvciBpbml0aWFsaXphdGlvbiBsb2dpYyBhZnRlciB0aGUgY29uc3RydWN0b3IgaGFzIGJlZW4gY2FsbGVkXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHR9LFxuXG5cblx0Ly8gQ29tcHV0ZXMgdGhlIGZsYXR0ZW5lZCBvcHRpb25zIGhhc2ggZm9yIHRoZSBjYWxlbmRhciBhbmQgYXNzaWducyB0byBgdGhpcy5vcHRpb25zYC5cblx0Ly8gQXNzdW1lcyB0aGlzLm92ZXJyaWRlcyBhbmQgdGhpcy5keW5hbWljT3ZlcnJpZGVzIGhhdmUgYWxyZWFkeSBiZWVuIGluaXRpYWxpemVkLlxuXHRwb3B1bGF0ZU9wdGlvbnNIYXNoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbG9jYWxlLCBsb2NhbGVEZWZhdWx0cztcblx0XHR2YXIgaXNSVEwsIGRpckRlZmF1bHRzO1xuXG5cdFx0bG9jYWxlID0gZmlyc3REZWZpbmVkKCAvLyBleHBsaWNpdCBsb2NhbGUgb3B0aW9uIGdpdmVuP1xuXHRcdFx0dGhpcy5keW5hbWljT3ZlcnJpZGVzLmxvY2FsZSxcblx0XHRcdHRoaXMub3ZlcnJpZGVzLmxvY2FsZVxuXHRcdCk7XG5cdFx0bG9jYWxlRGVmYXVsdHMgPSBsb2NhbGVPcHRpb25IYXNoW2xvY2FsZV07XG5cdFx0aWYgKCFsb2NhbGVEZWZhdWx0cykgeyAvLyBleHBsaWNpdCBsb2NhbGUgb3B0aW9uIG5vdCBnaXZlbiBvciBpbnZhbGlkP1xuXHRcdFx0bG9jYWxlID0gQ2FsZW5kYXIuZGVmYXVsdHMubG9jYWxlO1xuXHRcdFx0bG9jYWxlRGVmYXVsdHMgPSBsb2NhbGVPcHRpb25IYXNoW2xvY2FsZV0gfHwge307XG5cdFx0fVxuXG5cdFx0aXNSVEwgPSBmaXJzdERlZmluZWQoIC8vIGJhc2VkIG9uIG9wdGlvbnMgY29tcHV0ZWQgc28gZmFyLCBpcyBkaXJlY3Rpb24gUlRMP1xuXHRcdFx0dGhpcy5keW5hbWljT3ZlcnJpZGVzLmlzUlRMLFxuXHRcdFx0dGhpcy5vdmVycmlkZXMuaXNSVEwsXG5cdFx0XHRsb2NhbGVEZWZhdWx0cy5pc1JUTCxcblx0XHRcdENhbGVuZGFyLmRlZmF1bHRzLmlzUlRMXG5cdFx0KTtcblx0XHRkaXJEZWZhdWx0cyA9IGlzUlRMID8gQ2FsZW5kYXIucnRsRGVmYXVsdHMgOiB7fTtcblxuXHRcdHRoaXMuZGlyRGVmYXVsdHMgPSBkaXJEZWZhdWx0cztcblx0XHR0aGlzLmxvY2FsZURlZmF1bHRzID0gbG9jYWxlRGVmYXVsdHM7XG5cdFx0dGhpcy5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFsgLy8gbWVyZ2UgZGVmYXVsdHMgYW5kIG92ZXJyaWRlcy4gbG93ZXN0IHRvIGhpZ2hlc3QgcHJlY2VkZW5jZVxuXHRcdFx0Q2FsZW5kYXIuZGVmYXVsdHMsIC8vIGdsb2JhbCBkZWZhdWx0c1xuXHRcdFx0ZGlyRGVmYXVsdHMsXG5cdFx0XHRsb2NhbGVEZWZhdWx0cyxcblx0XHRcdHRoaXMub3ZlcnJpZGVzLFxuXHRcdFx0dGhpcy5keW5hbWljT3ZlcnJpZGVzXG5cdFx0XSk7XG5cdFx0cG9wdWxhdGVJbnN0YW5jZUNvbXB1dGFibGVPcHRpb25zKHRoaXMub3B0aW9ucyk7IC8vIGZpbGwgaW4gZ2FwcyB3aXRoIGNvbXB1dGVkIG9wdGlvbnNcblx0fSxcblxuXG5cdC8vIEdldHMgaW5mb3JtYXRpb24gYWJvdXQgaG93IHRvIGNyZWF0ZSBhIHZpZXcuIFdpbGwgdXNlIGEgY2FjaGUuXG5cdGdldFZpZXdTcGVjOiBmdW5jdGlvbih2aWV3VHlwZSkge1xuXHRcdHZhciBjYWNoZSA9IHRoaXMudmlld1NwZWNDYWNoZTtcblxuXHRcdHJldHVybiBjYWNoZVt2aWV3VHlwZV0gfHwgKGNhY2hlW3ZpZXdUeXBlXSA9IHRoaXMuYnVpbGRWaWV3U3BlYyh2aWV3VHlwZSkpO1xuXHR9LFxuXG5cblx0Ly8gR2l2ZW4gYSBkdXJhdGlvbiBzaW5ndWxhciB1bml0LCBsaWtlIFwid2Vla1wiIG9yIFwiZGF5XCIsIGZpbmRzIGEgbWF0Y2hpbmcgdmlldyBzcGVjLlxuXHQvLyBQcmVmZXJlbmNlIGlzIGdpdmVuIHRvIHZpZXdzIHRoYXQgaGF2ZSBjb3JyZXNwb25kaW5nIGJ1dHRvbnMuXG5cdGdldFVuaXRWaWV3U3BlYzogZnVuY3Rpb24odW5pdCkge1xuXHRcdHZhciB2aWV3VHlwZXM7XG5cdFx0dmFyIGk7XG5cdFx0dmFyIHNwZWM7XG5cblx0XHRpZiAoJC5pbkFycmF5KHVuaXQsIGludGVydmFsVW5pdHMpICE9IC0xKSB7XG5cblx0XHRcdC8vIHB1dCB2aWV3cyB0aGF0IGhhdmUgYnV0dG9ucyBmaXJzdC4gdGhlcmUgd2lsbCBiZSBkdXBsaWNhdGVzLCBidXQgb2ggd2VsbFxuXHRcdFx0dmlld1R5cGVzID0gdGhpcy5oZWFkZXIuZ2V0Vmlld3NXaXRoQnV0dG9ucygpO1xuXHRcdFx0JC5lYWNoKEZDLnZpZXdzLCBmdW5jdGlvbih2aWV3VHlwZSkgeyAvLyBhbGwgdmlld3Ncblx0XHRcdFx0dmlld1R5cGVzLnB1c2godmlld1R5cGUpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGZvciAoaSA9IDA7IGkgPCB2aWV3VHlwZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0c3BlYyA9IHRoaXMuZ2V0Vmlld1NwZWModmlld1R5cGVzW2ldKTtcblx0XHRcdFx0aWYgKHNwZWMpIHtcblx0XHRcdFx0XHRpZiAoc3BlYy5zaW5nbGVVbml0ID09IHVuaXQpIHtcblx0XHRcdFx0XHRcdHJldHVybiBzcGVjO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXG5cdC8vIEJ1aWxkcyBhbiBvYmplY3Qgd2l0aCBpbmZvcm1hdGlvbiBvbiBob3cgdG8gY3JlYXRlIGEgZ2l2ZW4gdmlld1xuXHRidWlsZFZpZXdTcGVjOiBmdW5jdGlvbihyZXF1ZXN0ZWRWaWV3VHlwZSkge1xuXHRcdHZhciB2aWV3T3ZlcnJpZGVzID0gdGhpcy5vdmVycmlkZXMudmlld3MgfHwge307XG5cdFx0dmFyIHNwZWNDaGFpbiA9IFtdOyAvLyBmb3IgdGhlIHZpZXcuIGxvd2VzdCB0byBoaWdoZXN0IHByaW9yaXR5XG5cdFx0dmFyIGRlZmF1bHRzQ2hhaW4gPSBbXTsgLy8gZm9yIHRoZSB2aWV3LiBsb3dlc3QgdG8gaGlnaGVzdCBwcmlvcml0eVxuXHRcdHZhciBvdmVycmlkZXNDaGFpbiA9IFtdOyAvLyBmb3IgdGhlIHZpZXcuIGxvd2VzdCB0byBoaWdoZXN0IHByaW9yaXR5XG5cdFx0dmFyIHZpZXdUeXBlID0gcmVxdWVzdGVkVmlld1R5cGU7XG5cdFx0dmFyIHNwZWM7IC8vIGZvciB0aGUgdmlld1xuXHRcdHZhciBvdmVycmlkZXM7IC8vIGZvciB0aGUgdmlld1xuXHRcdHZhciBkdXJhdGlvbjtcblx0XHR2YXIgdW5pdDtcblxuXHRcdC8vIGl0ZXJhdGUgZnJvbSB0aGUgc3BlY2lmaWMgdmlldyBkZWZpbml0aW9uIHRvIGEgbW9yZSBnZW5lcmFsIG9uZSB1bnRpbCB3ZSBoaXQgYW4gYWN0dWFsIFZpZXcgY2xhc3Ncblx0XHR3aGlsZSAodmlld1R5cGUpIHtcblx0XHRcdHNwZWMgPSBmY1ZpZXdzW3ZpZXdUeXBlXTtcblx0XHRcdG92ZXJyaWRlcyA9IHZpZXdPdmVycmlkZXNbdmlld1R5cGVdO1xuXHRcdFx0dmlld1R5cGUgPSBudWxsOyAvLyBjbGVhci4gbWlnaHQgcmVwb3B1bGF0ZSBmb3IgYW5vdGhlciBpdGVyYXRpb25cblxuXHRcdFx0aWYgKHR5cGVvZiBzcGVjID09PSAnZnVuY3Rpb24nKSB7IC8vIFRPRE86IGRlcHJlY2F0ZVxuXHRcdFx0XHRzcGVjID0geyAnY2xhc3MnOiBzcGVjIH07XG5cdFx0XHR9XG5cblx0XHRcdGlmIChzcGVjKSB7XG5cdFx0XHRcdHNwZWNDaGFpbi51bnNoaWZ0KHNwZWMpO1xuXHRcdFx0XHRkZWZhdWx0c0NoYWluLnVuc2hpZnQoc3BlYy5kZWZhdWx0cyB8fCB7fSk7XG5cdFx0XHRcdGR1cmF0aW9uID0gZHVyYXRpb24gfHwgc3BlYy5kdXJhdGlvbjtcblx0XHRcdFx0dmlld1R5cGUgPSB2aWV3VHlwZSB8fCBzcGVjLnR5cGU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvdmVycmlkZXMpIHtcblx0XHRcdFx0b3ZlcnJpZGVzQ2hhaW4udW5zaGlmdChvdmVycmlkZXMpOyAvLyB2aWV3LXNwZWNpZmljIG9wdGlvbiBoYXNoZXMgaGF2ZSBvcHRpb25zIGF0IHplcm8tbGV2ZWxcblx0XHRcdFx0ZHVyYXRpb24gPSBkdXJhdGlvbiB8fCBvdmVycmlkZXMuZHVyYXRpb247XG5cdFx0XHRcdHZpZXdUeXBlID0gdmlld1R5cGUgfHwgb3ZlcnJpZGVzLnR5cGU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c3BlYyA9IG1lcmdlUHJvcHMoc3BlY0NoYWluKTtcblx0XHRzcGVjLnR5cGUgPSByZXF1ZXN0ZWRWaWV3VHlwZTtcblx0XHRpZiAoIXNwZWNbJ2NsYXNzJ10pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAoZHVyYXRpb24pIHtcblx0XHRcdGR1cmF0aW9uID0gbW9tZW50LmR1cmF0aW9uKGR1cmF0aW9uKTtcblx0XHRcdGlmIChkdXJhdGlvbi52YWx1ZU9mKCkpIHsgLy8gdmFsaWQ/XG5cdFx0XHRcdHNwZWMuZHVyYXRpb24gPSBkdXJhdGlvbjtcblx0XHRcdFx0dW5pdCA9IGNvbXB1dGVJbnRlcnZhbFVuaXQoZHVyYXRpb24pO1xuXG5cdFx0XHRcdC8vIHZpZXcgaXMgYSBzaW5nbGUtdW5pdCBkdXJhdGlvbiwgbGlrZSBcIndlZWtcIiBvciBcImRheVwiXG5cdFx0XHRcdC8vIGluY29ycG9yYXRlIG9wdGlvbnMgZm9yIHRoaXMuIGxvd2VzdCBwcmlvcml0eVxuXHRcdFx0XHRpZiAoZHVyYXRpb24uYXModW5pdCkgPT09IDEpIHtcblx0XHRcdFx0XHRzcGVjLnNpbmdsZVVuaXQgPSB1bml0O1xuXHRcdFx0XHRcdG92ZXJyaWRlc0NoYWluLnVuc2hpZnQodmlld092ZXJyaWRlc1t1bml0XSB8fCB7fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRzcGVjLmRlZmF1bHRzID0gbWVyZ2VPcHRpb25zKGRlZmF1bHRzQ2hhaW4pO1xuXHRcdHNwZWMub3ZlcnJpZGVzID0gbWVyZ2VPcHRpb25zKG92ZXJyaWRlc0NoYWluKTtcblxuXHRcdHRoaXMuYnVpbGRWaWV3U3BlY09wdGlvbnMoc3BlYyk7XG5cdFx0dGhpcy5idWlsZFZpZXdTcGVjQnV0dG9uVGV4dChzcGVjLCByZXF1ZXN0ZWRWaWV3VHlwZSk7XG5cblx0XHRyZXR1cm4gc3BlYztcblx0fSxcblxuXG5cdC8vIEJ1aWxkcyBhbmQgYXNzaWducyBhIHZpZXcgc3BlYydzIG9wdGlvbnMgb2JqZWN0IGZyb20gaXRzIGFscmVhZHktYXNzaWduZWQgZGVmYXVsdHMgYW5kIG92ZXJyaWRlc1xuXHRidWlsZFZpZXdTcGVjT3B0aW9uczogZnVuY3Rpb24oc3BlYykge1xuXHRcdHNwZWMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhbIC8vIGxvd2VzdCB0byBoaWdoZXN0IHByaW9yaXR5XG5cdFx0XHRDYWxlbmRhci5kZWZhdWx0cywgLy8gZ2xvYmFsIGRlZmF1bHRzXG5cdFx0XHRzcGVjLmRlZmF1bHRzLCAvLyB2aWV3J3MgZGVmYXVsdHMgKGZyb20gVmlld1N1YmNsYXNzLmRlZmF1bHRzKVxuXHRcdFx0dGhpcy5kaXJEZWZhdWx0cyxcblx0XHRcdHRoaXMubG9jYWxlRGVmYXVsdHMsIC8vIGxvY2FsZSBhbmQgZGlyIHRha2UgcHJlY2VkZW5jZSBvdmVyIHZpZXcncyBkZWZhdWx0cyFcblx0XHRcdHRoaXMub3ZlcnJpZGVzLCAvLyBjYWxlbmRhcidzIG92ZXJyaWRlcyAob3B0aW9ucyBnaXZlbiB0byBjb25zdHJ1Y3Rvcilcblx0XHRcdHNwZWMub3ZlcnJpZGVzLCAvLyB2aWV3J3Mgb3ZlcnJpZGVzICh2aWV3LXNwZWNpZmljIG9wdGlvbnMpXG5cdFx0XHR0aGlzLmR5bmFtaWNPdmVycmlkZXMgLy8gZHluYW1pY2FsbHkgc2V0IHZpYSBzZXR0ZXIuIGhpZ2hlc3QgcHJlY2VkZW5jZVxuXHRcdF0pO1xuXHRcdHBvcHVsYXRlSW5zdGFuY2VDb21wdXRhYmxlT3B0aW9ucyhzcGVjLm9wdGlvbnMpO1xuXHR9LFxuXG5cblx0Ly8gQ29tcHV0ZXMgYW5kIGFzc2lnbnMgYSB2aWV3IHNwZWMncyBidXR0b25UZXh0LXJlbGF0ZWQgb3B0aW9uc1xuXHRidWlsZFZpZXdTcGVjQnV0dG9uVGV4dDogZnVuY3Rpb24oc3BlYywgcmVxdWVzdGVkVmlld1R5cGUpIHtcblxuXHRcdC8vIGdpdmVuIGFuIG9wdGlvbnMgb2JqZWN0IHdpdGggYSBwb3NzaWJsZSBgYnV0dG9uVGV4dGAgaGFzaCwgbG9va3VwIHRoZSBidXR0b25UZXh0IGZvciB0aGVcblx0XHQvLyByZXF1ZXN0ZWQgdmlldywgZmFsbGluZyBiYWNrIHRvIGEgZ2VuZXJpYyB1bml0IGVudHJ5IGxpa2UgXCJ3ZWVrXCIgb3IgXCJkYXlcIlxuXHRcdGZ1bmN0aW9uIHF1ZXJ5QnV0dG9uVGV4dChvcHRpb25zKSB7XG5cdFx0XHR2YXIgYnV0dG9uVGV4dCA9IG9wdGlvbnMuYnV0dG9uVGV4dCB8fCB7fTtcblx0XHRcdHJldHVybiBidXR0b25UZXh0W3JlcXVlc3RlZFZpZXdUeXBlXSB8fFxuXHRcdFx0XHQvLyB2aWV3IGNhbiBkZWNpZGUgdG8gbG9vayB1cCBhIGNlcnRhaW4ga2V5XG5cdFx0XHRcdChzcGVjLmJ1dHRvblRleHRLZXkgPyBidXR0b25UZXh0W3NwZWMuYnV0dG9uVGV4dEtleV0gOiBudWxsKSB8fFxuXHRcdFx0XHQvLyBhIGtleSBsaWtlIFwibW9udGhcIlxuXHRcdFx0XHQoc3BlYy5zaW5nbGVVbml0ID8gYnV0dG9uVGV4dFtzcGVjLnNpbmdsZVVuaXRdIDogbnVsbCk7XG5cdFx0fVxuXG5cdFx0Ly8gaGlnaGVzdCB0byBsb3dlc3QgcHJpb3JpdHlcblx0XHRzcGVjLmJ1dHRvblRleHRPdmVycmlkZSA9XG5cdFx0XHRxdWVyeUJ1dHRvblRleHQodGhpcy5keW5hbWljT3ZlcnJpZGVzKSB8fFxuXHRcdFx0cXVlcnlCdXR0b25UZXh0KHRoaXMub3ZlcnJpZGVzKSB8fCAvLyBjb25zdHJ1Y3Rvci1zcGVjaWZpZWQgYnV0dG9uVGV4dCBsb29rdXAgaGFzaCB0YWtlcyBwcmVjZWRlbmNlXG5cdFx0XHRzcGVjLm92ZXJyaWRlcy5idXR0b25UZXh0OyAvLyBgYnV0dG9uVGV4dGAgZm9yIHZpZXctc3BlY2lmaWMgb3B0aW9ucyBpcyBhIHN0cmluZ1xuXG5cdFx0Ly8gaGlnaGVzdCB0byBsb3dlc3QgcHJpb3JpdHkuIG1pcnJvcnMgYnVpbGRWaWV3U3BlY09wdGlvbnNcblx0XHRzcGVjLmJ1dHRvblRleHREZWZhdWx0ID1cblx0XHRcdHF1ZXJ5QnV0dG9uVGV4dCh0aGlzLmxvY2FsZURlZmF1bHRzKSB8fFxuXHRcdFx0cXVlcnlCdXR0b25UZXh0KHRoaXMuZGlyRGVmYXVsdHMpIHx8XG5cdFx0XHRzcGVjLmRlZmF1bHRzLmJ1dHRvblRleHQgfHwgLy8gYSBzaW5nbGUgc3RyaW5nLiBmcm9tIFZpZXdTdWJjbGFzcy5kZWZhdWx0c1xuXHRcdFx0cXVlcnlCdXR0b25UZXh0KENhbGVuZGFyLmRlZmF1bHRzKSB8fFxuXHRcdFx0KHNwZWMuZHVyYXRpb24gPyB0aGlzLmh1bWFuaXplRHVyYXRpb24oc3BlYy5kdXJhdGlvbikgOiBudWxsKSB8fCAvLyBsaWtlIFwiMyBkYXlzXCJcblx0XHRcdHJlcXVlc3RlZFZpZXdUeXBlOyAvLyBmYWxsIGJhY2sgdG8gZ2l2ZW4gdmlldyBuYW1lXG5cdH0sXG5cblxuXHQvLyBHaXZlbiBhIHZpZXcgbmFtZSBmb3IgYSBjdXN0b20gdmlldyBvciBhIHN0YW5kYXJkIHZpZXcsIGNyZWF0ZXMgYSByZWFkeS10by1nbyBWaWV3IG9iamVjdFxuXHRpbnN0YW50aWF0ZVZpZXc6IGZ1bmN0aW9uKHZpZXdUeXBlKSB7XG5cdFx0dmFyIHNwZWMgPSB0aGlzLmdldFZpZXdTcGVjKHZpZXdUeXBlKTtcblxuXHRcdHJldHVybiBuZXcgc3BlY1snY2xhc3MnXSh0aGlzLCB2aWV3VHlwZSwgc3BlYy5vcHRpb25zLCBzcGVjLmR1cmF0aW9uKTtcblx0fSxcblxuXG5cdC8vIFJldHVybnMgYSBib29sZWFuIGFib3V0IHdoZXRoZXIgdGhlIHZpZXcgaXMgb2theSB0byBpbnN0YW50aWF0ZSBhdCBzb21lIHBvaW50XG5cdGlzVmFsaWRWaWV3VHlwZTogZnVuY3Rpb24odmlld1R5cGUpIHtcblx0XHRyZXR1cm4gQm9vbGVhbih0aGlzLmdldFZpZXdTcGVjKHZpZXdUeXBlKSk7XG5cdH0sXG5cblxuXHQvLyBTaG91bGQgYmUgY2FsbGVkIHdoZW4gYW55IHR5cGUgb2YgYXN5bmMgZGF0YSBmZXRjaGluZyBiZWdpbnNcblx0cHVzaExvYWRpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghKHRoaXMubG9hZGluZ0xldmVsKyspKSB7XG5cdFx0XHR0aGlzLnRyaWdnZXIoJ2xvYWRpbmcnLCBudWxsLCB0cnVlLCB0aGlzLnZpZXcpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIFNob3VsZCBiZSBjYWxsZWQgd2hlbiBhbnkgdHlwZSBvZiBhc3luYyBkYXRhIGZldGNoaW5nIGNvbXBsZXRlc1xuXHRwb3BMb2FkaW5nOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoISgtLXRoaXMubG9hZGluZ0xldmVsKSkge1xuXHRcdFx0dGhpcy50cmlnZ2VyKCdsb2FkaW5nJywgbnVsbCwgZmFsc2UsIHRoaXMudmlldyk7XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gR2l2ZW4gYXJndW1lbnRzIHRvIHRoZSBzZWxlY3QgbWV0aG9kIGluIHRoZSBBUEksIHJldHVybnMgYSBzcGFuICh1bnpvbmVkIHN0YXJ0L2VuZCBhbmQgb3RoZXIgaW5mbylcblx0YnVpbGRTZWxlY3RTcGFuOiBmdW5jdGlvbih6b25lZFN0YXJ0SW5wdXQsIHpvbmVkRW5kSW5wdXQpIHtcblx0XHR2YXIgc3RhcnQgPSB0aGlzLm1vbWVudCh6b25lZFN0YXJ0SW5wdXQpLnN0cmlwWm9uZSgpO1xuXHRcdHZhciBlbmQ7XG5cblx0XHRpZiAoem9uZWRFbmRJbnB1dCkge1xuXHRcdFx0ZW5kID0gdGhpcy5tb21lbnQoem9uZWRFbmRJbnB1dCkuc3RyaXBab25lKCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHN0YXJ0Lmhhc1RpbWUoKSkge1xuXHRcdFx0ZW5kID0gc3RhcnQuY2xvbmUoKS5hZGQodGhpcy5kZWZhdWx0VGltZWRFdmVudER1cmF0aW9uKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRlbmQgPSBzdGFydC5jbG9uZSgpLmFkZCh0aGlzLmRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uKTtcblx0XHR9XG5cblx0XHRyZXR1cm4geyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH07XG5cdH1cblxufSk7XG5cblxuQ2FsZW5kYXIubWl4aW4oRW1pdHRlck1peGluKTtcblxuXG5mdW5jdGlvbiBDYWxlbmRhcl9jb25zdHJ1Y3RvcihlbGVtZW50LCBvdmVycmlkZXMpIHtcblx0dmFyIHQgPSB0aGlzO1xuXG5cblx0Ly8gRXhwb3J0c1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdHQucmVuZGVyID0gcmVuZGVyO1xuXHR0LmRlc3Ryb3kgPSBkZXN0cm95O1xuXHR0LnJlZmV0Y2hFdmVudHMgPSByZWZldGNoRXZlbnRzO1xuXHR0LnJlZmV0Y2hFdmVudFNvdXJjZXMgPSByZWZldGNoRXZlbnRTb3VyY2VzO1xuXHR0LnJlcG9ydEV2ZW50cyA9IHJlcG9ydEV2ZW50cztcblx0dC5yZXBvcnRFdmVudENoYW5nZSA9IHJlcG9ydEV2ZW50Q2hhbmdlO1xuXHR0LnJlcmVuZGVyRXZlbnRzID0gcmVuZGVyRXZlbnRzOyAvLyBgcmVuZGVyRXZlbnRzYCBzZXJ2ZXMgYXMgYSByZXJlbmRlci4gYW4gQVBJIG1ldGhvZFxuXHR0LmNoYW5nZVZpZXcgPSByZW5kZXJWaWV3OyAvLyBgcmVuZGVyVmlld2Agd2lsbCBzd2l0Y2ggdG8gYW5vdGhlciB2aWV3XG5cdHQuc2VsZWN0ID0gc2VsZWN0O1xuXHR0LnVuc2VsZWN0ID0gdW5zZWxlY3Q7XG5cdHQucHJldiA9IHByZXY7XG5cdHQubmV4dCA9IG5leHQ7XG5cdHQucHJldlllYXIgPSBwcmV2WWVhcjtcblx0dC5uZXh0WWVhciA9IG5leHRZZWFyO1xuXHR0LnRvZGF5ID0gdG9kYXk7XG5cdHQuZ290b0RhdGUgPSBnb3RvRGF0ZTtcblx0dC5pbmNyZW1lbnREYXRlID0gaW5jcmVtZW50RGF0ZTtcblx0dC56b29tVG8gPSB6b29tVG87XG5cdHQuZ2V0RGF0ZSA9IGdldERhdGU7XG5cdHQuZ2V0Q2FsZW5kYXIgPSBnZXRDYWxlbmRhcjtcblx0dC5nZXRWaWV3ID0gZ2V0Vmlldztcblx0dC5vcHRpb24gPSBvcHRpb247IC8vIGdldHRlci9zZXR0ZXIgbWV0aG9kXG5cdHQudHJpZ2dlciA9IHRyaWdnZXI7XG5cblxuXHQvLyBPcHRpb25zXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0dC5keW5hbWljT3ZlcnJpZGVzID0ge307XG5cdHQudmlld1NwZWNDYWNoZSA9IHt9O1xuXHR0Lm9wdGlvbkhhbmRsZXJzID0ge307IC8vIGZvciBDYWxlbmRhci5vcHRpb25zLmpzXG5cdHQub3ZlcnJpZGVzID0gJC5leHRlbmQoe30sIG92ZXJyaWRlcyk7IC8vIG1ha2UgYSBjb3B5XG5cblx0dC5wb3B1bGF0ZU9wdGlvbnNIYXNoKCk7IC8vIHNldHMgdGhpcy5vcHRpb25zXG5cblxuXG5cdC8vIExvY2FsZS1kYXRhIEludGVybmFsc1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvLyBBcHBseSBvdmVycmlkZXMgdG8gdGhlIGN1cnJlbnQgbG9jYWxlJ3MgZGF0YVxuXG5cdHZhciBsb2NhbGVEYXRhO1xuXG5cdC8vIENhbGxlZCBpbW1lZGlhdGVseSwgYW5kIHdoZW4gYW55IG9mIHRoZSBvcHRpb25zIGNoYW5nZS5cblx0Ly8gSGFwcGVucyBiZWZvcmUgYW55IGludGVybmFsIG9iamVjdHMgcmVidWlsZCBvciByZXJlbmRlciwgYmVjYXVzZSB0aGlzIGlzIHZlcnkgY29yZS5cblx0dC5iaW5kT3B0aW9ucyhbXG5cdFx0J2xvY2FsZScsICdtb250aE5hbWVzJywgJ21vbnRoTmFtZXNTaG9ydCcsICdkYXlOYW1lcycsICdkYXlOYW1lc1Nob3J0JywgJ2ZpcnN0RGF5JywgJ3dlZWtOdW1iZXJDYWxjdWxhdGlvbidcblx0XSwgZnVuY3Rpb24obG9jYWxlLCBtb250aE5hbWVzLCBtb250aE5hbWVzU2hvcnQsIGRheU5hbWVzLCBkYXlOYW1lc1Nob3J0LCBmaXJzdERheSwgd2Vla051bWJlckNhbGN1bGF0aW9uKSB7XG5cblx0XHQvLyBub3JtYWxpemVcblx0XHRpZiAod2Vla051bWJlckNhbGN1bGF0aW9uID09PSAnaXNvJykge1xuXHRcdFx0d2Vla051bWJlckNhbGN1bGF0aW9uID0gJ0lTTyc7IC8vIG5vcm1hbGl6ZVxuXHRcdH1cblxuXHRcdGxvY2FsZURhdGEgPSBjcmVhdGVPYmplY3QoIC8vIG1ha2UgYSBjaGVhcCBjb3B5XG5cdFx0XHRnZXRNb21lbnRMb2NhbGVEYXRhKGxvY2FsZSkgLy8gd2lsbCBmYWxsIGJhY2sgdG8gZW5cblx0XHQpO1xuXG5cdFx0aWYgKG1vbnRoTmFtZXMpIHtcblx0XHRcdGxvY2FsZURhdGEuX21vbnRocyA9IG1vbnRoTmFtZXM7XG5cdFx0fVxuXHRcdGlmIChtb250aE5hbWVzU2hvcnQpIHtcblx0XHRcdGxvY2FsZURhdGEuX21vbnRoc1Nob3J0ID0gbW9udGhOYW1lc1Nob3J0O1xuXHRcdH1cblx0XHRpZiAoZGF5TmFtZXMpIHtcblx0XHRcdGxvY2FsZURhdGEuX3dlZWtkYXlzID0gZGF5TmFtZXM7XG5cdFx0fVxuXHRcdGlmIChkYXlOYW1lc1Nob3J0KSB7XG5cdFx0XHRsb2NhbGVEYXRhLl93ZWVrZGF5c1Nob3J0ID0gZGF5TmFtZXNTaG9ydDtcblx0XHR9XG5cblx0XHRpZiAoZmlyc3REYXkgPT0gbnVsbCAmJiB3ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdJU08nKSB7XG5cdFx0XHRmaXJzdERheSA9IDE7XG5cdFx0fVxuXHRcdGlmIChmaXJzdERheSAhPSBudWxsKSB7XG5cdFx0XHR2YXIgX3dlZWsgPSBjcmVhdGVPYmplY3QobG9jYWxlRGF0YS5fd2Vlayk7IC8vIF93ZWVrOiB7IGRvdzogIyB9XG5cdFx0XHRfd2Vlay5kb3cgPSBmaXJzdERheTtcblx0XHRcdGxvY2FsZURhdGEuX3dlZWsgPSBfd2Vlaztcblx0XHR9XG5cblx0XHRpZiAoIC8vIHdoaXRlbGlzdCBjZXJ0YWluIGtpbmRzIG9mIGlucHV0XG5cdFx0XHR3ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdJU08nIHx8XG5cdFx0XHR3ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdsb2NhbCcgfHxcblx0XHRcdHR5cGVvZiB3ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdmdW5jdGlvbidcblx0XHQpIHtcblx0XHRcdGxvY2FsZURhdGEuX2Z1bGxDYWxlbmRhcl93ZWVrQ2FsYyA9IHdlZWtOdW1iZXJDYWxjdWxhdGlvbjsgLy8gbW9tZW50LWV4dCB3aWxsIGtub3cgd2hhdCB0byBkbyB3aXRoIGl0XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlIGludGVybmFsIGN1cnJlbnQgZGF0ZSBvYmplY3QgYWxyZWFkeSBleGlzdHMsIG1vdmUgdG8gbmV3IGxvY2FsZS5cblx0XHQvLyBXZSBkbyBOT1QgbmVlZCB0byBkbyB0aGlzIHRlY2huaXF1ZSBmb3IgZXZlbnQgZGF0ZXMsIGJlY2F1c2UgdGhpcyBoYXBwZW5zIHdoZW4gY29udmVydGluZyB0byBcInNlZ21lbnRzXCIuXG5cdFx0aWYgKGRhdGUpIHtcblx0XHRcdGxvY2FsaXplTW9tZW50KGRhdGUpOyAvLyBzZXRzIHRvIGxvY2FsZURhdGFcblx0XHR9XG5cdH0pO1xuXG5cblx0Ly8gQ2FsZW5kYXItc3BlY2lmaWMgRGF0ZSBVdGlsaXRpZXNcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5cdHQuZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24gPSBtb21lbnQuZHVyYXRpb24odC5vcHRpb25zLmRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uKTtcblx0dC5kZWZhdWx0VGltZWRFdmVudER1cmF0aW9uID0gbW9tZW50LmR1cmF0aW9uKHQub3B0aW9ucy5kZWZhdWx0VGltZWRFdmVudER1cmF0aW9uKTtcblxuXG5cdC8vIEJ1aWxkcyBhIG1vbWVudCB1c2luZyB0aGUgc2V0dGluZ3Mgb2YgdGhlIGN1cnJlbnQgY2FsZW5kYXI6IHRpbWV6b25lIGFuZCBsb2NhbGUuXG5cdC8vIEFjY2VwdHMgYW55dGhpbmcgdGhlIHZhbmlsbGEgbW9tZW50KCkgY29uc3RydWN0b3IgYWNjZXB0cy5cblx0dC5tb21lbnQgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgbW9tO1xuXG5cdFx0aWYgKHQub3B0aW9ucy50aW1lem9uZSA9PT0gJ2xvY2FsJykge1xuXHRcdFx0bW9tID0gRkMubW9tZW50LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cblx0XHRcdC8vIEZvcmNlIHRoZSBtb21lbnQgdG8gYmUgbG9jYWwsIGJlY2F1c2UgRkMubW9tZW50IGRvZXNuJ3QgZ3VhcmFudGVlIGl0LlxuXHRcdFx0aWYgKG1vbS5oYXNUaW1lKCkpIHsgLy8gZG9uJ3QgZ2l2ZSBhbWJpZ3VvdXNseS10aW1lZCBtb21lbnRzIGEgbG9jYWwgem9uZVxuXHRcdFx0XHRtb20ubG9jYWwoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZiAodC5vcHRpb25zLnRpbWV6b25lID09PSAnVVRDJykge1xuXHRcdFx0bW9tID0gRkMubW9tZW50LnV0Yy5hcHBseShudWxsLCBhcmd1bWVudHMpOyAvLyBwcm9jZXNzIGFzIFVUQ1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdG1vbSA9IEZDLm1vbWVudC5wYXJzZVpvbmUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTsgLy8gbGV0IHRoZSBpbnB1dCBkZWNpZGUgdGhlIHpvbmVcblx0XHR9XG5cblx0XHRsb2NhbGl6ZU1vbWVudChtb20pO1xuXG5cdFx0cmV0dXJuIG1vbTtcblx0fTtcblxuXG5cdC8vIFVwZGF0ZXMgdGhlIGdpdmVuIG1vbWVudCdzIGxvY2FsZSBzZXR0aW5ncyB0byB0aGUgY3VycmVudCBjYWxlbmRhciBsb2NhbGUgc2V0dGluZ3MuXG5cdGZ1bmN0aW9uIGxvY2FsaXplTW9tZW50KG1vbSkge1xuXHRcdG1vbS5fbG9jYWxlID0gbG9jYWxlRGF0YTtcblx0fVxuXHR0LmxvY2FsaXplTW9tZW50ID0gbG9jYWxpemVNb21lbnQ7XG5cblxuXHQvLyBSZXR1cm5zIGEgYm9vbGVhbiBhYm91dCB3aGV0aGVyIG9yIG5vdCB0aGUgY2FsZW5kYXIga25vd3MgaG93IHRvIGNhbGN1bGF0ZVxuXHQvLyB0aGUgdGltZXpvbmUgb2Zmc2V0IG9mIGFyYml0cmFyeSBkYXRlcyBpbiB0aGUgY3VycmVudCB0aW1lem9uZS5cblx0dC5nZXRJc0FtYmlnVGltZXpvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdC5vcHRpb25zLnRpbWV6b25lICE9PSAnbG9jYWwnICYmIHQub3B0aW9ucy50aW1lem9uZSAhPT0gJ1VUQyc7XG5cdH07XG5cblxuXHQvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgZ2l2ZW4gZGF0ZSBpbiB0aGUgY3VycmVudCB0aW1lem9uZS4gSGFzIG5vIGVmZmVjdCBvbiBkYXRlcyB3aXRob3V0IHRpbWVzLlxuXHR0LmFwcGx5VGltZXpvbmUgPSBmdW5jdGlvbihkYXRlKSB7XG5cdFx0aWYgKCFkYXRlLmhhc1RpbWUoKSkge1xuXHRcdFx0cmV0dXJuIGRhdGUuY2xvbmUoKTtcblx0XHR9XG5cblx0XHR2YXIgem9uZWREYXRlID0gdC5tb21lbnQoZGF0ZS50b0FycmF5KCkpO1xuXHRcdHZhciB0aW1lQWRqdXN0ID0gZGF0ZS50aW1lKCkgLSB6b25lZERhdGUudGltZSgpO1xuXHRcdHZhciBhZGp1c3RlZFpvbmVkRGF0ZTtcblxuXHRcdC8vIFNhZmFyaSBzb21ldGltZXMgaGFzIHByb2JsZW1zIHdpdGggdGhpcyBjb2Vyc2lvbiB3aGVuIG5lYXIgRFNULiBBZGp1c3QgaWYgbmVjZXNzYXJ5LiAoYnVnICMyMzk2KVxuXHRcdGlmICh0aW1lQWRqdXN0KSB7IC8vIGlzIHRoZSB0aW1lIHJlc3VsdCBkaWZmZXJlbnQgdGhhbiBleHBlY3RlZD9cblx0XHRcdGFkanVzdGVkWm9uZWREYXRlID0gem9uZWREYXRlLmNsb25lKCkuYWRkKHRpbWVBZGp1c3QpOyAvLyBhZGQgbWlsbGlzZWNvbmRzXG5cdFx0XHRpZiAoZGF0ZS50aW1lKCkgLSBhZGp1c3RlZFpvbmVkRGF0ZS50aW1lKCkgPT09IDApIHsgLy8gZG9lcyBpdCBtYXRjaCBwZXJmZWN0bHkgbm93P1xuXHRcdFx0XHR6b25lZERhdGUgPSBhZGp1c3RlZFpvbmVkRGF0ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gem9uZWREYXRlO1xuXHR9O1xuXG5cblx0Ly8gUmV0dXJucyBhIG1vbWVudCBmb3IgdGhlIGN1cnJlbnQgZGF0ZSwgYXMgZGVmaW5lZCBieSB0aGUgY2xpZW50J3MgY29tcHV0ZXIgb3IgZnJvbSB0aGUgYG5vd2Agb3B0aW9uLlxuXHQvLyBXaWxsIHJldHVybiBhbiBtb21lbnQgd2l0aCBhbiBhbWJpZ3VvdXMgdGltZXpvbmUuXG5cdHQuZ2V0Tm93ID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5vdyA9IHQub3B0aW9ucy5ub3c7XG5cdFx0aWYgKHR5cGVvZiBub3cgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdG5vdyA9IG5vdygpO1xuXHRcdH1cblx0XHRyZXR1cm4gdC5tb21lbnQobm93KS5zdHJpcFpvbmUoKTtcblx0fTtcblxuXG5cdC8vIEdldCBhbiBldmVudCdzIG5vcm1hbGl6ZWQgZW5kIGRhdGUuIElmIG5vdCBwcmVzZW50LCBjYWxjdWxhdGUgaXQgZnJvbSB0aGUgZGVmYXVsdHMuXG5cdHQuZ2V0RXZlbnRFbmQgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdGlmIChldmVudC5lbmQpIHtcblx0XHRcdHJldHVybiBldmVudC5lbmQuY2xvbmUoKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRyZXR1cm4gdC5nZXREZWZhdWx0RXZlbnRFbmQoZXZlbnQuYWxsRGF5LCBldmVudC5zdGFydCk7XG5cdFx0fVxuXHR9O1xuXG5cblx0Ly8gR2l2ZW4gYW4gZXZlbnQncyBhbGxEYXkgc3RhdHVzIGFuZCBzdGFydCBkYXRlLCByZXR1cm4gd2hhdCBpdHMgZmFsbGJhY2sgZW5kIGRhdGUgc2hvdWxkIGJlLlxuXHQvLyBUT0RPOiByZW5hbWUgdG8gY29tcHV0ZURlZmF1bHRFdmVudEVuZFxuXHR0LmdldERlZmF1bHRFdmVudEVuZCA9IGZ1bmN0aW9uKGFsbERheSwgem9uZWRTdGFydCkge1xuXHRcdHZhciBlbmQgPSB6b25lZFN0YXJ0LmNsb25lKCk7XG5cblx0XHRpZiAoYWxsRGF5KSB7XG5cdFx0XHRlbmQuc3RyaXBUaW1lKCkuYWRkKHQuZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24pO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGVuZC5hZGQodC5kZWZhdWx0VGltZWRFdmVudER1cmF0aW9uKTtcblx0XHR9XG5cblx0XHRpZiAodC5nZXRJc0FtYmlnVGltZXpvbmUoKSkge1xuXHRcdFx0ZW5kLnN0cmlwWm9uZSgpOyAvLyB3ZSBkb24ndCBrbm93IHdoYXQgdGhlIHR6byBzaG91bGQgYmVcblx0XHR9XG5cblx0XHRyZXR1cm4gZW5kO1xuXHR9O1xuXG5cblx0Ly8gUHJvZHVjZXMgYSBodW1hbi1yZWFkYWJsZSBzdHJpbmcgZm9yIHRoZSBnaXZlbiBkdXJhdGlvbi5cblx0Ly8gU2lkZS1lZmZlY3Q6IGNoYW5nZXMgdGhlIGxvY2FsZSBvZiB0aGUgZ2l2ZW4gZHVyYXRpb24uXG5cdHQuaHVtYW5pemVEdXJhdGlvbiA9IGZ1bmN0aW9uKGR1cmF0aW9uKSB7XG5cdFx0cmV0dXJuIGR1cmF0aW9uLmxvY2FsZSh0Lm9wdGlvbnMubG9jYWxlKS5odW1hbml6ZSgpO1xuXHR9O1xuXG5cblx0XG5cdC8vIEltcG9ydHNcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG5cdEV2ZW50TWFuYWdlci5jYWxsKHQpO1xuXHR2YXIgaXNGZXRjaE5lZWRlZCA9IHQuaXNGZXRjaE5lZWRlZDtcblx0dmFyIGZldGNoRXZlbnRzID0gdC5mZXRjaEV2ZW50cztcblx0dmFyIGZldGNoRXZlbnRTb3VyY2VzID0gdC5mZXRjaEV2ZW50U291cmNlcztcblxuXG5cblx0Ly8gTG9jYWxzXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuXHR2YXIgX2VsZW1lbnQgPSBlbGVtZW50WzBdO1xuXHR2YXIgaGVhZGVyO1xuXHR2YXIgY29udGVudDtcblx0dmFyIHRtOyAvLyBmb3IgbWFraW5nIHRoZW1lIGNsYXNzZXNcblx0dmFyIGN1cnJlbnRWaWV3OyAvLyBOT1RFOiBrZWVwIHRoaXMgaW4gc3luYyB3aXRoIHRoaXMudmlld1xuXHR2YXIgdmlld3NCeVR5cGUgPSB7fTsgLy8gaG9sZHMgYWxsIGluc3RhbnRpYXRlZCB2aWV3IGluc3RhbmNlcywgY3VycmVudCBvciBub3Rcblx0dmFyIHN1Z2dlc3RlZFZpZXdIZWlnaHQ7XG5cdHZhciB3aW5kb3dSZXNpemVQcm94eTsgLy8gd3JhcHMgdGhlIHdpbmRvd1Jlc2l6ZSBmdW5jdGlvblxuXHR2YXIgaWdub3JlV2luZG93UmVzaXplID0gMDtcblx0dmFyIGV2ZW50cyA9IFtdO1xuXHR2YXIgZGF0ZTsgLy8gdW56b25lZFxuXHRcblx0XG5cdFxuXHQvLyBNYWluIFJlbmRlcmluZ1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblx0Ly8gY29tcHV0ZSB0aGUgaW5pdGlhbCBhbWJpZy10aW1lem9uZSBkYXRlXG5cdGlmICh0Lm9wdGlvbnMuZGVmYXVsdERhdGUgIT0gbnVsbCkge1xuXHRcdGRhdGUgPSB0Lm1vbWVudCh0Lm9wdGlvbnMuZGVmYXVsdERhdGUpLnN0cmlwWm9uZSgpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdGRhdGUgPSB0LmdldE5vdygpOyAvLyBnZXROb3cgYWxyZWFkeSByZXR1cm5zIHVuem9uZWRcblx0fVxuXHRcblx0XG5cdGZ1bmN0aW9uIHJlbmRlcigpIHtcblx0XHRpZiAoIWNvbnRlbnQpIHtcblx0XHRcdGluaXRpYWxSZW5kZXIoKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoZWxlbWVudFZpc2libGUoKSkge1xuXHRcdFx0Ly8gbWFpbmx5IGZvciB0aGUgcHVibGljIEFQSVxuXHRcdFx0Y2FsY1NpemUoKTtcblx0XHRcdHJlbmRlclZpZXcoKTtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHRmdW5jdGlvbiBpbml0aWFsUmVuZGVyKCkge1xuXHRcdGVsZW1lbnQuYWRkQ2xhc3MoJ2ZjJyk7XG5cblx0XHQvLyBldmVudCBkZWxlZ2F0aW9uIGZvciBuYXYgbGlua3Ncblx0XHRlbGVtZW50Lm9uKCdjbGljay5mYycsICdhW2RhdGEtZ290b10nLCBmdW5jdGlvbihldikge1xuXHRcdFx0dmFyIGFuY2hvckVsID0gJCh0aGlzKTtcblx0XHRcdHZhciBnb3RvT3B0aW9ucyA9IGFuY2hvckVsLmRhdGEoJ2dvdG8nKTsgLy8gd2lsbCBhdXRvbWF0aWNhbGx5IHBhcnNlIEpTT05cblx0XHRcdHZhciBkYXRlID0gdC5tb21lbnQoZ290b09wdGlvbnMuZGF0ZSk7XG5cdFx0XHR2YXIgdmlld1R5cGUgPSBnb3RvT3B0aW9ucy50eXBlO1xuXG5cdFx0XHQvLyBwcm9wZXJ0eSBsaWtlIFwibmF2TGlua0RheUNsaWNrXCIuIG1pZ2h0IGJlIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb25cblx0XHRcdHZhciBjdXN0b21BY3Rpb24gPSBjdXJyZW50Vmlldy5vcHQoJ25hdkxpbmsnICsgY2FwaXRhbGlzZUZpcnN0TGV0dGVyKHZpZXdUeXBlKSArICdDbGljaycpO1xuXG5cdFx0XHRpZiAodHlwZW9mIGN1c3RvbUFjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRjdXN0b21BY3Rpb24oZGF0ZSwgZXYpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgY3VzdG9tQWN0aW9uID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdHZpZXdUeXBlID0gY3VzdG9tQWN0aW9uO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHpvb21UbyhkYXRlLCB2aWV3VHlwZSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBjYWxsZWQgaW1tZWRpYXRlbHksIGFuZCB1cG9uIG9wdGlvbiBjaGFuZ2Vcblx0XHR0LmJpbmRPcHRpb24oJ3RoZW1lJywgZnVuY3Rpb24odGhlbWUpIHtcblx0XHRcdHRtID0gdGhlbWUgPyAndWknIDogJ2ZjJzsgLy8gYWZmZWN0cyBhIGxhcmdlciBzY29wZVxuXHRcdFx0ZWxlbWVudC50b2dnbGVDbGFzcygndWktd2lkZ2V0JywgdGhlbWUpO1xuXHRcdFx0ZWxlbWVudC50b2dnbGVDbGFzcygnZmMtdW50aGVtZWQnLCAhdGhlbWUpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gY2FsbGVkIGltbWVkaWF0ZWx5LCBhbmQgdXBvbiBvcHRpb24gY2hhbmdlLlxuXHRcdC8vIEhBQ0s6IGxvY2FsZSBvZnRlbiBhZmZlY3RzIGlzUlRMLCBzbyB3ZSBleHBsaWNpdGx5IGxpc3RlbiB0byB0aGF0IHRvby5cblx0XHR0LmJpbmRPcHRpb25zKFsgJ2lzUlRMJywgJ2xvY2FsZScgXSwgZnVuY3Rpb24oaXNSVEwpIHtcblx0XHRcdGVsZW1lbnQudG9nZ2xlQ2xhc3MoJ2ZjLWx0cicsICFpc1JUTCk7XG5cdFx0XHRlbGVtZW50LnRvZ2dsZUNsYXNzKCdmYy1ydGwnLCBpc1JUTCk7XG5cdFx0fSk7XG5cblx0XHRjb250ZW50ID0gJChcIjxkaXYgY2xhc3M9J2ZjLXZpZXctY29udGFpbmVyJy8+XCIpLnByZXBlbmRUbyhlbGVtZW50KTtcblxuXHRcdGhlYWRlciA9IHQuaGVhZGVyID0gbmV3IEhlYWRlcih0KTtcblx0XHRyZW5kZXJIZWFkZXIoKTtcblxuXHRcdHJlbmRlclZpZXcodC5vcHRpb25zLmRlZmF1bHRWaWV3KTtcblxuXHRcdGlmICh0Lm9wdGlvbnMuaGFuZGxlV2luZG93UmVzaXplKSB7XG5cdFx0XHR3aW5kb3dSZXNpemVQcm94eSA9IGRlYm91bmNlKHdpbmRvd1Jlc2l6ZSwgdC5vcHRpb25zLndpbmRvd1Jlc2l6ZURlbGF5KTsgLy8gcHJldmVudHMgcmFwaWQgY2FsbHNcblx0XHRcdCQod2luZG93KS5yZXNpemUod2luZG93UmVzaXplUHJveHkpO1xuXHRcdH1cblx0fVxuXG5cblx0Ly8gY2FuIGJlIGNhbGxlZCByZXBlYXRlZGx5IGFuZCBIZWFkZXIgd2lsbCByZXJlbmRlclxuXHRmdW5jdGlvbiByZW5kZXJIZWFkZXIoKSB7XG5cdFx0aGVhZGVyLnJlbmRlcigpO1xuXHRcdGlmIChoZWFkZXIuZWwpIHtcblx0XHRcdGVsZW1lbnQucHJlcGVuZChoZWFkZXIuZWwpO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cblx0XHRpZiAoY3VycmVudFZpZXcpIHtcblx0XHRcdGN1cnJlbnRWaWV3LnJlbW92ZUVsZW1lbnQoKTtcblxuXHRcdFx0Ly8gTk9URTogZG9uJ3QgbnVsbC1vdXQgY3VycmVudFZpZXcvdC52aWV3IGluIGNhc2UgQVBJIG1ldGhvZHMgYXJlIGNhbGxlZCBhZnRlciBkZXN0cm95LlxuXHRcdFx0Ly8gSXQgaXMgc3RpbGwgdGhlIFwiY3VycmVudFwiIHZpZXcsIGp1c3Qgbm90IHJlbmRlcmVkLlxuXHRcdH1cblxuXHRcdGhlYWRlci5yZW1vdmVFbGVtZW50KCk7XG5cdFx0Y29udGVudC5yZW1vdmUoKTtcblx0XHRlbGVtZW50LnJlbW92ZUNsYXNzKCdmYyBmYy1sdHIgZmMtcnRsIGZjLXVudGhlbWVkIHVpLXdpZGdldCcpO1xuXG5cdFx0ZWxlbWVudC5vZmYoJy5mYycpOyAvLyB1bmJpbmQgbmF2IGxpbmsgaGFuZGxlcnNcblxuXHRcdGlmICh3aW5kb3dSZXNpemVQcm94eSkge1xuXHRcdFx0JCh3aW5kb3cpLnVuYmluZCgncmVzaXplJywgd2luZG93UmVzaXplUHJveHkpO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdGZ1bmN0aW9uIGVsZW1lbnRWaXNpYmxlKCkge1xuXHRcdHJldHVybiBlbGVtZW50LmlzKCc6dmlzaWJsZScpO1xuXHR9XG5cdFxuXHRcblxuXHQvLyBWaWV3IFJlbmRlcmluZ1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblx0Ly8gUmVuZGVycyBhIHZpZXcgYmVjYXVzZSBvZiBhIGRhdGUgY2hhbmdlLCB2aWV3LXR5cGUgY2hhbmdlLCBvciBmb3IgdGhlIGZpcnN0IHRpbWUuXG5cdC8vIElmIG5vdCBnaXZlbiBhIHZpZXdUeXBlLCBrZWVwIHRoZSBjdXJyZW50IHZpZXcgYnV0IHJlbmRlciBkaWZmZXJlbnQgZGF0ZXMuXG5cdC8vIEFjY2VwdHMgYW4gb3B0aW9uYWwgc2Nyb2xsIHN0YXRlIHRvIHJlc3RvcmUgdG8uXG5cdGZ1bmN0aW9uIHJlbmRlclZpZXcodmlld1R5cGUsIGV4cGxpY2l0U2Nyb2xsU3RhdGUpIHtcblx0XHRpZ25vcmVXaW5kb3dSZXNpemUrKztcblxuXHRcdC8vIGlmIHZpZXdUeXBlIGlzIGNoYW5naW5nLCByZW1vdmUgdGhlIG9sZCB2aWV3J3MgcmVuZGVyaW5nXG5cdFx0aWYgKGN1cnJlbnRWaWV3ICYmIHZpZXdUeXBlICYmIGN1cnJlbnRWaWV3LnR5cGUgIT09IHZpZXdUeXBlKSB7XG5cdFx0XHRmcmVlemVDb250ZW50SGVpZ2h0KCk7IC8vIHByZXZlbnQgYSBzY3JvbGwganVtcCB3aGVuIHZpZXcgZWxlbWVudCBpcyByZW1vdmVkXG5cdFx0XHRjbGVhclZpZXcoKTtcblx0XHR9XG5cblx0XHQvLyBpZiB2aWV3VHlwZSBjaGFuZ2VkLCBvciB0aGUgdmlldyB3YXMgbmV2ZXIgY3JlYXRlZCwgY3JlYXRlIGEgZnJlc2ggdmlld1xuXHRcdGlmICghY3VycmVudFZpZXcgJiYgdmlld1R5cGUpIHtcblx0XHRcdGN1cnJlbnRWaWV3ID0gdC52aWV3ID1cblx0XHRcdFx0dmlld3NCeVR5cGVbdmlld1R5cGVdIHx8XG5cdFx0XHRcdCh2aWV3c0J5VHlwZVt2aWV3VHlwZV0gPSB0Lmluc3RhbnRpYXRlVmlldyh2aWV3VHlwZSkpO1xuXG5cdFx0XHRjdXJyZW50Vmlldy5zZXRFbGVtZW50KFxuXHRcdFx0XHQkKFwiPGRpdiBjbGFzcz0nZmMtdmlldyBmYy1cIiArIHZpZXdUeXBlICsgXCItdmlldycgLz5cIikuYXBwZW5kVG8oY29udGVudClcblx0XHRcdCk7XG5cdFx0XHRoZWFkZXIuYWN0aXZhdGVCdXR0b24odmlld1R5cGUpO1xuXHRcdH1cblxuXHRcdGlmIChjdXJyZW50Vmlldykge1xuXG5cdFx0XHQvLyBpbiBjYXNlIHRoZSB2aWV3IHNob3VsZCByZW5kZXIgYSBwZXJpb2Qgb2YgdGltZSB0aGF0IGlzIGNvbXBsZXRlbHkgaGlkZGVuXG5cdFx0XHRkYXRlID0gY3VycmVudFZpZXcubWFzc2FnZUN1cnJlbnREYXRlKGRhdGUpO1xuXG5cdFx0XHQvLyByZW5kZXIgb3IgcmVyZW5kZXIgdGhlIHZpZXdcblx0XHRcdGlmIChcblx0XHRcdFx0IWN1cnJlbnRWaWV3LmRpc3BsYXlpbmcgfHxcblx0XHRcdFx0ISggLy8gTk9UIHdpdGhpbiBpbnRlcnZhbCByYW5nZSBzaWduYWxzIGFuIGltcGxpY2l0IGRhdGUgd2luZG93IGNoYW5nZVxuXHRcdFx0XHRcdGRhdGUgPj0gY3VycmVudFZpZXcuaW50ZXJ2YWxTdGFydCAmJlxuXHRcdFx0XHRcdGRhdGUgPCBjdXJyZW50Vmlldy5pbnRlcnZhbEVuZFxuXHRcdFx0XHQpXG5cdFx0XHQpIHtcblx0XHRcdFx0aWYgKGVsZW1lbnRWaXNpYmxlKCkpIHtcblxuXHRcdFx0XHRcdGN1cnJlbnRWaWV3LmRpc3BsYXkoZGF0ZSwgZXhwbGljaXRTY3JvbGxTdGF0ZSk7IC8vIHdpbGwgY2FsbCBmcmVlemVDb250ZW50SGVpZ2h0XG5cdFx0XHRcdFx0dW5mcmVlemVDb250ZW50SGVpZ2h0KCk7IC8vIGltbWVkaWF0ZWx5IHVuZnJlZXplIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciBkaXNwbGF5IGlzIGFzeW5jXG5cblx0XHRcdFx0XHQvLyBuZWVkIHRvIGRvIHRoaXMgYWZ0ZXIgVmlldzo6cmVuZGVyLCBzbyBkYXRlcyBhcmUgY2FsY3VsYXRlZFxuXHRcdFx0XHRcdHVwZGF0ZUhlYWRlclRpdGxlKCk7XG5cdFx0XHRcdFx0dXBkYXRlVG9kYXlCdXR0b24oKTtcblxuXHRcdFx0XHRcdGdldEFuZFJlbmRlckV2ZW50cygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dW5mcmVlemVDb250ZW50SGVpZ2h0KCk7IC8vIHVuZG8gYW55IGxvbmUgZnJlZXplQ29udGVudEhlaWdodCBjYWxsc1xuXHRcdGlnbm9yZVdpbmRvd1Jlc2l6ZS0tO1xuXHR9XG5cblxuXHQvLyBVbnJlbmRlcnMgdGhlIGN1cnJlbnQgdmlldyBhbmQgcmVmbGVjdHMgdGhpcyBjaGFuZ2UgaW4gdGhlIEhlYWRlci5cblx0Ly8gVW5yZWdzaXRlcnMgdGhlIGBjdXJyZW50Vmlld2AsIGJ1dCBkb2VzIG5vdCByZW1vdmUgZnJvbSB2aWV3QnlUeXBlIGhhc2guXG5cdGZ1bmN0aW9uIGNsZWFyVmlldygpIHtcblx0XHRoZWFkZXIuZGVhY3RpdmF0ZUJ1dHRvbihjdXJyZW50Vmlldy50eXBlKTtcblx0XHRjdXJyZW50Vmlldy5yZW1vdmVFbGVtZW50KCk7XG5cdFx0Y3VycmVudFZpZXcgPSB0LnZpZXcgPSBudWxsO1xuXHR9XG5cblxuXHQvLyBEZXN0cm95cyB0aGUgdmlldywgaW5jbHVkaW5nIHRoZSB2aWV3IG9iamVjdC4gVGhlbiwgcmUtaW5zdGFudGlhdGVzIGl0IGFuZCByZW5kZXJzIGl0LlxuXHQvLyBNYWludGFpbnMgdGhlIHNhbWUgc2Nyb2xsIHN0YXRlLlxuXHQvLyBUT0RPOiBtYWludGFpbiBhbnkgb3RoZXIgdXNlci1tYW5pcHVsYXRlZCBzdGF0ZS5cblx0ZnVuY3Rpb24gcmVpbml0VmlldygpIHtcblx0XHRpZ25vcmVXaW5kb3dSZXNpemUrKztcblx0XHRmcmVlemVDb250ZW50SGVpZ2h0KCk7XG5cblx0XHR2YXIgdmlld1R5cGUgPSBjdXJyZW50Vmlldy50eXBlO1xuXHRcdHZhciBzY3JvbGxTdGF0ZSA9IGN1cnJlbnRWaWV3LnF1ZXJ5U2Nyb2xsKCk7XG5cdFx0Y2xlYXJWaWV3KCk7XG5cdFx0cmVuZGVyVmlldyh2aWV3VHlwZSwgc2Nyb2xsU3RhdGUpO1xuXG5cdFx0dW5mcmVlemVDb250ZW50SGVpZ2h0KCk7XG5cdFx0aWdub3JlV2luZG93UmVzaXplLS07XG5cdH1cblxuXHRcblxuXHQvLyBSZXNpemluZ1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblx0dC5nZXRTdWdnZXN0ZWRWaWV3SGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHN1Z2dlc3RlZFZpZXdIZWlnaHQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y2FsY1NpemUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHN1Z2dlc3RlZFZpZXdIZWlnaHQ7XG5cdH07XG5cblxuXHR0LmlzSGVpZ2h0QXV0byA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0Lm9wdGlvbnMuY29udGVudEhlaWdodCA9PT0gJ2F1dG8nIHx8IHQub3B0aW9ucy5oZWlnaHQgPT09ICdhdXRvJztcblx0fTtcblx0XG5cdFxuXHRmdW5jdGlvbiB1cGRhdGVTaXplKHNob3VsZFJlY2FsYykge1xuXHRcdGlmIChlbGVtZW50VmlzaWJsZSgpKSB7XG5cblx0XHRcdGlmIChzaG91bGRSZWNhbGMpIHtcblx0XHRcdFx0X2NhbGNTaXplKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlnbm9yZVdpbmRvd1Jlc2l6ZSsrO1xuXHRcdFx0Y3VycmVudFZpZXcudXBkYXRlU2l6ZSh0cnVlKTsgLy8gaXNSZXNpemU9dHJ1ZS4gd2lsbCBwb2xsIGdldFN1Z2dlc3RlZFZpZXdIZWlnaHQoKSBhbmQgaXNIZWlnaHRBdXRvKClcblx0XHRcdGlnbm9yZVdpbmRvd1Jlc2l6ZS0tO1xuXG5cdFx0XHRyZXR1cm4gdHJ1ZTsgLy8gc2lnbmFsIHN1Y2Nlc3Ncblx0XHR9XG5cdH1cblxuXG5cdGZ1bmN0aW9uIGNhbGNTaXplKCkge1xuXHRcdGlmIChlbGVtZW50VmlzaWJsZSgpKSB7XG5cdFx0XHRfY2FsY1NpemUoKTtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHRmdW5jdGlvbiBfY2FsY1NpemUoKSB7IC8vIGFzc3VtZXMgZWxlbWVudFZpc2libGVcblx0XHR2YXIgY29udGVudEhlaWdodElucHV0ID0gdC5vcHRpb25zLmNvbnRlbnRIZWlnaHQ7XG5cdFx0dmFyIGhlaWdodElucHV0ID0gdC5vcHRpb25zLmhlaWdodDtcblxuXHRcdGlmICh0eXBlb2YgY29udGVudEhlaWdodElucHV0ID09PSAnbnVtYmVyJykgeyAvLyBleGlzdHMgYW5kIG5vdCAnYXV0bydcblx0XHRcdHN1Z2dlc3RlZFZpZXdIZWlnaHQgPSBjb250ZW50SGVpZ2h0SW5wdXQ7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHR5cGVvZiBjb250ZW50SGVpZ2h0SW5wdXQgPT09ICdmdW5jdGlvbicpIHsgLy8gZXhpc3RzIGFuZCBpcyBhIGZ1bmN0aW9uXG5cdFx0XHRzdWdnZXN0ZWRWaWV3SGVpZ2h0ID0gY29udGVudEhlaWdodElucHV0KCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHR5cGVvZiBoZWlnaHRJbnB1dCA9PT0gJ251bWJlcicpIHsgLy8gZXhpc3RzIGFuZCBub3QgJ2F1dG8nXG5cdFx0XHRzdWdnZXN0ZWRWaWV3SGVpZ2h0ID0gaGVpZ2h0SW5wdXQgLSBxdWVyeUhlYWRlckhlaWdodCgpO1xuXHRcdH1cblx0XHRlbHNlIGlmICh0eXBlb2YgaGVpZ2h0SW5wdXQgPT09ICdmdW5jdGlvbicpIHsgLy8gZXhpc3RzIGFuZCBpcyBhIGZ1bmN0aW9uXG5cdFx0XHRzdWdnZXN0ZWRWaWV3SGVpZ2h0ID0gaGVpZ2h0SW5wdXQoKSAtIHF1ZXJ5SGVhZGVySGVpZ2h0KCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKGhlaWdodElucHV0ID09PSAncGFyZW50JykgeyAvLyBzZXQgdG8gaGVpZ2h0IG9mIHBhcmVudCBlbGVtZW50XG5cdFx0XHRzdWdnZXN0ZWRWaWV3SGVpZ2h0ID0gZWxlbWVudC5wYXJlbnQoKS5oZWlnaHQoKSAtIHF1ZXJ5SGVhZGVySGVpZ2h0KCk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0c3VnZ2VzdGVkVmlld0hlaWdodCA9IE1hdGgucm91bmQoY29udGVudC53aWR0aCgpIC8gTWF0aC5tYXgodC5vcHRpb25zLmFzcGVjdFJhdGlvLCAuNSkpO1xuXHRcdH1cblx0fVxuXG5cblx0ZnVuY3Rpb24gcXVlcnlIZWFkZXJIZWlnaHQoKSB7XG5cdFx0cmV0dXJuIGhlYWRlci5lbCA/IGhlYWRlci5lbC5vdXRlckhlaWdodCh0cnVlKSA6IDA7IC8vIGluY2x1ZGVzIG1hcmdpblxuXHR9XG5cdFxuXHRcblx0ZnVuY3Rpb24gd2luZG93UmVzaXplKGV2KSB7XG5cdFx0aWYgKFxuXHRcdFx0IWlnbm9yZVdpbmRvd1Jlc2l6ZSAmJlxuXHRcdFx0ZXYudGFyZ2V0ID09PSB3aW5kb3cgJiYgLy8gc28gd2UgZG9uJ3QgcHJvY2VzcyBqcXVpIFwicmVzaXplXCIgZXZlbnRzIHRoYXQgaGF2ZSBidWJibGVkIHVwXG5cdFx0XHRjdXJyZW50Vmlldy5zdGFydCAvLyB2aWV3IGhhcyBhbHJlYWR5IGJlZW4gcmVuZGVyZWRcblx0XHQpIHtcblx0XHRcdGlmICh1cGRhdGVTaXplKHRydWUpKSB7XG5cdFx0XHRcdGN1cnJlbnRWaWV3LnRyaWdnZXIoJ3dpbmRvd1Jlc2l6ZScsIF9lbGVtZW50KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0XG5cdFxuXHRcblx0LyogRXZlbnQgRmV0Y2hpbmcvUmVuZGVyaW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblx0Ly8gVE9ETzogZ29pbmcgZm9yd2FyZCwgbW9zdCBvZiB0aGlzIHN0dWZmIHNob3VsZCBiZSBkaXJlY3RseSBoYW5kbGVkIGJ5IHRoZSB2aWV3XG5cblxuXHRmdW5jdGlvbiByZWZldGNoRXZlbnRzKCkgeyAvLyBjYW4gYmUgY2FsbGVkIGFzIGFuIEFQSSBtZXRob2Rcblx0XHRmZXRjaEFuZFJlbmRlckV2ZW50cygpO1xuXHR9XG5cblxuXHQvLyBUT0RPOiBtb3ZlIHRoaXMgaW50byBFdmVudE1hbmFnZXI/XG5cdGZ1bmN0aW9uIHJlZmV0Y2hFdmVudFNvdXJjZXMobWF0Y2hJbnB1dHMpIHtcblx0XHRmZXRjaEV2ZW50U291cmNlcyh0LmdldEV2ZW50U291cmNlc0J5TWF0Y2hBcnJheShtYXRjaElucHV0cykpO1xuXHR9XG5cblxuXHRmdW5jdGlvbiByZW5kZXJFdmVudHMoKSB7IC8vIGRlc3Ryb3lzIG9sZCBldmVudHMgaWYgcHJldmlvdXNseSByZW5kZXJlZFxuXHRcdGlmIChlbGVtZW50VmlzaWJsZSgpKSB7XG5cdFx0XHRmcmVlemVDb250ZW50SGVpZ2h0KCk7XG5cdFx0XHRjdXJyZW50Vmlldy5kaXNwbGF5RXZlbnRzKGV2ZW50cyk7XG5cdFx0XHR1bmZyZWV6ZUNvbnRlbnRIZWlnaHQoKTtcblx0XHR9XG5cdH1cblx0XG5cblx0ZnVuY3Rpb24gZ2V0QW5kUmVuZGVyRXZlbnRzKCkge1xuXHRcdGlmICghdC5vcHRpb25zLmxhenlGZXRjaGluZyB8fCBpc0ZldGNoTmVlZGVkKGN1cnJlbnRWaWV3LnN0YXJ0LCBjdXJyZW50Vmlldy5lbmQpKSB7XG5cdFx0XHRmZXRjaEFuZFJlbmRlckV2ZW50cygpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHJlbmRlckV2ZW50cygpO1xuXHRcdH1cblx0fVxuXG5cblx0ZnVuY3Rpb24gZmV0Y2hBbmRSZW5kZXJFdmVudHMoKSB7XG5cdFx0ZmV0Y2hFdmVudHMoY3VycmVudFZpZXcuc3RhcnQsIGN1cnJlbnRWaWV3LmVuZCk7XG5cdFx0XHQvLyAuLi4gd2lsbCBjYWxsIHJlcG9ydEV2ZW50c1xuXHRcdFx0Ly8gLi4uIHdoaWNoIHdpbGwgY2FsbCByZW5kZXJFdmVudHNcblx0fVxuXG5cdFxuXHQvLyBjYWxsZWQgd2hlbiBldmVudCBkYXRhIGFycml2ZXNcblx0ZnVuY3Rpb24gcmVwb3J0RXZlbnRzKF9ldmVudHMpIHtcblx0XHRldmVudHMgPSBfZXZlbnRzO1xuXHRcdHJlbmRlckV2ZW50cygpO1xuXHR9XG5cblxuXHQvLyBjYWxsZWQgd2hlbiBhIHNpbmdsZSBldmVudCdzIGRhdGEgaGFzIGJlZW4gY2hhbmdlZFxuXHRmdW5jdGlvbiByZXBvcnRFdmVudENoYW5nZSgpIHtcblx0XHRyZW5kZXJFdmVudHMoKTtcblx0fVxuXG5cblxuXHQvKiBIZWFkZXIgVXBkYXRpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0ZnVuY3Rpb24gdXBkYXRlSGVhZGVyVGl0bGUoKSB7XG5cdFx0aGVhZGVyLnVwZGF0ZVRpdGxlKGN1cnJlbnRWaWV3LnRpdGxlKTtcblx0fVxuXG5cblx0ZnVuY3Rpb24gdXBkYXRlVG9kYXlCdXR0b24oKSB7XG5cdFx0dmFyIG5vdyA9IHQuZ2V0Tm93KCk7XG5cblx0XHRpZiAobm93ID49IGN1cnJlbnRWaWV3LmludGVydmFsU3RhcnQgJiYgbm93IDwgY3VycmVudFZpZXcuaW50ZXJ2YWxFbmQpIHtcblx0XHRcdGhlYWRlci5kaXNhYmxlQnV0dG9uKCd0b2RheScpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGhlYWRlci5lbmFibGVCdXR0b24oJ3RvZGF5Jyk7XG5cdFx0fVxuXHR9XG5cdFxuXG5cblx0LyogU2VsZWN0aW9uXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblx0XG5cblx0Ly8gdGhpcyBwdWJsaWMgbWV0aG9kIHJlY2VpdmVzIHN0YXJ0L2VuZCBkYXRlcyBpbiBhbnkgZm9ybWF0LCB3aXRoIGFueSB0aW1lem9uZVxuXHRmdW5jdGlvbiBzZWxlY3Qoem9uZWRTdGFydElucHV0LCB6b25lZEVuZElucHV0KSB7XG5cdFx0Y3VycmVudFZpZXcuc2VsZWN0KFxuXHRcdFx0dC5idWlsZFNlbGVjdFNwYW4uYXBwbHkodCwgYXJndW1lbnRzKVxuXHRcdCk7XG5cdH1cblx0XG5cblx0ZnVuY3Rpb24gdW5zZWxlY3QoKSB7IC8vIHNhZmUgdG8gYmUgY2FsbGVkIGJlZm9yZSByZW5kZXJWaWV3XG5cdFx0aWYgKGN1cnJlbnRWaWV3KSB7XG5cdFx0XHRjdXJyZW50Vmlldy51bnNlbGVjdCgpO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdFxuXHQvKiBEYXRlXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblx0XG5cdFxuXHRmdW5jdGlvbiBwcmV2KCkge1xuXHRcdGRhdGUgPSBjdXJyZW50Vmlldy5jb21wdXRlUHJldkRhdGUoZGF0ZSk7XG5cdFx0cmVuZGVyVmlldygpO1xuXHR9XG5cdFxuXHRcblx0ZnVuY3Rpb24gbmV4dCgpIHtcblx0XHRkYXRlID0gY3VycmVudFZpZXcuY29tcHV0ZU5leHREYXRlKGRhdGUpO1xuXHRcdHJlbmRlclZpZXcoKTtcblx0fVxuXHRcblx0XG5cdGZ1bmN0aW9uIHByZXZZZWFyKCkge1xuXHRcdGRhdGUuYWRkKC0xLCAneWVhcnMnKTtcblx0XHRyZW5kZXJWaWV3KCk7XG5cdH1cblx0XG5cdFxuXHRmdW5jdGlvbiBuZXh0WWVhcigpIHtcblx0XHRkYXRlLmFkZCgxLCAneWVhcnMnKTtcblx0XHRyZW5kZXJWaWV3KCk7XG5cdH1cblx0XG5cdFxuXHRmdW5jdGlvbiB0b2RheSgpIHtcblx0XHRkYXRlID0gdC5nZXROb3coKTtcblx0XHRyZW5kZXJWaWV3KCk7XG5cdH1cblx0XG5cdFxuXHRmdW5jdGlvbiBnb3RvRGF0ZSh6b25lZERhdGVJbnB1dCkge1xuXHRcdGRhdGUgPSB0Lm1vbWVudCh6b25lZERhdGVJbnB1dCkuc3RyaXBab25lKCk7XG5cdFx0cmVuZGVyVmlldygpO1xuXHR9XG5cdFxuXHRcblx0ZnVuY3Rpb24gaW5jcmVtZW50RGF0ZShkZWx0YSkge1xuXHRcdGRhdGUuYWRkKG1vbWVudC5kdXJhdGlvbihkZWx0YSkpO1xuXHRcdHJlbmRlclZpZXcoKTtcblx0fVxuXG5cblx0Ly8gRm9yY2VzIG5hdmlnYXRpb24gdG8gYSB2aWV3IGZvciB0aGUgZ2l2ZW4gZGF0ZS5cblx0Ly8gYHZpZXdUeXBlYCBjYW4gYmUgYSBzcGVjaWZpYyB2aWV3IG5hbWUgb3IgYSBnZW5lcmljIG9uZSBsaWtlIFwid2Vla1wiIG9yIFwiZGF5XCIuXG5cdGZ1bmN0aW9uIHpvb21UbyhuZXdEYXRlLCB2aWV3VHlwZSkge1xuXHRcdHZhciBzcGVjO1xuXG5cdFx0dmlld1R5cGUgPSB2aWV3VHlwZSB8fCAnZGF5JzsgLy8gZGF5IGlzIGRlZmF1bHQgem9vbVxuXHRcdHNwZWMgPSB0LmdldFZpZXdTcGVjKHZpZXdUeXBlKSB8fCB0LmdldFVuaXRWaWV3U3BlYyh2aWV3VHlwZSk7XG5cblx0XHRkYXRlID0gbmV3RGF0ZS5jbG9uZSgpO1xuXHRcdHJlbmRlclZpZXcoc3BlYyA/IHNwZWMudHlwZSA6IG51bGwpO1xuXHR9XG5cdFxuXHRcblx0Ly8gZm9yIGV4dGVybmFsIEFQSVxuXHRmdW5jdGlvbiBnZXREYXRlKCkge1xuXHRcdHJldHVybiB0LmFwcGx5VGltZXpvbmUoZGF0ZSk7IC8vIGluZnVzZSB0aGUgY2FsZW5kYXIncyB0aW1lem9uZVxuXHR9XG5cblxuXG5cdC8qIEhlaWdodCBcIkZyZWV6aW5nXCJcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHQvLyBUT0RPOiBtb3ZlIHRoaXMgaW50byB0aGUgdmlld1xuXG5cdHQuZnJlZXplQ29udGVudEhlaWdodCA9IGZyZWV6ZUNvbnRlbnRIZWlnaHQ7XG5cdHQudW5mcmVlemVDb250ZW50SGVpZ2h0ID0gdW5mcmVlemVDb250ZW50SGVpZ2h0O1xuXG5cblx0ZnVuY3Rpb24gZnJlZXplQ29udGVudEhlaWdodCgpIHtcblx0XHRjb250ZW50LmNzcyh7XG5cdFx0XHR3aWR0aDogJzEwMCUnLFxuXHRcdFx0aGVpZ2h0OiBjb250ZW50LmhlaWdodCgpLFxuXHRcdFx0b3ZlcmZsb3c6ICdoaWRkZW4nXG5cdFx0fSk7XG5cdH1cblxuXG5cdGZ1bmN0aW9uIHVuZnJlZXplQ29udGVudEhlaWdodCgpIHtcblx0XHRjb250ZW50LmNzcyh7XG5cdFx0XHR3aWR0aDogJycsXG5cdFx0XHRoZWlnaHQ6ICcnLFxuXHRcdFx0b3ZlcmZsb3c6ICcnXG5cdFx0fSk7XG5cdH1cblx0XG5cdFxuXHRcblx0LyogTWlzY1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cdFxuXG5cdGZ1bmN0aW9uIGdldENhbGVuZGFyKCkge1xuXHRcdHJldHVybiB0O1xuXHR9XG5cblx0XG5cdGZ1bmN0aW9uIGdldFZpZXcoKSB7XG5cdFx0cmV0dXJuIGN1cnJlbnRWaWV3O1xuXHR9XG5cdFxuXHRcblx0ZnVuY3Rpb24gb3B0aW9uKG5hbWUsIHZhbHVlKSB7XG5cdFx0dmFyIG5ld09wdGlvbkhhc2g7XG5cblx0XHRpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgeyAvLyBnZXR0ZXJcblx0XHRcdFx0cmV0dXJuIHQub3B0aW9uc1tuYW1lXTtcblx0XHRcdH1cblx0XHRcdGVsc2UgeyAvLyBzZXR0ZXIgZm9yIGluZGl2aWR1YWwgb3B0aW9uXG5cdFx0XHRcdG5ld09wdGlvbkhhc2ggPSB7fTtcblx0XHRcdFx0bmV3T3B0aW9uSGFzaFtuYW1lXSA9IHZhbHVlO1xuXHRcdFx0XHRzZXRPcHRpb25zKG5ld09wdGlvbkhhc2gpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHsgLy8gY29tcG91bmQgc2V0dGVyIHdpdGggb2JqZWN0IGlucHV0XG5cdFx0XHRzZXRPcHRpb25zKG5hbWUpO1xuXHRcdH1cblx0fVxuXG5cblx0ZnVuY3Rpb24gc2V0T3B0aW9ucyhuZXdPcHRpb25IYXNoKSB7XG5cdFx0dmFyIG9wdGlvbkNudCA9IDA7XG5cdFx0dmFyIG9wdGlvbk5hbWU7XG5cblx0XHRmb3IgKG9wdGlvbk5hbWUgaW4gbmV3T3B0aW9uSGFzaCkge1xuXHRcdFx0dC5keW5hbWljT3ZlcnJpZGVzW29wdGlvbk5hbWVdID0gbmV3T3B0aW9uSGFzaFtvcHRpb25OYW1lXTtcblx0XHR9XG5cblx0XHR0LnZpZXdTcGVjQ2FjaGUgPSB7fTsgLy8gdGhlIGR5bmFtaWMgb3ZlcnJpZGUgaW52YWxpZGF0ZXMgdGhlIG9wdGlvbnMgaW4gdGhpcyBjYWNoZSwgc28ganVzdCBjbGVhciBpdFxuXHRcdHQucG9wdWxhdGVPcHRpb25zSGFzaCgpOyAvLyB0aGlzLm9wdGlvbnMgbmVlZHMgdG8gYmUgcmVjb21wdXRlZCBhZnRlciB0aGUgZHluYW1pYyBvdmVycmlkZVxuXG5cdFx0Ly8gdHJpZ2dlciBoYW5kbGVycyBhZnRlciB0aGlzLm9wdGlvbnMgaGFzIGJlZW4gdXBkYXRlZFxuXHRcdGZvciAob3B0aW9uTmFtZSBpbiBuZXdPcHRpb25IYXNoKSB7XG5cdFx0XHR0LnRyaWdnZXJPcHRpb25IYW5kbGVycyhvcHRpb25OYW1lKTsgLy8gcmVjYWxsIGJpbmRPcHRpb24vYmluZE9wdGlvbnNcblx0XHRcdG9wdGlvbkNudCsrO1xuXHRcdH1cblxuXHRcdC8vIHNwZWNpYWwtY2FzZSBoYW5kbGluZyBvZiBzaW5nbGUgb3B0aW9uIGNoYW5nZS5cblx0XHQvLyBpZiBvbmx5IG9uZSBvcHRpb24gY2hhbmdlLCBgb3B0aW9uTmFtZWAgd2lsbCBiZSBpdHMgbmFtZS5cblx0XHRpZiAob3B0aW9uQ250ID09PSAxKSB7XG5cdFx0XHRpZiAob3B0aW9uTmFtZSA9PT0gJ2hlaWdodCcgfHwgb3B0aW9uTmFtZSA9PT0gJ2NvbnRlbnRIZWlnaHQnIHx8IG9wdGlvbk5hbWUgPT09ICdhc3BlY3RSYXRpbycpIHtcblx0XHRcdFx0dXBkYXRlU2l6ZSh0cnVlKTsgLy8gdHJ1ZSA9IGFsbG93IHJlY2FsY3VsYXRpb24gb2YgaGVpZ2h0XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKG9wdGlvbk5hbWUgPT09ICdkZWZhdWx0RGF0ZScpIHtcblx0XHRcdFx0cmV0dXJuOyAvLyBjYW4ndCBjaGFuZ2UgZGF0ZSB0aGlzIHdheS4gdXNlIGdvdG9EYXRlIGluc3RlYWRcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKG9wdGlvbk5hbWUgPT09ICdidXNpbmVzc0hvdXJzJykge1xuXHRcdFx0XHRpZiAoY3VycmVudFZpZXcpIHtcblx0XHRcdFx0XHRjdXJyZW50Vmlldy51bnJlbmRlckJ1c2luZXNzSG91cnMoKTtcblx0XHRcdFx0XHRjdXJyZW50Vmlldy5yZW5kZXJCdXNpbmVzc0hvdXJzKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAob3B0aW9uTmFtZSA9PT0gJ3RpbWV6b25lJykge1xuXHRcdFx0XHR0LnJlem9uZUFycmF5RXZlbnRTb3VyY2VzKCk7XG5cdFx0XHRcdHJlZmV0Y2hFdmVudHMoKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGNhdGNoLWFsbC4gcmVyZW5kZXIgdGhlIGhlYWRlciBhbmQgcmVidWlsZC9yZXJlbmRlciB0aGUgY3VycmVudCB2aWV3XG5cdFx0cmVuZGVySGVhZGVyKCk7XG5cdFx0dmlld3NCeVR5cGUgPSB7fTsgLy8gZXZlbiBub24tY3VycmVudCB2aWV3cyB3aWxsIGJlIGFmZmVjdGVkIGJ5IHRoaXMgb3B0aW9uIGNoYW5nZS4gZG8gYmVmb3JlIHJlcmVuZGVyXG5cdFx0cmVpbml0VmlldygpO1xuXHR9XG5cdFxuXHRcblx0ZnVuY3Rpb24gdHJpZ2dlcihuYW1lLCB0aGlzT2JqKSB7IC8vIG92ZXJyaWRlcyB0aGUgRW1pdHRlcidzIHRyaWdnZXIgbWV0aG9kIDooXG5cdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuXG5cdFx0dGhpc09iaiA9IHRoaXNPYmogfHwgX2VsZW1lbnQ7XG5cdFx0dGhpcy50cmlnZ2VyV2l0aChuYW1lLCB0aGlzT2JqLCBhcmdzKTsgLy8gRW1pdHRlcidzIG1ldGhvZFxuXG5cdFx0aWYgKHQub3B0aW9uc1tuYW1lXSkge1xuXHRcdFx0cmV0dXJuIHQub3B0aW9uc1tuYW1lXS5hcHBseSh0aGlzT2JqLCBhcmdzKTtcblx0XHR9XG5cdH1cblxuXHR0LmluaXRpYWxpemUoKTtcbn1cblxuOztcbi8qXG5PcHRpb25zIGJpbmRpbmcvdHJpZ2dlcmluZyBzeXN0ZW0uXG4qL1xuQ2FsZW5kYXIubWl4aW4oe1xuXG5cdC8vIEEgbWFwIG9mIG9wdGlvbiBuYW1lcyB0byBhcnJheXMgb2YgaGFuZGxlciBvYmplY3RzLiBJbml0aWFsaXplZCB0byB7fSBpbiBDYWxlbmRhci5cblx0Ly8gRm9ybWF0IGZvciBhIGhhbmRsZXIgb2JqZWN0OlxuXHQvLyB7XG5cdC8vICAgZnVuYyAvLyBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWQgdXBvbiBjaGFuZ2Vcblx0Ly8gICBuYW1lcyAvLyBvcHRpb24gbmFtZXMgd2hvc2UgdmFsdWVzIHNob3VsZCBiZSBnaXZlbiB0byBmdW5jXG5cdC8vIH1cblx0b3B0aW9uSGFuZGxlcnM6IG51bGwsIFxuXG5cdC8vIENhbGxzIGhhbmRsZXJGdW5jIGltbWVkaWF0ZWx5LCBhbmQgd2hlbiB0aGUgZ2l2ZW4gb3B0aW9uIGhhcyBjaGFuZ2VkLlxuXHQvLyBoYW5kbGVyRnVuYyB3aWxsIGJlIGdpdmVuIHRoZSBvcHRpb24gdmFsdWUuXG5cdGJpbmRPcHRpb246IGZ1bmN0aW9uKG9wdGlvbk5hbWUsIGhhbmRsZXJGdW5jKSB7XG5cdFx0dGhpcy5iaW5kT3B0aW9ucyhbIG9wdGlvbk5hbWUgXSwgaGFuZGxlckZ1bmMpO1xuXHR9LFxuXG5cdC8vIENhbGxzIGhhbmRsZXJGdW5jIGltbWVkaWF0ZWx5LCBhbmQgd2hlbiBhbnkgb2YgdGhlIGdpdmVuIG9wdGlvbnMgY2hhbmdlLlxuXHQvLyBoYW5kbGVyRnVuYyB3aWxsIGJlIGdpdmVuIGVhY2ggb3B0aW9uIHZhbHVlIGFzIG9yZGVyZWQgZnVuY3Rpb24gYXJndW1lbnRzLlxuXHRiaW5kT3B0aW9uczogZnVuY3Rpb24ob3B0aW9uTmFtZXMsIGhhbmRsZXJGdW5jKSB7XG5cdFx0dmFyIGhhbmRsZXJPYmogPSB7IGZ1bmM6IGhhbmRsZXJGdW5jLCBuYW1lczogb3B0aW9uTmFtZXMgfTtcblx0XHR2YXIgaTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBvcHRpb25OYW1lcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dGhpcy5yZWdpc3Rlck9wdGlvbkhhbmRsZXJPYmoob3B0aW9uTmFtZXNbaV0sIGhhbmRsZXJPYmopO1xuXHRcdH1cblxuXHRcdHRoaXMudHJpZ2dlck9wdGlvbkhhbmRsZXJPYmooaGFuZGxlck9iaik7XG5cdH0sXG5cblx0Ly8gUHV0cyB0aGUgZ2l2ZW4gaGFuZGxlciBvYmplY3QgaW50byB0aGUgaW50ZXJuYWwgaGFzaFxuXHRyZWdpc3Rlck9wdGlvbkhhbmRsZXJPYmo6IGZ1bmN0aW9uKG9wdGlvbk5hbWUsIGhhbmRsZXJPYmopIHtcblx0XHQodGhpcy5vcHRpb25IYW5kbGVyc1tvcHRpb25OYW1lXSB8fCAodGhpcy5vcHRpb25IYW5kbGVyc1tvcHRpb25OYW1lXSA9IFtdKSlcblx0XHRcdC5wdXNoKGhhbmRsZXJPYmopO1xuXHR9LFxuXG5cdC8vIFJlcG9ydHMgdGhhdCB0aGUgZ2l2ZW4gb3B0aW9uIGhhcyBjaGFuZ2VkLCBhbmQgY2FsbHMgYWxsIGFwcHJvcHJpYXRlIGhhbmRsZXJzLlxuXHR0cmlnZ2VyT3B0aW9uSGFuZGxlcnM6IGZ1bmN0aW9uKG9wdGlvbk5hbWUpIHtcblx0XHR2YXIgaGFuZGxlck9ianMgPSB0aGlzLm9wdGlvbkhhbmRsZXJzW29wdGlvbk5hbWVdIHx8IFtdO1xuXHRcdHZhciBpO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGhhbmRsZXJPYmpzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0aGlzLnRyaWdnZXJPcHRpb25IYW5kbGVyT2JqKGhhbmRsZXJPYmpzW2ldKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ2FsbHMgdGhlIGNhbGxiYWNrIGZvciBhIHNwZWNpZmljIGhhbmRsZXIgb2JqZWN0LCBwYXNzaW5nIGluIHRoZSBhcHByb3ByaWF0ZSBhcmd1bWVudHMuXG5cdHRyaWdnZXJPcHRpb25IYW5kbGVyT2JqOiBmdW5jdGlvbihoYW5kbGVyT2JqKSB7XG5cdFx0dmFyIG9wdGlvbk5hbWVzID0gaGFuZGxlck9iai5uYW1lcztcblx0XHR2YXIgb3B0aW9uVmFsdWVzID0gW107XG5cdFx0dmFyIGk7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgb3B0aW9uTmFtZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdG9wdGlvblZhbHVlcy5wdXNoKHRoaXMub3B0aW9uc1tvcHRpb25OYW1lc1tpXV0pO1xuXHRcdH1cblxuXHRcdGhhbmRsZXJPYmouZnVuYy5hcHBseSh0aGlzLCBvcHRpb25WYWx1ZXMpOyAvLyBtYWludGFpbiB0aGUgQ2FsZW5kYXIncyBgdGhpc2AgY29udGV4dFxuXHR9XG5cbn0pO1xuXG47O1xuXG5DYWxlbmRhci5kZWZhdWx0cyA9IHtcblxuXHR0aXRsZVJhbmdlU2VwYXJhdG9yOiAnIFxcdTIwMTMgJywgLy8gZW4gZGFzaFxuXHRtb250aFllYXJGb3JtYXQ6ICdNTU1NIFlZWVknLCAvLyByZXF1aXJlZCBmb3IgZW4uIG90aGVyIGxvY2FsZXMgcmVseSBvbiBkYXRlcGlja2VyIGNvbXB1dGFibGUgb3B0aW9uXG5cblx0ZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbjogJzAyOjAwOjAwJyxcblx0ZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb246IHsgZGF5czogMSB9LFxuXHRmb3JjZUV2ZW50RHVyYXRpb246IGZhbHNlLFxuXHRuZXh0RGF5VGhyZXNob2xkOiAnMDk6MDA6MDAnLCAvLyA5YW1cblxuXHQvLyBkaXNwbGF5XG5cdGRlZmF1bHRWaWV3OiAnbW9udGgnLFxuXHRhc3BlY3RSYXRpbzogMS4zNSxcblx0aGVhZGVyOiB7XG5cdFx0bGVmdDogJ3RpdGxlJyxcblx0XHRjZW50ZXI6ICcnLFxuXHRcdHJpZ2h0OiAndG9kYXkgcHJldixuZXh0J1xuXHR9LFxuXHR3ZWVrZW5kczogdHJ1ZSxcblx0d2Vla051bWJlcnM6IGZhbHNlLFxuXG5cdHdlZWtOdW1iZXJUaXRsZTogJ1cnLFxuXHR3ZWVrTnVtYmVyQ2FsY3VsYXRpb246ICdsb2NhbCcsXG5cdFxuXHQvL2VkaXRhYmxlOiBmYWxzZSxcblxuXHQvL25vd0luZGljYXRvcjogZmFsc2UsXG5cblx0c2Nyb2xsVGltZTogJzA2OjAwOjAwJyxcblx0XG5cdC8vIGV2ZW50IGFqYXhcblx0bGF6eUZldGNoaW5nOiB0cnVlLFxuXHRzdGFydFBhcmFtOiAnc3RhcnQnLFxuXHRlbmRQYXJhbTogJ2VuZCcsXG5cdHRpbWV6b25lUGFyYW06ICd0aW1lem9uZScsXG5cblx0dGltZXpvbmU6IGZhbHNlLFxuXG5cdC8vYWxsRGF5RGVmYXVsdDogdW5kZWZpbmVkLFxuXG5cdC8vIGxvY2FsZVxuXHRpc1JUTDogZmFsc2UsXG5cdGJ1dHRvblRleHQ6IHtcblx0XHRwcmV2OiBcInByZXZcIixcblx0XHRuZXh0OiBcIm5leHRcIixcblx0XHRwcmV2WWVhcjogXCJwcmV2IHllYXJcIixcblx0XHRuZXh0WWVhcjogXCJuZXh0IHllYXJcIixcblx0XHR5ZWFyOiAneWVhcicsIC8vIFRPRE86IGxvY2FsZSBmaWxlcyBuZWVkIHRvIHNwZWNpZnkgdGhpc1xuXHRcdHRvZGF5OiAndG9kYXknLFxuXHRcdG1vbnRoOiAnbW9udGgnLFxuXHRcdHdlZWs6ICd3ZWVrJyxcblx0XHRkYXk6ICdkYXknXG5cdH0sXG5cblx0YnV0dG9uSWNvbnM6IHtcblx0XHRwcmV2OiAnbGVmdC1zaW5nbGUtYXJyb3cnLFxuXHRcdG5leHQ6ICdyaWdodC1zaW5nbGUtYXJyb3cnLFxuXHRcdHByZXZZZWFyOiAnbGVmdC1kb3VibGUtYXJyb3cnLFxuXHRcdG5leHRZZWFyOiAncmlnaHQtZG91YmxlLWFycm93J1xuXHR9LFxuXG5cdGFsbERheVRleHQ6ICdhbGwtZGF5Jyxcblx0XG5cdC8vIGpxdWVyeS11aSB0aGVtaW5nXG5cdHRoZW1lOiBmYWxzZSxcblx0dGhlbWVCdXR0b25JY29uczoge1xuXHRcdHByZXY6ICdjaXJjbGUtdHJpYW5nbGUtdycsXG5cdFx0bmV4dDogJ2NpcmNsZS10cmlhbmdsZS1lJyxcblx0XHRwcmV2WWVhcjogJ3NlZWstcHJldicsXG5cdFx0bmV4dFllYXI6ICdzZWVrLW5leHQnXG5cdH0sXG5cblx0Ly9ldmVudFJlc2l6YWJsZUZyb21TdGFydDogZmFsc2UsXG5cdGRyYWdPcGFjaXR5OiAuNzUsXG5cdGRyYWdSZXZlcnREdXJhdGlvbjogNTAwLFxuXHRkcmFnU2Nyb2xsOiB0cnVlLFxuXHRcblx0Ly9zZWxlY3RhYmxlOiBmYWxzZSxcblx0dW5zZWxlY3RBdXRvOiB0cnVlLFxuXHRcblx0ZHJvcEFjY2VwdDogJyonLFxuXG5cdGV2ZW50T3JkZXI6ICd0aXRsZScsXG5cblx0ZXZlbnRMaW1pdDogZmFsc2UsXG5cdGV2ZW50TGltaXRUZXh0OiAnbW9yZScsXG5cdGV2ZW50TGltaXRDbGljazogJ3BvcG92ZXInLFxuXHRkYXlQb3BvdmVyRm9ybWF0OiAnTEwnLFxuXHRcblx0aGFuZGxlV2luZG93UmVzaXplOiB0cnVlLFxuXHR3aW5kb3dSZXNpemVEZWxheTogMTAwLCAvLyBtaWxsaXNlY29uZHMgYmVmb3JlIGFuIHVwZGF0ZVNpemUgaGFwcGVuc1xuXG5cdGxvbmdQcmVzc0RlbGF5OiAxMDAwXG5cdFxufTtcblxuXG5DYWxlbmRhci5lbmdsaXNoRGVmYXVsdHMgPSB7IC8vIHVzZWQgYnkgbG9jYWxlLmpzXG5cdGRheVBvcG92ZXJGb3JtYXQ6ICdkZGRkLCBNTU1NIEQnXG59O1xuXG5cbkNhbGVuZGFyLnJ0bERlZmF1bHRzID0geyAvLyByaWdodC10by1sZWZ0IGRlZmF1bHRzXG5cdGhlYWRlcjogeyAvLyBUT0RPOiBzbWFydGVyIHNvbHV0aW9uIChmaXJzdC9jZW50ZXIvbGFzdCA/KVxuXHRcdGxlZnQ6ICduZXh0LHByZXYgdG9kYXknLFxuXHRcdGNlbnRlcjogJycsXG5cdFx0cmlnaHQ6ICd0aXRsZSdcblx0fSxcblx0YnV0dG9uSWNvbnM6IHtcblx0XHRwcmV2OiAncmlnaHQtc2luZ2xlLWFycm93Jyxcblx0XHRuZXh0OiAnbGVmdC1zaW5nbGUtYXJyb3cnLFxuXHRcdHByZXZZZWFyOiAncmlnaHQtZG91YmxlLWFycm93Jyxcblx0XHRuZXh0WWVhcjogJ2xlZnQtZG91YmxlLWFycm93J1xuXHR9LFxuXHR0aGVtZUJ1dHRvbkljb25zOiB7XG5cdFx0cHJldjogJ2NpcmNsZS10cmlhbmdsZS1lJyxcblx0XHRuZXh0OiAnY2lyY2xlLXRyaWFuZ2xlLXcnLFxuXHRcdG5leHRZZWFyOiAnc2Vlay1wcmV2Jyxcblx0XHRwcmV2WWVhcjogJ3NlZWstbmV4dCdcblx0fVxufTtcblxuOztcblxudmFyIGxvY2FsZU9wdGlvbkhhc2ggPSBGQy5sb2NhbGVzID0ge307IC8vIGluaXRpYWxpemUgYW5kIGV4cG9zZVxuXG5cbi8vIFRPRE86IGRvY3VtZW50IHRoZSBzdHJ1Y3R1cmUgYW5kIG9yZGVyaW5nIG9mIGEgRnVsbENhbGVuZGFyIGxvY2FsZSBmaWxlXG5cblxuLy8gSW5pdGlhbGl6ZSBqUXVlcnkgVUkgZGF0ZXBpY2tlciB0cmFuc2xhdGlvbnMgd2hpbGUgdXNpbmcgc29tZSBvZiB0aGUgdHJhbnNsYXRpb25zXG4vLyBXaWxsIHNldCB0aGlzIGFzIHRoZSBkZWZhdWx0IGxvY2FsZXMgZm9yIGRhdGVwaWNrZXIuXG5GQy5kYXRlcGlja2VyTG9jYWxlID0gZnVuY3Rpb24obG9jYWxlQ29kZSwgZHBMb2NhbGVDb2RlLCBkcE9wdGlvbnMpIHtcblxuXHQvLyBnZXQgdGhlIEZ1bGxDYWxlbmRhciBpbnRlcm5hbCBvcHRpb24gaGFzaCBmb3IgdGhpcyBsb2NhbGUuIGNyZWF0ZSBpZiBuZWNlc3Nhcnlcblx0dmFyIGZjT3B0aW9ucyA9IGxvY2FsZU9wdGlvbkhhc2hbbG9jYWxlQ29kZV0gfHwgKGxvY2FsZU9wdGlvbkhhc2hbbG9jYWxlQ29kZV0gPSB7fSk7XG5cblx0Ly8gdHJhbnNmZXIgc29tZSBzaW1wbGUgb3B0aW9ucyBmcm9tIGRhdGVwaWNrZXIgdG8gZmNcblx0ZmNPcHRpb25zLmlzUlRMID0gZHBPcHRpb25zLmlzUlRMO1xuXHRmY09wdGlvbnMud2Vla051bWJlclRpdGxlID0gZHBPcHRpb25zLndlZWtIZWFkZXI7XG5cblx0Ly8gY29tcHV0ZSBzb21lIG1vcmUgY29tcGxleCBvcHRpb25zIGZyb20gZGF0ZXBpY2tlclxuXHQkLmVhY2goZHBDb21wdXRhYmxlT3B0aW9ucywgZnVuY3Rpb24obmFtZSwgZnVuYykge1xuXHRcdGZjT3B0aW9uc1tuYW1lXSA9IGZ1bmMoZHBPcHRpb25zKTtcblx0fSk7XG5cblx0Ly8gaXMgalF1ZXJ5IFVJIERhdGVwaWNrZXIgaXMgb24gdGhlIHBhZ2U/XG5cdGlmICgkLmRhdGVwaWNrZXIpIHtcblxuXHRcdC8vIFJlZ2lzdGVyIHRoZSBsb2NhbGUgZGF0YS5cblx0XHQvLyBGdWxsQ2FsZW5kYXIgYW5kIE1vbWVudEpTIHVzZSBsb2NhbGUgY29kZXMgbGlrZSBcInB0LWJyXCIgYnV0IERhdGVwaWNrZXJcblx0XHQvLyBkb2VzIGl0IGxpa2UgXCJwdC1CUlwiIG9yIGlmIGl0IGRvZXNuJ3QgaGF2ZSB0aGUgbG9jYWxlLCBtYXliZSBqdXN0IFwicHRcIi5cblx0XHQvLyBNYWtlIGFuIGFsaWFzIHNvIHRoZSBsb2NhbGUgY2FuIGJlIHJlZmVyZW5jZWQgZWl0aGVyIHdheS5cblx0XHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbZHBMb2NhbGVDb2RlXSA9XG5cdFx0XHQkLmRhdGVwaWNrZXIucmVnaW9uYWxbbG9jYWxlQ29kZV0gPSAvLyBhbGlhc1xuXHRcdFx0XHRkcE9wdGlvbnM7XG5cblx0XHQvLyBBbGlhcyAnZW4nIHRvIHRoZSBkZWZhdWx0IGxvY2FsZSBkYXRhLiBEbyB0aGlzIGV2ZXJ5IHRpbWUuXG5cdFx0JC5kYXRlcGlja2VyLnJlZ2lvbmFsLmVuID0gJC5kYXRlcGlja2VyLnJlZ2lvbmFsWycnXTtcblxuXHRcdC8vIFNldCBhcyBEYXRlcGlja2VyJ3MgZ2xvYmFsIGRlZmF1bHRzLlxuXHRcdCQuZGF0ZXBpY2tlci5zZXREZWZhdWx0cyhkcE9wdGlvbnMpO1xuXHR9XG59O1xuXG5cbi8vIFNldHMgRnVsbENhbGVuZGFyLXNwZWNpZmljIHRyYW5zbGF0aW9ucy4gV2lsbCBzZXQgdGhlIGxvY2FsZXMgYXMgdGhlIGdsb2JhbCBkZWZhdWx0LlxuRkMubG9jYWxlID0gZnVuY3Rpb24obG9jYWxlQ29kZSwgbmV3RmNPcHRpb25zKSB7XG5cdHZhciBmY09wdGlvbnM7XG5cdHZhciBtb21PcHRpb25zO1xuXG5cdC8vIGdldCB0aGUgRnVsbENhbGVuZGFyIGludGVybmFsIG9wdGlvbiBoYXNoIGZvciB0aGlzIGxvY2FsZS4gY3JlYXRlIGlmIG5lY2Vzc2FyeVxuXHRmY09wdGlvbnMgPSBsb2NhbGVPcHRpb25IYXNoW2xvY2FsZUNvZGVdIHx8IChsb2NhbGVPcHRpb25IYXNoW2xvY2FsZUNvZGVdID0ge30pO1xuXG5cdC8vIHByb3ZpZGVkIG5ldyBvcHRpb25zIGZvciB0aGlzIGxvY2FsZXM/IG1lcmdlIHRoZW0gaW5cblx0aWYgKG5ld0ZjT3B0aW9ucykge1xuXHRcdGZjT3B0aW9ucyA9IGxvY2FsZU9wdGlvbkhhc2hbbG9jYWxlQ29kZV0gPSBtZXJnZU9wdGlvbnMoWyBmY09wdGlvbnMsIG5ld0ZjT3B0aW9ucyBdKTtcblx0fVxuXG5cdC8vIGNvbXB1dGUgbG9jYWxlIG9wdGlvbnMgdGhhdCB3ZXJlbid0IGRlZmluZWQuXG5cdC8vIGFsd2F5cyBkbyB0aGlzLiBuZXdGY09wdGlvbnMgY2FuIGJlIHVuZGVmaW5lZCB3aGVuIGluaXRpYWxpemluZyBmcm9tIGkxOG4gZmlsZSxcblx0Ly8gc28gbm8gd2F5IHRvIHRlbGwgaWYgdGhpcyBpcyBhbiBpbml0aWFsaXphdGlvbiBvciBhIGRlZmF1bHQtc2V0dGluZy5cblx0bW9tT3B0aW9ucyA9IGdldE1vbWVudExvY2FsZURhdGEobG9jYWxlQ29kZSk7IC8vIHdpbGwgZmFsbCBiYWNrIHRvIGVuXG5cdCQuZWFjaChtb21Db21wdXRhYmxlT3B0aW9ucywgZnVuY3Rpb24obmFtZSwgZnVuYykge1xuXHRcdGlmIChmY09wdGlvbnNbbmFtZV0gPT0gbnVsbCkge1xuXHRcdFx0ZmNPcHRpb25zW25hbWVdID0gZnVuYyhtb21PcHRpb25zLCBmY09wdGlvbnMpO1xuXHRcdH1cblx0fSk7XG5cblx0Ly8gc2V0IGl0IGFzIHRoZSBkZWZhdWx0IGxvY2FsZSBmb3IgRnVsbENhbGVuZGFyXG5cdENhbGVuZGFyLmRlZmF1bHRzLmxvY2FsZSA9IGxvY2FsZUNvZGU7XG59O1xuXG5cbi8vIE5PVEU6IGNhbid0IGd1YXJhbnRlZSBhbnkgb2YgdGhlc2UgY29tcHV0YXRpb25zIHdpbGwgcnVuIGJlY2F1c2Ugbm90IGV2ZXJ5IGxvY2FsZSBoYXMgZGF0ZXBpY2tlclxuLy8gY29uZmlncywgc28gbWFrZSBzdXJlIHRoZXJlIGFyZSBFbmdsaXNoIGZhbGxiYWNrcyBmb3IgdGhlc2UgaW4gdGhlIGRlZmF1bHRzIGZpbGUuXG52YXIgZHBDb21wdXRhYmxlT3B0aW9ucyA9IHtcblxuXHRidXR0b25UZXh0OiBmdW5jdGlvbihkcE9wdGlvbnMpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0Ly8gdGhlIHRyYW5zbGF0aW9ucyBzb21ldGltZXMgd3JvbmdseSBjb250YWluIEhUTUwgZW50aXRpZXNcblx0XHRcdHByZXY6IHN0cmlwSHRtbEVudGl0aWVzKGRwT3B0aW9ucy5wcmV2VGV4dCksXG5cdFx0XHRuZXh0OiBzdHJpcEh0bWxFbnRpdGllcyhkcE9wdGlvbnMubmV4dFRleHQpLFxuXHRcdFx0dG9kYXk6IHN0cmlwSHRtbEVudGl0aWVzKGRwT3B0aW9ucy5jdXJyZW50VGV4dClcblx0XHR9O1xuXHR9LFxuXG5cdC8vIFByb2R1Y2VzIGZvcm1hdCBzdHJpbmdzIGxpa2UgXCJNTU1NIFlZWVlcIiAtPiBcIlNlcHRlbWJlciAyMDE0XCJcblx0bW9udGhZZWFyRm9ybWF0OiBmdW5jdGlvbihkcE9wdGlvbnMpIHtcblx0XHRyZXR1cm4gZHBPcHRpb25zLnNob3dNb250aEFmdGVyWWVhciA/XG5cdFx0XHQnWVlZWVsnICsgZHBPcHRpb25zLnllYXJTdWZmaXggKyAnXSBNTU1NJyA6XG5cdFx0XHQnTU1NTSBZWVlZWycgKyBkcE9wdGlvbnMueWVhclN1ZmZpeCArICddJztcblx0fVxuXG59O1xuXG52YXIgbW9tQ29tcHV0YWJsZU9wdGlvbnMgPSB7XG5cblx0Ly8gUHJvZHVjZXMgZm9ybWF0IHN0cmluZ3MgbGlrZSBcImRkZCBNL0RcIiAtPiBcIkZyaSA5LzE1XCJcblx0ZGF5T2ZNb250aEZvcm1hdDogZnVuY3Rpb24obW9tT3B0aW9ucywgZmNPcHRpb25zKSB7XG5cdFx0dmFyIGZvcm1hdCA9IG1vbU9wdGlvbnMubG9uZ0RhdGVGb3JtYXQoJ2wnKTsgLy8gZm9yIHRoZSBmb3JtYXQgbGlrZSBcIk0vRC9ZWVlZXCJcblxuXHRcdC8vIHN0cmlwIHRoZSB5ZWFyIG9mZiB0aGUgZWRnZSwgYXMgd2VsbCBhcyBvdGhlciBtaXNjIG5vbi13aGl0ZXNwYWNlIGNoYXJzXG5cdFx0Zm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoL15ZK1teXFx3XFxzXSp8W15cXHdcXHNdKlkrJC9nLCAnJyk7XG5cblx0XHRpZiAoZmNPcHRpb25zLmlzUlRMKSB7XG5cdFx0XHRmb3JtYXQgKz0gJyBkZGQnOyAvLyBmb3IgUlRMLCBhZGQgZGF5LW9mLXdlZWsgdG8gZW5kXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Zm9ybWF0ID0gJ2RkZCAnICsgZm9ybWF0OyAvLyBmb3IgTFRSLCBhZGQgZGF5LW9mLXdlZWsgdG8gYmVnaW5uaW5nXG5cdFx0fVxuXHRcdHJldHVybiBmb3JtYXQ7XG5cdH0sXG5cblx0Ly8gUHJvZHVjZXMgZm9ybWF0IHN0cmluZ3MgbGlrZSBcImg6bW1hXCIgLT4gXCI2OjAwcG1cIlxuXHRtZWRpdW1UaW1lRm9ybWF0OiBmdW5jdGlvbihtb21PcHRpb25zKSB7IC8vIGNhbid0IGJlIGNhbGxlZCBgdGltZUZvcm1hdGAgYmVjYXVzZSBjb2xsaWRlcyB3aXRoIG9wdGlvblxuXHRcdHJldHVybiBtb21PcHRpb25zLmxvbmdEYXRlRm9ybWF0KCdMVCcpXG5cdFx0XHQucmVwbGFjZSgvXFxzKmEkL2ksICdhJyk7IC8vIGNvbnZlcnQgQU0vUE0vYW0vcG0gdG8gbG93ZXJjYXNlLiByZW1vdmUgYW55IHNwYWNlcyBiZWZvcmVoYW5kXG5cdH0sXG5cblx0Ly8gUHJvZHVjZXMgZm9ybWF0IHN0cmluZ3MgbGlrZSBcImgoOm1tKWFcIiAtPiBcIjZwbVwiIC8gXCI2OjMwcG1cIlxuXHRzbWFsbFRpbWVGb3JtYXQ6IGZ1bmN0aW9uKG1vbU9wdGlvbnMpIHtcblx0XHRyZXR1cm4gbW9tT3B0aW9ucy5sb25nRGF0ZUZvcm1hdCgnTFQnKVxuXHRcdFx0LnJlcGxhY2UoJzptbScsICcoOm1tKScpXG5cdFx0XHQucmVwbGFjZSgvKFxcV21tKSQvLCAnKCQxKScpIC8vIGxpa2UgYWJvdmUsIGJ1dCBmb3IgZm9yZWlnbiBsb2NhbGVzXG5cdFx0XHQucmVwbGFjZSgvXFxzKmEkL2ksICdhJyk7IC8vIGNvbnZlcnQgQU0vUE0vYW0vcG0gdG8gbG93ZXJjYXNlLiByZW1vdmUgYW55IHNwYWNlcyBiZWZvcmVoYW5kXG5cdH0sXG5cblx0Ly8gUHJvZHVjZXMgZm9ybWF0IHN0cmluZ3MgbGlrZSBcImgoOm1tKXRcIiAtPiBcIjZwXCIgLyBcIjY6MzBwXCJcblx0ZXh0cmFTbWFsbFRpbWVGb3JtYXQ6IGZ1bmN0aW9uKG1vbU9wdGlvbnMpIHtcblx0XHRyZXR1cm4gbW9tT3B0aW9ucy5sb25nRGF0ZUZvcm1hdCgnTFQnKVxuXHRcdFx0LnJlcGxhY2UoJzptbScsICcoOm1tKScpXG5cdFx0XHQucmVwbGFjZSgvKFxcV21tKSQvLCAnKCQxKScpIC8vIGxpa2UgYWJvdmUsIGJ1dCBmb3IgZm9yZWlnbiBsb2NhbGVzXG5cdFx0XHQucmVwbGFjZSgvXFxzKmEkL2ksICd0Jyk7IC8vIGNvbnZlcnQgdG8gQU0vUE0vYW0vcG0gdG8gbG93ZXJjYXNlIG9uZS1sZXR0ZXIuIHJlbW92ZSBhbnkgc3BhY2VzIGJlZm9yZWhhbmRcblx0fSxcblxuXHQvLyBQcm9kdWNlcyBmb3JtYXQgc3RyaW5ncyBsaWtlIFwiaGFcIiAvIFwiSFwiIC0+IFwiNnBtXCIgLyBcIjE4XCJcblx0aG91ckZvcm1hdDogZnVuY3Rpb24obW9tT3B0aW9ucykge1xuXHRcdHJldHVybiBtb21PcHRpb25zLmxvbmdEYXRlRm9ybWF0KCdMVCcpXG5cdFx0XHQucmVwbGFjZSgnOm1tJywgJycpXG5cdFx0XHQucmVwbGFjZSgvKFxcV21tKSQvLCAnJykgLy8gbGlrZSBhYm92ZSwgYnV0IGZvciBmb3JlaWduIGxvY2FsZXNcblx0XHRcdC5yZXBsYWNlKC9cXHMqYSQvaSwgJ2EnKTsgLy8gY29udmVydCBBTS9QTS9hbS9wbSB0byBsb3dlcmNhc2UuIHJlbW92ZSBhbnkgc3BhY2VzIGJlZm9yZWhhbmRcblx0fSxcblxuXHQvLyBQcm9kdWNlcyBmb3JtYXQgc3RyaW5ncyBsaWtlIFwiaDptbVwiIC0+IFwiNjozMFwiICh3aXRoIG5vIEFNL1BNKVxuXHRub01lcmlkaWVtVGltZUZvcm1hdDogZnVuY3Rpb24obW9tT3B0aW9ucykge1xuXHRcdHJldHVybiBtb21PcHRpb25zLmxvbmdEYXRlRm9ybWF0KCdMVCcpXG5cdFx0XHQucmVwbGFjZSgvXFxzKmEkL2ksICcnKTsgLy8gcmVtb3ZlIHRyYWlsaW5nIEFNL1BNXG5cdH1cblxufTtcblxuXG4vLyBvcHRpb25zIHRoYXQgc2hvdWxkIGJlIGNvbXB1dGVkIG9mZiBsaXZlIGNhbGVuZGFyIG9wdGlvbnMgKGNvbnNpZGVycyBvdmVycmlkZSBvcHRpb25zKVxuLy8gVE9ETzogYmVzdCBwbGFjZSBmb3IgdGhpcz8gcmVsYXRlZCB0byBsb2NhbGU/XG4vLyBUT0RPOiBmbGlwcGluZyB0ZXh0IGJhc2VkIG9uIGlzUlRMIGlzIGEgYmFkIGlkZWEgYmVjYXVzZSB0aGUgQ1NTIGBkaXJlY3Rpb25gIG1pZ2h0IHdhbnQgdG8gaGFuZGxlIGl0XG52YXIgaW5zdGFuY2VDb21wdXRhYmxlT3B0aW9ucyA9IHtcblxuXHQvLyBQcm9kdWNlcyBmb3JtYXQgc3RyaW5ncyBmb3IgcmVzdWx0cyBsaWtlIFwiTW8gMTZcIlxuXHRzbWFsbERheURhdGVGb3JtYXQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gb3B0aW9ucy5pc1JUTCA/XG5cdFx0XHQnRCBkZCcgOlxuXHRcdFx0J2RkIEQnO1xuXHR9LFxuXG5cdC8vIFByb2R1Y2VzIGZvcm1hdCBzdHJpbmdzIGZvciByZXN1bHRzIGxpa2UgXCJXayA1XCJcblx0d2Vla0Zvcm1hdDogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHJldHVybiBvcHRpb25zLmlzUlRMID9cblx0XHRcdCd3WyAnICsgb3B0aW9ucy53ZWVrTnVtYmVyVGl0bGUgKyAnXScgOlxuXHRcdFx0J1snICsgb3B0aW9ucy53ZWVrTnVtYmVyVGl0bGUgKyAnIF13Jztcblx0fSxcblxuXHQvLyBQcm9kdWNlcyBmb3JtYXQgc3RyaW5ncyBmb3IgcmVzdWx0cyBsaWtlIFwiV2s1XCJcblx0c21hbGxXZWVrRm9ybWF0OiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0cmV0dXJuIG9wdGlvbnMuaXNSVEwgP1xuXHRcdFx0J3dbJyArIG9wdGlvbnMud2Vla051bWJlclRpdGxlICsgJ10nIDpcblx0XHRcdCdbJyArIG9wdGlvbnMud2Vla051bWJlclRpdGxlICsgJ113Jztcblx0fVxuXG59O1xuXG5mdW5jdGlvbiBwb3B1bGF0ZUluc3RhbmNlQ29tcHV0YWJsZU9wdGlvbnMob3B0aW9ucykge1xuXHQkLmVhY2goaW5zdGFuY2VDb21wdXRhYmxlT3B0aW9ucywgZnVuY3Rpb24obmFtZSwgZnVuYykge1xuXHRcdGlmIChvcHRpb25zW25hbWVdID09IG51bGwpIHtcblx0XHRcdG9wdGlvbnNbbmFtZV0gPSBmdW5jKG9wdGlvbnMpO1xuXHRcdH1cblx0fSk7XG59XG5cblxuLy8gUmV0dXJucyBtb21lbnQncyBpbnRlcm5hbCBsb2NhbGUgZGF0YS4gSWYgZG9lc24ndCBleGlzdCwgcmV0dXJucyBFbmdsaXNoLlxuZnVuY3Rpb24gZ2V0TW9tZW50TG9jYWxlRGF0YShsb2NhbGVDb2RlKSB7XG5cdHJldHVybiBtb21lbnQubG9jYWxlRGF0YShsb2NhbGVDb2RlKSB8fCBtb21lbnQubG9jYWxlRGF0YSgnZW4nKTtcbn1cblxuXG4vLyBJbml0aWFsaXplIEVuZ2xpc2ggYnkgZm9yY2luZyBjb21wdXRhdGlvbiBvZiBtb21lbnQtZGVyaXZlZCBvcHRpb25zLlxuLy8gQWxzbywgc2V0cyBpdCBhcyB0aGUgZGVmYXVsdC5cbkZDLmxvY2FsZSgnZW4nLCBDYWxlbmRhci5lbmdsaXNoRGVmYXVsdHMpO1xuXG47O1xuXG4vKiBUb3AgdG9vbGJhciBhcmVhIHdpdGggYnV0dG9ucyBhbmQgdGl0bGVcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLy8gVE9ETzogcmVuYW1lIGFsbCBoZWFkZXItcmVsYXRlZCB0aGluZ3MgdG8gXCJ0b29sYmFyXCJcblxuZnVuY3Rpb24gSGVhZGVyKGNhbGVuZGFyKSB7XG5cdHZhciB0ID0gdGhpcztcblx0XG5cdC8vIGV4cG9ydHNcblx0dC5yZW5kZXIgPSByZW5kZXI7XG5cdHQucmVtb3ZlRWxlbWVudCA9IHJlbW92ZUVsZW1lbnQ7XG5cdHQudXBkYXRlVGl0bGUgPSB1cGRhdGVUaXRsZTtcblx0dC5hY3RpdmF0ZUJ1dHRvbiA9IGFjdGl2YXRlQnV0dG9uO1xuXHR0LmRlYWN0aXZhdGVCdXR0b24gPSBkZWFjdGl2YXRlQnV0dG9uO1xuXHR0LmRpc2FibGVCdXR0b24gPSBkaXNhYmxlQnV0dG9uO1xuXHR0LmVuYWJsZUJ1dHRvbiA9IGVuYWJsZUJ1dHRvbjtcblx0dC5nZXRWaWV3c1dpdGhCdXR0b25zID0gZ2V0Vmlld3NXaXRoQnV0dG9ucztcblx0dC5lbCA9IG51bGw7IC8vIG1pcnJvcnMgbG9jYWwgYGVsYFxuXHRcblx0Ly8gbG9jYWxzXG5cdHZhciBlbDtcblx0dmFyIHZpZXdzV2l0aEJ1dHRvbnMgPSBbXTtcblx0dmFyIHRtO1xuXG5cblx0Ly8gY2FuIGJlIGNhbGxlZCByZXBlYXRlZGx5IGFuZCB3aWxsIHJlcmVuZGVyXG5cdGZ1bmN0aW9uIHJlbmRlcigpIHtcblx0XHR2YXIgb3B0aW9ucyA9IGNhbGVuZGFyLm9wdGlvbnM7XG5cdFx0dmFyIHNlY3Rpb25zID0gb3B0aW9ucy5oZWFkZXI7XG5cblx0XHR0bSA9IG9wdGlvbnMudGhlbWUgPyAndWknIDogJ2ZjJztcblxuXHRcdGlmIChzZWN0aW9ucykge1xuXHRcdFx0aWYgKCFlbCkge1xuXHRcdFx0XHRlbCA9IHRoaXMuZWwgPSAkKFwiPGRpdiBjbGFzcz0nZmMtdG9vbGJhcicvPlwiKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRlbC5lbXB0eSgpO1xuXHRcdFx0fVxuXHRcdFx0ZWwuYXBwZW5kKHJlbmRlclNlY3Rpb24oJ2xlZnQnKSlcblx0XHRcdFx0LmFwcGVuZChyZW5kZXJTZWN0aW9uKCdyaWdodCcpKVxuXHRcdFx0XHQuYXBwZW5kKHJlbmRlclNlY3Rpb24oJ2NlbnRlcicpKVxuXHRcdFx0XHQuYXBwZW5kKCc8ZGl2IGNsYXNzPVwiZmMtY2xlYXJcIi8+Jyk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmVtb3ZlRWxlbWVudCgpO1xuXHRcdH1cblx0fVxuXHRcblx0XG5cdGZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQoKSB7XG5cdFx0aWYgKGVsKSB7XG5cdFx0XHRlbC5yZW1vdmUoKTtcblx0XHRcdGVsID0gdC5lbCA9IG51bGw7XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0ZnVuY3Rpb24gcmVuZGVyU2VjdGlvbihwb3NpdGlvbikge1xuXHRcdHZhciBzZWN0aW9uRWwgPSAkKCc8ZGl2IGNsYXNzPVwiZmMtJyArIHBvc2l0aW9uICsgJ1wiLz4nKTtcblx0XHR2YXIgb3B0aW9ucyA9IGNhbGVuZGFyLm9wdGlvbnM7XG5cdFx0dmFyIGJ1dHRvblN0ciA9IG9wdGlvbnMuaGVhZGVyW3Bvc2l0aW9uXTtcblxuXHRcdGlmIChidXR0b25TdHIpIHtcblx0XHRcdCQuZWFjaChidXR0b25TdHIuc3BsaXQoJyAnKSwgZnVuY3Rpb24oaSkge1xuXHRcdFx0XHR2YXIgZ3JvdXBDaGlsZHJlbiA9ICQoKTtcblx0XHRcdFx0dmFyIGlzT25seUJ1dHRvbnMgPSB0cnVlO1xuXHRcdFx0XHR2YXIgZ3JvdXBFbDtcblxuXHRcdFx0XHQkLmVhY2godGhpcy5zcGxpdCgnLCcpLCBmdW5jdGlvbihqLCBidXR0b25OYW1lKSB7XG5cdFx0XHRcdFx0dmFyIGN1c3RvbUJ1dHRvblByb3BzO1xuXHRcdFx0XHRcdHZhciB2aWV3U3BlYztcblx0XHRcdFx0XHR2YXIgYnV0dG9uQ2xpY2s7XG5cdFx0XHRcdFx0dmFyIG92ZXJyaWRlVGV4dDsgLy8gdGV4dCBleHBsaWNpdGx5IHNldCBieSBjYWxlbmRhcidzIGNvbnN0cnVjdG9yIG9wdGlvbnMuIG92ZXJjb21lcyBpY29uc1xuXHRcdFx0XHRcdHZhciBkZWZhdWx0VGV4dDtcblx0XHRcdFx0XHR2YXIgdGhlbWVJY29uO1xuXHRcdFx0XHRcdHZhciBub3JtYWxJY29uO1xuXHRcdFx0XHRcdHZhciBpbm5lckh0bWw7XG5cdFx0XHRcdFx0dmFyIGNsYXNzZXM7XG5cdFx0XHRcdFx0dmFyIGJ1dHRvbjsgLy8gdGhlIGVsZW1lbnRcblxuXHRcdFx0XHRcdGlmIChidXR0b25OYW1lID09ICd0aXRsZScpIHtcblx0XHRcdFx0XHRcdGdyb3VwQ2hpbGRyZW4gPSBncm91cENoaWxkcmVuLmFkZCgkKCc8aDI+Jm5ic3A7PC9oMj4nKSk7IC8vIHdlIGFsd2F5cyB3YW50IGl0IHRvIHRha2UgdXAgaGVpZ2h0XG5cdFx0XHRcdFx0XHRpc09ubHlCdXR0b25zID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKChjdXN0b21CdXR0b25Qcm9wcyA9IChvcHRpb25zLmN1c3RvbUJ1dHRvbnMgfHwge30pW2J1dHRvbk5hbWVdKSkge1xuXHRcdFx0XHRcdFx0XHRidXR0b25DbGljayA9IGZ1bmN0aW9uKGV2KSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGN1c3RvbUJ1dHRvblByb3BzLmNsaWNrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXN0b21CdXR0b25Qcm9wcy5jbGljay5jYWxsKGJ1dHRvblswXSwgZXYpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0b3ZlcnJpZGVUZXh0ID0gJyc7IC8vIGljb25zIHdpbGwgb3ZlcnJpZGUgdGV4dFxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0VGV4dCA9IGN1c3RvbUJ1dHRvblByb3BzLnRleHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIGlmICgodmlld1NwZWMgPSBjYWxlbmRhci5nZXRWaWV3U3BlYyhidXR0b25OYW1lKSkpIHtcblx0XHRcdFx0XHRcdFx0YnV0dG9uQ2xpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRjYWxlbmRhci5jaGFuZ2VWaWV3KGJ1dHRvbk5hbWUpO1xuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHR2aWV3c1dpdGhCdXR0b25zLnB1c2goYnV0dG9uTmFtZSk7XG5cdFx0XHRcdFx0XHRcdG92ZXJyaWRlVGV4dCA9IHZpZXdTcGVjLmJ1dHRvblRleHRPdmVycmlkZTtcblx0XHRcdFx0XHRcdFx0ZGVmYXVsdFRleHQgPSB2aWV3U3BlYy5idXR0b25UZXh0RGVmYXVsdDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2UgaWYgKGNhbGVuZGFyW2J1dHRvbk5hbWVdKSB7IC8vIGEgY2FsZW5kYXIgbWV0aG9kXG5cdFx0XHRcdFx0XHRcdGJ1dHRvbkNsaWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2FsZW5kYXJbYnV0dG9uTmFtZV0oKTtcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0b3ZlcnJpZGVUZXh0ID0gKGNhbGVuZGFyLm92ZXJyaWRlcy5idXR0b25UZXh0IHx8IHt9KVtidXR0b25OYW1lXTtcblx0XHRcdFx0XHRcdFx0ZGVmYXVsdFRleHQgPSBvcHRpb25zLmJ1dHRvblRleHRbYnV0dG9uTmFtZV07IC8vIGV2ZXJ5dGhpbmcgZWxzZSBpcyBjb25zaWRlcmVkIGRlZmF1bHRcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKGJ1dHRvbkNsaWNrKSB7XG5cblx0XHRcdFx0XHRcdFx0dGhlbWVJY29uID1cblx0XHRcdFx0XHRcdFx0XHRjdXN0b21CdXR0b25Qcm9wcyA/XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXN0b21CdXR0b25Qcm9wcy50aGVtZUljb24gOlxuXHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9ucy50aGVtZUJ1dHRvbkljb25zW2J1dHRvbk5hbWVdO1xuXG5cdFx0XHRcdFx0XHRcdG5vcm1hbEljb24gPVxuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUJ1dHRvblByb3BzID9cblx0XHRcdFx0XHRcdFx0XHRcdGN1c3RvbUJ1dHRvblByb3BzLmljb24gOlxuXHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5idXR0b25JY29uc1tidXR0b25OYW1lXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAob3ZlcnJpZGVUZXh0KSB7XG5cdFx0XHRcdFx0XHRcdFx0aW5uZXJIdG1sID0gaHRtbEVzY2FwZShvdmVycmlkZVRleHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2UgaWYgKHRoZW1lSWNvbiAmJiBvcHRpb25zLnRoZW1lKSB7XG5cdFx0XHRcdFx0XHRcdFx0aW5uZXJIdG1sID0gXCI8c3BhbiBjbGFzcz0ndWktaWNvbiB1aS1pY29uLVwiICsgdGhlbWVJY29uICsgXCInPjwvc3Bhbj5cIjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRlbHNlIGlmIChub3JtYWxJY29uICYmICFvcHRpb25zLnRoZW1lKSB7XG5cdFx0XHRcdFx0XHRcdFx0aW5uZXJIdG1sID0gXCI8c3BhbiBjbGFzcz0nZmMtaWNvbiBmYy1pY29uLVwiICsgbm9ybWFsSWNvbiArIFwiJz48L3NwYW4+XCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0aW5uZXJIdG1sID0gaHRtbEVzY2FwZShkZWZhdWx0VGV4dCk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRjbGFzc2VzID0gW1xuXHRcdFx0XHRcdFx0XHRcdCdmYy0nICsgYnV0dG9uTmFtZSArICctYnV0dG9uJyxcblx0XHRcdFx0XHRcdFx0XHR0bSArICctYnV0dG9uJyxcblx0XHRcdFx0XHRcdFx0XHR0bSArICctc3RhdGUtZGVmYXVsdCdcblx0XHRcdFx0XHRcdFx0XTtcblxuXHRcdFx0XHRcdFx0XHRidXR0b24gPSAkKCAvLyB0eXBlPVwiYnV0dG9uXCIgc28gdGhhdCBpdCBkb2Vzbid0IHN1Ym1pdCBhIGZvcm1cblx0XHRcdFx0XHRcdFx0XHQnPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCInICsgY2xhc3Nlcy5qb2luKCcgJykgKyAnXCI+JyArXG5cdFx0XHRcdFx0XHRcdFx0XHRpbm5lckh0bWwgK1xuXHRcdFx0XHRcdFx0XHRcdCc8L2J1dHRvbj4nXG5cdFx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0XHRcdC5jbGljayhmdW5jdGlvbihldikge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gZG9uJ3QgcHJvY2VzcyBjbGlja3MgZm9yIGRpc2FibGVkIGJ1dHRvbnNcblx0XHRcdFx0XHRcdFx0XHRcdGlmICghYnV0dG9uLmhhc0NsYXNzKHRtICsgJy1zdGF0ZS1kaXNhYmxlZCcpKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0YnV0dG9uQ2xpY2soZXYpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFmdGVyIHRoZSBjbGljayBhY3Rpb24sIGlmIHRoZSBidXR0b24gYmVjb21lcyB0aGUgXCJhY3RpdmVcIiB0YWIsIG9yIGRpc2FibGVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBpdCBzaG91bGQgbmV2ZXIgaGF2ZSBhIGhvdmVyIGNsYXNzLCBzbyByZW1vdmUgaXQgbm93LlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnV0dG9uLmhhc0NsYXNzKHRtICsgJy1zdGF0ZS1hY3RpdmUnKSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJ1dHRvbi5oYXNDbGFzcyh0bSArICctc3RhdGUtZGlzYWJsZWQnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRidXR0b24ucmVtb3ZlQ2xhc3ModG0gKyAnLXN0YXRlLWhvdmVyJyk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0XHRcdC5tb3VzZWRvd24oZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyB0aGUgKmRvd24qIGVmZmVjdCAobW91c2UgcHJlc3NlZCBpbikuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBvbmx5IG9uIGJ1dHRvbnMgdGhhdCBhcmUgbm90IHRoZSBcImFjdGl2ZVwiIHRhYiwgb3IgZGlzYWJsZWRcblx0XHRcdFx0XHRcdFx0XHRcdGJ1dHRvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQubm90KCcuJyArIHRtICsgJy1zdGF0ZS1hY3RpdmUnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQubm90KCcuJyArIHRtICsgJy1zdGF0ZS1kaXNhYmxlZCcpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5hZGRDbGFzcyh0bSArICctc3RhdGUtZG93bicpO1xuXHRcdFx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHRcdFx0Lm1vdXNldXAoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyB1bmRvIHRoZSAqZG93biogZWZmZWN0XG5cdFx0XHRcdFx0XHRcdFx0XHRidXR0b24ucmVtb3ZlQ2xhc3ModG0gKyAnLXN0YXRlLWRvd24nKTtcblx0XHRcdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0XHRcdC5ob3Zlcihcblx0XHRcdFx0XHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyB0aGUgKmhvdmVyKiBlZmZlY3QuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIG9ubHkgb24gYnV0dG9ucyB0aGF0IGFyZSBub3QgdGhlIFwiYWN0aXZlXCIgdGFiLCBvciBkaXNhYmxlZFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRidXR0b25cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQubm90KCcuJyArIHRtICsgJy1zdGF0ZS1hY3RpdmUnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5ub3QoJy4nICsgdG0gKyAnLXN0YXRlLWRpc2FibGVkJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQuYWRkQ2xhc3ModG0gKyAnLXN0YXRlLWhvdmVyJyk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIHVuZG8gdGhlICpob3ZlciogZWZmZWN0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJ1dHRvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5yZW1vdmVDbGFzcyh0bSArICctc3RhdGUtaG92ZXInKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5yZW1vdmVDbGFzcyh0bSArICctc3RhdGUtZG93bicpOyAvLyBpZiBtb3VzZWxlYXZlIGhhcHBlbnMgYmVmb3JlIG1vdXNldXBcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdGdyb3VwQ2hpbGRyZW4gPSBncm91cENoaWxkcmVuLmFkZChidXR0b24pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0aWYgKGlzT25seUJ1dHRvbnMpIHtcblx0XHRcdFx0XHRncm91cENoaWxkcmVuXG5cdFx0XHRcdFx0XHQuZmlyc3QoKS5hZGRDbGFzcyh0bSArICctY29ybmVyLWxlZnQnKS5lbmQoKVxuXHRcdFx0XHRcdFx0Lmxhc3QoKS5hZGRDbGFzcyh0bSArICctY29ybmVyLXJpZ2h0JykuZW5kKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZ3JvdXBDaGlsZHJlbi5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdFx0Z3JvdXBFbCA9ICQoJzxkaXYvPicpO1xuXHRcdFx0XHRcdGlmIChpc09ubHlCdXR0b25zKSB7XG5cdFx0XHRcdFx0XHRncm91cEVsLmFkZENsYXNzKCdmYy1idXR0b24tZ3JvdXAnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Z3JvdXBFbC5hcHBlbmQoZ3JvdXBDaGlsZHJlbik7XG5cdFx0XHRcdFx0c2VjdGlvbkVsLmFwcGVuZChncm91cEVsKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRzZWN0aW9uRWwuYXBwZW5kKGdyb3VwQ2hpbGRyZW4pOyAvLyAxIG9yIDAgY2hpbGRyZW5cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNlY3Rpb25FbDtcblx0fVxuXHRcblx0XG5cdGZ1bmN0aW9uIHVwZGF0ZVRpdGxlKHRleHQpIHtcblx0XHRpZiAoZWwpIHtcblx0XHRcdGVsLmZpbmQoJ2gyJykudGV4dCh0ZXh0KTtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHRmdW5jdGlvbiBhY3RpdmF0ZUJ1dHRvbihidXR0b25OYW1lKSB7XG5cdFx0aWYgKGVsKSB7XG5cdFx0XHRlbC5maW5kKCcuZmMtJyArIGJ1dHRvbk5hbWUgKyAnLWJ1dHRvbicpXG5cdFx0XHRcdC5hZGRDbGFzcyh0bSArICctc3RhdGUtYWN0aXZlJyk7XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0ZnVuY3Rpb24gZGVhY3RpdmF0ZUJ1dHRvbihidXR0b25OYW1lKSB7XG5cdFx0aWYgKGVsKSB7XG5cdFx0XHRlbC5maW5kKCcuZmMtJyArIGJ1dHRvbk5hbWUgKyAnLWJ1dHRvbicpXG5cdFx0XHRcdC5yZW1vdmVDbGFzcyh0bSArICctc3RhdGUtYWN0aXZlJyk7XG5cdFx0fVxuXHR9XG5cdFxuXHRcblx0ZnVuY3Rpb24gZGlzYWJsZUJ1dHRvbihidXR0b25OYW1lKSB7XG5cdFx0aWYgKGVsKSB7XG5cdFx0XHRlbC5maW5kKCcuZmMtJyArIGJ1dHRvbk5hbWUgKyAnLWJ1dHRvbicpXG5cdFx0XHRcdC5wcm9wKCdkaXNhYmxlZCcsIHRydWUpXG5cdFx0XHRcdC5hZGRDbGFzcyh0bSArICctc3RhdGUtZGlzYWJsZWQnKTtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHRmdW5jdGlvbiBlbmFibGVCdXR0b24oYnV0dG9uTmFtZSkge1xuXHRcdGlmIChlbCkge1xuXHRcdFx0ZWwuZmluZCgnLmZjLScgKyBidXR0b25OYW1lICsgJy1idXR0b24nKVxuXHRcdFx0XHQucHJvcCgnZGlzYWJsZWQnLCBmYWxzZSlcblx0XHRcdFx0LnJlbW92ZUNsYXNzKHRtICsgJy1zdGF0ZS1kaXNhYmxlZCcpO1xuXHRcdH1cblx0fVxuXG5cblx0ZnVuY3Rpb24gZ2V0Vmlld3NXaXRoQnV0dG9ucygpIHtcblx0XHRyZXR1cm4gdmlld3NXaXRoQnV0dG9ucztcblx0fVxuXG59XG5cbjs7XG5cbkZDLnNvdXJjZU5vcm1hbGl6ZXJzID0gW107XG5GQy5zb3VyY2VGZXRjaGVycyA9IFtdO1xuXG52YXIgYWpheERlZmF1bHRzID0ge1xuXHRkYXRhVHlwZTogJ2pzb24nLFxuXHRjYWNoZTogZmFsc2Vcbn07XG5cbnZhciBldmVudEdVSUQgPSAxO1xuXG5cbmZ1bmN0aW9uIEV2ZW50TWFuYWdlcigpIHsgLy8gYXNzdW1lZCB0byBiZSBhIGNhbGVuZGFyXG5cdHZhciB0ID0gdGhpcztcblx0XG5cdFxuXHQvLyBleHBvcnRzXG5cdHQuaXNGZXRjaE5lZWRlZCA9IGlzRmV0Y2hOZWVkZWQ7XG5cdHQuZmV0Y2hFdmVudHMgPSBmZXRjaEV2ZW50cztcblx0dC5mZXRjaEV2ZW50U291cmNlcyA9IGZldGNoRXZlbnRTb3VyY2VzO1xuXHR0LmdldEV2ZW50U291cmNlcyA9IGdldEV2ZW50U291cmNlcztcblx0dC5nZXRFdmVudFNvdXJjZUJ5SWQgPSBnZXRFdmVudFNvdXJjZUJ5SWQ7XG5cdHQuZ2V0RXZlbnRTb3VyY2VzQnlNYXRjaEFycmF5ID0gZ2V0RXZlbnRTb3VyY2VzQnlNYXRjaEFycmF5O1xuXHR0LmdldEV2ZW50U291cmNlc0J5TWF0Y2ggPSBnZXRFdmVudFNvdXJjZXNCeU1hdGNoO1xuXHR0LmFkZEV2ZW50U291cmNlID0gYWRkRXZlbnRTb3VyY2U7XG5cdHQucmVtb3ZlRXZlbnRTb3VyY2UgPSByZW1vdmVFdmVudFNvdXJjZTtcblx0dC5yZW1vdmVFdmVudFNvdXJjZXMgPSByZW1vdmVFdmVudFNvdXJjZXM7XG5cdHQudXBkYXRlRXZlbnQgPSB1cGRhdGVFdmVudDtcblx0dC5yZW5kZXJFdmVudCA9IHJlbmRlckV2ZW50O1xuXHR0LnJlbW92ZUV2ZW50cyA9IHJlbW92ZUV2ZW50cztcblx0dC5jbGllbnRFdmVudHMgPSBjbGllbnRFdmVudHM7XG5cdHQubXV0YXRlRXZlbnQgPSBtdXRhdGVFdmVudDtcblx0dC5ub3JtYWxpemVFdmVudERhdGVzID0gbm9ybWFsaXplRXZlbnREYXRlcztcblx0dC5ub3JtYWxpemVFdmVudFRpbWVzID0gbm9ybWFsaXplRXZlbnRUaW1lcztcblx0XG5cdFxuXHQvLyBpbXBvcnRzXG5cdHZhciByZXBvcnRFdmVudHMgPSB0LnJlcG9ydEV2ZW50cztcblx0XG5cdFxuXHQvLyBsb2NhbHNcblx0dmFyIHN0aWNreVNvdXJjZSA9IHsgZXZlbnRzOiBbXSB9O1xuXHR2YXIgc291cmNlcyA9IFsgc3RpY2t5U291cmNlIF07XG5cdHZhciByYW5nZVN0YXJ0LCByYW5nZUVuZDtcblx0dmFyIHBlbmRpbmdTb3VyY2VDbnQgPSAwOyAvLyBvdXRzdGFuZGluZyBmZXRjaCByZXF1ZXN0cywgbWF4IG9uZSBwZXIgc291cmNlXG5cdHZhciBjYWNoZSA9IFtdOyAvLyBob2xkcyBldmVudHMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBleHBhbmRlZFxuXG5cblx0JC5lYWNoKFxuXHRcdCh0Lm9wdGlvbnMuZXZlbnRzID8gWyB0Lm9wdGlvbnMuZXZlbnRzIF0gOiBbXSkuY29uY2F0KHQub3B0aW9ucy5ldmVudFNvdXJjZXMgfHwgW10pLFxuXHRcdGZ1bmN0aW9uKGksIHNvdXJjZUlucHV0KSB7XG5cdFx0XHR2YXIgc291cmNlID0gYnVpbGRFdmVudFNvdXJjZShzb3VyY2VJbnB1dCk7XG5cdFx0XHRpZiAoc291cmNlKSB7XG5cdFx0XHRcdHNvdXJjZXMucHVzaChzb3VyY2UpO1xuXHRcdFx0fVxuXHRcdH1cblx0KTtcblx0XG5cdFxuXHRcblx0LyogRmV0Y2hpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gc3RhcnQgYW5kIGVuZCBhcmUgYXNzdW1lZCB0byBiZSB1bnpvbmVkXG5cdGZ1bmN0aW9uIGlzRmV0Y2hOZWVkZWQoc3RhcnQsIGVuZCkge1xuXHRcdHJldHVybiAhcmFuZ2VTdGFydCB8fCAvLyBub3RoaW5nIGhhcyBiZWVuIGZldGNoZWQgeWV0P1xuXHRcdFx0c3RhcnQgPCByYW5nZVN0YXJ0IHx8IGVuZCA+IHJhbmdlRW5kOyAvLyBpcyBwYXJ0IG9mIHRoZSBuZXcgcmFuZ2Ugb3V0c2lkZSBvZiB0aGUgb2xkIHJhbmdlP1xuXHR9XG5cdFxuXHRcblx0ZnVuY3Rpb24gZmV0Y2hFdmVudHMoc3RhcnQsIGVuZCkge1xuXHRcdHJhbmdlU3RhcnQgPSBzdGFydDtcblx0XHRyYW5nZUVuZCA9IGVuZDtcblx0XHRmZXRjaEV2ZW50U291cmNlcyhzb3VyY2VzLCAncmVzZXQnKTtcblx0fVxuXG5cblx0Ly8gZXhwZWN0cyBhbiBhcnJheSBvZiBldmVudCBzb3VyY2Ugb2JqZWN0cyAodGhlIG9yaWdpbmFscywgbm90IGNvcGllcylcblx0Ly8gYHNwZWNpYWxGZXRjaFR5cGVgIGlzIGFuIG9wdGltaXphdGlvbiBwYXJhbWV0ZXIgdGhhdCBhZmZlY3RzIHB1cmdpbmcgb2YgdGhlIGV2ZW50IGNhY2hlLlxuXHRmdW5jdGlvbiBmZXRjaEV2ZW50U291cmNlcyhzcGVjaWZpY1NvdXJjZXMsIHNwZWNpYWxGZXRjaFR5cGUpIHtcblx0XHR2YXIgaSwgc291cmNlO1xuXG5cdFx0aWYgKHNwZWNpYWxGZXRjaFR5cGUgPT09ICdyZXNldCcpIHtcblx0XHRcdGNhY2hlID0gW107XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHNwZWNpYWxGZXRjaFR5cGUgIT09ICdhZGQnKSB7XG5cdFx0XHRjYWNoZSA9IGV4Y2x1ZGVFdmVudHNCeVNvdXJjZXMoY2FjaGUsIHNwZWNpZmljU291cmNlcyk7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMDsgaSA8IHNwZWNpZmljU291cmNlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0c291cmNlID0gc3BlY2lmaWNTb3VyY2VzW2ldO1xuXG5cdFx0XHQvLyBhbHJlYWR5LXBlbmRpbmcgc291cmNlcyBoYXZlIGFscmVhZHkgYmVlbiBhY2NvdW50ZWQgZm9yIGluIHBlbmRpbmdTb3VyY2VDbnRcblx0XHRcdGlmIChzb3VyY2UuX3N0YXR1cyAhPT0gJ3BlbmRpbmcnKSB7XG5cdFx0XHRcdHBlbmRpbmdTb3VyY2VDbnQrKztcblx0XHRcdH1cblxuXHRcdFx0c291cmNlLl9mZXRjaElkID0gKHNvdXJjZS5fZmV0Y2hJZCB8fCAwKSArIDE7XG5cdFx0XHRzb3VyY2UuX3N0YXR1cyA9ICdwZW5kaW5nJztcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgc3BlY2lmaWNTb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRzb3VyY2UgPSBzcGVjaWZpY1NvdXJjZXNbaV07XG5cblx0XHRcdHRyeUZldGNoRXZlbnRTb3VyY2Uoc291cmNlLCBzb3VyY2UuX2ZldGNoSWQpO1xuXHRcdH1cblx0fVxuXG5cblx0Ly8gZmV0Y2hlcyBhbiBldmVudCBzb3VyY2UgYW5kIHByb2Nlc3NlcyBpdHMgcmVzdWx0IE9OTFkgaWYgaXQgaXMgc3RpbGwgdGhlIGN1cnJlbnQgZmV0Y2guXG5cdC8vIGNhbGxlciBpcyByZXNwb25zaWJsZSBmb3IgaW5jcmVtZW50aW5nIHBlbmRpbmdTb3VyY2VDbnQgZmlyc3QuXG5cdGZ1bmN0aW9uIHRyeUZldGNoRXZlbnRTb3VyY2Uoc291cmNlLCBmZXRjaElkKSB7XG5cdFx0X2ZldGNoRXZlbnRTb3VyY2Uoc291cmNlLCBmdW5jdGlvbihldmVudElucHV0cykge1xuXHRcdFx0dmFyIGlzQXJyYXlTb3VyY2UgPSAkLmlzQXJyYXkoc291cmNlLmV2ZW50cyk7XG5cdFx0XHR2YXIgaSwgZXZlbnRJbnB1dDtcblx0XHRcdHZhciBhYnN0cmFjdEV2ZW50O1xuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdC8vIGlzIHRoaXMgdGhlIHNvdXJjZSdzIG1vc3QgcmVjZW50IGZldGNoP1xuXHRcdFx0XHQvLyBpZiBub3QsIHJlbHkgb24gYW4gdXBjb21pbmcgZmV0Y2ggb2YgdGhpcyBzb3VyY2UgdG8gZGVjcmVtZW50IHBlbmRpbmdTb3VyY2VDbnRcblx0XHRcdFx0ZmV0Y2hJZCA9PT0gc291cmNlLl9mZXRjaElkICYmXG5cdFx0XHRcdC8vIGV2ZW50IHNvdXJjZSBubyBsb25nZXIgdmFsaWQ/XG5cdFx0XHRcdHNvdXJjZS5fc3RhdHVzICE9PSAncmVqZWN0ZWQnXG5cdFx0XHQpIHtcblx0XHRcdFx0c291cmNlLl9zdGF0dXMgPSAncmVzb2x2ZWQnO1xuXG5cdFx0XHRcdGlmIChldmVudElucHV0cykge1xuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBldmVudElucHV0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0ZXZlbnRJbnB1dCA9IGV2ZW50SW5wdXRzW2ldO1xuXG5cdFx0XHRcdFx0XHRpZiAoaXNBcnJheVNvdXJjZSkgeyAvLyBhcnJheSBzb3VyY2VzIGhhdmUgYWxyZWFkeSBiZWVuIGNvbnZlcnQgdG8gRXZlbnQgT2JqZWN0c1xuXHRcdFx0XHRcdFx0XHRhYnN0cmFjdEV2ZW50ID0gZXZlbnRJbnB1dDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRhYnN0cmFjdEV2ZW50ID0gYnVpbGRFdmVudEZyb21JbnB1dChldmVudElucHV0LCBzb3VyY2UpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoYWJzdHJhY3RFdmVudCkgeyAvLyBub3QgZmFsc2UgKGFuIGludmFsaWQgZXZlbnQpXG5cdFx0XHRcdFx0XHRcdGNhY2hlLnB1c2guYXBwbHkoXG5cdFx0XHRcdFx0XHRcdFx0Y2FjaGUsXG5cdFx0XHRcdFx0XHRcdFx0ZXhwYW5kRXZlbnQoYWJzdHJhY3RFdmVudCkgLy8gYWRkIGluZGl2aWR1YWwgZXhwYW5kZWQgZXZlbnRzIHRvIHRoZSBjYWNoZVxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlY3JlbWVudFBlbmRpbmdTb3VyY2VDbnQoKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cblx0ZnVuY3Rpb24gcmVqZWN0RXZlbnRTb3VyY2Uoc291cmNlKSB7XG5cdFx0dmFyIHdhc1BlbmRpbmcgPSBzb3VyY2UuX3N0YXR1cyA9PT0gJ3BlbmRpbmcnO1xuXG5cdFx0c291cmNlLl9zdGF0dXMgPSAncmVqZWN0ZWQnO1xuXG5cdFx0aWYgKHdhc1BlbmRpbmcpIHtcblx0XHRcdGRlY3JlbWVudFBlbmRpbmdTb3VyY2VDbnQoKTtcblx0XHR9XG5cdH1cblxuXG5cdGZ1bmN0aW9uIGRlY3JlbWVudFBlbmRpbmdTb3VyY2VDbnQoKSB7XG5cdFx0cGVuZGluZ1NvdXJjZUNudC0tO1xuXHRcdGlmICghcGVuZGluZ1NvdXJjZUNudCkge1xuXHRcdFx0cmVwb3J0RXZlbnRzKGNhY2hlKTtcblx0XHR9XG5cdH1cblx0XG5cdFxuXHRmdW5jdGlvbiBfZmV0Y2hFdmVudFNvdXJjZShzb3VyY2UsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIGk7XG5cdFx0dmFyIGZldGNoZXJzID0gRkMuc291cmNlRmV0Y2hlcnM7XG5cdFx0dmFyIHJlcztcblxuXHRcdGZvciAoaT0wOyBpPGZldGNoZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRyZXMgPSBmZXRjaGVyc1tpXS5jYWxsKFxuXHRcdFx0XHR0LCAvLyB0aGlzLCB0aGUgQ2FsZW5kYXIgb2JqZWN0XG5cdFx0XHRcdHNvdXJjZSxcblx0XHRcdFx0cmFuZ2VTdGFydC5jbG9uZSgpLFxuXHRcdFx0XHRyYW5nZUVuZC5jbG9uZSgpLFxuXHRcdFx0XHR0Lm9wdGlvbnMudGltZXpvbmUsXG5cdFx0XHRcdGNhbGxiYWNrXG5cdFx0XHQpO1xuXG5cdFx0XHRpZiAocmVzID09PSB0cnVlKSB7XG5cdFx0XHRcdC8vIHRoZSBmZXRjaGVyIGlzIGluIGNoYXJnZS4gbWFkZSBpdHMgb3duIGFzeW5jIHJlcXVlc3Rcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAodHlwZW9mIHJlcyA9PSAnb2JqZWN0Jykge1xuXHRcdFx0XHQvLyB0aGUgZmV0Y2hlciByZXR1cm5lZCBhIG5ldyBzb3VyY2UuIHByb2Nlc3MgaXRcblx0XHRcdFx0X2ZldGNoRXZlbnRTb3VyY2UocmVzLCBjYWxsYmFjayk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgZXZlbnRzID0gc291cmNlLmV2ZW50cztcblx0XHRpZiAoZXZlbnRzKSB7XG5cdFx0XHRpZiAoJC5pc0Z1bmN0aW9uKGV2ZW50cykpIHtcblx0XHRcdFx0dC5wdXNoTG9hZGluZygpO1xuXHRcdFx0XHRldmVudHMuY2FsbChcblx0XHRcdFx0XHR0LCAvLyB0aGlzLCB0aGUgQ2FsZW5kYXIgb2JqZWN0XG5cdFx0XHRcdFx0cmFuZ2VTdGFydC5jbG9uZSgpLFxuXHRcdFx0XHRcdHJhbmdlRW5kLmNsb25lKCksXG5cdFx0XHRcdFx0dC5vcHRpb25zLnRpbWV6b25lLFxuXHRcdFx0XHRcdGZ1bmN0aW9uKGV2ZW50cykge1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2soZXZlbnRzKTtcblx0XHRcdFx0XHRcdHQucG9wTG9hZGluZygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCQuaXNBcnJheShldmVudHMpKSB7XG5cdFx0XHRcdGNhbGxiYWNrKGV2ZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdH1cblx0XHR9ZWxzZXtcblx0XHRcdHZhciB1cmwgPSBzb3VyY2UudXJsO1xuXHRcdFx0aWYgKHVybCkge1xuXHRcdFx0XHR2YXIgc3VjY2VzcyA9IHNvdXJjZS5zdWNjZXNzO1xuXHRcdFx0XHR2YXIgZXJyb3IgPSBzb3VyY2UuZXJyb3I7XG5cdFx0XHRcdHZhciBjb21wbGV0ZSA9IHNvdXJjZS5jb21wbGV0ZTtcblxuXHRcdFx0XHQvLyByZXRyaWV2ZSBhbnkgb3V0Ym91bmQgR0VUL1BPU1QgJC5hamF4IGRhdGEgZnJvbSB0aGUgb3B0aW9uc1xuXHRcdFx0XHR2YXIgY3VzdG9tRGF0YTtcblx0XHRcdFx0aWYgKCQuaXNGdW5jdGlvbihzb3VyY2UuZGF0YSkpIHtcblx0XHRcdFx0XHQvLyBzdXBwbGllZCBhcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGtleS92YWx1ZSBvYmplY3Rcblx0XHRcdFx0XHRjdXN0b21EYXRhID0gc291cmNlLmRhdGEoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHQvLyBzdXBwbGllZCBhcyBhIHN0cmFpZ2h0IGtleS92YWx1ZSBvYmplY3Rcblx0XHRcdFx0XHRjdXN0b21EYXRhID0gc291cmNlLmRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyB1c2UgYSBjb3B5IG9mIHRoZSBjdXN0b20gZGF0YSBzbyB3ZSBjYW4gbW9kaWZ5IHRoZSBwYXJhbWV0ZXJzXG5cdFx0XHRcdC8vIGFuZCBub3QgYWZmZWN0IHRoZSBwYXNzZWQtaW4gb2JqZWN0LlxuXHRcdFx0XHR2YXIgZGF0YSA9ICQuZXh0ZW5kKHt9LCBjdXN0b21EYXRhIHx8IHt9KTtcblxuXHRcdFx0XHR2YXIgc3RhcnRQYXJhbSA9IGZpcnN0RGVmaW5lZChzb3VyY2Uuc3RhcnRQYXJhbSwgdC5vcHRpb25zLnN0YXJ0UGFyYW0pO1xuXHRcdFx0XHR2YXIgZW5kUGFyYW0gPSBmaXJzdERlZmluZWQoc291cmNlLmVuZFBhcmFtLCB0Lm9wdGlvbnMuZW5kUGFyYW0pO1xuXHRcdFx0XHR2YXIgdGltZXpvbmVQYXJhbSA9IGZpcnN0RGVmaW5lZChzb3VyY2UudGltZXpvbmVQYXJhbSwgdC5vcHRpb25zLnRpbWV6b25lUGFyYW0pO1xuXG5cdFx0XHRcdGlmIChzdGFydFBhcmFtKSB7XG5cdFx0XHRcdFx0ZGF0YVtzdGFydFBhcmFtXSA9IHJhbmdlU3RhcnQuZm9ybWF0KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGVuZFBhcmFtKSB7XG5cdFx0XHRcdFx0ZGF0YVtlbmRQYXJhbV0gPSByYW5nZUVuZC5mb3JtYXQoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodC5vcHRpb25zLnRpbWV6b25lICYmIHQub3B0aW9ucy50aW1lem9uZSAhPSAnbG9jYWwnKSB7XG5cdFx0XHRcdFx0ZGF0YVt0aW1lem9uZVBhcmFtXSA9IHQub3B0aW9ucy50aW1lem9uZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHQucHVzaExvYWRpbmcoKTtcblx0XHRcdFx0JC5hamF4KCQuZXh0ZW5kKHt9LCBhamF4RGVmYXVsdHMsIHNvdXJjZSwge1xuXHRcdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdFx0c3VjY2VzczogZnVuY3Rpb24oZXZlbnRzKSB7XG5cdFx0XHRcdFx0XHRldmVudHMgPSBldmVudHMgfHwgW107XG5cdFx0XHRcdFx0XHR2YXIgcmVzID0gYXBwbHlBbGwoc3VjY2VzcywgdGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0XHRcdGlmICgkLmlzQXJyYXkocmVzKSkge1xuXHRcdFx0XHRcdFx0XHRldmVudHMgPSByZXM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjYWxsYmFjayhldmVudHMpO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0ZXJyb3I6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0YXBwbHlBbGwoZXJyb3IsIHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0Y29tcGxldGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0YXBwbHlBbGwoY29tcGxldGUsIHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdFx0XHR0LnBvcExvYWRpbmcoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pKTtcblx0XHRcdH1lbHNle1xuXHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRcblx0XG5cdFxuXHQvKiBTb3VyY2VzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdGZ1bmN0aW9uIGFkZEV2ZW50U291cmNlKHNvdXJjZUlucHV0KSB7XG5cdFx0dmFyIHNvdXJjZSA9IGJ1aWxkRXZlbnRTb3VyY2Uoc291cmNlSW5wdXQpO1xuXHRcdGlmIChzb3VyY2UpIHtcblx0XHRcdHNvdXJjZXMucHVzaChzb3VyY2UpO1xuXHRcdFx0ZmV0Y2hFdmVudFNvdXJjZXMoWyBzb3VyY2UgXSwgJ2FkZCcpOyAvLyB3aWxsIGV2ZW50dWFsbHkgY2FsbCByZXBvcnRFdmVudHNcblx0XHR9XG5cdH1cblxuXG5cdGZ1bmN0aW9uIGJ1aWxkRXZlbnRTb3VyY2Uoc291cmNlSW5wdXQpIHsgLy8gd2lsbCByZXR1cm4gdW5kZWZpbmVkIGlmIGludmFsaWQgc291cmNlXG5cdFx0dmFyIG5vcm1hbGl6ZXJzID0gRkMuc291cmNlTm9ybWFsaXplcnM7XG5cdFx0dmFyIHNvdXJjZTtcblx0XHR2YXIgaTtcblxuXHRcdGlmICgkLmlzRnVuY3Rpb24oc291cmNlSW5wdXQpIHx8ICQuaXNBcnJheShzb3VyY2VJbnB1dCkpIHtcblx0XHRcdHNvdXJjZSA9IHsgZXZlbnRzOiBzb3VyY2VJbnB1dCB9O1xuXHRcdH1cblx0XHRlbHNlIGlmICh0eXBlb2Ygc291cmNlSW5wdXQgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRzb3VyY2UgPSB7IHVybDogc291cmNlSW5wdXQgfTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAodHlwZW9mIHNvdXJjZUlucHV0ID09PSAnb2JqZWN0Jykge1xuXHRcdFx0c291cmNlID0gJC5leHRlbmQoe30sIHNvdXJjZUlucHV0KTsgLy8gc2hhbGxvdyBjb3B5XG5cdFx0fVxuXG5cdFx0aWYgKHNvdXJjZSkge1xuXG5cdFx0XHQvLyBUT0RPOiByZXBlYXQgY29kZSwgc2FtZSBjb2RlIGZvciBldmVudCBjbGFzc05hbWVzXG5cdFx0XHRpZiAoc291cmNlLmNsYXNzTmFtZSkge1xuXHRcdFx0XHRpZiAodHlwZW9mIHNvdXJjZS5jbGFzc05hbWUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0c291cmNlLmNsYXNzTmFtZSA9IHNvdXJjZS5jbGFzc05hbWUuc3BsaXQoL1xccysvKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBvdGhlcndpc2UsIGFzc3VtZWQgdG8gYmUgYW4gYXJyYXlcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRzb3VyY2UuY2xhc3NOYW1lID0gW107XG5cdFx0XHR9XG5cblx0XHRcdC8vIGZvciBhcnJheSBzb3VyY2VzLCB3ZSBjb252ZXJ0IHRvIHN0YW5kYXJkIEV2ZW50IE9iamVjdHMgdXAgZnJvbnRcblx0XHRcdGlmICgkLmlzQXJyYXkoc291cmNlLmV2ZW50cykpIHtcblx0XHRcdFx0c291cmNlLm9yaWdBcnJheSA9IHNvdXJjZS5ldmVudHM7IC8vIGZvciByZW1vdmVFdmVudFNvdXJjZVxuXHRcdFx0XHRzb3VyY2UuZXZlbnRzID0gJC5tYXAoc291cmNlLmV2ZW50cywgZnVuY3Rpb24oZXZlbnRJbnB1dCkge1xuXHRcdFx0XHRcdHJldHVybiBidWlsZEV2ZW50RnJvbUlucHV0KGV2ZW50SW5wdXQsIHNvdXJjZSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKGk9MDsgaTxub3JtYWxpemVycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRub3JtYWxpemVyc1tpXS5jYWxsKHQsIHNvdXJjZSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzb3VyY2U7XG5cdFx0fVxuXHR9XG5cblxuXHRmdW5jdGlvbiByZW1vdmVFdmVudFNvdXJjZShtYXRjaElucHV0KSB7XG5cdFx0cmVtb3ZlU3BlY2lmaWNFdmVudFNvdXJjZXMoXG5cdFx0XHRnZXRFdmVudFNvdXJjZXNCeU1hdGNoKG1hdGNoSW5wdXQpXG5cdFx0KTtcblx0fVxuXG5cblx0Ly8gaWYgY2FsbGVkIHdpdGggbm8gYXJndW1lbnRzLCByZW1vdmVzIGFsbC5cblx0ZnVuY3Rpb24gcmVtb3ZlRXZlbnRTb3VyY2VzKG1hdGNoSW5wdXRzKSB7XG5cdFx0aWYgKG1hdGNoSW5wdXRzID09IG51bGwpIHtcblx0XHRcdHJlbW92ZVNwZWNpZmljRXZlbnRTb3VyY2VzKHNvdXJjZXMsIHRydWUpOyAvLyBpc0FsbD10cnVlXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmVtb3ZlU3BlY2lmaWNFdmVudFNvdXJjZXMoXG5cdFx0XHRcdGdldEV2ZW50U291cmNlc0J5TWF0Y2hBcnJheShtYXRjaElucHV0cylcblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cblxuXHRmdW5jdGlvbiByZW1vdmVTcGVjaWZpY0V2ZW50U291cmNlcyh0YXJnZXRTb3VyY2VzLCBpc0FsbCkge1xuXHRcdHZhciBpO1xuXG5cdFx0Ly8gY2FuY2VsIHBlbmRpbmcgcmVxdWVzdHNcblx0XHRmb3IgKGkgPSAwOyBpIDwgdGFyZ2V0U291cmNlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0cmVqZWN0RXZlbnRTb3VyY2UodGFyZ2V0U291cmNlc1tpXSk7XG5cdFx0fVxuXG5cdFx0aWYgKGlzQWxsKSB7IC8vIGFuIG9wdGltaXphdGlvblxuXHRcdFx0c291cmNlcyA9IFtdO1xuXHRcdFx0Y2FjaGUgPSBbXTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyByZW1vdmUgZnJvbSBwZXJzaXN0ZWQgc291cmNlIGxpc3Rcblx0XHRcdHNvdXJjZXMgPSAkLmdyZXAoc291cmNlcywgZnVuY3Rpb24oc291cmNlKSB7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCB0YXJnZXRTb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKHNvdXJjZSA9PT0gdGFyZ2V0U291cmNlc1tpXSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlOyAvLyBleGNsdWRlXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlOyAvLyBpbmNsdWRlXG5cdFx0XHR9KTtcblxuXHRcdFx0Y2FjaGUgPSBleGNsdWRlRXZlbnRzQnlTb3VyY2VzKGNhY2hlLCB0YXJnZXRTb3VyY2VzKTtcblx0XHR9XG5cblx0XHRyZXBvcnRFdmVudHMoY2FjaGUpO1xuXHR9XG5cblxuXHRmdW5jdGlvbiBnZXRFdmVudFNvdXJjZXMoKSB7XG5cdFx0cmV0dXJuIHNvdXJjZXMuc2xpY2UoMSk7IC8vIHJldHVybnMgYSBzaGFsbG93IGNvcHkgb2Ygc291cmNlcyB3aXRoIHN0aWNreVNvdXJjZSByZW1vdmVkXG5cdH1cblxuXG5cdGZ1bmN0aW9uIGdldEV2ZW50U291cmNlQnlJZChpZCkge1xuXHRcdHJldHVybiAkLmdyZXAoc291cmNlcywgZnVuY3Rpb24oc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gc291cmNlLmlkICYmIHNvdXJjZS5pZCA9PT0gaWQ7XG5cdFx0fSlbMF07XG5cdH1cblxuXG5cdC8vIGxpa2UgZ2V0RXZlbnRTb3VyY2VzQnlNYXRjaCwgYnV0IGFjY2VwdHMgbXVsdHBsZSBtYXRjaCBjcml0ZXJpYSAobGlrZSBtdWx0aXBsZSBJRHMpXG5cdGZ1bmN0aW9uIGdldEV2ZW50U291cmNlc0J5TWF0Y2hBcnJheShtYXRjaElucHV0cykge1xuXG5cdFx0Ly8gY29lcmNlIGludG8gYW4gYXJyYXlcblx0XHRpZiAoIW1hdGNoSW5wdXRzKSB7XG5cdFx0XHRtYXRjaElucHV0cyA9IFtdO1xuXHRcdH1cblx0XHRlbHNlIGlmICghJC5pc0FycmF5KG1hdGNoSW5wdXRzKSkge1xuXHRcdFx0bWF0Y2hJbnB1dHMgPSBbIG1hdGNoSW5wdXRzIF07XG5cdFx0fVxuXG5cdFx0dmFyIG1hdGNoaW5nU291cmNlcyA9IFtdO1xuXHRcdHZhciBpO1xuXG5cdFx0Ly8gcmVzb2x2ZSByYXcgaW5wdXRzIHRvIHJlYWwgZXZlbnQgc291cmNlIG9iamVjdHNcblx0XHRmb3IgKGkgPSAwOyBpIDwgbWF0Y2hJbnB1dHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdG1hdGNoaW5nU291cmNlcy5wdXNoLmFwcGx5KCAvLyBhcHBlbmRcblx0XHRcdFx0bWF0Y2hpbmdTb3VyY2VzLFxuXHRcdFx0XHRnZXRFdmVudFNvdXJjZXNCeU1hdGNoKG1hdGNoSW5wdXRzW2ldKVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0Y2hpbmdTb3VyY2VzO1xuXHR9XG5cblxuXHQvLyBtYXRjaElucHV0IGNhbiBlaXRoZXIgYnkgYSByZWFsIGV2ZW50IHNvdXJjZSBvYmplY3QsIGFuIElELCBvciB0aGUgZnVuY3Rpb24vVVJMIGZvciB0aGUgc291cmNlLlxuXHQvLyByZXR1cm5zIGFuIGFycmF5IG9mIG1hdGNoaW5nIHNvdXJjZSBvYmplY3RzLlxuXHRmdW5jdGlvbiBnZXRFdmVudFNvdXJjZXNCeU1hdGNoKG1hdGNoSW5wdXQpIHtcblx0XHR2YXIgaSwgc291cmNlO1xuXG5cdFx0Ly8gZ2l2ZW4gYW4gcHJvcGVyIGV2ZW50IHNvdXJjZSBvYmplY3Rcblx0XHRmb3IgKGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0c291cmNlID0gc291cmNlc1tpXTtcblx0XHRcdGlmIChzb3VyY2UgPT09IG1hdGNoSW5wdXQpIHtcblx0XHRcdFx0cmV0dXJuIFsgc291cmNlIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gYW4gSUQgbWF0Y2hcblx0XHRzb3VyY2UgPSBnZXRFdmVudFNvdXJjZUJ5SWQobWF0Y2hJbnB1dCk7XG5cdFx0aWYgKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuIFsgc291cmNlIF07XG5cdFx0fVxuXG5cdFx0cmV0dXJuICQuZ3JlcChzb3VyY2VzLCBmdW5jdGlvbihzb3VyY2UpIHtcblx0XHRcdHJldHVybiBpc1NvdXJjZXNFcXVpdmFsZW50KG1hdGNoSW5wdXQsIHNvdXJjZSk7XG5cdFx0fSk7XG5cdH1cblxuXG5cdGZ1bmN0aW9uIGlzU291cmNlc0VxdWl2YWxlbnQoc291cmNlMSwgc291cmNlMikge1xuXHRcdHJldHVybiBzb3VyY2UxICYmIHNvdXJjZTIgJiYgZ2V0U291cmNlUHJpbWl0aXZlKHNvdXJjZTEpID09IGdldFNvdXJjZVByaW1pdGl2ZShzb3VyY2UyKTtcblx0fVxuXG5cblx0ZnVuY3Rpb24gZ2V0U291cmNlUHJpbWl0aXZlKHNvdXJjZSkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQodHlwZW9mIHNvdXJjZSA9PT0gJ29iamVjdCcpID8gLy8gYSBub3JtYWxpemVkIGV2ZW50IHNvdXJjZT9cblx0XHRcdFx0KHNvdXJjZS5vcmlnQXJyYXkgfHwgc291cmNlLmdvb2dsZUNhbGVuZGFySWQgfHwgc291cmNlLnVybCB8fCBzb3VyY2UuZXZlbnRzKSA6IC8vIGdldCB0aGUgcHJpbWl0aXZlXG5cdFx0XHRcdG51bGxcblx0XHQpIHx8XG5cdFx0c291cmNlOyAvLyB0aGUgZ2l2ZW4gYXJndW1lbnQgKmlzKiB0aGUgcHJpbWl0aXZlXG5cdH1cblxuXG5cdC8vIHV0aWxcblx0Ly8gcmV0dXJucyBhIGZpbHRlcmVkIGFycmF5IHdpdGhvdXQgZXZlbnRzIHRoYXQgYXJlIHBhcnQgb2YgYW55IG9mIHRoZSBnaXZlbiBzb3VyY2VzXG5cdGZ1bmN0aW9uIGV4Y2x1ZGVFdmVudHNCeVNvdXJjZXMoc3BlY2lmaWNFdmVudHMsIHNwZWNpZmljU291cmNlcykge1xuXHRcdHJldHVybiAkLmdyZXAoc3BlY2lmaWNFdmVudHMsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHNwZWNpZmljU291cmNlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoZXZlbnQuc291cmNlID09PSBzcGVjaWZpY1NvdXJjZXNbaV0pIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7IC8vIGV4Y2x1ZGVcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7IC8vIGtlZXBcblx0XHR9KTtcblx0fVxuXHRcblx0XG5cdFxuXHQvKiBNYW5pcHVsYXRpb25cblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gT25seSBldmVyIGNhbGxlZCBmcm9tIHRoZSBleHRlcm5hbGx5LWZhY2luZyBBUElcblx0ZnVuY3Rpb24gdXBkYXRlRXZlbnQoZXZlbnQpIHtcblxuXHRcdC8vIG1hc3NhZ2Ugc3RhcnQvZW5kIHZhbHVlcywgZXZlbiBpZiBkYXRlIHN0cmluZyB2YWx1ZXNcblx0XHRldmVudC5zdGFydCA9IHQubW9tZW50KGV2ZW50LnN0YXJ0KTtcblx0XHRpZiAoZXZlbnQuZW5kKSB7XG5cdFx0XHRldmVudC5lbmQgPSB0Lm1vbWVudChldmVudC5lbmQpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGV2ZW50LmVuZCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0bXV0YXRlRXZlbnQoZXZlbnQsIGdldE1pc2NFdmVudFByb3BzKGV2ZW50KSk7IC8vIHdpbGwgaGFuZGxlIHN0YXJ0L2VuZC9hbGxEYXkgbm9ybWFsaXphdGlvblxuXHRcdHJlcG9ydEV2ZW50cyhjYWNoZSk7IC8vIHJlcG9ydHMgZXZlbnQgbW9kaWZpY2F0aW9ucyAoc28gd2UgY2FuIHJlZHJhdylcblx0fVxuXG5cblx0Ly8gUmV0dXJucyBhIGhhc2ggb2YgbWlzYyBldmVudCBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGJlIGNvcGllZCBvdmVyIHRvIHJlbGF0ZWQgZXZlbnRzLlxuXHRmdW5jdGlvbiBnZXRNaXNjRXZlbnRQcm9wcyhldmVudCkge1xuXHRcdHZhciBwcm9wcyA9IHt9O1xuXG5cdFx0JC5lYWNoKGV2ZW50LCBmdW5jdGlvbihuYW1lLCB2YWwpIHtcblx0XHRcdGlmIChpc01pc2NFdmVudFByb3BOYW1lKG5hbWUpKSB7XG5cdFx0XHRcdGlmICh2YWwgIT09IHVuZGVmaW5lZCAmJiBpc0F0b21pYyh2YWwpKSB7IC8vIGEgZGVmaW5lZCBub24tb2JqZWN0XG5cdFx0XHRcdFx0cHJvcHNbbmFtZV0gPSB2YWw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiBwcm9wcztcblx0fVxuXG5cdC8vIG5vbi1kYXRlLXJlbGF0ZWQsIG5vbi1pZC1yZWxhdGVkLCBub24tc2VjcmV0XG5cdGZ1bmN0aW9uIGlzTWlzY0V2ZW50UHJvcE5hbWUobmFtZSkge1xuXHRcdHJldHVybiAhL15ffF4oaWR8YWxsRGF5fHN0YXJ0fGVuZCkkLy50ZXN0KG5hbWUpO1xuXHR9XG5cblx0XG5cdC8vIHJldHVybnMgdGhlIGV4cGFuZGVkIGV2ZW50cyB0aGF0IHdlcmUgY3JlYXRlZFxuXHRmdW5jdGlvbiByZW5kZXJFdmVudChldmVudElucHV0LCBzdGljaykge1xuXHRcdHZhciBhYnN0cmFjdEV2ZW50ID0gYnVpbGRFdmVudEZyb21JbnB1dChldmVudElucHV0KTtcblx0XHR2YXIgZXZlbnRzO1xuXHRcdHZhciBpLCBldmVudDtcblxuXHRcdGlmIChhYnN0cmFjdEV2ZW50KSB7IC8vIG5vdCBmYWxzZSAoYSB2YWxpZCBpbnB1dClcblx0XHRcdGV2ZW50cyA9IGV4cGFuZEV2ZW50KGFic3RyYWN0RXZlbnQpO1xuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGV2ZW50ID0gZXZlbnRzW2ldO1xuXG5cdFx0XHRcdGlmICghZXZlbnQuc291cmNlKSB7XG5cdFx0XHRcdFx0aWYgKHN0aWNrKSB7XG5cdFx0XHRcdFx0XHRzdGlja3lTb3VyY2UuZXZlbnRzLnB1c2goZXZlbnQpO1xuXHRcdFx0XHRcdFx0ZXZlbnQuc291cmNlID0gc3RpY2t5U291cmNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjYWNoZS5wdXNoKGV2ZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXBvcnRFdmVudHMoY2FjaGUpO1xuXG5cdFx0XHRyZXR1cm4gZXZlbnRzO1xuXHRcdH1cblxuXHRcdHJldHVybiBbXTtcblx0fVxuXHRcblx0XG5cdGZ1bmN0aW9uIHJlbW92ZUV2ZW50cyhmaWx0ZXIpIHtcblx0XHR2YXIgZXZlbnRJRDtcblx0XHR2YXIgaTtcblxuXHRcdGlmIChmaWx0ZXIgPT0gbnVsbCkgeyAvLyBudWxsIG9yIHVuZGVmaW5lZC4gcmVtb3ZlIGFsbCBldmVudHNcblx0XHRcdGZpbHRlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfTsgLy8gd2lsbCBhbHdheXMgbWF0Y2hcblx0XHR9XG5cdFx0ZWxzZSBpZiAoISQuaXNGdW5jdGlvbihmaWx0ZXIpKSB7IC8vIGFuIGV2ZW50IElEXG5cdFx0XHRldmVudElEID0gZmlsdGVyICsgJyc7XG5cdFx0XHRmaWx0ZXIgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRyZXR1cm4gZXZlbnQuX2lkID09IGV2ZW50SUQ7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIFB1cmdlIGV2ZW50KHMpIGZyb20gb3VyIGxvY2FsIGNhY2hlXG5cdFx0Y2FjaGUgPSAkLmdyZXAoY2FjaGUsIGZpbHRlciwgdHJ1ZSk7IC8vIGludmVyc2U9dHJ1ZVxuXG5cdFx0Ly8gUmVtb3ZlIGV2ZW50cyBmcm9tIGFycmF5IHNvdXJjZXMuXG5cdFx0Ly8gVGhpcyB3b3JrcyBiZWNhdXNlIHRoZXkgaGF2ZSBiZWVuIGNvbnZlcnRlZCB0byBvZmZpY2lhbCBFdmVudCBPYmplY3RzIHVwIGZyb250LlxuXHRcdC8vIChhbmQgYXMgYSByZXN1bHQsIGV2ZW50Ll9pZCBoYXMgYmVlbiBjYWxjdWxhdGVkKS5cblx0XHRmb3IgKGk9MDsgaTxzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoJC5pc0FycmF5KHNvdXJjZXNbaV0uZXZlbnRzKSkge1xuXHRcdFx0XHRzb3VyY2VzW2ldLmV2ZW50cyA9ICQuZ3JlcChzb3VyY2VzW2ldLmV2ZW50cywgZmlsdGVyLCB0cnVlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXBvcnRFdmVudHMoY2FjaGUpO1xuXHR9XG5cblx0XG5cdGZ1bmN0aW9uIGNsaWVudEV2ZW50cyhmaWx0ZXIpIHtcblx0XHRpZiAoJC5pc0Z1bmN0aW9uKGZpbHRlcikpIHtcblx0XHRcdHJldHVybiAkLmdyZXAoY2FjaGUsIGZpbHRlcik7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKGZpbHRlciAhPSBudWxsKSB7IC8vIG5vdCBudWxsLCBub3QgdW5kZWZpbmVkLiBhbiBldmVudCBJRFxuXHRcdFx0ZmlsdGVyICs9ICcnO1xuXHRcdFx0cmV0dXJuICQuZ3JlcChjYWNoZSwgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRyZXR1cm4gZS5faWQgPT0gZmlsdGVyO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHJldHVybiBjYWNoZTsgLy8gZWxzZSwgcmV0dXJuIGFsbFxuXHR9XG5cblxuXHQvLyBNYWtlcyBzdXJlIGFsbCBhcnJheSBldmVudCBzb3VyY2VzIGhhdmUgdGhlaXIgaW50ZXJuYWwgZXZlbnQgb2JqZWN0c1xuXHQvLyBjb252ZXJ0ZWQgb3ZlciB0byB0aGUgQ2FsZW5kYXIncyBjdXJyZW50IHRpbWV6b25lLlxuXHR0LnJlem9uZUFycmF5RXZlbnRTb3VyY2VzID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGk7XG5cdFx0dmFyIGV2ZW50cztcblx0XHR2YXIgajtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRldmVudHMgPSBzb3VyY2VzW2ldLmV2ZW50cztcblx0XHRcdGlmICgkLmlzQXJyYXkoZXZlbnRzKSkge1xuXG5cdFx0XHRcdGZvciAoaiA9IDA7IGogPCBldmVudHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRyZXpvbmVFdmVudERhdGVzKGV2ZW50c1tqXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0ZnVuY3Rpb24gcmV6b25lRXZlbnREYXRlcyhldmVudCkge1xuXHRcdGV2ZW50LnN0YXJ0ID0gdC5tb21lbnQoZXZlbnQuc3RhcnQpO1xuXHRcdGlmIChldmVudC5lbmQpIHtcblx0XHRcdGV2ZW50LmVuZCA9IHQubW9tZW50KGV2ZW50LmVuZCk7XG5cdFx0fVxuXHRcdGJhY2t1cEV2ZW50RGF0ZXMoZXZlbnQpO1xuXHR9XG5cdFxuXHRcblx0LyogRXZlbnQgTm9ybWFsaXphdGlvblxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBHaXZlbiBhIHJhdyBvYmplY3Qgd2l0aCBrZXkvdmFsdWUgcHJvcGVydGllcywgcmV0dXJucyBhbiBcImFic3RyYWN0XCIgRXZlbnQgb2JqZWN0LlxuXHQvLyBBbiBcImFic3RyYWN0XCIgZXZlbnQgaXMgYW4gZXZlbnQgdGhhdCwgaWYgcmVjdXJyaW5nLCB3aWxsIG5vdCBoYXZlIGJlZW4gZXhwYW5kZWQgeWV0LlxuXHQvLyBXaWxsIHJldHVybiBgZmFsc2VgIHdoZW4gaW5wdXQgaXMgaW52YWxpZC5cblx0Ly8gYHNvdXJjZWAgaXMgb3B0aW9uYWxcblx0ZnVuY3Rpb24gYnVpbGRFdmVudEZyb21JbnB1dChpbnB1dCwgc291cmNlKSB7XG5cdFx0dmFyIG91dCA9IHt9O1xuXHRcdHZhciBzdGFydCwgZW5kO1xuXHRcdHZhciBhbGxEYXk7XG5cblx0XHRpZiAodC5vcHRpb25zLmV2ZW50RGF0YVRyYW5zZm9ybSkge1xuXHRcdFx0aW5wdXQgPSB0Lm9wdGlvbnMuZXZlbnREYXRhVHJhbnNmb3JtKGlucHV0KTtcblx0XHR9XG5cdFx0aWYgKHNvdXJjZSAmJiBzb3VyY2UuZXZlbnREYXRhVHJhbnNmb3JtKSB7XG5cdFx0XHRpbnB1dCA9IHNvdXJjZS5ldmVudERhdGFUcmFuc2Zvcm0oaW5wdXQpO1xuXHRcdH1cblxuXHRcdC8vIENvcHkgYWxsIHByb3BlcnRpZXMgb3ZlciB0byB0aGUgcmVzdWx0aW5nIG9iamVjdC5cblx0XHQvLyBUaGUgc3BlY2lhbC1jYXNlIHByb3BlcnRpZXMgd2lsbCBiZSBjb3BpZWQgb3ZlciBhZnRlcndhcmRzLlxuXHRcdCQuZXh0ZW5kKG91dCwgaW5wdXQpO1xuXG5cdFx0aWYgKHNvdXJjZSkge1xuXHRcdFx0b3V0LnNvdXJjZSA9IHNvdXJjZTtcblx0XHR9XG5cblx0XHRvdXQuX2lkID0gaW5wdXQuX2lkIHx8IChpbnB1dC5pZCA9PT0gdW5kZWZpbmVkID8gJ19mYycgKyBldmVudEdVSUQrKyA6IGlucHV0LmlkICsgJycpO1xuXG5cdFx0aWYgKGlucHV0LmNsYXNzTmFtZSkge1xuXHRcdFx0aWYgKHR5cGVvZiBpbnB1dC5jbGFzc05hbWUgPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0b3V0LmNsYXNzTmFtZSA9IGlucHV0LmNsYXNzTmFtZS5zcGxpdCgvXFxzKy8pO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7IC8vIGFzc3VtZWQgdG8gYmUgYW4gYXJyYXlcblx0XHRcdFx0b3V0LmNsYXNzTmFtZSA9IGlucHV0LmNsYXNzTmFtZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRvdXQuY2xhc3NOYW1lID0gW107XG5cdFx0fVxuXG5cdFx0c3RhcnQgPSBpbnB1dC5zdGFydCB8fCBpbnB1dC5kYXRlOyAvLyBcImRhdGVcIiBpcyBhbiBhbGlhcyBmb3IgXCJzdGFydFwiXG5cdFx0ZW5kID0gaW5wdXQuZW5kO1xuXG5cdFx0Ly8gcGFyc2UgYXMgYSB0aW1lIChEdXJhdGlvbikgaWYgYXBwbGljYWJsZVxuXHRcdGlmIChpc1RpbWVTdHJpbmcoc3RhcnQpKSB7XG5cdFx0XHRzdGFydCA9IG1vbWVudC5kdXJhdGlvbihzdGFydCk7XG5cdFx0fVxuXHRcdGlmIChpc1RpbWVTdHJpbmcoZW5kKSkge1xuXHRcdFx0ZW5kID0gbW9tZW50LmR1cmF0aW9uKGVuZCk7XG5cdFx0fVxuXG5cdFx0aWYgKGlucHV0LmRvdyB8fCBtb21lbnQuaXNEdXJhdGlvbihzdGFydCkgfHwgbW9tZW50LmlzRHVyYXRpb24oZW5kKSkge1xuXG5cdFx0XHQvLyB0aGUgZXZlbnQgaXMgXCJhYnN0cmFjdFwiIChyZWN1cnJpbmcpIHNvIGRvbid0IGNhbGN1bGF0ZSBleGFjdCBzdGFydC9lbmQgZGF0ZXMganVzdCB5ZXRcblx0XHRcdG91dC5zdGFydCA9IHN0YXJ0ID8gbW9tZW50LmR1cmF0aW9uKHN0YXJ0KSA6IG51bGw7IC8vIHdpbGwgYmUgYSBEdXJhdGlvbiBvciBudWxsXG5cdFx0XHRvdXQuZW5kID0gZW5kID8gbW9tZW50LmR1cmF0aW9uKGVuZCkgOiBudWxsOyAvLyB3aWxsIGJlIGEgRHVyYXRpb24gb3IgbnVsbFxuXHRcdFx0b3V0Ll9yZWN1cnJpbmcgPSB0cnVlOyAvLyBvdXIgaW50ZXJuYWwgbWFya2VyXG5cdFx0fVxuXHRcdGVsc2Uge1xuXG5cdFx0XHRpZiAoc3RhcnQpIHtcblx0XHRcdFx0c3RhcnQgPSB0Lm1vbWVudChzdGFydCk7XG5cdFx0XHRcdGlmICghc3RhcnQuaXNWYWxpZCgpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChlbmQpIHtcblx0XHRcdFx0ZW5kID0gdC5tb21lbnQoZW5kKTtcblx0XHRcdFx0aWYgKCFlbmQuaXNWYWxpZCgpKSB7XG5cdFx0XHRcdFx0ZW5kID0gbnVsbDsgLy8gbGV0IGRlZmF1bHRzIHRha2Ugb3ZlclxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGFsbERheSA9IGlucHV0LmFsbERheTtcblx0XHRcdGlmIChhbGxEYXkgPT09IHVuZGVmaW5lZCkgeyAvLyBzdGlsbCB1bmRlZmluZWQ/IGZhbGxiYWNrIHRvIGRlZmF1bHRcblx0XHRcdFx0YWxsRGF5ID0gZmlyc3REZWZpbmVkKFxuXHRcdFx0XHRcdHNvdXJjZSA/IHNvdXJjZS5hbGxEYXlEZWZhdWx0IDogdW5kZWZpbmVkLFxuXHRcdFx0XHRcdHQub3B0aW9ucy5hbGxEYXlEZWZhdWx0XG5cdFx0XHRcdCk7XG5cdFx0XHRcdC8vIHN0aWxsIHVuZGVmaW5lZD8gbm9ybWFsaXplRXZlbnREYXRlcyB3aWxsIGNhbGN1bGF0ZSBpdFxuXHRcdFx0fVxuXG5cdFx0XHRhc3NpZ25EYXRlc1RvRXZlbnQoc3RhcnQsIGVuZCwgYWxsRGF5LCBvdXQpO1xuXHRcdH1cblxuXHRcdHQubm9ybWFsaXplRXZlbnQob3V0KTsgLy8gaG9vayBmb3IgZXh0ZXJuYWwgdXNlLiBhIHByb3RvdHlwZSBtZXRob2RcblxuXHRcdHJldHVybiBvdXQ7XG5cdH1cblx0dC5idWlsZEV2ZW50RnJvbUlucHV0ID0gYnVpbGRFdmVudEZyb21JbnB1dDtcblxuXG5cdC8vIE5vcm1hbGl6ZXMgYW5kIGFzc2lnbnMgdGhlIGdpdmVuIGRhdGVzIHRvIHRoZSBnaXZlbiBwYXJ0aWFsbHktZm9ybWVkIGV2ZW50IG9iamVjdC5cblx0Ly8gTk9URTogbXV0YXRlcyB0aGUgZ2l2ZW4gc3RhcnQvZW5kIG1vbWVudHMuIGRvZXMgbm90IG1ha2UgYSBjb3B5LlxuXHRmdW5jdGlvbiBhc3NpZ25EYXRlc1RvRXZlbnQoc3RhcnQsIGVuZCwgYWxsRGF5LCBldmVudCkge1xuXHRcdGV2ZW50LnN0YXJ0ID0gc3RhcnQ7XG5cdFx0ZXZlbnQuZW5kID0gZW5kO1xuXHRcdGV2ZW50LmFsbERheSA9IGFsbERheTtcblx0XHRub3JtYWxpemVFdmVudERhdGVzKGV2ZW50KTtcblx0XHRiYWNrdXBFdmVudERhdGVzKGV2ZW50KTtcblx0fVxuXG5cblx0Ly8gRW5zdXJlcyBwcm9wZXIgdmFsdWVzIGZvciBhbGxEYXkvc3RhcnQvZW5kLiBBY2NlcHRzIGFuIEV2ZW50IG9iamVjdCwgb3IgYSBwbGFpbiBvYmplY3Qgd2l0aCBldmVudC1pc2ggcHJvcGVydGllcy5cblx0Ly8gTk9URTogV2lsbCBtb2RpZnkgdGhlIGdpdmVuIG9iamVjdC5cblx0ZnVuY3Rpb24gbm9ybWFsaXplRXZlbnREYXRlcyhldmVudFByb3BzKSB7XG5cblx0XHRub3JtYWxpemVFdmVudFRpbWVzKGV2ZW50UHJvcHMpO1xuXG5cdFx0aWYgKGV2ZW50UHJvcHMuZW5kICYmICFldmVudFByb3BzLmVuZC5pc0FmdGVyKGV2ZW50UHJvcHMuc3RhcnQpKSB7XG5cdFx0XHRldmVudFByb3BzLmVuZCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKCFldmVudFByb3BzLmVuZCkge1xuXHRcdFx0aWYgKHQub3B0aW9ucy5mb3JjZUV2ZW50RHVyYXRpb24pIHtcblx0XHRcdFx0ZXZlbnRQcm9wcy5lbmQgPSB0LmdldERlZmF1bHRFdmVudEVuZChldmVudFByb3BzLmFsbERheSwgZXZlbnRQcm9wcy5zdGFydCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0ZXZlbnRQcm9wcy5lbmQgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cblx0Ly8gRW5zdXJlcyB0aGUgYWxsRGF5IHByb3BlcnR5IGV4aXN0cyBhbmQgdGhlIHRpbWVsaW5lc3Mgb2YgdGhlIHN0YXJ0L2VuZCBkYXRlcyBhcmUgY29uc2lzdGVudFxuXHRmdW5jdGlvbiBub3JtYWxpemVFdmVudFRpbWVzKGV2ZW50UHJvcHMpIHtcblx0XHRpZiAoZXZlbnRQcm9wcy5hbGxEYXkgPT0gbnVsbCkge1xuXHRcdFx0ZXZlbnRQcm9wcy5hbGxEYXkgPSAhKGV2ZW50UHJvcHMuc3RhcnQuaGFzVGltZSgpIHx8IChldmVudFByb3BzLmVuZCAmJiBldmVudFByb3BzLmVuZC5oYXNUaW1lKCkpKTtcblx0XHR9XG5cblx0XHRpZiAoZXZlbnRQcm9wcy5hbGxEYXkpIHtcblx0XHRcdGV2ZW50UHJvcHMuc3RhcnQuc3RyaXBUaW1lKCk7XG5cdFx0XHRpZiAoZXZlbnRQcm9wcy5lbmQpIHtcblx0XHRcdFx0Ly8gVE9ETzogY29uc2lkZXIgbmV4dERheVRocmVzaG9sZCBoZXJlPyBJZiBzbywgd2lsbCByZXF1aXJlIGEgbG90IG9mIHRlc3RpbmcgYW5kIGFkanVzdG1lbnRcblx0XHRcdFx0ZXZlbnRQcm9wcy5lbmQuc3RyaXBUaW1lKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKCFldmVudFByb3BzLnN0YXJ0Lmhhc1RpbWUoKSkge1xuXHRcdFx0XHRldmVudFByb3BzLnN0YXJ0ID0gdC5hcHBseVRpbWV6b25lKGV2ZW50UHJvcHMuc3RhcnQudGltZSgwKSk7IC8vIHdpbGwgYXNzaWduIGEgMDA6MDAgdGltZVxuXHRcdFx0fVxuXHRcdFx0aWYgKGV2ZW50UHJvcHMuZW5kICYmICFldmVudFByb3BzLmVuZC5oYXNUaW1lKCkpIHtcblx0XHRcdFx0ZXZlbnRQcm9wcy5lbmQgPSB0LmFwcGx5VGltZXpvbmUoZXZlbnRQcm9wcy5lbmQudGltZSgwKSk7IC8vIHdpbGwgYXNzaWduIGEgMDA6MDAgdGltZVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cblx0Ly8gSWYgdGhlIGdpdmVuIGV2ZW50IGlzIGEgcmVjdXJyaW5nIGV2ZW50LCBicmVhayBpdCBkb3duIGludG8gYW4gYXJyYXkgb2YgaW5kaXZpZHVhbCBpbnN0YW5jZXMuXG5cdC8vIElmIG5vdCBhIHJlY3VycmluZyBldmVudCwgcmV0dXJuIGFuIGFycmF5IHdpdGggdGhlIHNpbmdsZSBvcmlnaW5hbCBldmVudC5cblx0Ly8gSWYgZ2l2ZW4gYSBmYWxzeSBpbnB1dCAocHJvYmFibHkgYmVjYXVzZSBvZiBhIGZhaWxlZCBidWlsZEV2ZW50RnJvbUlucHV0IGNhbGwpLCByZXR1cm5zIGFuIGVtcHR5IGFycmF5LlxuXHQvLyBIQUNLOiBjYW4gb3ZlcnJpZGUgdGhlIHJlY3VycmluZyB3aW5kb3cgYnkgcHJvdmlkaW5nIGN1c3RvbSByYW5nZVN0YXJ0L3JhbmdlRW5kIChmb3IgYnVzaW5lc3NIb3VycykuXG5cdGZ1bmN0aW9uIGV4cGFuZEV2ZW50KGFic3RyYWN0RXZlbnQsIF9yYW5nZVN0YXJ0LCBfcmFuZ2VFbmQpIHtcblx0XHR2YXIgZXZlbnRzID0gW107XG5cdFx0dmFyIGRvd0hhc2g7XG5cdFx0dmFyIGRvdztcblx0XHR2YXIgaTtcblx0XHR2YXIgZGF0ZTtcblx0XHR2YXIgc3RhcnRUaW1lLCBlbmRUaW1lO1xuXHRcdHZhciBzdGFydCwgZW5kO1xuXHRcdHZhciBldmVudDtcblxuXHRcdF9yYW5nZVN0YXJ0ID0gX3JhbmdlU3RhcnQgfHwgcmFuZ2VTdGFydDtcblx0XHRfcmFuZ2VFbmQgPSBfcmFuZ2VFbmQgfHwgcmFuZ2VFbmQ7XG5cblx0XHRpZiAoYWJzdHJhY3RFdmVudCkge1xuXHRcdFx0aWYgKGFic3RyYWN0RXZlbnQuX3JlY3VycmluZykge1xuXG5cdFx0XHRcdC8vIG1ha2UgYSBib29sZWFuIGhhc2ggYXMgdG8gd2hldGhlciB0aGUgZXZlbnQgb2NjdXJzIG9uIGVhY2ggZGF5LW9mLXdlZWtcblx0XHRcdFx0aWYgKChkb3cgPSBhYnN0cmFjdEV2ZW50LmRvdykpIHtcblx0XHRcdFx0XHRkb3dIYXNoID0ge307XG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGRvdy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0ZG93SGFzaFtkb3dbaV1dID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpdGVyYXRlIHRocm91Z2ggZXZlcnkgZGF5IGluIHRoZSBjdXJyZW50IHJhbmdlXG5cdFx0XHRcdGRhdGUgPSBfcmFuZ2VTdGFydC5jbG9uZSgpLnN0cmlwVGltZSgpOyAvLyBob2xkcyB0aGUgZGF0ZSBvZiB0aGUgY3VycmVudCBkYXlcblx0XHRcdFx0d2hpbGUgKGRhdGUuaXNCZWZvcmUoX3JhbmdlRW5kKSkge1xuXG5cdFx0XHRcdFx0aWYgKCFkb3dIYXNoIHx8IGRvd0hhc2hbZGF0ZS5kYXkoKV0pIHsgLy8gaWYgZXZlcnlkYXksIG9yIHRoaXMgcGFydGljdWxhciBkYXktb2Ytd2Vla1xuXG5cdFx0XHRcdFx0XHRzdGFydFRpbWUgPSBhYnN0cmFjdEV2ZW50LnN0YXJ0OyAvLyB0aGUgc3RvcmVkIHN0YXJ0IGFuZCBlbmQgcHJvcGVydGllcyBhcmUgdGltZXMgKER1cmF0aW9ucylcblx0XHRcdFx0XHRcdGVuZFRpbWUgPSBhYnN0cmFjdEV2ZW50LmVuZDsgLy8gXCJcblx0XHRcdFx0XHRcdHN0YXJ0ID0gZGF0ZS5jbG9uZSgpO1xuXHRcdFx0XHRcdFx0ZW5kID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0aWYgKHN0YXJ0VGltZSkge1xuXHRcdFx0XHRcdFx0XHRzdGFydCA9IHN0YXJ0LnRpbWUoc3RhcnRUaW1lKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChlbmRUaW1lKSB7XG5cdFx0XHRcdFx0XHRcdGVuZCA9IGRhdGUuY2xvbmUoKS50aW1lKGVuZFRpbWUpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRldmVudCA9ICQuZXh0ZW5kKHt9LCBhYnN0cmFjdEV2ZW50KTsgLy8gbWFrZSBhIGNvcHkgb2YgdGhlIG9yaWdpbmFsXG5cdFx0XHRcdFx0XHRhc3NpZ25EYXRlc1RvRXZlbnQoXG5cdFx0XHRcdFx0XHRcdHN0YXJ0LCBlbmQsXG5cdFx0XHRcdFx0XHRcdCFzdGFydFRpbWUgJiYgIWVuZFRpbWUsIC8vIGFsbERheT9cblx0XHRcdFx0XHRcdFx0ZXZlbnRcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRldmVudHMucHVzaChldmVudCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZGF0ZS5hZGQoMSwgJ2RheXMnKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGV2ZW50cy5wdXNoKGFic3RyYWN0RXZlbnQpOyAvLyByZXR1cm4gdGhlIG9yaWdpbmFsIGV2ZW50LiB3aWxsIGJlIGEgb25lLWl0ZW0gYXJyYXlcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnRzO1xuXHR9XG5cdHQuZXhwYW5kRXZlbnQgPSBleHBhbmRFdmVudDtcblxuXG5cblx0LyogRXZlbnQgTW9kaWZpY2F0aW9uIE1hdGhcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gTW9kaWZpZXMgYW4gZXZlbnQgYW5kIGFsbCByZWxhdGVkIGV2ZW50cyBieSBhcHBseWluZyB0aGUgZ2l2ZW4gcHJvcGVydGllcy5cblx0Ly8gU3BlY2lhbCBkYXRlLWRpZmZpbmcgbG9naWMgaXMgdXNlZCBmb3IgbWFuaXB1bGF0aW9uIG9mIGRhdGVzLlxuXHQvLyBJZiBgcHJvcHNgIGRvZXMgbm90IGNvbnRhaW4gc3RhcnQvZW5kIGRhdGVzLCB0aGUgdXBkYXRlZCB2YWx1ZXMgYXJlIGFzc3VtZWQgdG8gYmUgdGhlIGV2ZW50J3MgY3VycmVudCBzdGFydC9lbmQuXG5cdC8vIEFsbCBkYXRlIGNvbXBhcmlzb25zIGFyZSBkb25lIGFnYWluc3QgdGhlIGV2ZW50J3MgcHJpc3RpbmUgX3N0YXJ0IGFuZCBfZW5kIGRhdGVzLlxuXHQvLyBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIGRlbHRhIGluZm9ybWF0aW9uIGFuZCBhIGZ1bmN0aW9uIHRvIHVuZG8gYWxsIG9wZXJhdGlvbnMuXG5cdC8vIEZvciBtYWtpbmcgY29tcHV0YXRpb25zIGluIGEgZ3JhbnVsYXJpdHkgZ3JlYXRlciB0aGFuIGRheS90aW1lLCBzcGVjaWZ5IGxhcmdlVW5pdC5cblx0Ly8gTk9URTogVGhlIGdpdmVuIGBuZXdQcm9wc2AgbWlnaHQgYmUgbXV0YXRlZCBmb3Igbm9ybWFsaXphdGlvbiBwdXJwb3Nlcy5cblx0ZnVuY3Rpb24gbXV0YXRlRXZlbnQoZXZlbnQsIG5ld1Byb3BzLCBsYXJnZVVuaXQpIHtcblx0XHR2YXIgbWlzY1Byb3BzID0ge307XG5cdFx0dmFyIG9sZFByb3BzO1xuXHRcdHZhciBjbGVhckVuZDtcblx0XHR2YXIgc3RhcnREZWx0YTtcblx0XHR2YXIgZW5kRGVsdGE7XG5cdFx0dmFyIGR1cmF0aW9uRGVsdGE7XG5cdFx0dmFyIHVuZG9GdW5jO1xuXG5cdFx0Ly8gZGlmZnMgdGhlIGRhdGVzIGluIHRoZSBhcHByb3ByaWF0ZSB3YXksIHJldHVybmluZyBhIGR1cmF0aW9uXG5cdFx0ZnVuY3Rpb24gZGlmZkRhdGVzKGRhdGUxLCBkYXRlMCkgeyAvLyBkYXRlMSAtIGRhdGUwXG5cdFx0XHRpZiAobGFyZ2VVbml0KSB7XG5cdFx0XHRcdHJldHVybiBkaWZmQnlVbml0KGRhdGUxLCBkYXRlMCwgbGFyZ2VVbml0KTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKG5ld1Byb3BzLmFsbERheSkge1xuXHRcdFx0XHRyZXR1cm4gZGlmZkRheShkYXRlMSwgZGF0ZTApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHJldHVybiBkaWZmRGF5VGltZShkYXRlMSwgZGF0ZTApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG5ld1Byb3BzID0gbmV3UHJvcHMgfHwge307XG5cblx0XHQvLyBub3JtYWxpemUgbmV3IGRhdGUtcmVsYXRlZCBwcm9wZXJ0aWVzXG5cdFx0aWYgKCFuZXdQcm9wcy5zdGFydCkge1xuXHRcdFx0bmV3UHJvcHMuc3RhcnQgPSBldmVudC5zdGFydC5jbG9uZSgpO1xuXHRcdH1cblx0XHRpZiAobmV3UHJvcHMuZW5kID09PSB1bmRlZmluZWQpIHtcblx0XHRcdG5ld1Byb3BzLmVuZCA9IGV2ZW50LmVuZCA/IGV2ZW50LmVuZC5jbG9uZSgpIDogbnVsbDtcblx0XHR9XG5cdFx0aWYgKG5ld1Byb3BzLmFsbERheSA9PSBudWxsKSB7IC8vIGlzIG51bGwgb3IgdW5kZWZpbmVkP1xuXHRcdFx0bmV3UHJvcHMuYWxsRGF5ID0gZXZlbnQuYWxsRGF5O1xuXHRcdH1cblx0XHRub3JtYWxpemVFdmVudERhdGVzKG5ld1Byb3BzKTtcblxuXHRcdC8vIGNyZWF0ZSBub3JtYWxpemVkIHZlcnNpb25zIG9mIHRoZSBvcmlnaW5hbCBwcm9wcyB0byBjb21wYXJlIGFnYWluc3Rcblx0XHQvLyBuZWVkIGEgcmVhbCBlbmQgdmFsdWUsIGZvciBkaWZmaW5nXG5cdFx0b2xkUHJvcHMgPSB7XG5cdFx0XHRzdGFydDogZXZlbnQuX3N0YXJ0LmNsb25lKCksXG5cdFx0XHRlbmQ6IGV2ZW50Ll9lbmQgPyBldmVudC5fZW5kLmNsb25lKCkgOiB0LmdldERlZmF1bHRFdmVudEVuZChldmVudC5fYWxsRGF5LCBldmVudC5fc3RhcnQpLFxuXHRcdFx0YWxsRGF5OiBuZXdQcm9wcy5hbGxEYXkgLy8gbm9ybWFsaXplIHRoZSBkYXRlcyBpbiB0aGUgc2FtZSByZWdhcmQgYXMgdGhlIG5ldyBwcm9wZXJ0aWVzXG5cdFx0fTtcblx0XHRub3JtYWxpemVFdmVudERhdGVzKG9sZFByb3BzKTtcblxuXHRcdC8vIG5lZWQgdG8gY2xlYXIgdGhlIGVuZCBkYXRlIGlmIGV4cGxpY2l0bHkgY2hhbmdlZCB0byBudWxsXG5cdFx0Y2xlYXJFbmQgPSBldmVudC5fZW5kICE9PSBudWxsICYmIG5ld1Byb3BzLmVuZCA9PT0gbnVsbDtcblxuXHRcdC8vIGNvbXB1dGUgdGhlIGRlbHRhIGZvciBtb3ZpbmcgdGhlIHN0YXJ0IGRhdGVcblx0XHRzdGFydERlbHRhID0gZGlmZkRhdGVzKG5ld1Byb3BzLnN0YXJ0LCBvbGRQcm9wcy5zdGFydCk7XG5cblx0XHQvLyBjb21wdXRlIHRoZSBkZWx0YSBmb3IgbW92aW5nIHRoZSBlbmQgZGF0ZVxuXHRcdGlmIChuZXdQcm9wcy5lbmQpIHtcblx0XHRcdGVuZERlbHRhID0gZGlmZkRhdGVzKG5ld1Byb3BzLmVuZCwgb2xkUHJvcHMuZW5kKTtcblx0XHRcdGR1cmF0aW9uRGVsdGEgPSBlbmREZWx0YS5zdWJ0cmFjdChzdGFydERlbHRhKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRkdXJhdGlvbkRlbHRhID0gbnVsbDtcblx0XHR9XG5cblx0XHQvLyBnYXRoZXIgYWxsIG5vbi1kYXRlLXJlbGF0ZWQgcHJvcGVydGllc1xuXHRcdCQuZWFjaChuZXdQcm9wcywgZnVuY3Rpb24obmFtZSwgdmFsKSB7XG5cdFx0XHRpZiAoaXNNaXNjRXZlbnRQcm9wTmFtZShuYW1lKSkge1xuXHRcdFx0XHRpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRtaXNjUHJvcHNbbmFtZV0gPSB2YWw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIGFwcGx5IHRoZSBvcGVyYXRpb25zIHRvIHRoZSBldmVudCBhbmQgYWxsIHJlbGF0ZWQgZXZlbnRzXG5cdFx0dW5kb0Z1bmMgPSBtdXRhdGVFdmVudHMoXG5cdFx0XHRjbGllbnRFdmVudHMoZXZlbnQuX2lkKSwgLy8gZ2V0IGV2ZW50cyB3aXRoIHRoaXMgSURcblx0XHRcdGNsZWFyRW5kLFxuXHRcdFx0bmV3UHJvcHMuYWxsRGF5LFxuXHRcdFx0c3RhcnREZWx0YSxcblx0XHRcdGR1cmF0aW9uRGVsdGEsXG5cdFx0XHRtaXNjUHJvcHNcblx0XHQpO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGRhdGVEZWx0YTogc3RhcnREZWx0YSxcblx0XHRcdGR1cmF0aW9uRGVsdGE6IGR1cmF0aW9uRGVsdGEsXG5cdFx0XHR1bmRvOiB1bmRvRnVuY1xuXHRcdH07XG5cdH1cblxuXG5cdC8vIE1vZGlmaWVzIGFuIGFycmF5IG9mIGV2ZW50cyBpbiB0aGUgZm9sbG93aW5nIHdheXMgKG9wZXJhdGlvbnMgYXJlIGluIG9yZGVyKTpcblx0Ly8gLSBjbGVhciB0aGUgZXZlbnQncyBgZW5kYFxuXHQvLyAtIGNvbnZlcnQgdGhlIGV2ZW50IHRvIGFsbERheVxuXHQvLyAtIGFkZCBgZGF0ZURlbHRhYCB0byB0aGUgc3RhcnQgYW5kIGVuZFxuXHQvLyAtIGFkZCBgZHVyYXRpb25EZWx0YWAgdG8gdGhlIGV2ZW50J3MgZHVyYXRpb25cblx0Ly8gLSBhc3NpZ24gYG1pc2NQcm9wc2AgdG8gdGhlIGV2ZW50XG5cdC8vXG5cdC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBjYWxsZWQgdG8gdW5kbyBhbGwgdGhlIG9wZXJhdGlvbnMuXG5cdC8vXG5cdC8vIFRPRE86IGRvbid0IHVzZSBzbyBtYW55IGNsb3N1cmVzLiBwb3NzaWJsZSBtZW1vcnkgaXNzdWVzIHdoZW4gbG90cyBvZiBldmVudHMgd2l0aCBzYW1lIElELlxuXHQvL1xuXHRmdW5jdGlvbiBtdXRhdGVFdmVudHMoZXZlbnRzLCBjbGVhckVuZCwgYWxsRGF5LCBkYXRlRGVsdGEsIGR1cmF0aW9uRGVsdGEsIG1pc2NQcm9wcykge1xuXHRcdHZhciBpc0FtYmlnVGltZXpvbmUgPSB0LmdldElzQW1iaWdUaW1lem9uZSgpO1xuXHRcdHZhciB1bmRvRnVuY3Rpb25zID0gW107XG5cblx0XHQvLyBub3JtYWxpemUgemVyby1sZW5ndGggZGVsdGFzIHRvIGJlIG51bGxcblx0XHRpZiAoZGF0ZURlbHRhICYmICFkYXRlRGVsdGEudmFsdWVPZigpKSB7IGRhdGVEZWx0YSA9IG51bGw7IH1cblx0XHRpZiAoZHVyYXRpb25EZWx0YSAmJiAhZHVyYXRpb25EZWx0YS52YWx1ZU9mKCkpIHsgZHVyYXRpb25EZWx0YSA9IG51bGw7IH1cblxuXHRcdCQuZWFjaChldmVudHMsIGZ1bmN0aW9uKGksIGV2ZW50KSB7XG5cdFx0XHR2YXIgb2xkUHJvcHM7XG5cdFx0XHR2YXIgbmV3UHJvcHM7XG5cblx0XHRcdC8vIGJ1aWxkIGFuIG9iamVjdCBob2xkaW5nIGFsbCB0aGUgb2xkIHZhbHVlcywgYm90aCBkYXRlLXJlbGF0ZWQgYW5kIG1pc2MuXG5cdFx0XHQvLyBmb3IgdGhlIHVuZG8gZnVuY3Rpb24uXG5cdFx0XHRvbGRQcm9wcyA9IHtcblx0XHRcdFx0c3RhcnQ6IGV2ZW50LnN0YXJ0LmNsb25lKCksXG5cdFx0XHRcdGVuZDogZXZlbnQuZW5kID8gZXZlbnQuZW5kLmNsb25lKCkgOiBudWxsLFxuXHRcdFx0XHRhbGxEYXk6IGV2ZW50LmFsbERheVxuXHRcdFx0fTtcblx0XHRcdCQuZWFjaChtaXNjUHJvcHMsIGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdFx0b2xkUHJvcHNbbmFtZV0gPSBldmVudFtuYW1lXTtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBuZXcgZGF0ZS1yZWxhdGVkIHByb3BlcnRpZXMuIHdvcmsgb2ZmIHRoZSBvcmlnaW5hbCBkYXRlIHNuYXBzaG90LlxuXHRcdFx0Ly8gb2sgdG8gdXNlIHJlZmVyZW5jZXMgYmVjYXVzZSB0aGV5IHdpbGwgYmUgdGhyb3duIGF3YXkgd2hlbiBiYWNrdXBFdmVudERhdGVzIGlzIGNhbGxlZC5cblx0XHRcdG5ld1Byb3BzID0ge1xuXHRcdFx0XHRzdGFydDogZXZlbnQuX3N0YXJ0LFxuXHRcdFx0XHRlbmQ6IGV2ZW50Ll9lbmQsXG5cdFx0XHRcdGFsbERheTogYWxsRGF5IC8vIG5vcm1hbGl6ZSB0aGUgZGF0ZXMgaW4gdGhlIHNhbWUgcmVnYXJkIGFzIHRoZSBuZXcgcHJvcGVydGllc1xuXHRcdFx0fTtcblx0XHRcdG5vcm1hbGl6ZUV2ZW50RGF0ZXMobmV3UHJvcHMpOyAvLyBtYXNzYWdlcyBzdGFydC9lbmQvYWxsRGF5XG5cblx0XHRcdC8vIHN0cmlwIG9yIGVuc3VyZSB0aGUgZW5kIGRhdGVcblx0XHRcdGlmIChjbGVhckVuZCkge1xuXHRcdFx0XHRuZXdQcm9wcy5lbmQgPSBudWxsO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoZHVyYXRpb25EZWx0YSAmJiAhbmV3UHJvcHMuZW5kKSB7IC8vIHRoZSBkdXJhdGlvbiB0cmFuc2xhdGlvbiByZXF1aXJlcyBhbiBlbmQgZGF0ZVxuXHRcdFx0XHRuZXdQcm9wcy5lbmQgPSB0LmdldERlZmF1bHRFdmVudEVuZChuZXdQcm9wcy5hbGxEYXksIG5ld1Byb3BzLnN0YXJ0KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGRhdGVEZWx0YSkge1xuXHRcdFx0XHRuZXdQcm9wcy5zdGFydC5hZGQoZGF0ZURlbHRhKTtcblx0XHRcdFx0aWYgKG5ld1Byb3BzLmVuZCkge1xuXHRcdFx0XHRcdG5ld1Byb3BzLmVuZC5hZGQoZGF0ZURlbHRhKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZHVyYXRpb25EZWx0YSkge1xuXHRcdFx0XHRuZXdQcm9wcy5lbmQuYWRkKGR1cmF0aW9uRGVsdGEpOyAvLyBlbmQgYWxyZWFkeSBlbnN1cmVkIGFib3ZlXG5cdFx0XHR9XG5cblx0XHRcdC8vIGlmIHRoZSBkYXRlcyBoYXZlIGNoYW5nZWQsIGFuZCB3ZSBrbm93IGl0IGlzIGltcG9zc2libGUgdG8gcmVjb21wdXRlIHRoZVxuXHRcdFx0Ly8gdGltZXpvbmUgb2Zmc2V0cywgc3RyaXAgdGhlIHpvbmUuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdGlzQW1iaWdUaW1lem9uZSAmJlxuXHRcdFx0XHQhbmV3UHJvcHMuYWxsRGF5ICYmXG5cdFx0XHRcdChkYXRlRGVsdGEgfHwgZHVyYXRpb25EZWx0YSlcblx0XHRcdCkge1xuXHRcdFx0XHRuZXdQcm9wcy5zdGFydC5zdHJpcFpvbmUoKTtcblx0XHRcdFx0aWYgKG5ld1Byb3BzLmVuZCkge1xuXHRcdFx0XHRcdG5ld1Byb3BzLmVuZC5zdHJpcFpvbmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQkLmV4dGVuZChldmVudCwgbWlzY1Byb3BzLCBuZXdQcm9wcyk7IC8vIGNvcHkgb3ZlciBtaXNjIHByb3BzLCB0aGVuIGRhdGUtcmVsYXRlZCBwcm9wc1xuXHRcdFx0YmFja3VwRXZlbnREYXRlcyhldmVudCk7IC8vIHJlZ2VuZXJhdGUgaW50ZXJuYWwgX3N0YXJ0L19lbmQvX2FsbERheVxuXG5cdFx0XHR1bmRvRnVuY3Rpb25zLnB1c2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdCQuZXh0ZW5kKGV2ZW50LCBvbGRQcm9wcyk7XG5cdFx0XHRcdGJhY2t1cEV2ZW50RGF0ZXMoZXZlbnQpOyAvLyByZWdlbmVyYXRlIGludGVybmFsIF9zdGFydC9fZW5kL19hbGxEYXlcblx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB1bmRvRnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHVuZG9GdW5jdGlvbnNbaV0oKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblxuXHR0LmdldEV2ZW50Q2FjaGUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gY2FjaGU7XG5cdH07XG5cbn1cblxuXG4vLyBob29rIGZvciBleHRlcm5hbCBsaWJzIHRvIG1hbmlwdWxhdGUgZXZlbnQgcHJvcGVydGllcyB1cG9uIGNyZWF0aW9uLlxuLy8gc2hvdWxkIG1hbmlwdWxhdGUgdGhlIGV2ZW50IGluLXBsYWNlLlxuQ2FsZW5kYXIucHJvdG90eXBlLm5vcm1hbGl6ZUV2ZW50ID0gZnVuY3Rpb24oZXZlbnQpIHtcbn07XG5cblxuLy8gRG9lcyB0aGUgZ2l2ZW4gc3BhbiAoc3RhcnQsIGVuZCwgYW5kIG90aGVyIGxvY2F0aW9uIGluZm9ybWF0aW9uKVxuLy8gZnVsbHkgY29udGFpbiB0aGUgb3RoZXI/XG5DYWxlbmRhci5wcm90b3R5cGUuc3BhbkNvbnRhaW5zU3BhbiA9IGZ1bmN0aW9uKG91dGVyU3BhbiwgaW5uZXJTcGFuKSB7XG5cdHZhciBldmVudFN0YXJ0ID0gb3V0ZXJTcGFuLnN0YXJ0LmNsb25lKCkuc3RyaXBab25lKCk7XG5cdHZhciBldmVudEVuZCA9IHRoaXMuZ2V0RXZlbnRFbmQob3V0ZXJTcGFuKS5zdHJpcFpvbmUoKTtcblxuXHRyZXR1cm4gaW5uZXJTcGFuLnN0YXJ0ID49IGV2ZW50U3RhcnQgJiYgaW5uZXJTcGFuLmVuZCA8PSBldmVudEVuZDtcbn07XG5cblxuLy8gUmV0dXJucyBhIGxpc3Qgb2YgZXZlbnRzIHRoYXQgdGhlIGdpdmVuIGV2ZW50IHNob3VsZCBiZSBjb21wYXJlZCBhZ2FpbnN0IHdoZW4gYmVpbmcgY29uc2lkZXJlZCBmb3IgYSBtb3ZlIHRvXG4vLyB0aGUgc3BlY2lmaWVkIHNwYW4uIEF0dGFjaGVkIHRvIHRoZSBDYWxlbmRhcidzIHByb3RvdHlwZSBiZWNhdXNlIEV2ZW50TWFuYWdlciBpcyBhIG1peGluIGZvciBhIENhbGVuZGFyLlxuQ2FsZW5kYXIucHJvdG90eXBlLmdldFBlZXJFdmVudHMgPSBmdW5jdGlvbihzcGFuLCBldmVudCkge1xuXHR2YXIgY2FjaGUgPSB0aGlzLmdldEV2ZW50Q2FjaGUoKTtcblx0dmFyIHBlZXJFdmVudHMgPSBbXTtcblx0dmFyIGksIG90aGVyRXZlbnQ7XG5cblx0Zm9yIChpID0gMDsgaSA8IGNhY2hlLmxlbmd0aDsgaSsrKSB7XG5cdFx0b3RoZXJFdmVudCA9IGNhY2hlW2ldO1xuXHRcdGlmIChcblx0XHRcdCFldmVudCB8fFxuXHRcdFx0ZXZlbnQuX2lkICE9PSBvdGhlckV2ZW50Ll9pZCAvLyBkb24ndCBjb21wYXJlIHRoZSBldmVudCB0byBpdHNlbGYgb3Igb3RoZXIgcmVsYXRlZCBbcmVwZWF0aW5nXSBldmVudHNcblx0XHQpIHtcblx0XHRcdHBlZXJFdmVudHMucHVzaChvdGhlckV2ZW50KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcGVlckV2ZW50cztcbn07XG5cblxuLy8gdXBkYXRlcyB0aGUgXCJiYWNrdXBcIiBwcm9wZXJ0aWVzLCB3aGljaCBhcmUgcHJlc2VydmVkIGluIG9yZGVyIHRvIGNvbXB1dGUgZGlmZnMgbGF0ZXIgb24uXG5mdW5jdGlvbiBiYWNrdXBFdmVudERhdGVzKGV2ZW50KSB7XG5cdGV2ZW50Ll9hbGxEYXkgPSBldmVudC5hbGxEYXk7XG5cdGV2ZW50Ll9zdGFydCA9IGV2ZW50LnN0YXJ0LmNsb25lKCk7XG5cdGV2ZW50Ll9lbmQgPSBldmVudC5lbmQgPyBldmVudC5lbmQuY2xvbmUoKSA6IG51bGw7XG59XG5cblxuLyogT3ZlcmxhcHBpbmcgLyBDb25zdHJhaW5pbmdcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG4vLyBEZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiBldmVudCBjYW4gYmUgcmVsb2NhdGVkIHRvIHRoZSBnaXZlbiBzcGFuICh1bnpvbmVkIHN0YXJ0L2VuZCB3aXRoIG90aGVyIG1pc2MgZGF0YSlcbkNhbGVuZGFyLnByb3RvdHlwZS5pc0V2ZW50U3BhbkFsbG93ZWQgPSBmdW5jdGlvbihzcGFuLCBldmVudCkge1xuXHR2YXIgc291cmNlID0gZXZlbnQuc291cmNlIHx8IHt9O1xuXG5cdHZhciBjb25zdHJhaW50ID0gZmlyc3REZWZpbmVkKFxuXHRcdGV2ZW50LmNvbnN0cmFpbnQsXG5cdFx0c291cmNlLmNvbnN0cmFpbnQsXG5cdFx0dGhpcy5vcHRpb25zLmV2ZW50Q29uc3RyYWludFxuXHQpO1xuXG5cdHZhciBvdmVybGFwID0gZmlyc3REZWZpbmVkKFxuXHRcdGV2ZW50Lm92ZXJsYXAsXG5cdFx0c291cmNlLm92ZXJsYXAsXG5cdFx0dGhpcy5vcHRpb25zLmV2ZW50T3ZlcmxhcFxuXHQpO1xuXG5cdHJldHVybiB0aGlzLmlzU3BhbkFsbG93ZWQoc3BhbiwgY29uc3RyYWludCwgb3ZlcmxhcCwgZXZlbnQpICYmXG5cdFx0KCF0aGlzLm9wdGlvbnMuZXZlbnRBbGxvdyB8fCB0aGlzLm9wdGlvbnMuZXZlbnRBbGxvdyhzcGFuLCBldmVudCkgIT09IGZhbHNlKTtcbn07XG5cblxuLy8gRGV0ZXJtaW5lcyBpZiBhbiBleHRlcm5hbCBldmVudCBjYW4gYmUgcmVsb2NhdGVkIHRvIHRoZSBnaXZlbiBzcGFuICh1bnpvbmVkIHN0YXJ0L2VuZCB3aXRoIG90aGVyIG1pc2MgZGF0YSlcbkNhbGVuZGFyLnByb3RvdHlwZS5pc0V4dGVybmFsU3BhbkFsbG93ZWQgPSBmdW5jdGlvbihldmVudFNwYW4sIGV2ZW50TG9jYXRpb24sIGV2ZW50UHJvcHMpIHtcblx0dmFyIGV2ZW50SW5wdXQ7XG5cdHZhciBldmVudDtcblxuXHQvLyBub3RlOiB2ZXJ5IHNpbWlsYXIgbG9naWMgaXMgaW4gVmlldydzIHJlcG9ydEV4dGVybmFsRHJvcFxuXHRpZiAoZXZlbnRQcm9wcykge1xuXHRcdGV2ZW50SW5wdXQgPSAkLmV4dGVuZCh7fSwgZXZlbnRQcm9wcywgZXZlbnRMb2NhdGlvbik7XG5cdFx0ZXZlbnQgPSB0aGlzLmV4cGFuZEV2ZW50KFxuXHRcdFx0dGhpcy5idWlsZEV2ZW50RnJvbUlucHV0KGV2ZW50SW5wdXQpXG5cdFx0KVswXTtcblx0fVxuXG5cdGlmIChldmVudCkge1xuXHRcdHJldHVybiB0aGlzLmlzRXZlbnRTcGFuQWxsb3dlZChldmVudFNwYW4sIGV2ZW50KTtcblx0fVxuXHRlbHNlIHsgLy8gdHJlYXQgaXQgYXMgYSBzZWxlY3Rpb25cblxuXHRcdHJldHVybiB0aGlzLmlzU2VsZWN0aW9uU3BhbkFsbG93ZWQoZXZlbnRTcGFuKTtcblx0fVxufTtcblxuXG4vLyBEZXRlcm1pbmVzIHRoZSBnaXZlbiBzcGFuICh1bnpvbmVkIHN0YXJ0L2VuZCB3aXRoIG90aGVyIG1pc2MgZGF0YSkgY2FuIGJlIHNlbGVjdGVkLlxuQ2FsZW5kYXIucHJvdG90eXBlLmlzU2VsZWN0aW9uU3BhbkFsbG93ZWQgPSBmdW5jdGlvbihzcGFuKSB7XG5cdHJldHVybiB0aGlzLmlzU3BhbkFsbG93ZWQoc3BhbiwgdGhpcy5vcHRpb25zLnNlbGVjdENvbnN0cmFpbnQsIHRoaXMub3B0aW9ucy5zZWxlY3RPdmVybGFwKSAmJlxuXHRcdCghdGhpcy5vcHRpb25zLnNlbGVjdEFsbG93IHx8IHRoaXMub3B0aW9ucy5zZWxlY3RBbGxvdyhzcGFuKSAhPT0gZmFsc2UpO1xufTtcblxuXG4vLyBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNwYW4gKGNhdXNlZCBieSBhbiBldmVudCBkcm9wL3Jlc2l6ZSBvciBhIHNlbGVjdGlvbikgaXMgYWxsb3dlZCB0byBleGlzdFxuLy8gYWNjb3JkaW5nIHRvIHRoZSBjb25zdHJhaW50L292ZXJsYXAgc2V0dGluZ3MuXG4vLyBgZXZlbnRgIGlzIG5vdCByZXF1aXJlZCBpZiBjaGVja2luZyBhIHNlbGVjdGlvbi5cbkNhbGVuZGFyLnByb3RvdHlwZS5pc1NwYW5BbGxvd2VkID0gZnVuY3Rpb24oc3BhbiwgY29uc3RyYWludCwgb3ZlcmxhcCwgZXZlbnQpIHtcblx0dmFyIGNvbnN0cmFpbnRFdmVudHM7XG5cdHZhciBhbnlDb250YWlubWVudDtcblx0dmFyIHBlZXJFdmVudHM7XG5cdHZhciBpLCBwZWVyRXZlbnQ7XG5cdHZhciBwZWVyT3ZlcmxhcDtcblxuXHQvLyB0aGUgcmFuZ2UgbXVzdCBiZSBmdWxseSBjb250YWluZWQgYnkgYXQgbGVhc3Qgb25lIG9mIHByb2R1Y2VkIGNvbnN0cmFpbnQgZXZlbnRzXG5cdGlmIChjb25zdHJhaW50ICE9IG51bGwpIHtcblxuXHRcdC8vIG5vdCB0cmVhdGVkIGFzIGFuIGV2ZW50ISBpbnRlcm1lZGlhdGUgZGF0YSBzdHJ1Y3R1cmVcblx0XHQvLyBUT0RPOiB1c2UgcmFuZ2VzIGluIHRoZSBmdXR1cmVcblx0XHRjb25zdHJhaW50RXZlbnRzID0gdGhpcy5jb25zdHJhaW50VG9FdmVudHMoY29uc3RyYWludCk7XG5cdFx0aWYgKGNvbnN0cmFpbnRFdmVudHMpIHsgLy8gbm90IGludmFsaWRcblxuXHRcdFx0YW55Q29udGFpbm1lbnQgPSBmYWxzZTtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBjb25zdHJhaW50RXZlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmICh0aGlzLnNwYW5Db250YWluc1NwYW4oY29uc3RyYWludEV2ZW50c1tpXSwgc3BhbikpIHtcblx0XHRcdFx0XHRhbnlDb250YWlubWVudCA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCFhbnlDb250YWlubWVudCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cGVlckV2ZW50cyA9IHRoaXMuZ2V0UGVlckV2ZW50cyhzcGFuLCBldmVudCk7XG5cblx0Zm9yIChpID0gMDsgaSA8IHBlZXJFdmVudHMubGVuZ3RoOyBpKyspICB7XG5cdFx0cGVlckV2ZW50ID0gcGVlckV2ZW50c1tpXTtcblxuXHRcdC8vIHRoZXJlIG5lZWRzIHRvIGJlIGFuIGFjdHVhbCBpbnRlcnNlY3Rpb24gYmVmb3JlIGRpc2FsbG93aW5nIGFueXRoaW5nXG5cdFx0aWYgKHRoaXMuZXZlbnRJbnRlcnNlY3RzUmFuZ2UocGVlckV2ZW50LCBzcGFuKSkge1xuXG5cdFx0XHQvLyBldmFsdWF0ZSBvdmVybGFwIGZvciB0aGUgZ2l2ZW4gcmFuZ2UgYW5kIHNob3J0LWNpcmN1aXQgaWYgbmVjZXNzYXJ5XG5cdFx0XHRpZiAob3ZlcmxhcCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gaWYgdGhlIGV2ZW50J3Mgb3ZlcmxhcCBpcyBhIHRlc3QgZnVuY3Rpb24sIHBhc3MgdGhlIHBlZXIgZXZlbnQgaW4gcXVlc3Rpb24gYXMgdGhlIGZpcnN0IHBhcmFtXG5cdFx0XHRlbHNlIGlmICh0eXBlb2Ygb3ZlcmxhcCA9PT0gJ2Z1bmN0aW9uJyAmJiAhb3ZlcmxhcChwZWVyRXZlbnQsIGV2ZW50KSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGlmIHdlIGFyZSBjb21wdXRpbmcgaWYgdGhlIGdpdmVuIHJhbmdlIGlzIGFsbG93YWJsZSBmb3IgYW4gZXZlbnQsIGNvbnNpZGVyIHRoZSBvdGhlciBldmVudCdzXG5cdFx0XHQvLyBFdmVudE9iamVjdC1zcGVjaWZpYyBvciBTb3VyY2Utc3BlY2lmaWMgYG92ZXJsYXBgIHByb3BlcnR5XG5cdFx0XHRpZiAoZXZlbnQpIHtcblx0XHRcdFx0cGVlck92ZXJsYXAgPSBmaXJzdERlZmluZWQoXG5cdFx0XHRcdFx0cGVlckV2ZW50Lm92ZXJsYXAsXG5cdFx0XHRcdFx0KHBlZXJFdmVudC5zb3VyY2UgfHwge30pLm92ZXJsYXBcblx0XHRcdFx0XHQvLyB3ZSBhbHJlYWR5IGNvbnNpZGVyZWQgdGhlIGdsb2JhbCBgZXZlbnRPdmVybGFwYFxuXHRcdFx0XHQpO1xuXHRcdFx0XHRpZiAocGVlck92ZXJsYXAgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGlmIHRoZSBwZWVyIGV2ZW50J3Mgb3ZlcmxhcCBpcyBhIHRlc3QgZnVuY3Rpb24sIHBhc3MgdGhlIHN1YmplY3QgZXZlbnQgYXMgdGhlIGZpcnN0IHBhcmFtXG5cdFx0XHRcdGlmICh0eXBlb2YgcGVlck92ZXJsYXAgPT09ICdmdW5jdGlvbicgJiYgIXBlZXJPdmVybGFwKGV2ZW50LCBwZWVyRXZlbnQpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59O1xuXG5cbi8vIEdpdmVuIGFuIGV2ZW50IGlucHV0IGZyb20gdGhlIEFQSSwgcHJvZHVjZXMgYW4gYXJyYXkgb2YgZXZlbnQgb2JqZWN0cy4gUG9zc2libGUgZXZlbnQgaW5wdXRzOlxuLy8gJ2J1c2luZXNzSG91cnMnXG4vLyBBbiBldmVudCBJRCAobnVtYmVyIG9yIHN0cmluZylcbi8vIEFuIG9iamVjdCB3aXRoIHNwZWNpZmljIHN0YXJ0L2VuZCBkYXRlcyBvciBhIHJlY3VycmluZyBldmVudCAobGlrZSB3aGF0IGJ1c2luZXNzSG91cnMgYWNjZXB0cylcbkNhbGVuZGFyLnByb3RvdHlwZS5jb25zdHJhaW50VG9FdmVudHMgPSBmdW5jdGlvbihjb25zdHJhaW50SW5wdXQpIHtcblxuXHRpZiAoY29uc3RyYWludElucHV0ID09PSAnYnVzaW5lc3NIb3VycycpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRDdXJyZW50QnVzaW5lc3NIb3VyRXZlbnRzKCk7XG5cdH1cblxuXHRpZiAodHlwZW9mIGNvbnN0cmFpbnRJbnB1dCA9PT0gJ29iamVjdCcpIHtcblx0XHRpZiAoY29uc3RyYWludElucHV0LnN0YXJ0ICE9IG51bGwpIHsgLy8gbmVlZHMgdG8gYmUgZXZlbnQtbGlrZSBpbnB1dFxuXHRcdFx0cmV0dXJuIHRoaXMuZXhwYW5kRXZlbnQodGhpcy5idWlsZEV2ZW50RnJvbUlucHV0KGNvbnN0cmFpbnRJbnB1dCkpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHJldHVybiBudWxsOyAvLyBpbnZhbGlkXG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRoaXMuY2xpZW50RXZlbnRzKGNvbnN0cmFpbnRJbnB1dCk7IC8vIHByb2JhYmx5IGFuIElEXG59O1xuXG5cbi8vIERvZXMgdGhlIGV2ZW50J3MgZGF0ZSByYW5nZSBpbnRlcnNlY3Qgd2l0aCB0aGUgZ2l2ZW4gcmFuZ2U/XG4vLyBzdGFydC9lbmQgYWxyZWFkeSBhc3N1bWVkIHRvIGhhdmUgc3RyaXBwZWQgem9uZXMgOihcbkNhbGVuZGFyLnByb3RvdHlwZS5ldmVudEludGVyc2VjdHNSYW5nZSA9IGZ1bmN0aW9uKGV2ZW50LCByYW5nZSkge1xuXHR2YXIgZXZlbnRTdGFydCA9IGV2ZW50LnN0YXJ0LmNsb25lKCkuc3RyaXBab25lKCk7XG5cdHZhciBldmVudEVuZCA9IHRoaXMuZ2V0RXZlbnRFbmQoZXZlbnQpLnN0cmlwWm9uZSgpO1xuXG5cdHJldHVybiByYW5nZS5zdGFydCA8IGV2ZW50RW5kICYmIHJhbmdlLmVuZCA+IGV2ZW50U3RhcnQ7XG59O1xuXG5cbi8qIEJ1c2luZXNzIEhvdXJzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbnZhciBCVVNJTkVTU19IT1VSX0VWRU5UX0RFRkFVTFRTID0ge1xuXHRpZDogJ19mY0J1c2luZXNzSG91cnMnLCAvLyB3aWxsIHJlbGF0ZSBldmVudHMgZnJvbSBkaWZmZXJlbnQgY2FsbHMgdG8gZXhwYW5kRXZlbnRcblx0c3RhcnQ6ICcwOTowMCcsXG5cdGVuZDogJzE3OjAwJyxcblx0ZG93OiBbIDEsIDIsIDMsIDQsIDUgXSwgLy8gbW9uZGF5IC0gZnJpZGF5XG5cdHJlbmRlcmluZzogJ2ludmVyc2UtYmFja2dyb3VuZCdcblx0Ly8gY2xhc3NOYW1lcyBhcmUgZGVmaW5lZCBpbiBidXNpbmVzc0hvdXJzU2VnQ2xhc3Nlc1xufTtcblxuLy8gUmV0dXJuIGV2ZW50cyBvYmplY3RzIGZvciBidXNpbmVzcyBob3VycyB3aXRoaW4gdGhlIGN1cnJlbnQgdmlldy5cbi8vIEFidXNlIG9mIG91ciBldmVudCBzeXN0ZW0gOihcbkNhbGVuZGFyLnByb3RvdHlwZS5nZXRDdXJyZW50QnVzaW5lc3NIb3VyRXZlbnRzID0gZnVuY3Rpb24od2hvbGVEYXkpIHtcblx0cmV0dXJuIHRoaXMuY29tcHV0ZUJ1c2luZXNzSG91ckV2ZW50cyh3aG9sZURheSwgdGhpcy5vcHRpb25zLmJ1c2luZXNzSG91cnMpO1xufTtcblxuLy8gR2l2ZW4gYSByYXcgaW5wdXQgdmFsdWUgZnJvbSBvcHRpb25zLCByZXR1cm4gZXZlbnRzIG9iamVjdHMgZm9yIGJ1c2luZXNzIGhvdXJzIHdpdGhpbiB0aGUgY3VycmVudCB2aWV3LlxuQ2FsZW5kYXIucHJvdG90eXBlLmNvbXB1dGVCdXNpbmVzc0hvdXJFdmVudHMgPSBmdW5jdGlvbih3aG9sZURheSwgaW5wdXQpIHtcblx0aWYgKGlucHV0ID09PSB0cnVlKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXhwYW5kQnVzaW5lc3NIb3VyRXZlbnRzKHdob2xlRGF5LCBbIHt9IF0pO1xuXHR9XG5cdGVsc2UgaWYgKCQuaXNQbGFpbk9iamVjdChpbnB1dCkpIHtcblx0XHRyZXR1cm4gdGhpcy5leHBhbmRCdXNpbmVzc0hvdXJFdmVudHMod2hvbGVEYXksIFsgaW5wdXQgXSk7XG5cdH1cblx0ZWxzZSBpZiAoJC5pc0FycmF5KGlucHV0KSkge1xuXHRcdHJldHVybiB0aGlzLmV4cGFuZEJ1c2luZXNzSG91ckV2ZW50cyh3aG9sZURheSwgaW5wdXQsIHRydWUpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdHJldHVybiBbXTtcblx0fVxufTtcblxuLy8gaW5wdXRzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5IG9mIG9iamVjdHMuXG4vLyBpZiBpZ25vcmVOb0RvdyBpcyB0cnVlLCB3aWxsIGlnbm9yZSBlbnRyaWVzIHRoYXQgZG9uJ3Qgc3BlY2lmeSBhIGRheS1vZi13ZWVrIChkb3cpIGtleS5cbkNhbGVuZGFyLnByb3RvdHlwZS5leHBhbmRCdXNpbmVzc0hvdXJFdmVudHMgPSBmdW5jdGlvbih3aG9sZURheSwgaW5wdXRzLCBpZ25vcmVOb0Rvdykge1xuXHR2YXIgdmlldyA9IHRoaXMuZ2V0VmlldygpO1xuXHR2YXIgZXZlbnRzID0gW107XG5cdHZhciBpLCBpbnB1dDtcblxuXHRmb3IgKGkgPSAwOyBpIDwgaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0aW5wdXQgPSBpbnB1dHNbaV07XG5cblx0XHRpZiAoaWdub3JlTm9Eb3cgJiYgIWlucHV0LmRvdykge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0Ly8gZ2l2ZSBkZWZhdWx0cy4gd2lsbCBtYWtlIGEgY29weVxuXHRcdGlucHV0ID0gJC5leHRlbmQoe30sIEJVU0lORVNTX0hPVVJfRVZFTlRfREVGQVVMVFMsIGlucHV0KTtcblxuXHRcdC8vIGlmIGEgd2hvbGUtZGF5IHNlcmllcyBpcyByZXF1ZXN0ZWQsIGNsZWFyIHRoZSBzdGFydC9lbmQgdGltZXNcblx0XHRpZiAod2hvbGVEYXkpIHtcblx0XHRcdGlucHV0LnN0YXJ0ID0gbnVsbDtcblx0XHRcdGlucHV0LmVuZCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0ZXZlbnRzLnB1c2guYXBwbHkoZXZlbnRzLCAvLyBhcHBlbmRcblx0XHRcdHRoaXMuZXhwYW5kRXZlbnQoXG5cdFx0XHRcdHRoaXMuYnVpbGRFdmVudEZyb21JbnB1dChpbnB1dCksXG5cdFx0XHRcdHZpZXcuc3RhcnQsXG5cdFx0XHRcdHZpZXcuZW5kXG5cdFx0XHQpXG5cdFx0KTtcblx0fVxuXG5cdHJldHVybiBldmVudHM7XG59O1xuXG47O1xuXG4vKiBBbiBhYnN0cmFjdCBjbGFzcyBmb3IgdGhlIFwiYmFzaWNcIiB2aWV3cywgYXMgd2VsbCBhcyBtb250aCB2aWV3LiBSZW5kZXJzIG9uZSBvciBtb3JlIHJvd3Mgb2YgZGF5IGNlbGxzLlxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vLyBJdCBpcyBhIG1hbmFnZXIgZm9yIGEgRGF5R3JpZCBzdWJjb21wb25lbnQsIHdoaWNoIGRvZXMgbW9zdCBvZiB0aGUgaGVhdnkgbGlmdGluZy5cbi8vIEl0IGlzIHJlc3BvbnNpYmxlIGZvciBtYW5hZ2luZyB3aWR0aC9oZWlnaHQuXG5cbnZhciBCYXNpY1ZpZXcgPSBGQy5CYXNpY1ZpZXcgPSBWaWV3LmV4dGVuZCh7XG5cblx0c2Nyb2xsZXI6IG51bGwsXG5cblx0ZGF5R3JpZENsYXNzOiBEYXlHcmlkLCAvLyBjbGFzcyB0aGUgZGF5R3JpZCB3aWxsIGJlIGluc3RhbnRpYXRlZCBmcm9tIChvdmVycmlkYWJsZSBieSBzdWJjbGFzc2VzKVxuXHRkYXlHcmlkOiBudWxsLCAvLyB0aGUgbWFpbiBzdWJjb21wb25lbnQgdGhhdCBkb2VzIG1vc3Qgb2YgdGhlIGhlYXZ5IGxpZnRpbmdcblxuXHRkYXlOdW1iZXJzVmlzaWJsZTogZmFsc2UsIC8vIGRpc3BsYXkgZGF5IG51bWJlcnMgb24gZWFjaCBkYXkgY2VsbD9cblx0Y29sV2Vla051bWJlcnNWaXNpYmxlOiBmYWxzZSwgLy8gZGlzcGxheSB3ZWVrIG51bWJlcnMgYWxvbmcgdGhlIHNpZGU/XG5cdGNlbGxXZWVrTnVtYmVyc1Zpc2libGU6IGZhbHNlLCAvLyBkaXNwbGF5IHdlZWsgbnVtYmVycyBpbiBkYXkgY2VsbD9cblxuXHR3ZWVrTnVtYmVyV2lkdGg6IG51bGwsIC8vIHdpZHRoIG9mIGFsbCB0aGUgd2Vlay1udW1iZXIgY2VsbHMgcnVubmluZyBkb3duIHRoZSBzaWRlXG5cblx0aGVhZENvbnRhaW5lckVsOiBudWxsLCAvLyBkaXYgdGhhdCBob2xkJ3MgdGhlIGRheUdyaWQncyByZW5kZXJlZCBkYXRlIGhlYWRlclxuXHRoZWFkUm93RWw6IG51bGwsIC8vIHRoZSBmYWtlIHJvdyBlbGVtZW50IG9mIHRoZSBkYXktb2Ytd2VlayBoZWFkZXJcblxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZGF5R3JpZCA9IHRoaXMuaW5zdGFudGlhdGVEYXlHcmlkKCk7XG5cblx0XHR0aGlzLnNjcm9sbGVyID0gbmV3IFNjcm9sbGVyKHtcblx0XHRcdG92ZXJmbG93WDogJ2hpZGRlbicsXG5cdFx0XHRvdmVyZmxvd1k6ICdhdXRvJ1xuXHRcdH0pO1xuXHR9LFxuXG5cblx0Ly8gR2VuZXJhdGVzIHRoZSBEYXlHcmlkIG9iamVjdCB0aGlzIHZpZXcgbmVlZHMuIERyYXdzIGZyb20gdGhpcy5kYXlHcmlkQ2xhc3Ncblx0aW5zdGFudGlhdGVEYXlHcmlkOiBmdW5jdGlvbigpIHtcblx0XHQvLyBnZW5lcmF0ZSBhIHN1YmNsYXNzIG9uIHRoZSBmbHkgd2l0aCBCYXNpY1ZpZXctc3BlY2lmaWMgYmVoYXZpb3Jcblx0XHQvLyBUT0RPOiBjYWNoZSB0aGlzIHN1YmNsYXNzXG5cdFx0dmFyIHN1YmNsYXNzID0gdGhpcy5kYXlHcmlkQ2xhc3MuZXh0ZW5kKGJhc2ljRGF5R3JpZE1ldGhvZHMpO1xuXG5cdFx0cmV0dXJuIG5ldyBzdWJjbGFzcyh0aGlzKTtcblx0fSxcblxuXG5cdC8vIFNldHMgdGhlIGRpc3BsYXkgcmFuZ2UgYW5kIGNvbXB1dGVzIGFsbCBuZWNlc3NhcnkgZGF0ZXNcblx0c2V0UmFuZ2U6IGZ1bmN0aW9uKHJhbmdlKSB7XG5cdFx0Vmlldy5wcm90b3R5cGUuc2V0UmFuZ2UuY2FsbCh0aGlzLCByYW5nZSk7IC8vIGNhbGwgdGhlIHN1cGVyLW1ldGhvZFxuXG5cdFx0dGhpcy5kYXlHcmlkLmJyZWFrT25XZWVrcyA9IC95ZWFyfG1vbnRofHdlZWsvLnRlc3QodGhpcy5pbnRlcnZhbFVuaXQpOyAvLyBkbyBiZWZvcmUgc2V0UmFuZ2Vcblx0XHR0aGlzLmRheUdyaWQuc2V0UmFuZ2UocmFuZ2UpO1xuXHR9LFxuXG5cblx0Ly8gQ29tcHV0ZSB0aGUgdmFsdWUgdG8gZmVlZCBpbnRvIHNldFJhbmdlLiBPdmVycmlkZXMgc3VwZXJjbGFzcy5cblx0Y29tcHV0ZVJhbmdlOiBmdW5jdGlvbihkYXRlKSB7XG5cdFx0dmFyIHJhbmdlID0gVmlldy5wcm90b3R5cGUuY29tcHV0ZVJhbmdlLmNhbGwodGhpcywgZGF0ZSk7IC8vIGdldCB2YWx1ZSBmcm9tIHRoZSBzdXBlci1tZXRob2RcblxuXHRcdC8vIHllYXIgYW5kIG1vbnRoIHZpZXdzIHNob3VsZCBiZSBhbGlnbmVkIHdpdGggd2Vla3MuIHRoaXMgaXMgYWxyZWFkeSBkb25lIGZvciB3ZWVrXG5cdFx0aWYgKC95ZWFyfG1vbnRoLy50ZXN0KHJhbmdlLmludGVydmFsVW5pdCkpIHtcblx0XHRcdHJhbmdlLnN0YXJ0LnN0YXJ0T2YoJ3dlZWsnKTtcblx0XHRcdHJhbmdlLnN0YXJ0ID0gdGhpcy5za2lwSGlkZGVuRGF5cyhyYW5nZS5zdGFydCk7XG5cblx0XHRcdC8vIG1ha2UgZW5kLW9mLXdlZWsgaWYgbm90IGFscmVhZHlcblx0XHRcdGlmIChyYW5nZS5lbmQud2Vla2RheSgpKSB7XG5cdFx0XHRcdHJhbmdlLmVuZC5hZGQoMSwgJ3dlZWsnKS5zdGFydE9mKCd3ZWVrJyk7XG5cdFx0XHRcdHJhbmdlLmVuZCA9IHRoaXMuc2tpcEhpZGRlbkRheXMocmFuZ2UuZW5kLCAtMSwgdHJ1ZSk7IC8vIGV4Y2x1c2l2ZWx5IG1vdmUgYmFja3dhcmRzXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJhbmdlO1xuXHR9LFxuXG5cblx0Ly8gUmVuZGVycyB0aGUgdmlldyBpbnRvIGB0aGlzLmVsYCwgd2hpY2ggc2hvdWxkIGFscmVhZHkgYmUgYXNzaWduZWRcblx0cmVuZGVyRGF0ZXM6IGZ1bmN0aW9uKCkge1xuXG5cdFx0dGhpcy5kYXlOdW1iZXJzVmlzaWJsZSA9IHRoaXMuZGF5R3JpZC5yb3dDbnQgPiAxOyAvLyBUT0RPOiBtYWtlIGdyaWQgcmVzcG9uc2libGVcblx0XHRpZiAodGhpcy5vcHQoJ3dlZWtOdW1iZXJzJykpIHtcblx0XHRcdGlmICh0aGlzLm9wdCgnd2Vla051bWJlcnNXaXRoaW5EYXlzJykpIHtcblx0XHRcdFx0dGhpcy5jZWxsV2Vla051bWJlcnNWaXNpYmxlID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5jb2xXZWVrTnVtYmVyc1Zpc2libGUgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0aGlzLmNlbGxXZWVrTnVtYmVyc1Zpc2libGUgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5jb2xXZWVrTnVtYmVyc1Zpc2libGUgPSB0cnVlO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0dGhpcy5kYXlHcmlkLm51bWJlcnNWaXNpYmxlID0gdGhpcy5kYXlOdW1iZXJzVmlzaWJsZSB8fFxuXHRcdFx0dGhpcy5jZWxsV2Vla051bWJlcnNWaXNpYmxlIHx8IHRoaXMuY29sV2Vla051bWJlcnNWaXNpYmxlO1xuXG5cdFx0dGhpcy5lbC5hZGRDbGFzcygnZmMtYmFzaWMtdmlldycpLmh0bWwodGhpcy5yZW5kZXJTa2VsZXRvbkh0bWwoKSk7XG5cdFx0dGhpcy5yZW5kZXJIZWFkKCk7XG5cblx0XHR0aGlzLnNjcm9sbGVyLnJlbmRlcigpO1xuXHRcdHZhciBkYXlHcmlkQ29udGFpbmVyRWwgPSB0aGlzLnNjcm9sbGVyLmVsLmFkZENsYXNzKCdmYy1kYXktZ3JpZC1jb250YWluZXInKTtcblx0XHR2YXIgZGF5R3JpZEVsID0gJCgnPGRpdiBjbGFzcz1cImZjLWRheS1ncmlkXCIgLz4nKS5hcHBlbmRUbyhkYXlHcmlkQ29udGFpbmVyRWwpO1xuXHRcdHRoaXMuZWwuZmluZCgnLmZjLWJvZHkgPiB0ciA+IHRkJykuYXBwZW5kKGRheUdyaWRDb250YWluZXJFbCk7XG5cblx0XHR0aGlzLmRheUdyaWQuc2V0RWxlbWVudChkYXlHcmlkRWwpO1xuXHRcdHRoaXMuZGF5R3JpZC5yZW5kZXJEYXRlcyh0aGlzLmhhc1JpZ2lkUm93cygpKTtcblx0fSxcblxuXG5cdC8vIHJlbmRlciB0aGUgZGF5LW9mLXdlZWsgaGVhZGVyc1xuXHRyZW5kZXJIZWFkOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmhlYWRDb250YWluZXJFbCA9XG5cdFx0XHR0aGlzLmVsLmZpbmQoJy5mYy1oZWFkLWNvbnRhaW5lcicpXG5cdFx0XHRcdC5odG1sKHRoaXMuZGF5R3JpZC5yZW5kZXJIZWFkSHRtbCgpKTtcblx0XHR0aGlzLmhlYWRSb3dFbCA9IHRoaXMuaGVhZENvbnRhaW5lckVsLmZpbmQoJy5mYy1yb3cnKTtcblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyB0aGUgY29udGVudCBvZiB0aGUgdmlldy4gU2luY2Ugd2UgaGF2ZW4ndCBzZXBhcmF0ZWQgc2tlbGV0b24gcmVuZGVyaW5nIGZyb20gZGF0ZSByZW5kZXJpbmcsXG5cdC8vIGFsd2F5cyBjb21wbGV0ZWx5IGtpbGwgdGhlIGRheUdyaWQncyByZW5kZXJpbmcuXG5cdHVucmVuZGVyRGF0ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZGF5R3JpZC51bnJlbmRlckRhdGVzKCk7XG5cdFx0dGhpcy5kYXlHcmlkLnJlbW92ZUVsZW1lbnQoKTtcblx0XHR0aGlzLnNjcm9sbGVyLmRlc3Ryb3koKTtcblx0fSxcblxuXG5cdHJlbmRlckJ1c2luZXNzSG91cnM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZGF5R3JpZC5yZW5kZXJCdXNpbmVzc0hvdXJzKCk7XG5cdH0sXG5cblxuXHR1bnJlbmRlckJ1c2luZXNzSG91cnM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZGF5R3JpZC51bnJlbmRlckJ1c2luZXNzSG91cnMoKTtcblx0fSxcblxuXG5cdC8vIEJ1aWxkcyB0aGUgSFRNTCBza2VsZXRvbiBmb3IgdGhlIHZpZXcuXG5cdC8vIFRoZSBkYXktZ3JpZCBjb21wb25lbnQgd2lsbCByZW5kZXIgaW5zaWRlIG9mIGEgY29udGFpbmVyIGRlZmluZWQgYnkgdGhpcyBIVE1MLlxuXHRyZW5kZXJTa2VsZXRvbkh0bWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAnJyArXG5cdFx0XHQnPHRhYmxlPicgK1xuXHRcdFx0XHQnPHRoZWFkIGNsYXNzPVwiZmMtaGVhZFwiPicgK1xuXHRcdFx0XHRcdCc8dHI+JyArXG5cdFx0XHRcdFx0XHQnPHRkIGNsYXNzPVwiZmMtaGVhZC1jb250YWluZXIgJyArIHRoaXMud2lkZ2V0SGVhZGVyQ2xhc3MgKyAnXCI+PC90ZD4nICtcblx0XHRcdFx0XHQnPC90cj4nICtcblx0XHRcdFx0JzwvdGhlYWQ+JyArXG5cdFx0XHRcdCc8dGJvZHkgY2xhc3M9XCJmYy1ib2R5XCI+JyArXG5cdFx0XHRcdFx0Jzx0cj4nICtcblx0XHRcdFx0XHRcdCc8dGQgY2xhc3M9XCInICsgdGhpcy53aWRnZXRDb250ZW50Q2xhc3MgKyAnXCI+PC90ZD4nICtcblx0XHRcdFx0XHQnPC90cj4nICtcblx0XHRcdFx0JzwvdGJvZHk+JyArXG5cdFx0XHQnPC90YWJsZT4nO1xuXHR9LFxuXG5cblx0Ly8gR2VuZXJhdGVzIGFuIEhUTUwgYXR0cmlidXRlIHN0cmluZyBmb3Igc2V0dGluZyB0aGUgd2lkdGggb2YgdGhlIHdlZWsgbnVtYmVyIGNvbHVtbiwgaWYgaXQgaXMga25vd25cblx0d2Vla051bWJlclN0eWxlQXR0cjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMud2Vla051bWJlcldpZHRoICE9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gJ3N0eWxlPVwid2lkdGg6JyArIHRoaXMud2Vla051bWJlcldpZHRoICsgJ3B4XCInO1xuXHRcdH1cblx0XHRyZXR1cm4gJyc7XG5cdH0sXG5cblxuXHQvLyBEZXRlcm1pbmVzIHdoZXRoZXIgZWFjaCByb3cgc2hvdWxkIGhhdmUgYSBjb25zdGFudCBoZWlnaHRcblx0aGFzUmlnaWRSb3dzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZXZlbnRMaW1pdCA9IHRoaXMub3B0KCdldmVudExpbWl0Jyk7XG5cdFx0cmV0dXJuIGV2ZW50TGltaXQgJiYgdHlwZW9mIGV2ZW50TGltaXQgIT09ICdudW1iZXInO1xuXHR9LFxuXG5cblx0LyogRGltZW5zaW9uc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gUmVmcmVzaGVzIHRoZSBob3Jpem9udGFsIGRpbWVuc2lvbnMgb2YgdGhlIHZpZXdcblx0dXBkYXRlV2lkdGg6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLmNvbFdlZWtOdW1iZXJzVmlzaWJsZSkge1xuXHRcdFx0Ly8gTWFrZSBzdXJlIGFsbCB3ZWVrIG51bWJlciBjZWxscyBydW5uaW5nIGRvd24gdGhlIHNpZGUgaGF2ZSB0aGUgc2FtZSB3aWR0aC5cblx0XHRcdC8vIFJlY29yZCB0aGUgd2lkdGggZm9yIGNlbGxzIGNyZWF0ZWQgbGF0ZXIuXG5cdFx0XHR0aGlzLndlZWtOdW1iZXJXaWR0aCA9IG1hdGNoQ2VsbFdpZHRocyhcblx0XHRcdFx0dGhpcy5lbC5maW5kKCcuZmMtd2Vlay1udW1iZXInKVxuXHRcdFx0KTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBBZGp1c3RzIHRoZSB2ZXJ0aWNhbCBkaW1lbnNpb25zIG9mIHRoZSB2aWV3IHRvIHRoZSBzcGVjaWZpZWQgdmFsdWVzXG5cdHNldEhlaWdodDogZnVuY3Rpb24odG90YWxIZWlnaHQsIGlzQXV0bykge1xuXHRcdHZhciBldmVudExpbWl0ID0gdGhpcy5vcHQoJ2V2ZW50TGltaXQnKTtcblx0XHR2YXIgc2Nyb2xsZXJIZWlnaHQ7XG5cdFx0dmFyIHNjcm9sbGJhcldpZHRocztcblxuXHRcdC8vIHJlc2V0IGFsbCBoZWlnaHRzIHRvIGJlIG5hdHVyYWxcblx0XHR0aGlzLnNjcm9sbGVyLmNsZWFyKCk7XG5cdFx0dW5jb21wZW5zYXRlU2Nyb2xsKHRoaXMuaGVhZFJvd0VsKTtcblxuXHRcdHRoaXMuZGF5R3JpZC5yZW1vdmVTZWdQb3BvdmVyKCk7IC8vIGtpbGwgdGhlIFwibW9yZVwiIHBvcG92ZXIgaWYgZGlzcGxheWVkXG5cblx0XHQvLyBpcyB0aGUgZXZlbnQgbGltaXQgYSBjb25zdGFudCBsZXZlbCBudW1iZXI/XG5cdFx0aWYgKGV2ZW50TGltaXQgJiYgdHlwZW9mIGV2ZW50TGltaXQgPT09ICdudW1iZXInKSB7XG5cdFx0XHR0aGlzLmRheUdyaWQubGltaXRSb3dzKGV2ZW50TGltaXQpOyAvLyBsaW1pdCB0aGUgbGV2ZWxzIGZpcnN0IHNvIHRoZSBoZWlnaHQgY2FuIHJlZGlzdHJpYnV0ZSBhZnRlclxuXHRcdH1cblxuXHRcdC8vIGRpc3RyaWJ1dGUgdGhlIGhlaWdodCB0byB0aGUgcm93c1xuXHRcdC8vICh0b3RhbEhlaWdodCBpcyBhIFwicmVjb21tZW5kZWRcIiB2YWx1ZSBpZiBpc0F1dG8pXG5cdFx0c2Nyb2xsZXJIZWlnaHQgPSB0aGlzLmNvbXB1dGVTY3JvbGxlckhlaWdodCh0b3RhbEhlaWdodCk7XG5cdFx0dGhpcy5zZXRHcmlkSGVpZ2h0KHNjcm9sbGVySGVpZ2h0LCBpc0F1dG8pO1xuXG5cdFx0Ly8gaXMgdGhlIGV2ZW50IGxpbWl0IGR5bmFtaWNhbGx5IGNhbGN1bGF0ZWQ/XG5cdFx0aWYgKGV2ZW50TGltaXQgJiYgdHlwZW9mIGV2ZW50TGltaXQgIT09ICdudW1iZXInKSB7XG5cdFx0XHR0aGlzLmRheUdyaWQubGltaXRSb3dzKGV2ZW50TGltaXQpOyAvLyBsaW1pdCB0aGUgbGV2ZWxzIGFmdGVyIHRoZSBncmlkJ3Mgcm93IGhlaWdodHMgaGF2ZSBiZWVuIHNldFxuXHRcdH1cblxuXHRcdGlmICghaXNBdXRvKSB7IC8vIHNob3VsZCB3ZSBmb3JjZSBkaW1lbnNpb25zIG9mIHRoZSBzY3JvbGwgY29udGFpbmVyP1xuXG5cdFx0XHR0aGlzLnNjcm9sbGVyLnNldEhlaWdodChzY3JvbGxlckhlaWdodCk7XG5cdFx0XHRzY3JvbGxiYXJXaWR0aHMgPSB0aGlzLnNjcm9sbGVyLmdldFNjcm9sbGJhcldpZHRocygpO1xuXG5cdFx0XHRpZiAoc2Nyb2xsYmFyV2lkdGhzLmxlZnQgfHwgc2Nyb2xsYmFyV2lkdGhzLnJpZ2h0KSB7IC8vIHVzaW5nIHNjcm9sbGJhcnM/XG5cblx0XHRcdFx0Y29tcGVuc2F0ZVNjcm9sbCh0aGlzLmhlYWRSb3dFbCwgc2Nyb2xsYmFyV2lkdGhzKTtcblxuXHRcdFx0XHQvLyBkb2luZyB0aGUgc2Nyb2xsYmFyIGNvbXBlbnNhdGlvbiBtaWdodCBoYXZlIGNyZWF0ZWQgdGV4dCBvdmVyZmxvdyB3aGljaCBjcmVhdGVkIG1vcmUgaGVpZ2h0LiByZWRvXG5cdFx0XHRcdHNjcm9sbGVySGVpZ2h0ID0gdGhpcy5jb21wdXRlU2Nyb2xsZXJIZWlnaHQodG90YWxIZWlnaHQpO1xuXHRcdFx0XHR0aGlzLnNjcm9sbGVyLnNldEhlaWdodChzY3JvbGxlckhlaWdodCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGd1YXJhbnRlZXMgdGhlIHNhbWUgc2Nyb2xsYmFyIHdpZHRoc1xuXHRcdFx0dGhpcy5zY3JvbGxlci5sb2NrT3ZlcmZsb3coc2Nyb2xsYmFyV2lkdGhzKTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBnaXZlbiBhIGRlc2lyZWQgdG90YWwgaGVpZ2h0IG9mIHRoZSB2aWV3LCByZXR1cm5zIHdoYXQgdGhlIGhlaWdodCBvZiB0aGUgc2Nyb2xsZXIgc2hvdWxkIGJlXG5cdGNvbXB1dGVTY3JvbGxlckhlaWdodDogZnVuY3Rpb24odG90YWxIZWlnaHQpIHtcblx0XHRyZXR1cm4gdG90YWxIZWlnaHQgLVxuXHRcdFx0c3VidHJhY3RJbm5lckVsSGVpZ2h0KHRoaXMuZWwsIHRoaXMuc2Nyb2xsZXIuZWwpOyAvLyBldmVyeXRoaW5nIHRoYXQncyBOT1QgdGhlIHNjcm9sbGVyXG5cdH0sXG5cblxuXHQvLyBTZXRzIHRoZSBoZWlnaHQgb2YganVzdCB0aGUgRGF5R3JpZCBjb21wb25lbnQgaW4gdGhpcyB2aWV3XG5cdHNldEdyaWRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCwgaXNBdXRvKSB7XG5cdFx0aWYgKGlzQXV0bykge1xuXHRcdFx0dW5kaXN0cmlidXRlSGVpZ2h0KHRoaXMuZGF5R3JpZC5yb3dFbHMpOyAvLyBsZXQgdGhlIHJvd3MgYmUgdGhlaXIgbmF0dXJhbCBoZWlnaHQgd2l0aCBubyBleHBhbmRpbmdcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRkaXN0cmlidXRlSGVpZ2h0KHRoaXMuZGF5R3JpZC5yb3dFbHMsIGhlaWdodCwgdHJ1ZSk7IC8vIHRydWUgPSBjb21wZW5zYXRlIGZvciBoZWlnaHQtaG9nZ2luZyByb3dzXG5cdFx0fVxuXHR9LFxuXG5cblx0LyogU2Nyb2xsXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHRxdWVyeVNjcm9sbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2Nyb2xsZXIuZ2V0U2Nyb2xsVG9wKCk7XG5cdH0sXG5cblxuXHRzZXRTY3JvbGw6IGZ1bmN0aW9uKHRvcCkge1xuXHRcdHRoaXMuc2Nyb2xsZXIuc2V0U2Nyb2xsVG9wKHRvcCk7XG5cdH0sXG5cblxuXHQvKiBIaXQgQXJlYXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblx0Ly8gZm9yd2FyZCBhbGwgaGl0LXJlbGF0ZWQgbWV0aG9kIGNhbGxzIHRvIGRheUdyaWRcblxuXG5cdHByZXBhcmVIaXRzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmRheUdyaWQucHJlcGFyZUhpdHMoKTtcblx0fSxcblxuXG5cdHJlbGVhc2VIaXRzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmRheUdyaWQucmVsZWFzZUhpdHMoKTtcblx0fSxcblxuXG5cdHF1ZXJ5SGl0OiBmdW5jdGlvbihsZWZ0LCB0b3ApIHtcblx0XHRyZXR1cm4gdGhpcy5kYXlHcmlkLnF1ZXJ5SGl0KGxlZnQsIHRvcCk7XG5cdH0sXG5cblxuXHRnZXRIaXRTcGFuOiBmdW5jdGlvbihoaXQpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXlHcmlkLmdldEhpdFNwYW4oaGl0KTtcblx0fSxcblxuXG5cdGdldEhpdEVsOiBmdW5jdGlvbihoaXQpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXlHcmlkLmdldEhpdEVsKGhpdCk7XG5cdH0sXG5cblxuXHQvKiBFdmVudHNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIFJlbmRlcnMgdGhlIGdpdmVuIGV2ZW50cyBvbnRvIHRoZSB2aWV3IGFuZCBwb3B1bGF0ZXMgdGhlIHNlZ21lbnRzIGFycmF5XG5cdHJlbmRlckV2ZW50czogZnVuY3Rpb24oZXZlbnRzKSB7XG5cdFx0dGhpcy5kYXlHcmlkLnJlbmRlckV2ZW50cyhldmVudHMpO1xuXG5cdFx0dGhpcy51cGRhdGVIZWlnaHQoKTsgLy8gbXVzdCBjb21wZW5zYXRlIGZvciBldmVudHMgdGhhdCBvdmVyZmxvdyB0aGUgcm93XG5cdH0sXG5cblxuXHQvLyBSZXRyaWV2ZXMgYWxsIHNlZ21lbnQgb2JqZWN0cyB0aGF0IGFyZSByZW5kZXJlZCBpbiB0aGUgdmlld1xuXHRnZXRFdmVudFNlZ3M6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmRheUdyaWQuZ2V0RXZlbnRTZWdzKCk7XG5cdH0sXG5cblxuXHQvLyBVbnJlbmRlcnMgYWxsIGV2ZW50IGVsZW1lbnRzIGFuZCBjbGVhcnMgaW50ZXJuYWwgc2VnbWVudCBkYXRhXG5cdHVucmVuZGVyRXZlbnRzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmRheUdyaWQudW5yZW5kZXJFdmVudHMoKTtcblxuXHRcdC8vIHdlIERPTidUIG5lZWQgdG8gY2FsbCB1cGRhdGVIZWlnaHQoKSBiZWNhdXNlXG5cdFx0Ly8gYSByZW5kZXJFdmVudHMoKSBjYWxsIGFsd2F5cyBoYXBwZW5zIGFmdGVyIHRoaXMsIHdoaWNoIHdpbGwgZXZlbnR1YWxseSBjYWxsIHVwZGF0ZUhlaWdodCgpXG5cdH0sXG5cblxuXHQvKiBEcmFnZ2luZyAoZm9yIGJvdGggZXZlbnRzIGFuZCBleHRlcm5hbCBlbGVtZW50cylcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIEEgcmV0dXJuZWQgdmFsdWUgb2YgYHRydWVgIHNpZ25hbHMgdGhhdCBhIG1vY2sgXCJoZWxwZXJcIiBldmVudCBoYXMgYmVlbiByZW5kZXJlZC5cblx0cmVuZGVyRHJhZzogZnVuY3Rpb24oZHJvcExvY2F0aW9uLCBzZWcpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXlHcmlkLnJlbmRlckRyYWcoZHJvcExvY2F0aW9uLCBzZWcpO1xuXHR9LFxuXG5cblx0dW5yZW5kZXJEcmFnOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmRheUdyaWQudW5yZW5kZXJEcmFnKCk7XG5cdH0sXG5cblxuXHQvKiBTZWxlY3Rpb25cblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIFJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhIHNlbGVjdGlvblxuXHRyZW5kZXJTZWxlY3Rpb246IGZ1bmN0aW9uKHNwYW4pIHtcblx0XHR0aGlzLmRheUdyaWQucmVuZGVyU2VsZWN0aW9uKHNwYW4pO1xuXHR9LFxuXG5cblx0Ly8gVW5yZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb25zIG9mIGEgc2VsZWN0aW9uXG5cdHVucmVuZGVyU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmRheUdyaWQudW5yZW5kZXJTZWxlY3Rpb24oKTtcblx0fVxuXG59KTtcblxuXG4vLyBNZXRob2RzIHRoYXQgd2lsbCBjdXN0b21pemUgdGhlIHJlbmRlcmluZyBiZWhhdmlvciBvZiB0aGUgQmFzaWNWaWV3J3MgZGF5R3JpZFxudmFyIGJhc2ljRGF5R3JpZE1ldGhvZHMgPSB7XG5cblxuXHQvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgdGhhdCB3aWxsIGdvIGJlZm9yZSB0aGUgZGF5LW9mIHdlZWsgaGVhZGVyIGNlbGxzXG5cdHJlbmRlckhlYWRJbnRyb0h0bWw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXG5cdFx0aWYgKHZpZXcuY29sV2Vla051bWJlcnNWaXNpYmxlKSB7XG5cdFx0XHRyZXR1cm4gJycgK1xuXHRcdFx0XHQnPHRoIGNsYXNzPVwiZmMtd2Vlay1udW1iZXIgJyArIHZpZXcud2lkZ2V0SGVhZGVyQ2xhc3MgKyAnXCIgJyArIHZpZXcud2Vla051bWJlclN0eWxlQXR0cigpICsgJz4nICtcblx0XHRcdFx0XHQnPHNwYW4+JyArIC8vIG5lZWRlZCBmb3IgbWF0Y2hDZWxsV2lkdGhzXG5cdFx0XHRcdFx0XHRodG1sRXNjYXBlKHZpZXcub3B0KCd3ZWVrTnVtYmVyVGl0bGUnKSkgK1xuXHRcdFx0XHRcdCc8L3NwYW4+JyArXG5cdFx0XHRcdCc8L3RoPic7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICcnO1xuXHR9LFxuXG5cblx0Ly8gR2VuZXJhdGVzIHRoZSBIVE1MIHRoYXQgd2lsbCBnbyBiZWZvcmUgY29udGVudC1za2VsZXRvbiBjZWxscyB0aGF0IGRpc3BsYXkgdGhlIGRheS93ZWVrIG51bWJlcnNcblx0cmVuZGVyTnVtYmVySW50cm9IdG1sOiBmdW5jdGlvbihyb3cpIHtcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblx0XHR2YXIgd2Vla1N0YXJ0ID0gdGhpcy5nZXRDZWxsRGF0ZShyb3csIDApO1xuXG5cdFx0aWYgKHZpZXcuY29sV2Vla051bWJlcnNWaXNpYmxlKSB7XG5cdFx0XHRyZXR1cm4gJycgK1xuXHRcdFx0XHQnPHRkIGNsYXNzPVwiZmMtd2Vlay1udW1iZXJcIiAnICsgdmlldy53ZWVrTnVtYmVyU3R5bGVBdHRyKCkgKyAnPicgK1xuXHRcdFx0XHRcdHZpZXcuYnVpbGRHb3RvQW5jaG9ySHRtbCggLy8gYXNpZGUgZnJvbSBsaW5rLCBpbXBvcnRhbnQgZm9yIG1hdGNoQ2VsbFdpZHRoc1xuXHRcdFx0XHRcdFx0eyBkYXRlOiB3ZWVrU3RhcnQsIHR5cGU6ICd3ZWVrJywgZm9yY2VPZmY6IHRoaXMuY29sQ250ID09PSAxIH0sXG5cdFx0XHRcdFx0XHR3ZWVrU3RhcnQuZm9ybWF0KCd3JykgLy8gaW5uZXIgSFRNTFxuXHRcdFx0XHRcdCkgK1xuXHRcdFx0XHQnPC90ZD4nO1xuXHRcdH1cblxuXHRcdHJldHVybiAnJztcblx0fSxcblxuXG5cdC8vIEdlbmVyYXRlcyB0aGUgSFRNTCB0aGF0IGdvZXMgYmVmb3JlIHRoZSBkYXkgYmcgY2VsbHMgZm9yIGVhY2ggZGF5LXJvd1xuXHRyZW5kZXJCZ0ludHJvSHRtbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cblx0XHRpZiAodmlldy5jb2xXZWVrTnVtYmVyc1Zpc2libGUpIHtcblx0XHRcdHJldHVybiAnPHRkIGNsYXNzPVwiZmMtd2Vlay1udW1iZXIgJyArIHZpZXcud2lkZ2V0Q29udGVudENsYXNzICsgJ1wiICcgK1xuXHRcdFx0XHR2aWV3LndlZWtOdW1iZXJTdHlsZUF0dHIoKSArICc+PC90ZD4nO1xuXHRcdH1cblxuXHRcdHJldHVybiAnJztcblx0fSxcblxuXG5cdC8vIEdlbmVyYXRlcyB0aGUgSFRNTCB0aGF0IGdvZXMgYmVmb3JlIGV2ZXJ5IG90aGVyIHR5cGUgb2Ygcm93IGdlbmVyYXRlZCBieSBEYXlHcmlkLlxuXHQvLyBBZmZlY3RzIGhlbHBlci1za2VsZXRvbiBhbmQgaGlnaGxpZ2h0LXNrZWxldG9uIHJvd3MuXG5cdHJlbmRlckludHJvSHRtbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cblx0XHRpZiAodmlldy5jb2xXZWVrTnVtYmVyc1Zpc2libGUpIHtcblx0XHRcdHJldHVybiAnPHRkIGNsYXNzPVwiZmMtd2Vlay1udW1iZXJcIiAnICsgdmlldy53ZWVrTnVtYmVyU3R5bGVBdHRyKCkgKyAnPjwvdGQ+Jztcblx0XHR9XG5cblx0XHRyZXR1cm4gJyc7XG5cdH1cblxufTtcblxuOztcblxuLyogQSBtb250aCB2aWV3IHdpdGggZGF5IGNlbGxzIHJ1bm5pbmcgaW4gcm93cyAob25lLXBlci13ZWVrKSBhbmQgY29sdW1uc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbnZhciBNb250aFZpZXcgPSBGQy5Nb250aFZpZXcgPSBCYXNpY1ZpZXcuZXh0ZW5kKHtcblxuXHQvLyBQcm9kdWNlcyBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IHJhbmdlIHRvIGRpc3BsYXlcblx0Y29tcHV0ZVJhbmdlOiBmdW5jdGlvbihkYXRlKSB7XG5cdFx0dmFyIHJhbmdlID0gQmFzaWNWaWV3LnByb3RvdHlwZS5jb21wdXRlUmFuZ2UuY2FsbCh0aGlzLCBkYXRlKTsgLy8gZ2V0IHZhbHVlIGZyb20gc3VwZXItbWV0aG9kXG5cdFx0dmFyIHJvd0NudDtcblxuXHRcdC8vIGVuc3VyZSA2IHdlZWtzXG5cdFx0aWYgKHRoaXMuaXNGaXhlZFdlZWtzKCkpIHtcblx0XHRcdHJvd0NudCA9IE1hdGguY2VpbChyYW5nZS5lbmQuZGlmZihyYW5nZS5zdGFydCwgJ3dlZWtzJywgdHJ1ZSkpOyAvLyBjb3VsZCBiZSBwYXJ0aWFsIHdlZWtzIGR1ZSB0byBoaWRkZW5EYXlzXG5cdFx0XHRyYW5nZS5lbmQuYWRkKDYgLSByb3dDbnQsICd3ZWVrcycpO1xuXHRcdH1cblxuXHRcdHJldHVybiByYW5nZTtcblx0fSxcblxuXG5cdC8vIE92ZXJyaWRlcyB0aGUgZGVmYXVsdCBCYXNpY1ZpZXcgYmVoYXZpb3IgdG8gaGF2ZSBzcGVjaWFsIG11bHRpLXdlZWsgYXV0by1oZWlnaHQgbG9naWNcblx0c2V0R3JpZEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0LCBpc0F1dG8pIHtcblxuXHRcdC8vIGlmIGF1dG8sIG1ha2UgdGhlIGhlaWdodCBvZiBlYWNoIHJvdyB0aGUgaGVpZ2h0IHRoYXQgaXQgd291bGQgYmUgaWYgdGhlcmUgd2VyZSA2IHdlZWtzXG5cdFx0aWYgKGlzQXV0bykge1xuXHRcdFx0aGVpZ2h0ICo9IHRoaXMucm93Q250IC8gNjtcblx0XHR9XG5cblx0XHRkaXN0cmlidXRlSGVpZ2h0KHRoaXMuZGF5R3JpZC5yb3dFbHMsIGhlaWdodCwgIWlzQXV0byk7IC8vIGlmIGF1dG8sIGRvbid0IGNvbXBlbnNhdGUgZm9yIGhlaWdodC1ob2dnaW5nIHJvd3Ncblx0fSxcblxuXG5cdGlzRml4ZWRXZWVrczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMub3B0KCdmaXhlZFdlZWtDb3VudCcpO1xuXHR9XG5cbn0pO1xuXG47O1xuXG5mY1ZpZXdzLmJhc2ljID0ge1xuXHQnY2xhc3MnOiBCYXNpY1ZpZXdcbn07XG5cbmZjVmlld3MuYmFzaWNEYXkgPSB7XG5cdHR5cGU6ICdiYXNpYycsXG5cdGR1cmF0aW9uOiB7IGRheXM6IDEgfVxufTtcblxuZmNWaWV3cy5iYXNpY1dlZWsgPSB7XG5cdHR5cGU6ICdiYXNpYycsXG5cdGR1cmF0aW9uOiB7IHdlZWtzOiAxIH1cbn07XG5cbmZjVmlld3MubW9udGggPSB7XG5cdCdjbGFzcyc6IE1vbnRoVmlldyxcblx0ZHVyYXRpb246IHsgbW9udGhzOiAxIH0sIC8vIGltcG9ydGFudCBmb3IgcHJldi9uZXh0XG5cdGRlZmF1bHRzOiB7XG5cdFx0Zml4ZWRXZWVrQ291bnQ6IHRydWVcblx0fVxufTtcbjs7XG5cbi8qIEFuIGFic3RyYWN0IGNsYXNzIGZvciBhbGwgYWdlbmRhLXJlbGF0ZWQgdmlld3MuIERpc3BsYXlzIG9uZSBtb3JlIGNvbHVtbnMgd2l0aCB0aW1lIHNsb3RzIHJ1bm5pbmcgdmVydGljYWxseS5cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLy8gSXMgYSBtYW5hZ2VyIGZvciB0aGUgVGltZUdyaWQgc3ViY29tcG9uZW50IGFuZCBwb3NzaWJseSB0aGUgRGF5R3JpZCBzdWJjb21wb25lbnQgKGlmIGFsbERheVNsb3QgaXMgb24pLlxuLy8gUmVzcG9uc2libGUgZm9yIG1hbmFnaW5nIHdpZHRoL2hlaWdodC5cblxudmFyIEFnZW5kYVZpZXcgPSBGQy5BZ2VuZGFWaWV3ID0gVmlldy5leHRlbmQoe1xuXG5cdHNjcm9sbGVyOiBudWxsLFxuXG5cdHRpbWVHcmlkQ2xhc3M6IFRpbWVHcmlkLCAvLyBjbGFzcyB1c2VkIHRvIGluc3RhbnRpYXRlIHRoZSB0aW1lR3JpZC4gc3ViY2xhc3NlcyBjYW4gb3ZlcnJpZGVcblx0dGltZUdyaWQ6IG51bGwsIC8vIHRoZSBtYWluIHRpbWUtZ3JpZCBzdWJjb21wb25lbnQgb2YgdGhpcyB2aWV3XG5cblx0ZGF5R3JpZENsYXNzOiBEYXlHcmlkLCAvLyBjbGFzcyB1c2VkIHRvIGluc3RhbnRpYXRlIHRoZSBkYXlHcmlkLiBzdWJjbGFzc2VzIGNhbiBvdmVycmlkZVxuXHRkYXlHcmlkOiBudWxsLCAvLyB0aGUgXCJhbGwtZGF5XCIgc3ViY29tcG9uZW50LiBpZiBhbGwtZGF5IGlzIHR1cm5lZCBvZmYsIHRoaXMgd2lsbCBiZSBudWxsXG5cblx0YXhpc1dpZHRoOiBudWxsLCAvLyB0aGUgd2lkdGggb2YgdGhlIHRpbWUgYXhpcyBydW5uaW5nIGRvd24gdGhlIHNpZGVcblxuXHRoZWFkQ29udGFpbmVyRWw6IG51bGwsIC8vIGRpdiB0aGF0IGhvbGQncyB0aGUgdGltZUdyaWQncyByZW5kZXJlZCBkYXRlIGhlYWRlclxuXHRub1Njcm9sbFJvd0VsczogbnVsbCwgLy8gc2V0IG9mIGZha2Ugcm93IGVsZW1lbnRzIHRoYXQgbXVzdCBjb21wZW5zYXRlIHdoZW4gc2Nyb2xsZXIgaGFzIHNjcm9sbGJhcnNcblxuXHQvLyB3aGVuIHRoZSB0aW1lLWdyaWQgaXNuJ3QgdGFsbCBlbm91Z2ggdG8gb2NjdXB5IHRoZSBnaXZlbiBoZWlnaHQsIHdlIHJlbmRlciBhbiA8aHI+IHVuZGVybmVhdGhcblx0Ym90dG9tUnVsZUVsOiBudWxsLFxuXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy50aW1lR3JpZCA9IHRoaXMuaW5zdGFudGlhdGVUaW1lR3JpZCgpO1xuXG5cdFx0aWYgKHRoaXMub3B0KCdhbGxEYXlTbG90JykpIHsgLy8gc2hvdWxkIHdlIGRpc3BsYXkgdGhlIFwiYWxsLWRheVwiIGFyZWE/XG5cdFx0XHR0aGlzLmRheUdyaWQgPSB0aGlzLmluc3RhbnRpYXRlRGF5R3JpZCgpOyAvLyB0aGUgYWxsLWRheSBzdWJjb21wb25lbnQgb2YgdGhpcyB2aWV3XG5cdFx0fVxuXG5cdFx0dGhpcy5zY3JvbGxlciA9IG5ldyBTY3JvbGxlcih7XG5cdFx0XHRvdmVyZmxvd1g6ICdoaWRkZW4nLFxuXHRcdFx0b3ZlcmZsb3dZOiAnYXV0bydcblx0XHR9KTtcblx0fSxcblxuXG5cdC8vIEluc3RhbnRpYXRlcyB0aGUgVGltZUdyaWQgb2JqZWN0IHRoaXMgdmlldyBuZWVkcy4gRHJhd3MgZnJvbSB0aGlzLnRpbWVHcmlkQ2xhc3Ncblx0aW5zdGFudGlhdGVUaW1lR3JpZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHN1YmNsYXNzID0gdGhpcy50aW1lR3JpZENsYXNzLmV4dGVuZChhZ2VuZGFUaW1lR3JpZE1ldGhvZHMpO1xuXG5cdFx0cmV0dXJuIG5ldyBzdWJjbGFzcyh0aGlzKTtcblx0fSxcblxuXG5cdC8vIEluc3RhbnRpYXRlcyB0aGUgRGF5R3JpZCBvYmplY3QgdGhpcyB2aWV3IG1pZ2h0IG5lZWQuIERyYXdzIGZyb20gdGhpcy5kYXlHcmlkQ2xhc3Ncblx0aW5zdGFudGlhdGVEYXlHcmlkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc3ViY2xhc3MgPSB0aGlzLmRheUdyaWRDbGFzcy5leHRlbmQoYWdlbmRhRGF5R3JpZE1ldGhvZHMpO1xuXG5cdFx0cmV0dXJuIG5ldyBzdWJjbGFzcyh0aGlzKTtcblx0fSxcblxuXG5cdC8qIFJlbmRlcmluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gU2V0cyB0aGUgZGlzcGxheSByYW5nZSBhbmQgY29tcHV0ZXMgYWxsIG5lY2Vzc2FyeSBkYXRlc1xuXHRzZXRSYW5nZTogZnVuY3Rpb24ocmFuZ2UpIHtcblx0XHRWaWV3LnByb3RvdHlwZS5zZXRSYW5nZS5jYWxsKHRoaXMsIHJhbmdlKTsgLy8gY2FsbCB0aGUgc3VwZXItbWV0aG9kXG5cblx0XHR0aGlzLnRpbWVHcmlkLnNldFJhbmdlKHJhbmdlKTtcblx0XHRpZiAodGhpcy5kYXlHcmlkKSB7XG5cdFx0XHR0aGlzLmRheUdyaWQuc2V0UmFuZ2UocmFuZ2UpO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIFJlbmRlcnMgdGhlIHZpZXcgaW50byBgdGhpcy5lbGAsIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gYXNzaWduZWRcblx0cmVuZGVyRGF0ZXM6IGZ1bmN0aW9uKCkge1xuXG5cdFx0dGhpcy5lbC5hZGRDbGFzcygnZmMtYWdlbmRhLXZpZXcnKS5odG1sKHRoaXMucmVuZGVyU2tlbGV0b25IdG1sKCkpO1xuXHRcdHRoaXMucmVuZGVySGVhZCgpO1xuXG5cdFx0dGhpcy5zY3JvbGxlci5yZW5kZXIoKTtcblx0XHR2YXIgdGltZUdyaWRXcmFwRWwgPSB0aGlzLnNjcm9sbGVyLmVsLmFkZENsYXNzKCdmYy10aW1lLWdyaWQtY29udGFpbmVyJyk7XG5cdFx0dmFyIHRpbWVHcmlkRWwgPSAkKCc8ZGl2IGNsYXNzPVwiZmMtdGltZS1ncmlkXCIgLz4nKS5hcHBlbmRUbyh0aW1lR3JpZFdyYXBFbCk7XG5cdFx0dGhpcy5lbC5maW5kKCcuZmMtYm9keSA+IHRyID4gdGQnKS5hcHBlbmQodGltZUdyaWRXcmFwRWwpO1xuXG5cdFx0dGhpcy50aW1lR3JpZC5zZXRFbGVtZW50KHRpbWVHcmlkRWwpO1xuXHRcdHRoaXMudGltZUdyaWQucmVuZGVyRGF0ZXMoKTtcblxuXHRcdC8vIHRoZSA8aHI+IHRoYXQgc29tZXRpbWVzIGRpc3BsYXlzIHVuZGVyIHRoZSB0aW1lLWdyaWRcblx0XHR0aGlzLmJvdHRvbVJ1bGVFbCA9ICQoJzxociBjbGFzcz1cImZjLWRpdmlkZXIgJyArIHRoaXMud2lkZ2V0SGVhZGVyQ2xhc3MgKyAnXCIvPicpXG5cdFx0XHQuYXBwZW5kVG8odGhpcy50aW1lR3JpZC5lbCk7IC8vIGluamVjdCBpdCBpbnRvIHRoZSB0aW1lLWdyaWRcblxuXHRcdGlmICh0aGlzLmRheUdyaWQpIHtcblx0XHRcdHRoaXMuZGF5R3JpZC5zZXRFbGVtZW50KHRoaXMuZWwuZmluZCgnLmZjLWRheS1ncmlkJykpO1xuXHRcdFx0dGhpcy5kYXlHcmlkLnJlbmRlckRhdGVzKCk7XG5cblx0XHRcdC8vIGhhdmUgdGhlIGRheS1ncmlkIGV4dGVuZCBpdCdzIGNvb3JkaW5hdGUgYXJlYSBvdmVyIHRoZSA8aHI+IGRpdmlkaW5nIHRoZSB0d28gZ3JpZHNcblx0XHRcdHRoaXMuZGF5R3JpZC5ib3R0b21Db29yZFBhZGRpbmcgPSB0aGlzLmRheUdyaWQuZWwubmV4dCgnaHInKS5vdXRlckhlaWdodCgpO1xuXHRcdH1cblxuXHRcdHRoaXMubm9TY3JvbGxSb3dFbHMgPSB0aGlzLmVsLmZpbmQoJy5mYy1yb3c6bm90KC5mYy1zY3JvbGxlciAqKScpOyAvLyBmYWtlIHJvd3Mgbm90IHdpdGhpbiB0aGUgc2Nyb2xsZXJcblx0fSxcblxuXG5cdC8vIHJlbmRlciB0aGUgZGF5LW9mLXdlZWsgaGVhZGVyc1xuXHRyZW5kZXJIZWFkOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmhlYWRDb250YWluZXJFbCA9XG5cdFx0XHR0aGlzLmVsLmZpbmQoJy5mYy1oZWFkLWNvbnRhaW5lcicpXG5cdFx0XHRcdC5odG1sKHRoaXMudGltZUdyaWQucmVuZGVySGVhZEh0bWwoKSk7XG5cdH0sXG5cblxuXHQvLyBVbnJlbmRlcnMgdGhlIGNvbnRlbnQgb2YgdGhlIHZpZXcuIFNpbmNlIHdlIGhhdmVuJ3Qgc2VwYXJhdGVkIHNrZWxldG9uIHJlbmRlcmluZyBmcm9tIGRhdGUgcmVuZGVyaW5nLFxuXHQvLyBhbHdheXMgY29tcGxldGVseSBraWxsIGVhY2ggZ3JpZCdzIHJlbmRlcmluZy5cblx0dW5yZW5kZXJEYXRlczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy50aW1lR3JpZC51bnJlbmRlckRhdGVzKCk7XG5cdFx0dGhpcy50aW1lR3JpZC5yZW1vdmVFbGVtZW50KCk7XG5cblx0XHRpZiAodGhpcy5kYXlHcmlkKSB7XG5cdFx0XHR0aGlzLmRheUdyaWQudW5yZW5kZXJEYXRlcygpO1xuXHRcdFx0dGhpcy5kYXlHcmlkLnJlbW92ZUVsZW1lbnQoKTtcblx0XHR9XG5cblx0XHR0aGlzLnNjcm9sbGVyLmRlc3Ryb3koKTtcblx0fSxcblxuXG5cdC8vIEJ1aWxkcyB0aGUgSFRNTCBza2VsZXRvbiBmb3IgdGhlIHZpZXcuXG5cdC8vIFRoZSBkYXktZ3JpZCBhbmQgdGltZS1ncmlkIGNvbXBvbmVudHMgd2lsbCByZW5kZXIgaW5zaWRlIGNvbnRhaW5lcnMgZGVmaW5lZCBieSB0aGlzIEhUTUwuXG5cdHJlbmRlclNrZWxldG9uSHRtbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICcnICtcblx0XHRcdCc8dGFibGU+JyArXG5cdFx0XHRcdCc8dGhlYWQgY2xhc3M9XCJmYy1oZWFkXCI+JyArXG5cdFx0XHRcdFx0Jzx0cj4nICtcblx0XHRcdFx0XHRcdCc8dGQgY2xhc3M9XCJmYy1oZWFkLWNvbnRhaW5lciAnICsgdGhpcy53aWRnZXRIZWFkZXJDbGFzcyArICdcIj48L3RkPicgK1xuXHRcdFx0XHRcdCc8L3RyPicgK1xuXHRcdFx0XHQnPC90aGVhZD4nICtcblx0XHRcdFx0Jzx0Ym9keSBjbGFzcz1cImZjLWJvZHlcIj4nICtcblx0XHRcdFx0XHQnPHRyPicgK1xuXHRcdFx0XHRcdFx0Jzx0ZCBjbGFzcz1cIicgKyB0aGlzLndpZGdldENvbnRlbnRDbGFzcyArICdcIj4nICtcblx0XHRcdFx0XHRcdFx0KHRoaXMuZGF5R3JpZCA/XG5cdFx0XHRcdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCJmYy1kYXktZ3JpZFwiLz4nICtcblx0XHRcdFx0XHRcdFx0XHQnPGhyIGNsYXNzPVwiZmMtZGl2aWRlciAnICsgdGhpcy53aWRnZXRIZWFkZXJDbGFzcyArICdcIi8+JyA6XG5cdFx0XHRcdFx0XHRcdFx0Jydcblx0XHRcdFx0XHRcdFx0XHQpICtcblx0XHRcdFx0XHRcdCc8L3RkPicgK1xuXHRcdFx0XHRcdCc8L3RyPicgK1xuXHRcdFx0XHQnPC90Ym9keT4nICtcblx0XHRcdCc8L3RhYmxlPic7XG5cdH0sXG5cblxuXHQvLyBHZW5lcmF0ZXMgYW4gSFRNTCBhdHRyaWJ1dGUgc3RyaW5nIGZvciBzZXR0aW5nIHRoZSB3aWR0aCBvZiB0aGUgYXhpcywgaWYgaXQgaXMga25vd25cblx0YXhpc1N0eWxlQXR0cjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuYXhpc1dpZHRoICE9PSBudWxsKSB7XG5cdFx0XHQgcmV0dXJuICdzdHlsZT1cIndpZHRoOicgKyB0aGlzLmF4aXNXaWR0aCArICdweFwiJztcblx0XHR9XG5cdFx0cmV0dXJuICcnO1xuXHR9LFxuXG5cblx0LyogQnVzaW5lc3MgSG91cnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdHJlbmRlckJ1c2luZXNzSG91cnM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudGltZUdyaWQucmVuZGVyQnVzaW5lc3NIb3VycygpO1xuXG5cdFx0aWYgKHRoaXMuZGF5R3JpZCkge1xuXHRcdFx0dGhpcy5kYXlHcmlkLnJlbmRlckJ1c2luZXNzSG91cnMoKTtcblx0XHR9XG5cdH0sXG5cblxuXHR1bnJlbmRlckJ1c2luZXNzSG91cnM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudGltZUdyaWQudW5yZW5kZXJCdXNpbmVzc0hvdXJzKCk7XG5cblx0XHRpZiAodGhpcy5kYXlHcmlkKSB7XG5cdFx0XHR0aGlzLmRheUdyaWQudW5yZW5kZXJCdXNpbmVzc0hvdXJzKCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0LyogTm93IEluZGljYXRvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Z2V0Tm93SW5kaWNhdG9yVW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMudGltZUdyaWQuZ2V0Tm93SW5kaWNhdG9yVW5pdCgpO1xuXHR9LFxuXG5cblx0cmVuZGVyTm93SW5kaWNhdG9yOiBmdW5jdGlvbihkYXRlKSB7XG5cdFx0dGhpcy50aW1lR3JpZC5yZW5kZXJOb3dJbmRpY2F0b3IoZGF0ZSk7XG5cdH0sXG5cblxuXHR1bnJlbmRlck5vd0luZGljYXRvcjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy50aW1lR3JpZC51bnJlbmRlck5vd0luZGljYXRvcigpO1xuXHR9LFxuXG5cblx0LyogRGltZW5zaW9uc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0dXBkYXRlU2l6ZTogZnVuY3Rpb24oaXNSZXNpemUpIHtcblx0XHR0aGlzLnRpbWVHcmlkLnVwZGF0ZVNpemUoaXNSZXNpemUpO1xuXG5cdFx0Vmlldy5wcm90b3R5cGUudXBkYXRlU2l6ZS5jYWxsKHRoaXMsIGlzUmVzaXplKTsgLy8gY2FsbCB0aGUgc3VwZXItbWV0aG9kXG5cdH0sXG5cblxuXHQvLyBSZWZyZXNoZXMgdGhlIGhvcml6b250YWwgZGltZW5zaW9ucyBvZiB0aGUgdmlld1xuXHR1cGRhdGVXaWR0aDogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gbWFrZSBhbGwgYXhpcyBjZWxscyBsaW5lIHVwLCBhbmQgcmVjb3JkIHRoZSB3aWR0aCBzbyBuZXdseSBjcmVhdGVkIGF4aXMgY2VsbHMgd2lsbCBoYXZlIGl0XG5cdFx0dGhpcy5heGlzV2lkdGggPSBtYXRjaENlbGxXaWR0aHModGhpcy5lbC5maW5kKCcuZmMtYXhpcycpKTtcblx0fSxcblxuXG5cdC8vIEFkanVzdHMgdGhlIHZlcnRpY2FsIGRpbWVuc2lvbnMgb2YgdGhlIHZpZXcgdG8gdGhlIHNwZWNpZmllZCB2YWx1ZXNcblx0c2V0SGVpZ2h0OiBmdW5jdGlvbih0b3RhbEhlaWdodCwgaXNBdXRvKSB7XG5cdFx0dmFyIGV2ZW50TGltaXQ7XG5cdFx0dmFyIHNjcm9sbGVySGVpZ2h0O1xuXHRcdHZhciBzY3JvbGxiYXJXaWR0aHM7XG5cblx0XHQvLyByZXNldCBhbGwgZGltZW5zaW9ucyBiYWNrIHRvIHRoZSBvcmlnaW5hbCBzdGF0ZVxuXHRcdHRoaXMuYm90dG9tUnVsZUVsLmhpZGUoKTsgLy8gLnNob3coKSB3aWxsIGJlIGNhbGxlZCBsYXRlciBpZiB0aGlzIDxocj4gaXMgbmVjZXNzYXJ5XG5cdFx0dGhpcy5zY3JvbGxlci5jbGVhcigpOyAvLyBzZXRzIGhlaWdodCB0byAnYXV0bycgYW5kIGNsZWFycyBvdmVyZmxvd1xuXHRcdHVuY29tcGVuc2F0ZVNjcm9sbCh0aGlzLm5vU2Nyb2xsUm93RWxzKTtcblxuXHRcdC8vIGxpbWl0IG51bWJlciBvZiBldmVudHMgaW4gdGhlIGFsbC1kYXkgYXJlYVxuXHRcdGlmICh0aGlzLmRheUdyaWQpIHtcblx0XHRcdHRoaXMuZGF5R3JpZC5yZW1vdmVTZWdQb3BvdmVyKCk7IC8vIGtpbGwgdGhlIFwibW9yZVwiIHBvcG92ZXIgaWYgZGlzcGxheWVkXG5cblx0XHRcdGV2ZW50TGltaXQgPSB0aGlzLm9wdCgnZXZlbnRMaW1pdCcpO1xuXHRcdFx0aWYgKGV2ZW50TGltaXQgJiYgdHlwZW9mIGV2ZW50TGltaXQgIT09ICdudW1iZXInKSB7XG5cdFx0XHRcdGV2ZW50TGltaXQgPSBBR0VOREFfQUxMX0RBWV9FVkVOVF9MSU1JVDsgLy8gbWFrZSBzdXJlIFwiYXV0b1wiIGdvZXMgdG8gYSByZWFsIG51bWJlclxuXHRcdFx0fVxuXHRcdFx0aWYgKGV2ZW50TGltaXQpIHtcblx0XHRcdFx0dGhpcy5kYXlHcmlkLmxpbWl0Um93cyhldmVudExpbWl0KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIWlzQXV0bykgeyAvLyBzaG91bGQgd2UgZm9yY2UgZGltZW5zaW9ucyBvZiB0aGUgc2Nyb2xsIGNvbnRhaW5lcj9cblxuXHRcdFx0c2Nyb2xsZXJIZWlnaHQgPSB0aGlzLmNvbXB1dGVTY3JvbGxlckhlaWdodCh0b3RhbEhlaWdodCk7XG5cdFx0XHR0aGlzLnNjcm9sbGVyLnNldEhlaWdodChzY3JvbGxlckhlaWdodCk7XG5cdFx0XHRzY3JvbGxiYXJXaWR0aHMgPSB0aGlzLnNjcm9sbGVyLmdldFNjcm9sbGJhcldpZHRocygpO1xuXG5cdFx0XHRpZiAoc2Nyb2xsYmFyV2lkdGhzLmxlZnQgfHwgc2Nyb2xsYmFyV2lkdGhzLnJpZ2h0KSB7IC8vIHVzaW5nIHNjcm9sbGJhcnM/XG5cblx0XHRcdFx0Ly8gbWFrZSB0aGUgYWxsLWRheSBhbmQgaGVhZGVyIHJvd3MgbGluZXMgdXBcblx0XHRcdFx0Y29tcGVuc2F0ZVNjcm9sbCh0aGlzLm5vU2Nyb2xsUm93RWxzLCBzY3JvbGxiYXJXaWR0aHMpO1xuXG5cdFx0XHRcdC8vIHRoZSBzY3JvbGxiYXIgY29tcGVuc2F0aW9uIG1pZ2h0IGhhdmUgY2hhbmdlZCB0ZXh0IGZsb3csIHdoaWNoIG1pZ2h0IGFmZmVjdCBoZWlnaHQsIHNvIHJlY2FsY3VsYXRlXG5cdFx0XHRcdC8vIGFuZCByZWFwcGx5IHRoZSBkZXNpcmVkIGhlaWdodCB0byB0aGUgc2Nyb2xsZXIuXG5cdFx0XHRcdHNjcm9sbGVySGVpZ2h0ID0gdGhpcy5jb21wdXRlU2Nyb2xsZXJIZWlnaHQodG90YWxIZWlnaHQpO1xuXHRcdFx0XHR0aGlzLnNjcm9sbGVyLnNldEhlaWdodChzY3JvbGxlckhlaWdodCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGd1YXJhbnRlZXMgdGhlIHNhbWUgc2Nyb2xsYmFyIHdpZHRoc1xuXHRcdFx0dGhpcy5zY3JvbGxlci5sb2NrT3ZlcmZsb3coc2Nyb2xsYmFyV2lkdGhzKTtcblxuXHRcdFx0Ly8gaWYgdGhlcmUncyBhbnkgc3BhY2UgYmVsb3cgdGhlIHNsYXRzLCBzaG93IHRoZSBob3Jpem9udGFsIHJ1bGUuXG5cdFx0XHQvLyB0aGlzIHdvbid0IGNhdXNlIGFueSBuZXcgb3ZlcmZsb3csIGJlY2F1c2UgbG9ja092ZXJmbG93IGFscmVhZHkgY2FsbGVkLlxuXHRcdFx0aWYgKHRoaXMudGltZUdyaWQuZ2V0VG90YWxTbGF0SGVpZ2h0KCkgPCBzY3JvbGxlckhlaWdodCkge1xuXHRcdFx0XHR0aGlzLmJvdHRvbVJ1bGVFbC5zaG93KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cblx0Ly8gZ2l2ZW4gYSBkZXNpcmVkIHRvdGFsIGhlaWdodCBvZiB0aGUgdmlldywgcmV0dXJucyB3aGF0IHRoZSBoZWlnaHQgb2YgdGhlIHNjcm9sbGVyIHNob3VsZCBiZVxuXHRjb21wdXRlU2Nyb2xsZXJIZWlnaHQ6IGZ1bmN0aW9uKHRvdGFsSGVpZ2h0KSB7XG5cdFx0cmV0dXJuIHRvdGFsSGVpZ2h0IC1cblx0XHRcdHN1YnRyYWN0SW5uZXJFbEhlaWdodCh0aGlzLmVsLCB0aGlzLnNjcm9sbGVyLmVsKTsgLy8gZXZlcnl0aGluZyB0aGF0J3MgTk9UIHRoZSBzY3JvbGxlclxuXHR9LFxuXG5cblx0LyogU2Nyb2xsXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBDb21wdXRlcyB0aGUgaW5pdGlhbCBwcmUtY29uZmlndXJlZCBzY3JvbGwgc3RhdGUgcHJpb3IgdG8gYWxsb3dpbmcgdGhlIHVzZXIgdG8gY2hhbmdlIGl0XG5cdGNvbXB1dGVJbml0aWFsU2Nyb2xsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2Nyb2xsVGltZSA9IG1vbWVudC5kdXJhdGlvbih0aGlzLm9wdCgnc2Nyb2xsVGltZScpKTtcblx0XHR2YXIgdG9wID0gdGhpcy50aW1lR3JpZC5jb21wdXRlVGltZVRvcChzY3JvbGxUaW1lKTtcblxuXHRcdC8vIHpvb20gY2FuIGdpdmUgd2VpcmQgZmxvYXRpbmctcG9pbnQgdmFsdWVzLiByYXRoZXIgc2Nyb2xsIGEgbGl0dGxlIGJpdCBmdXJ0aGVyXG5cdFx0dG9wID0gTWF0aC5jZWlsKHRvcCk7XG5cblx0XHRpZiAodG9wKSB7XG5cdFx0XHR0b3ArKzsgLy8gdG8gb3ZlcmNvbWUgdG9wIGJvcmRlciB0aGF0IHNsb3RzIGJleW9uZCB0aGUgZmlyc3QgaGF2ZS4gbG9va3MgYmV0dGVyXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRvcDtcblx0fSxcblxuXG5cdHF1ZXJ5U2Nyb2xsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5zY3JvbGxlci5nZXRTY3JvbGxUb3AoKTtcblx0fSxcblxuXG5cdHNldFNjcm9sbDogZnVuY3Rpb24odG9wKSB7XG5cdFx0dGhpcy5zY3JvbGxlci5zZXRTY3JvbGxUb3AodG9wKTtcblx0fSxcblxuXG5cdC8qIEhpdCBBcmVhc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHQvLyBmb3J3YXJkIGFsbCBoaXQtcmVsYXRlZCBtZXRob2QgY2FsbHMgdG8gdGhlIGdyaWRzIChkYXlHcmlkIG1pZ2h0IG5vdCBiZSBkZWZpbmVkKVxuXG5cblx0cHJlcGFyZUhpdHM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudGltZUdyaWQucHJlcGFyZUhpdHMoKTtcblx0XHRpZiAodGhpcy5kYXlHcmlkKSB7XG5cdFx0XHR0aGlzLmRheUdyaWQucHJlcGFyZUhpdHMoKTtcblx0XHR9XG5cdH0sXG5cblxuXHRyZWxlYXNlSGl0czogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy50aW1lR3JpZC5yZWxlYXNlSGl0cygpO1xuXHRcdGlmICh0aGlzLmRheUdyaWQpIHtcblx0XHRcdHRoaXMuZGF5R3JpZC5yZWxlYXNlSGl0cygpO1xuXHRcdH1cblx0fSxcblxuXG5cdHF1ZXJ5SGl0OiBmdW5jdGlvbihsZWZ0LCB0b3ApIHtcblx0XHR2YXIgaGl0ID0gdGhpcy50aW1lR3JpZC5xdWVyeUhpdChsZWZ0LCB0b3ApO1xuXG5cdFx0aWYgKCFoaXQgJiYgdGhpcy5kYXlHcmlkKSB7XG5cdFx0XHRoaXQgPSB0aGlzLmRheUdyaWQucXVlcnlIaXQobGVmdCwgdG9wKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaGl0O1xuXHR9LFxuXG5cblx0Z2V0SGl0U3BhbjogZnVuY3Rpb24oaGl0KSB7XG5cdFx0Ly8gVE9ETzogaGl0LmNvbXBvbmVudCBpcyBzZXQgYXMgYSBoYWNrIHRvIGlkZW50aWZ5IHdoZXJlIHRoZSBoaXQgY2FtZSBmcm9tXG5cdFx0cmV0dXJuIGhpdC5jb21wb25lbnQuZ2V0SGl0U3BhbihoaXQpO1xuXHR9LFxuXG5cblx0Z2V0SGl0RWw6IGZ1bmN0aW9uKGhpdCkge1xuXHRcdC8vIFRPRE86IGhpdC5jb21wb25lbnQgaXMgc2V0IGFzIGEgaGFjayB0byBpZGVudGlmeSB3aGVyZSB0aGUgaGl0IGNhbWUgZnJvbVxuXHRcdHJldHVybiBoaXQuY29tcG9uZW50LmdldEhpdEVsKGhpdCk7XG5cdH0sXG5cblxuXHQvKiBFdmVudHNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cdC8vIFJlbmRlcnMgZXZlbnRzIG9udG8gdGhlIHZpZXcgYW5kIHBvcHVsYXRlcyB0aGUgVmlldydzIHNlZ21lbnQgYXJyYXlcblx0cmVuZGVyRXZlbnRzOiBmdW5jdGlvbihldmVudHMpIHtcblx0XHR2YXIgZGF5RXZlbnRzID0gW107XG5cdFx0dmFyIHRpbWVkRXZlbnRzID0gW107XG5cdFx0dmFyIGRheVNlZ3MgPSBbXTtcblx0XHR2YXIgdGltZWRTZWdzO1xuXHRcdHZhciBpO1xuXG5cdFx0Ly8gc2VwYXJhdGUgdGhlIGV2ZW50cyBpbnRvIGFsbC1kYXkgYW5kIHRpbWVkXG5cdFx0Zm9yIChpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKGV2ZW50c1tpXS5hbGxEYXkpIHtcblx0XHRcdFx0ZGF5RXZlbnRzLnB1c2goZXZlbnRzW2ldKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0aW1lZEV2ZW50cy5wdXNoKGV2ZW50c1tpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gcmVuZGVyIHRoZSBldmVudHMgaW4gdGhlIHN1YmNvbXBvbmVudHNcblx0XHR0aW1lZFNlZ3MgPSB0aGlzLnRpbWVHcmlkLnJlbmRlckV2ZW50cyh0aW1lZEV2ZW50cyk7XG5cdFx0aWYgKHRoaXMuZGF5R3JpZCkge1xuXHRcdFx0ZGF5U2VncyA9IHRoaXMuZGF5R3JpZC5yZW5kZXJFdmVudHMoZGF5RXZlbnRzKTtcblx0XHR9XG5cblx0XHQvLyB0aGUgYWxsLWRheSBhcmVhIGlzIGZsZXhpYmxlIGFuZCBtaWdodCBoYXZlIGEgbG90IG9mIGV2ZW50cywgc28gc2hpZnQgdGhlIGhlaWdodFxuXHRcdHRoaXMudXBkYXRlSGVpZ2h0KCk7XG5cdH0sXG5cblxuXHQvLyBSZXRyaWV2ZXMgYWxsIHNlZ21lbnQgb2JqZWN0cyB0aGF0IGFyZSByZW5kZXJlZCBpbiB0aGUgdmlld1xuXHRnZXRFdmVudFNlZ3M6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnRpbWVHcmlkLmdldEV2ZW50U2VncygpLmNvbmNhdChcblx0XHRcdHRoaXMuZGF5R3JpZCA/IHRoaXMuZGF5R3JpZC5nZXRFdmVudFNlZ3MoKSA6IFtdXG5cdFx0KTtcblx0fSxcblxuXG5cdC8vIFVucmVuZGVycyBhbGwgZXZlbnQgZWxlbWVudHMgYW5kIGNsZWFycyBpbnRlcm5hbCBzZWdtZW50IGRhdGFcblx0dW5yZW5kZXJFdmVudHM6IGZ1bmN0aW9uKCkge1xuXG5cdFx0Ly8gdW5yZW5kZXIgdGhlIGV2ZW50cyBpbiB0aGUgc3ViY29tcG9uZW50c1xuXHRcdHRoaXMudGltZUdyaWQudW5yZW5kZXJFdmVudHMoKTtcblx0XHRpZiAodGhpcy5kYXlHcmlkKSB7XG5cdFx0XHR0aGlzLmRheUdyaWQudW5yZW5kZXJFdmVudHMoKTtcblx0XHR9XG5cblx0XHQvLyB3ZSBET04nVCBuZWVkIHRvIGNhbGwgdXBkYXRlSGVpZ2h0KCkgYmVjYXVzZVxuXHRcdC8vIGEgcmVuZGVyRXZlbnRzKCkgY2FsbCBhbHdheXMgaGFwcGVucyBhZnRlciB0aGlzLCB3aGljaCB3aWxsIGV2ZW50dWFsbHkgY2FsbCB1cGRhdGVIZWlnaHQoKVxuXHR9LFxuXG5cblx0LyogRHJhZ2dpbmcgKGZvciBldmVudHMgYW5kIGV4dGVybmFsIGVsZW1lbnRzKVxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblx0Ly8gQSByZXR1cm5lZCB2YWx1ZSBvZiBgdHJ1ZWAgc2lnbmFscyB0aGF0IGEgbW9jayBcImhlbHBlclwiIGV2ZW50IGhhcyBiZWVuIHJlbmRlcmVkLlxuXHRyZW5kZXJEcmFnOiBmdW5jdGlvbihkcm9wTG9jYXRpb24sIHNlZykge1xuXHRcdGlmIChkcm9wTG9jYXRpb24uc3RhcnQuaGFzVGltZSgpKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy50aW1lR3JpZC5yZW5kZXJEcmFnKGRyb3BMb2NhdGlvbiwgc2VnKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAodGhpcy5kYXlHcmlkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5kYXlHcmlkLnJlbmRlckRyYWcoZHJvcExvY2F0aW9uLCBzZWcpO1xuXHRcdH1cblx0fSxcblxuXG5cdHVucmVuZGVyRHJhZzogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy50aW1lR3JpZC51bnJlbmRlckRyYWcoKTtcblx0XHRpZiAodGhpcy5kYXlHcmlkKSB7XG5cdFx0XHR0aGlzLmRheUdyaWQudW5yZW5kZXJEcmFnKCk7XG5cdFx0fVxuXHR9LFxuXG5cblx0LyogU2VsZWN0aW9uXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXHQvLyBSZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgYSBzZWxlY3Rpb25cblx0cmVuZGVyU2VsZWN0aW9uOiBmdW5jdGlvbihzcGFuKSB7XG5cdFx0aWYgKHNwYW4uc3RhcnQuaGFzVGltZSgpIHx8IHNwYW4uZW5kLmhhc1RpbWUoKSkge1xuXHRcdFx0dGhpcy50aW1lR3JpZC5yZW5kZXJTZWxlY3Rpb24oc3Bhbik7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHRoaXMuZGF5R3JpZCkge1xuXHRcdFx0dGhpcy5kYXlHcmlkLnJlbmRlclNlbGVjdGlvbihzcGFuKTtcblx0XHR9XG5cdH0sXG5cblxuXHQvLyBVbnJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbnMgb2YgYSBzZWxlY3Rpb25cblx0dW5yZW5kZXJTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudGltZUdyaWQudW5yZW5kZXJTZWxlY3Rpb24oKTtcblx0XHRpZiAodGhpcy5kYXlHcmlkKSB7XG5cdFx0XHR0aGlzLmRheUdyaWQudW5yZW5kZXJTZWxlY3Rpb24oKTtcblx0XHR9XG5cdH1cblxufSk7XG5cblxuLy8gTWV0aG9kcyB0aGF0IHdpbGwgY3VzdG9taXplIHRoZSByZW5kZXJpbmcgYmVoYXZpb3Igb2YgdGhlIEFnZW5kYVZpZXcncyB0aW1lR3JpZFxuLy8gVE9ETzogbW92ZSBpbnRvIFRpbWVHcmlkXG52YXIgYWdlbmRhVGltZUdyaWRNZXRob2RzID0ge1xuXG5cblx0Ly8gR2VuZXJhdGVzIHRoZSBIVE1MIHRoYXQgd2lsbCBnbyBiZWZvcmUgdGhlIGRheS1vZiB3ZWVrIGhlYWRlciBjZWxsc1xuXHRyZW5kZXJIZWFkSW50cm9IdG1sOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblx0XHR2YXIgd2Vla1RleHQ7XG5cblx0XHRpZiAodmlldy5vcHQoJ3dlZWtOdW1iZXJzJykpIHtcblx0XHRcdHdlZWtUZXh0ID0gdGhpcy5zdGFydC5mb3JtYXQodmlldy5vcHQoJ3NtYWxsV2Vla0Zvcm1hdCcpKTtcblxuXHRcdFx0cmV0dXJuICcnICtcblx0XHRcdFx0Jzx0aCBjbGFzcz1cImZjLWF4aXMgZmMtd2Vlay1udW1iZXIgJyArIHZpZXcud2lkZ2V0SGVhZGVyQ2xhc3MgKyAnXCIgJyArIHZpZXcuYXhpc1N0eWxlQXR0cigpICsgJz4nICtcblx0XHRcdFx0XHR2aWV3LmJ1aWxkR290b0FuY2hvckh0bWwoIC8vIGFzaWRlIGZyb20gbGluaywgaW1wb3J0YW50IGZvciBtYXRjaENlbGxXaWR0aHNcblx0XHRcdFx0XHRcdHsgZGF0ZTogdGhpcy5zdGFydCwgdHlwZTogJ3dlZWsnLCBmb3JjZU9mZjogdGhpcy5jb2xDbnQgPiAxIH0sXG5cdFx0XHRcdFx0XHRodG1sRXNjYXBlKHdlZWtUZXh0KSAvLyBpbm5lciBIVE1MXG5cdFx0XHRcdFx0KSArXG5cdFx0XHRcdCc8L3RoPic7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmV0dXJuICc8dGggY2xhc3M9XCJmYy1heGlzICcgKyB2aWV3LndpZGdldEhlYWRlckNsYXNzICsgJ1wiICcgKyB2aWV3LmF4aXNTdHlsZUF0dHIoKSArICc+PC90aD4nO1xuXHRcdH1cblx0fSxcblxuXG5cdC8vIEdlbmVyYXRlcyB0aGUgSFRNTCB0aGF0IGdvZXMgYmVmb3JlIHRoZSBiZyBvZiB0aGUgVGltZUdyaWQgc2xvdCBhcmVhLiBMb25nIHZlcnRpY2FsIGNvbHVtbi5cblx0cmVuZGVyQmdJbnRyb0h0bWw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXG5cdFx0cmV0dXJuICc8dGQgY2xhc3M9XCJmYy1heGlzICcgKyB2aWV3LndpZGdldENvbnRlbnRDbGFzcyArICdcIiAnICsgdmlldy5heGlzU3R5bGVBdHRyKCkgKyAnPjwvdGQ+Jztcblx0fSxcblxuXG5cdC8vIEdlbmVyYXRlcyB0aGUgSFRNTCB0aGF0IGdvZXMgYmVmb3JlIGFsbCBvdGhlciB0eXBlcyBvZiBjZWxscy5cblx0Ly8gQWZmZWN0cyBjb250ZW50LXNrZWxldG9uLCBoZWxwZXItc2tlbGV0b24sIGhpZ2hsaWdodC1za2VsZXRvbiBmb3IgYm90aCB0aGUgdGltZS1ncmlkIGFuZCBkYXktZ3JpZC5cblx0cmVuZGVySW50cm9IdG1sOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblxuXHRcdHJldHVybiAnPHRkIGNsYXNzPVwiZmMtYXhpc1wiICcgKyB2aWV3LmF4aXNTdHlsZUF0dHIoKSArICc+PC90ZD4nO1xuXHR9XG5cbn07XG5cblxuLy8gTWV0aG9kcyB0aGF0IHdpbGwgY3VzdG9taXplIHRoZSByZW5kZXJpbmcgYmVoYXZpb3Igb2YgdGhlIEFnZW5kYVZpZXcncyBkYXlHcmlkXG52YXIgYWdlbmRhRGF5R3JpZE1ldGhvZHMgPSB7XG5cblxuXHQvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgdGhhdCBnb2VzIGJlZm9yZSB0aGUgYWxsLWRheSBjZWxsc1xuXHRyZW5kZXJCZ0ludHJvSHRtbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cblx0XHRyZXR1cm4gJycgK1xuXHRcdFx0Jzx0ZCBjbGFzcz1cImZjLWF4aXMgJyArIHZpZXcud2lkZ2V0Q29udGVudENsYXNzICsgJ1wiICcgKyB2aWV3LmF4aXNTdHlsZUF0dHIoKSArICc+JyArXG5cdFx0XHRcdCc8c3Bhbj4nICsgLy8gbmVlZGVkIGZvciBtYXRjaENlbGxXaWR0aHNcblx0XHRcdFx0XHR2aWV3LmdldEFsbERheUh0bWwoKSArXG5cdFx0XHRcdCc8L3NwYW4+JyArXG5cdFx0XHQnPC90ZD4nO1xuXHR9LFxuXG5cblx0Ly8gR2VuZXJhdGVzIHRoZSBIVE1MIHRoYXQgZ29lcyBiZWZvcmUgYWxsIG90aGVyIHR5cGVzIG9mIGNlbGxzLlxuXHQvLyBBZmZlY3RzIGNvbnRlbnQtc2tlbGV0b24sIGhlbHBlci1za2VsZXRvbiwgaGlnaGxpZ2h0LXNrZWxldG9uIGZvciBib3RoIHRoZSB0aW1lLWdyaWQgYW5kIGRheS1ncmlkLlxuXHRyZW5kZXJJbnRyb0h0bWw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXG5cdFx0cmV0dXJuICc8dGQgY2xhc3M9XCJmYy1heGlzXCIgJyArIHZpZXcuYXhpc1N0eWxlQXR0cigpICsgJz48L3RkPic7XG5cdH1cblxufTtcblxuOztcblxudmFyIEFHRU5EQV9BTExfREFZX0VWRU5UX0xJTUlUID0gNTtcblxuLy8gcG90ZW50aWFsIG5pY2UgdmFsdWVzIGZvciB0aGUgc2xvdC1kdXJhdGlvbiBhbmQgaW50ZXJ2YWwtZHVyYXRpb25cbi8vIGZyb20gbGFyZ2VzdCB0byBzbWFsbGVzdFxudmFyIEFHRU5EQV9TVE9DS19TVUJfRFVSQVRJT05TID0gW1xuXHR7IGhvdXJzOiAxIH0sXG5cdHsgbWludXRlczogMzAgfSxcblx0eyBtaW51dGVzOiAxNSB9LFxuXHR7IHNlY29uZHM6IDMwIH0sXG5cdHsgc2Vjb25kczogMTUgfVxuXTtcblxuZmNWaWV3cy5hZ2VuZGEgPSB7XG5cdCdjbGFzcyc6IEFnZW5kYVZpZXcsXG5cdGRlZmF1bHRzOiB7XG5cdFx0YWxsRGF5U2xvdDogdHJ1ZSxcblx0XHRzbG90RHVyYXRpb246ICcwMDozMDowMCcsXG5cdFx0bWluVGltZTogJzAwOjAwOjAwJyxcblx0XHRtYXhUaW1lOiAnMjQ6MDA6MDAnLFxuXHRcdHNsb3RFdmVudE92ZXJsYXA6IHRydWUgLy8gYSBiYWQgbmFtZS4gY29uZnVzZWQgd2l0aCBvdmVybGFwL2NvbnN0cmFpbnQgc3lzdGVtXG5cdH1cbn07XG5cbmZjVmlld3MuYWdlbmRhRGF5ID0ge1xuXHR0eXBlOiAnYWdlbmRhJyxcblx0ZHVyYXRpb246IHsgZGF5czogMSB9XG59O1xuXG5mY1ZpZXdzLmFnZW5kYVdlZWsgPSB7XG5cdHR5cGU6ICdhZ2VuZGEnLFxuXHRkdXJhdGlvbjogeyB3ZWVrczogMSB9XG59O1xuOztcblxuLypcblJlc3BvbnNpYmxlIGZvciB0aGUgc2Nyb2xsZXIsIGFuZCBmb3J3YXJkaW5nIGV2ZW50LXJlbGF0ZWQgYWN0aW9ucyBpbnRvIHRoZSBcImdyaWRcIlxuKi9cbnZhciBMaXN0VmlldyA9IFZpZXcuZXh0ZW5kKHtcblxuXHRncmlkOiBudWxsLFxuXHRzY3JvbGxlcjogbnVsbCxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmdyaWQgPSBuZXcgTGlzdFZpZXdHcmlkKHRoaXMpO1xuXHRcdHRoaXMuc2Nyb2xsZXIgPSBuZXcgU2Nyb2xsZXIoe1xuXHRcdFx0b3ZlcmZsb3dYOiAnaGlkZGVuJyxcblx0XHRcdG92ZXJmbG93WTogJ2F1dG8nXG5cdFx0fSk7XG5cdH0sXG5cblx0c2V0UmFuZ2U6IGZ1bmN0aW9uKHJhbmdlKSB7XG5cdFx0Vmlldy5wcm90b3R5cGUuc2V0UmFuZ2UuY2FsbCh0aGlzLCByYW5nZSk7IC8vIHN1cGVyXG5cblx0XHR0aGlzLmdyaWQuc2V0UmFuZ2UocmFuZ2UpOyAvLyBuZWVkcyB0byBwcm9jZXNzIHJhbmdlLXJlbGF0ZWQgb3B0aW9uc1xuXHR9LFxuXG5cdHJlbmRlclNrZWxldG9uOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmVsLmFkZENsYXNzKFxuXHRcdFx0J2ZjLWxpc3QtdmlldyAnICtcblx0XHRcdHRoaXMud2lkZ2V0Q29udGVudENsYXNzXG5cdFx0KTtcblxuXHRcdHRoaXMuc2Nyb2xsZXIucmVuZGVyKCk7XG5cdFx0dGhpcy5zY3JvbGxlci5lbC5hcHBlbmRUbyh0aGlzLmVsKTtcblxuXHRcdHRoaXMuZ3JpZC5zZXRFbGVtZW50KHRoaXMuc2Nyb2xsZXIuc2Nyb2xsRWwpO1xuXHR9LFxuXG5cdHVucmVuZGVyU2tlbGV0b246IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuc2Nyb2xsZXIuZGVzdHJveSgpOyAvLyB3aWxsIHJlbW92ZSB0aGUgR3JpZCB0b29cblx0fSxcblxuXHRzZXRIZWlnaHQ6IGZ1bmN0aW9uKHRvdGFsSGVpZ2h0LCBpc0F1dG8pIHtcblx0XHR0aGlzLnNjcm9sbGVyLnNldEhlaWdodCh0aGlzLmNvbXB1dGVTY3JvbGxlckhlaWdodCh0b3RhbEhlaWdodCkpO1xuXHR9LFxuXG5cdGNvbXB1dGVTY3JvbGxlckhlaWdodDogZnVuY3Rpb24odG90YWxIZWlnaHQpIHtcblx0XHRyZXR1cm4gdG90YWxIZWlnaHQgLVxuXHRcdFx0c3VidHJhY3RJbm5lckVsSGVpZ2h0KHRoaXMuZWwsIHRoaXMuc2Nyb2xsZXIuZWwpOyAvLyBldmVyeXRoaW5nIHRoYXQncyBOT1QgdGhlIHNjcm9sbGVyXG5cdH0sXG5cblx0cmVuZGVyRXZlbnRzOiBmdW5jdGlvbihldmVudHMpIHtcblx0XHR0aGlzLmdyaWQucmVuZGVyRXZlbnRzKGV2ZW50cyk7XG5cdH0sXG5cblx0dW5yZW5kZXJFdmVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZ3JpZC51bnJlbmRlckV2ZW50cygpO1xuXHR9LFxuXG5cdGlzRXZlbnRSZXNpemFibGU6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdGlzRXZlbnREcmFnZ2FibGU6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cbn0pO1xuXG4vKlxuUmVzcG9uc2libGUgZm9yIGV2ZW50IHJlbmRlcmluZyBhbmQgdXNlci1pbnRlcmFjdGlvbi5cbkl0cyBcImVsXCIgaXMgdGhlIGlubmVyLWNvbnRlbnQgb2YgdGhlIGFib3ZlIHZpZXcncyBzY3JvbGxlci5cbiovXG52YXIgTGlzdFZpZXdHcmlkID0gR3JpZC5leHRlbmQoe1xuXG5cdHNlZ1NlbGVjdG9yOiAnLmZjLWxpc3QtaXRlbScsIC8vIHdoaWNoIGVsZW1lbnRzIGFjY2VwdCBldmVudCBhY3Rpb25zXG5cdGhhc0RheUludGVyYWN0aW9uczogZmFsc2UsIC8vIG5vIGRheSBzZWxlY3Rpb24gb3IgZGF5IGNsaWNraW5nXG5cblx0Ly8gc2xpY2VzIGJ5IGRheVxuXHRzcGFuVG9TZWdzOiBmdW5jdGlvbihzcGFuKSB7XG5cdFx0dmFyIHZpZXcgPSB0aGlzLnZpZXc7XG5cdFx0dmFyIGRheVN0YXJ0ID0gdmlldy5zdGFydC5jbG9uZSgpLnRpbWUoMCk7IC8vIHRpbWVkLCBzbyBzZWdzIGdldCB0aW1lcyFcblx0XHR2YXIgZGF5SW5kZXggPSAwO1xuXHRcdHZhciBzZWc7XG5cdFx0dmFyIHNlZ3MgPSBbXTtcblxuXHRcdHdoaWxlIChkYXlTdGFydCA8IHZpZXcuZW5kKSB7XG5cblx0XHRcdHNlZyA9IGludGVyc2VjdFJhbmdlcyhzcGFuLCB7XG5cdFx0XHRcdHN0YXJ0OiBkYXlTdGFydCxcblx0XHRcdFx0ZW5kOiBkYXlTdGFydC5jbG9uZSgpLmFkZCgxLCAnZGF5Jylcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAoc2VnKSB7XG5cdFx0XHRcdHNlZy5kYXlJbmRleCA9IGRheUluZGV4O1xuXHRcdFx0XHRzZWdzLnB1c2goc2VnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGF5U3RhcnQuYWRkKDEsICdkYXknKTtcblx0XHRcdGRheUluZGV4Kys7XG5cblx0XHRcdC8vIGRldGVjdCB3aGVuIHNwYW4gd29uJ3QgZ28gZnVsbHkgaW50byB0aGUgbmV4dCBkYXksXG5cdFx0XHQvLyBhbmQgbXV0YXRlIHRoZSBsYXRlc3Qgc2VnIHRvIHRoZSBiZSB0aGUgZW5kLlxuXHRcdFx0aWYgKFxuXHRcdFx0XHRzZWcgJiYgIXNlZy5pc0VuZCAmJiBzcGFuLmVuZC5oYXNUaW1lKCkgJiZcblx0XHRcdFx0c3Bhbi5lbmQgPCBkYXlTdGFydC5jbG9uZSgpLmFkZCh0aGlzLnZpZXcubmV4dERheVRocmVzaG9sZClcblx0XHRcdCkge1xuXHRcdFx0XHRzZWcuZW5kID0gc3Bhbi5lbmQuY2xvbmUoKTtcblx0XHRcdFx0c2VnLmlzRW5kID0gdHJ1ZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNlZ3M7XG5cdH0sXG5cblx0Ly8gbGlrZSBcIjQ6MDBhbVwiXG5cdGNvbXB1dGVFdmVudFRpbWVGb3JtYXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnZpZXcub3B0KCdtZWRpdW1UaW1lRm9ybWF0Jyk7XG5cdH0sXG5cblx0Ly8gZm9yIGV2ZW50cyB3aXRoIGEgdXJsLCB0aGUgd2hvbGUgPHRyPiBzaG91bGQgYmUgY2xpY2thYmxlLFxuXHQvLyBidXQgaXQncyBpbXBvc3NpYmxlIHRvIHdyYXAgd2l0aCBhbiA8YT4gdGFnLiBzaW11bGF0ZSB0aGlzLlxuXHRoYW5kbGVTZWdDbGljazogZnVuY3Rpb24oc2VnLCBldikge1xuXHRcdHZhciB1cmw7XG5cblx0XHRHcmlkLnByb3RvdHlwZS5oYW5kbGVTZWdDbGljay5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBzdXBlci4gbWlnaHQgcHJldmVudCB0aGUgZGVmYXVsdCBhY3Rpb25cblxuXHRcdC8vIG5vdCBjbGlja2luZyBvbiBvciB3aXRoaW4gYW4gPGE+IHdpdGggYW4gaHJlZlxuXHRcdGlmICghJChldi50YXJnZXQpLmNsb3Nlc3QoJ2FbaHJlZl0nKS5sZW5ndGgpIHtcblx0XHRcdHVybCA9IHNlZy5ldmVudC51cmw7XG5cdFx0XHRpZiAodXJsICYmICFldi5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgeyAvLyBqc0V2ZW50IG5vdCBjYW5jZWxsZWQgaW4gaGFuZGxlclxuXHRcdFx0XHR3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDsgLy8gc2ltdWxhdGUgbGluayBjbGlja1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyByZXR1cm5zIGxpc3Qgb2YgZm9yZWdyb3VuZCBzZWdzIHRoYXQgd2VyZSBhY3R1YWxseSByZW5kZXJlZFxuXHRyZW5kZXJGZ1NlZ3M6IGZ1bmN0aW9uKHNlZ3MpIHtcblx0XHRzZWdzID0gdGhpcy5yZW5kZXJGZ1NlZ0VscyhzZWdzKTsgLy8gbWlnaHQgZmlsdGVyIGF3YXkgaGlkZGVuIGV2ZW50c1xuXG5cdFx0aWYgKCFzZWdzLmxlbmd0aCkge1xuXHRcdFx0dGhpcy5yZW5kZXJFbXB0eU1lc3NhZ2UoKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR0aGlzLnJlbmRlclNlZ0xpc3Qoc2Vncyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNlZ3M7XG5cdH0sXG5cblx0cmVuZGVyRW1wdHlNZXNzYWdlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmVsLmh0bWwoXG5cdFx0XHQnPGRpdiBjbGFzcz1cImZjLWxpc3QtZW1wdHktd3JhcDJcIj4nICsgLy8gVE9ETzogdHJ5IGxlc3Mgd3JhcHNcblx0XHRcdCc8ZGl2IGNsYXNzPVwiZmMtbGlzdC1lbXB0eS13cmFwMVwiPicgK1xuXHRcdFx0JzxkaXYgY2xhc3M9XCJmYy1saXN0LWVtcHR5XCI+JyArXG5cdFx0XHRcdGh0bWxFc2NhcGUodGhpcy52aWV3Lm9wdCgnbm9FdmVudHNNZXNzYWdlJykpICtcblx0XHRcdCc8L2Rpdj4nICtcblx0XHRcdCc8L2Rpdj4nICtcblx0XHRcdCc8L2Rpdj4nXG5cdFx0KTtcblx0fSxcblxuXHQvLyByZW5kZXIgdGhlIGV2ZW50IHNlZ21lbnRzIGluIHRoZSB2aWV3XG5cdHJlbmRlclNlZ0xpc3Q6IGZ1bmN0aW9uKGFsbFNlZ3MpIHtcblx0XHR2YXIgc2Vnc0J5RGF5ID0gdGhpcy5ncm91cFNlZ3NCeURheShhbGxTZWdzKTsgLy8gc3BhcnNlIGFycmF5XG5cdFx0dmFyIGRheUluZGV4O1xuXHRcdHZhciBkYXlTZWdzO1xuXHRcdHZhciBpO1xuXHRcdHZhciB0YWJsZUVsID0gJCgnPHRhYmxlIGNsYXNzPVwiZmMtbGlzdC10YWJsZVwiPjx0Ym9keS8+PC90YWJsZT4nKTtcblx0XHR2YXIgdGJvZHlFbCA9IHRhYmxlRWwuZmluZCgndGJvZHknKTtcblxuXHRcdGZvciAoZGF5SW5kZXggPSAwOyBkYXlJbmRleCA8IHNlZ3NCeURheS5sZW5ndGg7IGRheUluZGV4KyspIHtcblx0XHRcdGRheVNlZ3MgPSBzZWdzQnlEYXlbZGF5SW5kZXhdO1xuXHRcdFx0aWYgKGRheVNlZ3MpIHsgLy8gc3BhcnNlIGFycmF5LCBzbyBtaWdodCBiZSB1bmRlZmluZWRcblxuXHRcdFx0XHQvLyBhcHBlbmQgYSBkYXkgaGVhZGVyXG5cdFx0XHRcdHRib2R5RWwuYXBwZW5kKHRoaXMuZGF5SGVhZGVySHRtbChcblx0XHRcdFx0XHR0aGlzLnZpZXcuc3RhcnQuY2xvbmUoKS5hZGQoZGF5SW5kZXgsICdkYXlzJylcblx0XHRcdFx0KSk7XG5cblx0XHRcdFx0dGhpcy5zb3J0RXZlbnRTZWdzKGRheVNlZ3MpO1xuXG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBkYXlTZWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0dGJvZHlFbC5hcHBlbmQoZGF5U2Vnc1tpXS5lbCk7IC8vIGFwcGVuZCBldmVudCByb3dcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuZWwuZW1wdHkoKS5hcHBlbmQodGFibGVFbCk7XG5cdH0sXG5cblx0Ly8gUmV0dXJucyBhIHNwYXJzZSBhcnJheSBvZiBhcnJheXMsIHNlZ3MgZ3JvdXBlZCBieSB0aGVpciBkYXlJbmRleFxuXHRncm91cFNlZ3NCeURheTogZnVuY3Rpb24oc2Vncykge1xuXHRcdHZhciBzZWdzQnlEYXkgPSBbXTsgLy8gc3BhcnNlIGFycmF5XG5cdFx0dmFyIGksIHNlZztcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRzZWcgPSBzZWdzW2ldO1xuXHRcdFx0KHNlZ3NCeURheVtzZWcuZGF5SW5kZXhdIHx8IChzZWdzQnlEYXlbc2VnLmRheUluZGV4XSA9IFtdKSlcblx0XHRcdFx0LnB1c2goc2VnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc2Vnc0J5RGF5O1xuXHR9LFxuXG5cdC8vIGdlbmVyYXRlcyB0aGUgSFRNTCBmb3IgdGhlIGRheSBoZWFkZXJzIHRoYXQgbGl2ZSBhbW9uZ3N0IHRoZSBldmVudCByb3dzXG5cdGRheUhlYWRlckh0bWw6IGZ1bmN0aW9uKGRheURhdGUpIHtcblx0XHR2YXIgdmlldyA9IHRoaXMudmlldztcblx0XHR2YXIgbWFpbkZvcm1hdCA9IHZpZXcub3B0KCdsaXN0RGF5Rm9ybWF0Jyk7XG5cdFx0dmFyIGFsdEZvcm1hdCA9IHZpZXcub3B0KCdsaXN0RGF5QWx0Rm9ybWF0Jyk7XG5cblx0XHRyZXR1cm4gJzx0ciBjbGFzcz1cImZjLWxpc3QtaGVhZGluZ1wiIGRhdGEtZGF0ZT1cIicgKyBkYXlEYXRlLmZvcm1hdCgnWVlZWS1NTS1ERCcpICsgJ1wiPicgK1xuXHRcdFx0Jzx0ZCBjbGFzcz1cIicgKyB2aWV3LndpZGdldEhlYWRlckNsYXNzICsgJ1wiIGNvbHNwYW49XCIzXCI+JyArXG5cdFx0XHRcdChtYWluRm9ybWF0ID9cblx0XHRcdFx0XHR2aWV3LmJ1aWxkR290b0FuY2hvckh0bWwoXG5cdFx0XHRcdFx0XHRkYXlEYXRlLFxuXHRcdFx0XHRcdFx0eyAnY2xhc3MnOiAnZmMtbGlzdC1oZWFkaW5nLW1haW4nIH0sXG5cdFx0XHRcdFx0XHRodG1sRXNjYXBlKGRheURhdGUuZm9ybWF0KG1haW5Gb3JtYXQpKSAvLyBpbm5lciBIVE1MXG5cdFx0XHRcdFx0KSA6XG5cdFx0XHRcdFx0JycpICtcblx0XHRcdFx0KGFsdEZvcm1hdCA/XG5cdFx0XHRcdFx0dmlldy5idWlsZEdvdG9BbmNob3JIdG1sKFxuXHRcdFx0XHRcdFx0ZGF5RGF0ZSxcblx0XHRcdFx0XHRcdHsgJ2NsYXNzJzogJ2ZjLWxpc3QtaGVhZGluZy1hbHQnIH0sXG5cdFx0XHRcdFx0XHRodG1sRXNjYXBlKGRheURhdGUuZm9ybWF0KGFsdEZvcm1hdCkpIC8vIGlubmVyIEhUTUxcblx0XHRcdFx0XHQpIDpcblx0XHRcdFx0XHQnJykgK1xuXHRcdFx0JzwvdGQ+JyArXG5cdFx0JzwvdHI+Jztcblx0fSxcblxuXHQvLyBnZW5lcmF0ZXMgdGhlIEhUTUwgZm9yIGEgc2luZ2xlIGV2ZW50IHJvd1xuXHRmZ1NlZ0h0bWw6IGZ1bmN0aW9uKHNlZykge1xuXHRcdHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXHRcdHZhciBjbGFzc2VzID0gWyAnZmMtbGlzdC1pdGVtJyBdLmNvbmNhdCh0aGlzLmdldFNlZ0N1c3RvbUNsYXNzZXMoc2VnKSk7XG5cdFx0dmFyIGJnQ29sb3IgPSB0aGlzLmdldFNlZ0JhY2tncm91bmRDb2xvcihzZWcpO1xuXHRcdHZhciBldmVudCA9IHNlZy5ldmVudDtcblx0XHR2YXIgdXJsID0gZXZlbnQudXJsO1xuXHRcdHZhciB0aW1lSHRtbDtcblxuXHRcdGlmIChldmVudC5hbGxEYXkpIHtcblx0XHRcdHRpbWVIdG1sID0gdmlldy5nZXRBbGxEYXlIdG1sKCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHZpZXcuaXNNdWx0aURheUV2ZW50KGV2ZW50KSkgeyAvLyBpZiB0aGUgZXZlbnQgYXBwZWFycyB0byBzcGFuIG1vcmUgdGhhbiBvbmUgZGF5XG5cdFx0XHRpZiAoc2VnLmlzU3RhcnQgfHwgc2VnLmlzRW5kKSB7IC8vIG91dGVyIHNlZ21lbnQgdGhhdCBwcm9iYWJseSBsYXN0cyBwYXJ0IG9mIHRoZSBkYXlcblx0XHRcdFx0dGltZUh0bWwgPSBodG1sRXNjYXBlKHRoaXMuZ2V0RXZlbnRUaW1lVGV4dChzZWcpKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgeyAvLyBpbm5lciBzZWdtZW50IHRoYXQgbGFzdHMgdGhlIHdob2xlIGRheVxuXHRcdFx0XHR0aW1lSHRtbCA9IHZpZXcuZ2V0QWxsRGF5SHRtbCgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIERpc3BsYXkgdGhlIG5vcm1hbCB0aW1lIHRleHQgZm9yIHRoZSAqZXZlbnQncyogdGltZXNcblx0XHRcdHRpbWVIdG1sID0gaHRtbEVzY2FwZSh0aGlzLmdldEV2ZW50VGltZVRleHQoZXZlbnQpKTtcblx0XHR9XG5cblx0XHRpZiAodXJsKSB7XG5cdFx0XHRjbGFzc2VzLnB1c2goJ2ZjLWhhcy11cmwnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gJzx0ciBjbGFzcz1cIicgKyBjbGFzc2VzLmpvaW4oJyAnKSArICdcIj4nICtcblx0XHRcdCh0aGlzLmRpc3BsYXlFdmVudFRpbWUgP1xuXHRcdFx0XHQnPHRkIGNsYXNzPVwiZmMtbGlzdC1pdGVtLXRpbWUgJyArIHZpZXcud2lkZ2V0Q29udGVudENsYXNzICsgJ1wiPicgK1xuXHRcdFx0XHRcdCh0aW1lSHRtbCB8fCAnJykgK1xuXHRcdFx0XHQnPC90ZD4nIDpcblx0XHRcdFx0JycpICtcblx0XHRcdCc8dGQgY2xhc3M9XCJmYy1saXN0LWl0ZW0tbWFya2VyICcgKyB2aWV3LndpZGdldENvbnRlbnRDbGFzcyArICdcIj4nICtcblx0XHRcdFx0JzxzcGFuIGNsYXNzPVwiZmMtZXZlbnQtZG90XCInICtcblx0XHRcdFx0KGJnQ29sb3IgP1xuXHRcdFx0XHRcdCcgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOicgKyBiZ0NvbG9yICsgJ1wiJyA6XG5cdFx0XHRcdFx0JycpICtcblx0XHRcdFx0Jz48L3NwYW4+JyArXG5cdFx0XHQnPC90ZD4nICtcblx0XHRcdCc8dGQgY2xhc3M9XCJmYy1saXN0LWl0ZW0tdGl0bGUgJyArIHZpZXcud2lkZ2V0Q29udGVudENsYXNzICsgJ1wiPicgK1xuXHRcdFx0XHQnPGEnICsgKHVybCA/ICcgaHJlZj1cIicgKyBodG1sRXNjYXBlKHVybCkgKyAnXCInIDogJycpICsgJz4nICtcblx0XHRcdFx0XHRodG1sRXNjYXBlKHNlZy5ldmVudC50aXRsZSB8fCAnJykgK1xuXHRcdFx0XHQnPC9hPicgK1xuXHRcdFx0JzwvdGQ+JyArXG5cdFx0JzwvdHI+Jztcblx0fVxuXG59KTtcblxuOztcblxuZmNWaWV3cy5saXN0ID0ge1xuXHQnY2xhc3MnOiBMaXN0Vmlldyxcblx0YnV0dG9uVGV4dEtleTogJ2xpc3QnLCAvLyB3aGF0IHRvIGxvb2t1cCBpbiBsb2NhbGUgZmlsZXNcblx0ZGVmYXVsdHM6IHtcblx0XHRidXR0b25UZXh0OiAnbGlzdCcsIC8vIHRleHQgdG8gZGlzcGxheSBmb3IgRW5nbGlzaFxuXHRcdGxpc3REYXlGb3JtYXQ6ICdMTCcsIC8vIGxpa2UgXCJKYW51YXJ5IDEsIDIwMTZcIlxuXHRcdG5vRXZlbnRzTWVzc2FnZTogJ05vIGV2ZW50cyB0byBkaXNwbGF5J1xuXHR9XG59O1xuXG5mY1ZpZXdzLmxpc3REYXkgPSB7XG5cdHR5cGU6ICdsaXN0Jyxcblx0ZHVyYXRpb246IHsgZGF5czogMSB9LFxuXHRkZWZhdWx0czoge1xuXHRcdGxpc3REYXlGb3JtYXQ6ICdkZGRkJyAvLyBkYXktb2Ytd2VlayBpcyBhbGwgd2UgbmVlZC4gZnVsbCBkYXRlIGlzIHByb2JhYmx5IGluIGhlYWRlclxuXHR9XG59O1xuXG5mY1ZpZXdzLmxpc3RXZWVrID0ge1xuXHR0eXBlOiAnbGlzdCcsXG5cdGR1cmF0aW9uOiB7IHdlZWtzOiAxIH0sXG5cdGRlZmF1bHRzOiB7XG5cdFx0bGlzdERheUZvcm1hdDogJ2RkZGQnLCAvLyBkYXktb2Ytd2VlayBpcyBtb3JlIGltcG9ydGFudFxuXHRcdGxpc3REYXlBbHRGb3JtYXQ6ICdMTCdcblx0fVxufTtcblxuZmNWaWV3cy5saXN0TW9udGggPSB7XG5cdHR5cGU6ICdsaXN0Jyxcblx0ZHVyYXRpb246IHsgbW9udGg6IDEgfSxcblx0ZGVmYXVsdHM6IHtcblx0XHRsaXN0RGF5QWx0Rm9ybWF0OiAnZGRkZCcgLy8gZGF5LW9mLXdlZWsgaXMgbmljZS10by1oYXZlXG5cdH1cbn07XG5cbmZjVmlld3MubGlzdFllYXIgPSB7XG5cdHR5cGU6ICdsaXN0Jyxcblx0ZHVyYXRpb246IHsgeWVhcjogMSB9LFxuXHRkZWZhdWx0czoge1xuXHRcdGxpc3REYXlBbHRGb3JtYXQ6ICdkZGRkJyAvLyBkYXktb2Ytd2VlayBpcyBuaWNlLXRvLWhhdmVcblx0fVxufTtcblxuOztcblxyXG5yZXR1cm4gRkM7IC8vIGV4cG9ydCBmb3IgTm9kZS9Db21tb25KU1xyXG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZnVsbGNhbGVuZGFyL2Rpc3QvZnVsbGNhbGVuZGFyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDczXG4vLyBtb2R1bGUgY2h1bmtzID0gNSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 1079:
/* unknown exports provided */
/*!*************************************!*\
  !*** ./~/jquery-ui/ui/draggable.js ***!
  \*************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery UI Draggable 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/draggable/\n */\n(function( factory ) {\n\tif ( true ) {\n\n\t\t// AMD. Register as an anonymous module.\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n\t\t\t__webpack_require__(/*! jquery */ 41),\n\t\t\t__webpack_require__(/*! ./core */ 736),\n\t\t\t__webpack_require__(/*! ./mouse */ 737),\n\t\t\t__webpack_require__(/*! ./widget */ 712)\n\t\t], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {\n\n\t\t// Browser globals\n\t\tfactory( jQuery );\n\t}\n}(function( $ ) {\n\n$.widget(\"ui.draggable\", $.ui.mouse, {\n\tversion: \"1.11.4\",\n\twidgetEventPrefix: \"drag\",\n\toptions: {\n\t\taddClasses: true,\n\t\tappendTo: \"parent\",\n\t\taxis: false,\n\t\tconnectToSortable: false,\n\t\tcontainment: false,\n\t\tcursor: \"auto\",\n\t\tcursorAt: false,\n\t\tgrid: false,\n\t\thandle: false,\n\t\thelper: \"original\",\n\t\tiframeFix: false,\n\t\topacity: false,\n\t\trefreshPositions: false,\n\t\trevert: false,\n\t\trevertDuration: 500,\n\t\tscope: \"default\",\n\t\tscroll: true,\n\t\tscrollSensitivity: 20,\n\t\tscrollSpeed: 20,\n\t\tsnap: false,\n\t\tsnapMode: \"both\",\n\t\tsnapTolerance: 20,\n\t\tstack: false,\n\t\tzIndex: false,\n\n\t\t// callbacks\n\t\tdrag: null,\n\t\tstart: null,\n\t\tstop: null\n\t},\n\t_create: function() {\n\n\t\tif ( this.options.helper === \"original\" ) {\n\t\t\tthis._setPositionRelative();\n\t\t}\n\t\tif (this.options.addClasses){\n\t\t\tthis.element.addClass(\"ui-draggable\");\n\t\t}\n\t\tif (this.options.disabled){\n\t\t\tthis.element.addClass(\"ui-draggable-disabled\");\n\t\t}\n\t\tthis._setHandleClassName();\n\n\t\tthis._mouseInit();\n\t},\n\n\t_setOption: function( key, value ) {\n\t\tthis._super( key, value );\n\t\tif ( key === \"handle\" ) {\n\t\t\tthis._removeHandleClassName();\n\t\t\tthis._setHandleClassName();\n\t\t}\n\t},\n\n\t_destroy: function() {\n\t\tif ( ( this.helper || this.element ).is( \".ui-draggable-dragging\" ) ) {\n\t\t\tthis.destroyOnClear = true;\n\t\t\treturn;\n\t\t}\n\t\tthis.element.removeClass( \"ui-draggable ui-draggable-dragging ui-draggable-disabled\" );\n\t\tthis._removeHandleClassName();\n\t\tthis._mouseDestroy();\n\t},\n\n\t_mouseCapture: function(event) {\n\t\tvar o = this.options;\n\n\t\tthis._blurActiveElement( event );\n\n\t\t// among others, prevent a drag on a resizable-handle\n\t\tif (this.helper || o.disabled || $(event.target).closest(\".ui-resizable-handle\").length > 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\t//Quit if we're not on a valid handle\n\t\tthis.handle = this._getHandle(event);\n\t\tif (!this.handle) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis._blockFrames( o.iframeFix === true ? \"iframe\" : o.iframeFix );\n\n\t\treturn true;\n\n\t},\n\n\t_blockFrames: function( selector ) {\n\t\tthis.iframeBlocks = this.document.find( selector ).map(function() {\n\t\t\tvar iframe = $( this );\n\n\t\t\treturn $( \"<div>\" )\n\t\t\t\t.css( \"position\", \"absolute\" )\n\t\t\t\t.appendTo( iframe.parent() )\n\t\t\t\t.outerWidth( iframe.outerWidth() )\n\t\t\t\t.outerHeight( iframe.outerHeight() )\n\t\t\t\t.offset( iframe.offset() )[ 0 ];\n\t\t});\n\t},\n\n\t_unblockFrames: function() {\n\t\tif ( this.iframeBlocks ) {\n\t\t\tthis.iframeBlocks.remove();\n\t\t\tdelete this.iframeBlocks;\n\t\t}\n\t},\n\n\t_blurActiveElement: function( event ) {\n\t\tvar document = this.document[ 0 ];\n\n\t\t// Only need to blur if the event occurred on the draggable itself, see #10527\n\t\tif ( !this.handleElement.is( event.target ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// support: IE9\n\t\t// IE9 throws an \"Unspecified error\" accessing document.activeElement from an <iframe>\n\t\ttry {\n\n\t\t\t// Support: IE9, IE10\n\t\t\t// If the <body> is blurred, IE will switch windows, see #9520\n\t\t\tif ( document.activeElement && document.activeElement.nodeName.toLowerCase() !== \"body\" ) {\n\n\t\t\t\t// Blur any element that currently has focus, see #4261\n\t\t\t\t$( document.activeElement ).blur();\n\t\t\t}\n\t\t} catch ( error ) {}\n\t},\n\n\t_mouseStart: function(event) {\n\n\t\tvar o = this.options;\n\n\t\t//Create and append the visible helper\n\t\tthis.helper = this._createHelper(event);\n\n\t\tthis.helper.addClass(\"ui-draggable-dragging\");\n\n\t\t//Cache the helper size\n\t\tthis._cacheHelperProportions();\n\n\t\t//If ddmanager is used for droppables, set the global draggable\n\t\tif ($.ui.ddmanager) {\n\t\t\t$.ui.ddmanager.current = this;\n\t\t}\n\n\t\t/*\n\t\t * - Position generation -\n\t\t * This block generates everything position related - it's the core of draggables.\n\t\t */\n\n\t\t//Cache the margins of the original element\n\t\tthis._cacheMargins();\n\n\t\t//Store the helper's css position\n\t\tthis.cssPosition = this.helper.css( \"position\" );\n\t\tthis.scrollParent = this.helper.scrollParent( true );\n\t\tthis.offsetParent = this.helper.offsetParent();\n\t\tthis.hasFixedAncestor = this.helper.parents().filter(function() {\n\t\t\t\treturn $( this ).css( \"position\" ) === \"fixed\";\n\t\t\t}).length > 0;\n\n\t\t//The element's absolute position on the page minus margins\n\t\tthis.positionAbs = this.element.offset();\n\t\tthis._refreshOffsets( event );\n\n\t\t//Generate the original position\n\t\tthis.originalPosition = this.position = this._generatePosition( event, false );\n\t\tthis.originalPageX = event.pageX;\n\t\tthis.originalPageY = event.pageY;\n\n\t\t//Adjust the mouse offset relative to the helper if \"cursorAt\" is supplied\n\t\t(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));\n\n\t\t//Set a containment if given in the options\n\t\tthis._setContainment();\n\n\t\t//Trigger event + callbacks\n\t\tif (this._trigger(\"start\", event) === false) {\n\t\t\tthis._clear();\n\t\t\treturn false;\n\t\t}\n\n\t\t//Recache the helper size\n\t\tthis._cacheHelperProportions();\n\n\t\t//Prepare the droppable offsets\n\t\tif ($.ui.ddmanager && !o.dropBehaviour) {\n\t\t\t$.ui.ddmanager.prepareOffsets(this, event);\n\t\t}\n\n\t\t// Reset helper's right/bottom css if they're set and set explicit width/height instead\n\t\t// as this prevents resizing of elements with right/bottom set (see #7772)\n\t\tthis._normalizeRightBottom();\n\n\t\tthis._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position\n\n\t\t//If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)\n\t\tif ( $.ui.ddmanager ) {\n\t\t\t$.ui.ddmanager.dragStart(this, event);\n\t\t}\n\n\t\treturn true;\n\t},\n\n\t_refreshOffsets: function( event ) {\n\t\tthis.offset = {\n\t\t\ttop: this.positionAbs.top - this.margins.top,\n\t\t\tleft: this.positionAbs.left - this.margins.left,\n\t\t\tscroll: false,\n\t\t\tparent: this._getParentOffset(),\n\t\t\trelative: this._getRelativeOffset()\n\t\t};\n\n\t\tthis.offset.click = {\n\t\t\tleft: event.pageX - this.offset.left,\n\t\t\ttop: event.pageY - this.offset.top\n\t\t};\n\t},\n\n\t_mouseDrag: function(event, noPropagation) {\n\t\t// reset any necessary cached properties (see #5009)\n\t\tif ( this.hasFixedAncestor ) {\n\t\t\tthis.offset.parent = this._getParentOffset();\n\t\t}\n\n\t\t//Compute the helpers position\n\t\tthis.position = this._generatePosition( event, true );\n\t\tthis.positionAbs = this._convertPositionTo(\"absolute\");\n\n\t\t//Call plugins and callbacks and use the resulting position if something is returned\n\t\tif (!noPropagation) {\n\t\t\tvar ui = this._uiHash();\n\t\t\tif (this._trigger(\"drag\", event, ui) === false) {\n\t\t\t\tthis._mouseUp({});\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tthis.position = ui.position;\n\t\t}\n\n\t\tthis.helper[ 0 ].style.left = this.position.left + \"px\";\n\t\tthis.helper[ 0 ].style.top = this.position.top + \"px\";\n\n\t\tif ($.ui.ddmanager) {\n\t\t\t$.ui.ddmanager.drag(this, event);\n\t\t}\n\n\t\treturn false;\n\t},\n\n\t_mouseStop: function(event) {\n\n\t\t//If we are using droppables, inform the manager about the drop\n\t\tvar that = this,\n\t\t\tdropped = false;\n\t\tif ($.ui.ddmanager && !this.options.dropBehaviour) {\n\t\t\tdropped = $.ui.ddmanager.drop(this, event);\n\t\t}\n\n\t\t//if a drop comes from outside (a sortable)\n\t\tif (this.dropped) {\n\t\t\tdropped = this.dropped;\n\t\t\tthis.dropped = false;\n\t\t}\n\n\t\tif ((this.options.revert === \"invalid\" && !dropped) || (this.options.revert === \"valid\" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {\n\t\t\t$(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {\n\t\t\t\tif (that._trigger(\"stop\", event) !== false) {\n\t\t\t\t\tthat._clear();\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tif (this._trigger(\"stop\", event) !== false) {\n\t\t\t\tthis._clear();\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t},\n\n\t_mouseUp: function( event ) {\n\t\tthis._unblockFrames();\n\n\t\t//If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)\n\t\tif ( $.ui.ddmanager ) {\n\t\t\t$.ui.ddmanager.dragStop(this, event);\n\t\t}\n\n\t\t// Only need to focus if the event occurred on the draggable itself, see #10527\n\t\tif ( this.handleElement.is( event.target ) ) {\n\t\t\t// The interaction is over; whether or not the click resulted in a drag, focus the element\n\t\t\tthis.element.focus();\n\t\t}\n\n\t\treturn $.ui.mouse.prototype._mouseUp.call(this, event);\n\t},\n\n\tcancel: function() {\n\n\t\tif (this.helper.is(\".ui-draggable-dragging\")) {\n\t\t\tthis._mouseUp({});\n\t\t} else {\n\t\t\tthis._clear();\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t_getHandle: function(event) {\n\t\treturn this.options.handle ?\n\t\t\t!!$( event.target ).closest( this.element.find( this.options.handle ) ).length :\n\t\t\ttrue;\n\t},\n\n\t_setHandleClassName: function() {\n\t\tthis.handleElement = this.options.handle ?\n\t\t\tthis.element.find( this.options.handle ) : this.element;\n\t\tthis.handleElement.addClass( \"ui-draggable-handle\" );\n\t},\n\n\t_removeHandleClassName: function() {\n\t\tthis.handleElement.removeClass( \"ui-draggable-handle\" );\n\t},\n\n\t_createHelper: function(event) {\n\n\t\tvar o = this.options,\n\t\t\thelperIsFunction = $.isFunction( o.helper ),\n\t\t\thelper = helperIsFunction ?\n\t\t\t\t$( o.helper.apply( this.element[ 0 ], [ event ] ) ) :\n\t\t\t\t( o.helper === \"clone\" ?\n\t\t\t\t\tthis.element.clone().removeAttr( \"id\" ) :\n\t\t\t\t\tthis.element );\n\n\t\tif (!helper.parents(\"body\").length) {\n\t\t\thelper.appendTo((o.appendTo === \"parent\" ? this.element[0].parentNode : o.appendTo));\n\t\t}\n\n\t\t// http://bugs.jqueryui.com/ticket/9446\n\t\t// a helper function can return the original element\n\t\t// which wouldn't have been set to relative in _create\n\t\tif ( helperIsFunction && helper[ 0 ] === this.element[ 0 ] ) {\n\t\t\tthis._setPositionRelative();\n\t\t}\n\n\t\tif (helper[0] !== this.element[0] && !(/(fixed|absolute)/).test(helper.css(\"position\"))) {\n\t\t\thelper.css(\"position\", \"absolute\");\n\t\t}\n\n\t\treturn helper;\n\n\t},\n\n\t_setPositionRelative: function() {\n\t\tif ( !( /^(?:r|a|f)/ ).test( this.element.css( \"position\" ) ) ) {\n\t\t\tthis.element[ 0 ].style.position = \"relative\";\n\t\t}\n\t},\n\n\t_adjustOffsetFromHelper: function(obj) {\n\t\tif (typeof obj === \"string\") {\n\t\t\tobj = obj.split(\" \");\n\t\t}\n\t\tif ($.isArray(obj)) {\n\t\t\tobj = { left: +obj[0], top: +obj[1] || 0 };\n\t\t}\n\t\tif (\"left\" in obj) {\n\t\t\tthis.offset.click.left = obj.left + this.margins.left;\n\t\t}\n\t\tif (\"right\" in obj) {\n\t\t\tthis.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;\n\t\t}\n\t\tif (\"top\" in obj) {\n\t\t\tthis.offset.click.top = obj.top + this.margins.top;\n\t\t}\n\t\tif (\"bottom\" in obj) {\n\t\t\tthis.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;\n\t\t}\n\t},\n\n\t_isRootNode: function( element ) {\n\t\treturn ( /(html|body)/i ).test( element.tagName ) || element === this.document[ 0 ];\n\t},\n\n\t_getParentOffset: function() {\n\n\t\t//Get the offsetParent and cache its position\n\t\tvar po = this.offsetParent.offset(),\n\t\t\tdocument = this.document[ 0 ];\n\n\t\t// This is a special case where we need to modify a offset calculated on start, since the following happened:\n\t\t// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent\n\t\t// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that\n\t\t//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag\n\t\tif (this.cssPosition === \"absolute\" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {\n\t\t\tpo.left += this.scrollParent.scrollLeft();\n\t\t\tpo.top += this.scrollParent.scrollTop();\n\t\t}\n\n\t\tif ( this._isRootNode( this.offsetParent[ 0 ] ) ) {\n\t\t\tpo = { top: 0, left: 0 };\n\t\t}\n\n\t\treturn {\n\t\t\ttop: po.top + (parseInt(this.offsetParent.css(\"borderTopWidth\"), 10) || 0),\n\t\t\tleft: po.left + (parseInt(this.offsetParent.css(\"borderLeftWidth\"), 10) || 0)\n\t\t};\n\n\t},\n\n\t_getRelativeOffset: function() {\n\t\tif ( this.cssPosition !== \"relative\" ) {\n\t\t\treturn { top: 0, left: 0 };\n\t\t}\n\n\t\tvar p = this.element.position(),\n\t\t\tscrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );\n\n\t\treturn {\n\t\t\ttop: p.top - ( parseInt(this.helper.css( \"top\" ), 10) || 0 ) + ( !scrollIsRootNode ? this.scrollParent.scrollTop() : 0 ),\n\t\t\tleft: p.left - ( parseInt(this.helper.css( \"left\" ), 10) || 0 ) + ( !scrollIsRootNode ? this.scrollParent.scrollLeft() : 0 )\n\t\t};\n\n\t},\n\n\t_cacheMargins: function() {\n\t\tthis.margins = {\n\t\t\tleft: (parseInt(this.element.css(\"marginLeft\"), 10) || 0),\n\t\t\ttop: (parseInt(this.element.css(\"marginTop\"), 10) || 0),\n\t\t\tright: (parseInt(this.element.css(\"marginRight\"), 10) || 0),\n\t\t\tbottom: (parseInt(this.element.css(\"marginBottom\"), 10) || 0)\n\t\t};\n\t},\n\n\t_cacheHelperProportions: function() {\n\t\tthis.helperProportions = {\n\t\t\twidth: this.helper.outerWidth(),\n\t\t\theight: this.helper.outerHeight()\n\t\t};\n\t},\n\n\t_setContainment: function() {\n\n\t\tvar isUserScrollable, c, ce,\n\t\t\to = this.options,\n\t\t\tdocument = this.document[ 0 ];\n\n\t\tthis.relativeContainer = null;\n\n\t\tif ( !o.containment ) {\n\t\t\tthis.containment = null;\n\t\t\treturn;\n\t\t}\n\n\t\tif ( o.containment === \"window\" ) {\n\t\t\tthis.containment = [\n\t\t\t\t$( window ).scrollLeft() - this.offset.relative.left - this.offset.parent.left,\n\t\t\t\t$( window ).scrollTop() - this.offset.relative.top - this.offset.parent.top,\n\t\t\t\t$( window ).scrollLeft() + $( window ).width() - this.helperProportions.width - this.margins.left,\n\t\t\t\t$( window ).scrollTop() + ( $( window ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top\n\t\t\t];\n\t\t\treturn;\n\t\t}\n\n\t\tif ( o.containment === \"document\") {\n\t\t\tthis.containment = [\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\t$( document ).width() - this.helperProportions.width - this.margins.left,\n\t\t\t\t( $( document ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top\n\t\t\t];\n\t\t\treturn;\n\t\t}\n\n\t\tif ( o.containment.constructor === Array ) {\n\t\t\tthis.containment = o.containment;\n\t\t\treturn;\n\t\t}\n\n\t\tif ( o.containment === \"parent\" ) {\n\t\t\to.containment = this.helper[ 0 ].parentNode;\n\t\t}\n\n\t\tc = $( o.containment );\n\t\tce = c[ 0 ];\n\n\t\tif ( !ce ) {\n\t\t\treturn;\n\t\t}\n\n\t\tisUserScrollable = /(scroll|auto)/.test( c.css( \"overflow\" ) );\n\n\t\tthis.containment = [\n\t\t\t( parseInt( c.css( \"borderLeftWidth\" ), 10 ) || 0 ) + ( parseInt( c.css( \"paddingLeft\" ), 10 ) || 0 ),\n\t\t\t( parseInt( c.css( \"borderTopWidth\" ), 10 ) || 0 ) + ( parseInt( c.css( \"paddingTop\" ), 10 ) || 0 ),\n\t\t\t( isUserScrollable ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) -\n\t\t\t\t( parseInt( c.css( \"borderRightWidth\" ), 10 ) || 0 ) -\n\t\t\t\t( parseInt( c.css( \"paddingRight\" ), 10 ) || 0 ) -\n\t\t\t\tthis.helperProportions.width -\n\t\t\t\tthis.margins.left -\n\t\t\t\tthis.margins.right,\n\t\t\t( isUserScrollable ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) -\n\t\t\t\t( parseInt( c.css( \"borderBottomWidth\" ), 10 ) || 0 ) -\n\t\t\t\t( parseInt( c.css( \"paddingBottom\" ), 10 ) || 0 ) -\n\t\t\t\tthis.helperProportions.height -\n\t\t\t\tthis.margins.top -\n\t\t\t\tthis.margins.bottom\n\t\t];\n\t\tthis.relativeContainer = c;\n\t},\n\n\t_convertPositionTo: function(d, pos) {\n\n\t\tif (!pos) {\n\t\t\tpos = this.position;\n\t\t}\n\n\t\tvar mod = d === \"absolute\" ? 1 : -1,\n\t\t\tscrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );\n\n\t\treturn {\n\t\t\ttop: (\n\t\t\t\tpos.top\t+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// The absolute mouse position\n\t\t\t\tthis.offset.relative.top * mod +\t\t\t\t\t\t\t\t\t\t// Only for relative positioned nodes: Relative offset from element to offset parent\n\t\t\t\tthis.offset.parent.top * mod -\t\t\t\t\t\t\t\t\t\t// The offsetParent's offset without borders (offset + border)\n\t\t\t\t( ( this.cssPosition === \"fixed\" ? -this.offset.scroll.top : ( scrollIsRootNode ? 0 : this.offset.scroll.top ) ) * mod)\n\t\t\t),\n\t\t\tleft: (\n\t\t\t\tpos.left +\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// The absolute mouse position\n\t\t\t\tthis.offset.relative.left * mod +\t\t\t\t\t\t\t\t\t\t// Only for relative positioned nodes: Relative offset from element to offset parent\n\t\t\t\tthis.offset.parent.left * mod\t-\t\t\t\t\t\t\t\t\t\t// The offsetParent's offset without borders (offset + border)\n\t\t\t\t( ( this.cssPosition === \"fixed\" ? -this.offset.scroll.left : ( scrollIsRootNode ? 0 : this.offset.scroll.left ) ) * mod)\n\t\t\t)\n\t\t};\n\n\t},\n\n\t_generatePosition: function( event, constrainPosition ) {\n\n\t\tvar containment, co, top, left,\n\t\t\to = this.options,\n\t\t\tscrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] ),\n\t\t\tpageX = event.pageX,\n\t\t\tpageY = event.pageY;\n\n\t\t// Cache the scroll\n\t\tif ( !scrollIsRootNode || !this.offset.scroll ) {\n\t\t\tthis.offset.scroll = {\n\t\t\t\ttop: this.scrollParent.scrollTop(),\n\t\t\t\tleft: this.scrollParent.scrollLeft()\n\t\t\t};\n\t\t}\n\n\t\t/*\n\t\t * - Position constraining -\n\t\t * Constrain the position to a mix of grid, containment.\n\t\t */\n\n\t\t// If we are not dragging yet, we won't check for options\n\t\tif ( constrainPosition ) {\n\t\t\tif ( this.containment ) {\n\t\t\t\tif ( this.relativeContainer ){\n\t\t\t\t\tco = this.relativeContainer.offset();\n\t\t\t\t\tcontainment = [\n\t\t\t\t\t\tthis.containment[ 0 ] + co.left,\n\t\t\t\t\t\tthis.containment[ 1 ] + co.top,\n\t\t\t\t\t\tthis.containment[ 2 ] + co.left,\n\t\t\t\t\t\tthis.containment[ 3 ] + co.top\n\t\t\t\t\t];\n\t\t\t\t} else {\n\t\t\t\t\tcontainment = this.containment;\n\t\t\t\t}\n\n\t\t\t\tif (event.pageX - this.offset.click.left < containment[0]) {\n\t\t\t\t\tpageX = containment[0] + this.offset.click.left;\n\t\t\t\t}\n\t\t\t\tif (event.pageY - this.offset.click.top < containment[1]) {\n\t\t\t\t\tpageY = containment[1] + this.offset.click.top;\n\t\t\t\t}\n\t\t\t\tif (event.pageX - this.offset.click.left > containment[2]) {\n\t\t\t\t\tpageX = containment[2] + this.offset.click.left;\n\t\t\t\t}\n\t\t\t\tif (event.pageY - this.offset.click.top > containment[3]) {\n\t\t\t\t\tpageY = containment[3] + this.offset.click.top;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (o.grid) {\n\t\t\t\t//Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)\n\t\t\t\ttop = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;\n\t\t\t\tpageY = containment ? ((top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3]) ? top : ((top - this.offset.click.top >= containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;\n\n\t\t\t\tleft = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;\n\t\t\t\tpageX = containment ? ((left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2]) ? left : ((left - this.offset.click.left >= containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;\n\t\t\t}\n\n\t\t\tif ( o.axis === \"y\" ) {\n\t\t\t\tpageX = this.originalPageX;\n\t\t\t}\n\n\t\t\tif ( o.axis === \"x\" ) {\n\t\t\t\tpageY = this.originalPageY;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\ttop: (\n\t\t\t\tpageY -\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// The absolute mouse position\n\t\t\t\tthis.offset.click.top\t-\t\t\t\t\t\t\t\t\t\t\t\t// Click offset (relative to the element)\n\t\t\t\tthis.offset.relative.top -\t\t\t\t\t\t\t\t\t\t\t\t// Only for relative positioned nodes: Relative offset from element to offset parent\n\t\t\t\tthis.offset.parent.top +\t\t\t\t\t\t\t\t\t\t\t\t// The offsetParent's offset without borders (offset + border)\n\t\t\t\t( this.cssPosition === \"fixed\" ? -this.offset.scroll.top : ( scrollIsRootNode ? 0 : this.offset.scroll.top ) )\n\t\t\t),\n\t\t\tleft: (\n\t\t\t\tpageX -\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// The absolute mouse position\n\t\t\t\tthis.offset.click.left -\t\t\t\t\t\t\t\t\t\t\t\t// Click offset (relative to the element)\n\t\t\t\tthis.offset.relative.left -\t\t\t\t\t\t\t\t\t\t\t\t// Only for relative positioned nodes: Relative offset from element to offset parent\n\t\t\t\tthis.offset.parent.left +\t\t\t\t\t\t\t\t\t\t\t\t// The offsetParent's offset without borders (offset + border)\n\t\t\t\t( this.cssPosition === \"fixed\" ? -this.offset.scroll.left : ( scrollIsRootNode ? 0 : this.offset.scroll.left ) )\n\t\t\t)\n\t\t};\n\n\t},\n\n\t_clear: function() {\n\t\tthis.helper.removeClass(\"ui-draggable-dragging\");\n\t\tif (this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {\n\t\t\tthis.helper.remove();\n\t\t}\n\t\tthis.helper = null;\n\t\tthis.cancelHelperRemoval = false;\n\t\tif ( this.destroyOnClear ) {\n\t\t\tthis.destroy();\n\t\t}\n\t},\n\n\t_normalizeRightBottom: function() {\n\t\tif ( this.options.axis !== \"y\" && this.helper.css( \"right\" ) !== \"auto\" ) {\n\t\t\tthis.helper.width( this.helper.width() );\n\t\t\tthis.helper.css( \"right\", \"auto\" );\n\t\t}\n\t\tif ( this.options.axis !== \"x\" && this.helper.css( \"bottom\" ) !== \"auto\" ) {\n\t\t\tthis.helper.height( this.helper.height() );\n\t\t\tthis.helper.css( \"bottom\", \"auto\" );\n\t\t}\n\t},\n\n\t// From now on bulk stuff - mainly helpers\n\n\t_trigger: function( type, event, ui ) {\n\t\tui = ui || this._uiHash();\n\t\t$.ui.plugin.call( this, type, [ event, ui, this ], true );\n\n\t\t// Absolute position and offset (see #6884 ) have to be recalculated after plugins\n\t\tif ( /^(drag|start|stop)/.test( type ) ) {\n\t\t\tthis.positionAbs = this._convertPositionTo( \"absolute\" );\n\t\t\tui.offset = this.positionAbs;\n\t\t}\n\t\treturn $.Widget.prototype._trigger.call( this, type, event, ui );\n\t},\n\n\tplugins: {},\n\n\t_uiHash: function() {\n\t\treturn {\n\t\t\thelper: this.helper,\n\t\t\tposition: this.position,\n\t\t\toriginalPosition: this.originalPosition,\n\t\t\toffset: this.positionAbs\n\t\t};\n\t}\n\n});\n\n$.ui.plugin.add( \"draggable\", \"connectToSortable\", {\n\tstart: function( event, ui, draggable ) {\n\t\tvar uiSortable = $.extend( {}, ui, {\n\t\t\titem: draggable.element\n\t\t});\n\n\t\tdraggable.sortables = [];\n\t\t$( draggable.options.connectToSortable ).each(function() {\n\t\t\tvar sortable = $( this ).sortable( \"instance\" );\n\n\t\t\tif ( sortable && !sortable.options.disabled ) {\n\t\t\t\tdraggable.sortables.push( sortable );\n\n\t\t\t\t// refreshPositions is called at drag start to refresh the containerCache\n\t\t\t\t// which is used in drag. This ensures it's initialized and synchronized\n\t\t\t\t// with any changes that might have happened on the page since initialization.\n\t\t\t\tsortable.refreshPositions();\n\t\t\t\tsortable._trigger(\"activate\", event, uiSortable);\n\t\t\t}\n\t\t});\n\t},\n\tstop: function( event, ui, draggable ) {\n\t\tvar uiSortable = $.extend( {}, ui, {\n\t\t\titem: draggable.element\n\t\t});\n\n\t\tdraggable.cancelHelperRemoval = false;\n\n\t\t$.each( draggable.sortables, function() {\n\t\t\tvar sortable = this;\n\n\t\t\tif ( sortable.isOver ) {\n\t\t\t\tsortable.isOver = 0;\n\n\t\t\t\t// Allow this sortable to handle removing the helper\n\t\t\t\tdraggable.cancelHelperRemoval = true;\n\t\t\t\tsortable.cancelHelperRemoval = false;\n\n\t\t\t\t// Use _storedCSS To restore properties in the sortable,\n\t\t\t\t// as this also handles revert (#9675) since the draggable\n\t\t\t\t// may have modified them in unexpected ways (#8809)\n\t\t\t\tsortable._storedCSS = {\n\t\t\t\t\tposition: sortable.placeholder.css( \"position\" ),\n\t\t\t\t\ttop: sortable.placeholder.css( \"top\" ),\n\t\t\t\t\tleft: sortable.placeholder.css( \"left\" )\n\t\t\t\t};\n\n\t\t\t\tsortable._mouseStop(event);\n\n\t\t\t\t// Once drag has ended, the sortable should return to using\n\t\t\t\t// its original helper, not the shared helper from draggable\n\t\t\t\tsortable.options.helper = sortable.options._helper;\n\t\t\t} else {\n\t\t\t\t// Prevent this Sortable from removing the helper.\n\t\t\t\t// However, don't set the draggable to remove the helper\n\t\t\t\t// either as another connected Sortable may yet handle the removal.\n\t\t\t\tsortable.cancelHelperRemoval = true;\n\n\t\t\t\tsortable._trigger( \"deactivate\", event, uiSortable );\n\t\t\t}\n\t\t});\n\t},\n\tdrag: function( event, ui, draggable ) {\n\t\t$.each( draggable.sortables, function() {\n\t\t\tvar innermostIntersecting = false,\n\t\t\t\tsortable = this;\n\n\t\t\t// Copy over variables that sortable's _intersectsWith uses\n\t\t\tsortable.positionAbs = draggable.positionAbs;\n\t\t\tsortable.helperProportions = draggable.helperProportions;\n\t\t\tsortable.offset.click = draggable.offset.click;\n\n\t\t\tif ( sortable._intersectsWith( sortable.containerCache ) ) {\n\t\t\t\tinnermostIntersecting = true;\n\n\t\t\t\t$.each( draggable.sortables, function() {\n\t\t\t\t\t// Copy over variables that sortable's _intersectsWith uses\n\t\t\t\t\tthis.positionAbs = draggable.positionAbs;\n\t\t\t\t\tthis.helperProportions = draggable.helperProportions;\n\t\t\t\t\tthis.offset.click = draggable.offset.click;\n\n\t\t\t\t\tif ( this !== sortable &&\n\t\t\t\t\t\t\tthis._intersectsWith( this.containerCache ) &&\n\t\t\t\t\t\t\t$.contains( sortable.element[ 0 ], this.element[ 0 ] ) ) {\n\t\t\t\t\t\tinnermostIntersecting = false;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn innermostIntersecting;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif ( innermostIntersecting ) {\n\t\t\t\t// If it intersects, we use a little isOver variable and set it once,\n\t\t\t\t// so that the move-in stuff gets fired only once.\n\t\t\t\tif ( !sortable.isOver ) {\n\t\t\t\t\tsortable.isOver = 1;\n\n\t\t\t\t\t// Store draggable's parent in case we need to reappend to it later.\n\t\t\t\t\tdraggable._parent = ui.helper.parent();\n\n\t\t\t\t\tsortable.currentItem = ui.helper\n\t\t\t\t\t\t.appendTo( sortable.element )\n\t\t\t\t\t\t.data( \"ui-sortable-item\", true );\n\n\t\t\t\t\t// Store helper option to later restore it\n\t\t\t\t\tsortable.options._helper = sortable.options.helper;\n\n\t\t\t\t\tsortable.options.helper = function() {\n\t\t\t\t\t\treturn ui.helper[ 0 ];\n\t\t\t\t\t};\n\n\t\t\t\t\t// Fire the start events of the sortable with our passed browser event,\n\t\t\t\t\t// and our own helper (so it doesn't create a new one)\n\t\t\t\t\tevent.target = sortable.currentItem[ 0 ];\n\t\t\t\t\tsortable._mouseCapture( event, true );\n\t\t\t\t\tsortable._mouseStart( event, true, true );\n\n\t\t\t\t\t// Because the browser event is way off the new appended portlet,\n\t\t\t\t\t// modify necessary variables to reflect the changes\n\t\t\t\t\tsortable.offset.click.top = draggable.offset.click.top;\n\t\t\t\t\tsortable.offset.click.left = draggable.offset.click.left;\n\t\t\t\t\tsortable.offset.parent.left -= draggable.offset.parent.left -\n\t\t\t\t\t\tsortable.offset.parent.left;\n\t\t\t\t\tsortable.offset.parent.top -= draggable.offset.parent.top -\n\t\t\t\t\t\tsortable.offset.parent.top;\n\n\t\t\t\t\tdraggable._trigger( \"toSortable\", event );\n\n\t\t\t\t\t// Inform draggable that the helper is in a valid drop zone,\n\t\t\t\t\t// used solely in the revert option to handle \"valid/invalid\".\n\t\t\t\t\tdraggable.dropped = sortable.element;\n\n\t\t\t\t\t// Need to refreshPositions of all sortables in the case that\n\t\t\t\t\t// adding to one sortable changes the location of the other sortables (#9675)\n\t\t\t\t\t$.each( draggable.sortables, function() {\n\t\t\t\t\t\tthis.refreshPositions();\n\t\t\t\t\t});\n\n\t\t\t\t\t// hack so receive/update callbacks work (mostly)\n\t\t\t\t\tdraggable.currentItem = draggable.element;\n\t\t\t\t\tsortable.fromOutside = draggable;\n\t\t\t\t}\n\n\t\t\t\tif ( sortable.currentItem ) {\n\t\t\t\t\tsortable._mouseDrag( event );\n\t\t\t\t\t// Copy the sortable's position because the draggable's can potentially reflect\n\t\t\t\t\t// a relative position, while sortable is always absolute, which the dragged\n\t\t\t\t\t// element has now become. (#8809)\n\t\t\t\t\tui.position = sortable.position;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If it doesn't intersect with the sortable, and it intersected before,\n\t\t\t\t// we fake the drag stop of the sortable, but make sure it doesn't remove\n\t\t\t\t// the helper by using cancelHelperRemoval.\n\t\t\t\tif ( sortable.isOver ) {\n\n\t\t\t\t\tsortable.isOver = 0;\n\t\t\t\t\tsortable.cancelHelperRemoval = true;\n\n\t\t\t\t\t// Calling sortable's mouseStop would trigger a revert,\n\t\t\t\t\t// so revert must be temporarily false until after mouseStop is called.\n\t\t\t\t\tsortable.options._revert = sortable.options.revert;\n\t\t\t\t\tsortable.options.revert = false;\n\n\t\t\t\t\tsortable._trigger( \"out\", event, sortable._uiHash( sortable ) );\n\t\t\t\t\tsortable._mouseStop( event, true );\n\n\t\t\t\t\t// restore sortable behaviors that were modfied\n\t\t\t\t\t// when the draggable entered the sortable area (#9481)\n\t\t\t\t\tsortable.options.revert = sortable.options._revert;\n\t\t\t\t\tsortable.options.helper = sortable.options._helper;\n\n\t\t\t\t\tif ( sortable.placeholder ) {\n\t\t\t\t\t\tsortable.placeholder.remove();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Restore and recalculate the draggable's offset considering the sortable\n\t\t\t\t\t// may have modified them in unexpected ways. (#8809, #10669)\n\t\t\t\t\tui.helper.appendTo( draggable._parent );\n\t\t\t\t\tdraggable._refreshOffsets( event );\n\t\t\t\t\tui.position = draggable._generatePosition( event, true );\n\n\t\t\t\t\tdraggable._trigger( \"fromSortable\", event );\n\n\t\t\t\t\t// Inform draggable that the helper is no longer in a valid drop zone\n\t\t\t\t\tdraggable.dropped = false;\n\n\t\t\t\t\t// Need to refreshPositions of all sortables just in case removing\n\t\t\t\t\t// from one sortable changes the location of other sortables (#9675)\n\t\t\t\t\t$.each( draggable.sortables, function() {\n\t\t\t\t\t\tthis.refreshPositions();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n});\n\n$.ui.plugin.add(\"draggable\", \"cursor\", {\n\tstart: function( event, ui, instance ) {\n\t\tvar t = $( \"body\" ),\n\t\t\to = instance.options;\n\n\t\tif (t.css(\"cursor\")) {\n\t\t\to._cursor = t.css(\"cursor\");\n\t\t}\n\t\tt.css(\"cursor\", o.cursor);\n\t},\n\tstop: function( event, ui, instance ) {\n\t\tvar o = instance.options;\n\t\tif (o._cursor) {\n\t\t\t$(\"body\").css(\"cursor\", o._cursor);\n\t\t}\n\t}\n});\n\n$.ui.plugin.add(\"draggable\", \"opacity\", {\n\tstart: function( event, ui, instance ) {\n\t\tvar t = $( ui.helper ),\n\t\t\to = instance.options;\n\t\tif (t.css(\"opacity\")) {\n\t\t\to._opacity = t.css(\"opacity\");\n\t\t}\n\t\tt.css(\"opacity\", o.opacity);\n\t},\n\tstop: function( event, ui, instance ) {\n\t\tvar o = instance.options;\n\t\tif (o._opacity) {\n\t\t\t$(ui.helper).css(\"opacity\", o._opacity);\n\t\t}\n\t}\n});\n\n$.ui.plugin.add(\"draggable\", \"scroll\", {\n\tstart: function( event, ui, i ) {\n\t\tif ( !i.scrollParentNotHidden ) {\n\t\t\ti.scrollParentNotHidden = i.helper.scrollParent( false );\n\t\t}\n\n\t\tif ( i.scrollParentNotHidden[ 0 ] !== i.document[ 0 ] && i.scrollParentNotHidden[ 0 ].tagName !== \"HTML\" ) {\n\t\t\ti.overflowOffset = i.scrollParentNotHidden.offset();\n\t\t}\n\t},\n\tdrag: function( event, ui, i  ) {\n\n\t\tvar o = i.options,\n\t\t\tscrolled = false,\n\t\t\tscrollParent = i.scrollParentNotHidden[ 0 ],\n\t\t\tdocument = i.document[ 0 ];\n\n\t\tif ( scrollParent !== document && scrollParent.tagName !== \"HTML\" ) {\n\t\t\tif ( !o.axis || o.axis !== \"x\" ) {\n\t\t\t\tif ( ( i.overflowOffset.top + scrollParent.offsetHeight ) - event.pageY < o.scrollSensitivity ) {\n\t\t\t\t\tscrollParent.scrollTop = scrolled = scrollParent.scrollTop + o.scrollSpeed;\n\t\t\t\t} else if ( event.pageY - i.overflowOffset.top < o.scrollSensitivity ) {\n\t\t\t\t\tscrollParent.scrollTop = scrolled = scrollParent.scrollTop - o.scrollSpeed;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( !o.axis || o.axis !== \"y\" ) {\n\t\t\t\tif ( ( i.overflowOffset.left + scrollParent.offsetWidth ) - event.pageX < o.scrollSensitivity ) {\n\t\t\t\t\tscrollParent.scrollLeft = scrolled = scrollParent.scrollLeft + o.scrollSpeed;\n\t\t\t\t} else if ( event.pageX - i.overflowOffset.left < o.scrollSensitivity ) {\n\t\t\t\t\tscrollParent.scrollLeft = scrolled = scrollParent.scrollLeft - o.scrollSpeed;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif (!o.axis || o.axis !== \"x\") {\n\t\t\t\tif (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {\n\t\t\t\t\tscrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);\n\t\t\t\t} else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {\n\t\t\t\t\tscrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!o.axis || o.axis !== \"y\") {\n\t\t\t\tif (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {\n\t\t\t\t\tscrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);\n\t\t\t\t} else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {\n\t\t\t\t\tscrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tif (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {\n\t\t\t$.ui.ddmanager.prepareOffsets(i, event);\n\t\t}\n\n\t}\n});\n\n$.ui.plugin.add(\"draggable\", \"snap\", {\n\tstart: function( event, ui, i ) {\n\n\t\tvar o = i.options;\n\n\t\ti.snapElements = [];\n\n\t\t$(o.snap.constructor !== String ? ( o.snap.items || \":data(ui-draggable)\" ) : o.snap).each(function() {\n\t\t\tvar $t = $(this),\n\t\t\t\t$o = $t.offset();\n\t\t\tif (this !== i.element[0]) {\n\t\t\t\ti.snapElements.push({\n\t\t\t\t\titem: this,\n\t\t\t\t\twidth: $t.outerWidth(), height: $t.outerHeight(),\n\t\t\t\t\ttop: $o.top, left: $o.left\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t},\n\tdrag: function( event, ui, inst ) {\n\n\t\tvar ts, bs, ls, rs, l, r, t, b, i, first,\n\t\t\to = inst.options,\n\t\t\td = o.snapTolerance,\n\t\t\tx1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,\n\t\t\ty1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;\n\n\t\tfor (i = inst.snapElements.length - 1; i >= 0; i--){\n\n\t\t\tl = inst.snapElements[i].left - inst.margins.left;\n\t\t\tr = l + inst.snapElements[i].width;\n\t\t\tt = inst.snapElements[i].top - inst.margins.top;\n\t\t\tb = t + inst.snapElements[i].height;\n\n\t\t\tif ( x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains( inst.snapElements[ i ].item.ownerDocument, inst.snapElements[ i ].item ) ) {\n\t\t\t\tif (inst.snapElements[i].snapping) {\n\t\t\t\t\t(inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));\n\t\t\t\t}\n\t\t\t\tinst.snapElements[i].snapping = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (o.snapMode !== \"inner\") {\n\t\t\t\tts = Math.abs(t - y2) <= d;\n\t\t\t\tbs = Math.abs(b - y1) <= d;\n\t\t\t\tls = Math.abs(l - x2) <= d;\n\t\t\t\trs = Math.abs(r - x1) <= d;\n\t\t\t\tif (ts) {\n\t\t\t\t\tui.position.top = inst._convertPositionTo(\"relative\", { top: t - inst.helperProportions.height, left: 0 }).top;\n\t\t\t\t}\n\t\t\t\tif (bs) {\n\t\t\t\t\tui.position.top = inst._convertPositionTo(\"relative\", { top: b, left: 0 }).top;\n\t\t\t\t}\n\t\t\t\tif (ls) {\n\t\t\t\t\tui.position.left = inst._convertPositionTo(\"relative\", { top: 0, left: l - inst.helperProportions.width }).left;\n\t\t\t\t}\n\t\t\t\tif (rs) {\n\t\t\t\t\tui.position.left = inst._convertPositionTo(\"relative\", { top: 0, left: r }).left;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfirst = (ts || bs || ls || rs);\n\n\t\t\tif (o.snapMode !== \"outer\") {\n\t\t\t\tts = Math.abs(t - y1) <= d;\n\t\t\t\tbs = Math.abs(b - y2) <= d;\n\t\t\t\tls = Math.abs(l - x1) <= d;\n\t\t\t\trs = Math.abs(r - x2) <= d;\n\t\t\t\tif (ts) {\n\t\t\t\t\tui.position.top = inst._convertPositionTo(\"relative\", { top: t, left: 0 }).top;\n\t\t\t\t}\n\t\t\t\tif (bs) {\n\t\t\t\t\tui.position.top = inst._convertPositionTo(\"relative\", { top: b - inst.helperProportions.height, left: 0 }).top;\n\t\t\t\t}\n\t\t\t\tif (ls) {\n\t\t\t\t\tui.position.left = inst._convertPositionTo(\"relative\", { top: 0, left: l }).left;\n\t\t\t\t}\n\t\t\t\tif (rs) {\n\t\t\t\t\tui.position.left = inst._convertPositionTo(\"relative\", { top: 0, left: r - inst.helperProportions.width }).left;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {\n\t\t\t\t(inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));\n\t\t\t}\n\t\t\tinst.snapElements[i].snapping = (ts || bs || ls || rs || first);\n\n\t\t}\n\n\t}\n});\n\n$.ui.plugin.add(\"draggable\", \"stack\", {\n\tstart: function( event, ui, instance ) {\n\t\tvar min,\n\t\t\to = instance.options,\n\t\t\tgroup = $.makeArray($(o.stack)).sort(function(a, b) {\n\t\t\t\treturn (parseInt($(a).css(\"zIndex\"), 10) || 0) - (parseInt($(b).css(\"zIndex\"), 10) || 0);\n\t\t\t});\n\n\t\tif (!group.length) { return; }\n\n\t\tmin = parseInt($(group[0]).css(\"zIndex\"), 10) || 0;\n\t\t$(group).each(function(i) {\n\t\t\t$(this).css(\"zIndex\", min + i);\n\t\t});\n\t\tthis.css(\"zIndex\", (min + group.length));\n\t}\n});\n\n$.ui.plugin.add(\"draggable\", \"zIndex\", {\n\tstart: function( event, ui, instance ) {\n\t\tvar t = $( ui.helper ),\n\t\t\to = instance.options;\n\n\t\tif (t.css(\"zIndex\")) {\n\t\t\to._zIndex = t.css(\"zIndex\");\n\t\t}\n\t\tt.css(\"zIndex\", o.zIndex);\n\t},\n\tstop: function( event, ui, instance ) {\n\t\tvar o = instance.options;\n\n\t\tif (o._zIndex) {\n\t\t\t$(ui.helper).css(\"zIndex\", o._zIndex);\n\t\t}\n\t}\n});\n\nreturn $.ui.draggable;\n\n}));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA3OS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vanF1ZXJ5LXVpL3VpL2RyYWdnYWJsZS5qcz8xYTc3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogalF1ZXJ5IFVJIERyYWdnYWJsZSAxLjExLjRcbiAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL2RyYWdnYWJsZS9cbiAqL1xuKGZ1bmN0aW9uKCBmYWN0b3J5ICkge1xuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXG5cdFx0Ly8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuXHRcdGRlZmluZShbXG5cdFx0XHRcImpxdWVyeVwiLFxuXHRcdFx0XCIuL2NvcmVcIixcblx0XHRcdFwiLi9tb3VzZVwiLFxuXHRcdFx0XCIuL3dpZGdldFwiXG5cdFx0XSwgZmFjdG9yeSApO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gQnJvd3NlciBnbG9iYWxzXG5cdFx0ZmFjdG9yeSggalF1ZXJ5ICk7XG5cdH1cbn0oZnVuY3Rpb24oICQgKSB7XG5cbiQud2lkZ2V0KFwidWkuZHJhZ2dhYmxlXCIsICQudWkubW91c2UsIHtcblx0dmVyc2lvbjogXCIxLjExLjRcIixcblx0d2lkZ2V0RXZlbnRQcmVmaXg6IFwiZHJhZ1wiLFxuXHRvcHRpb25zOiB7XG5cdFx0YWRkQ2xhc3NlczogdHJ1ZSxcblx0XHRhcHBlbmRUbzogXCJwYXJlbnRcIixcblx0XHRheGlzOiBmYWxzZSxcblx0XHRjb25uZWN0VG9Tb3J0YWJsZTogZmFsc2UsXG5cdFx0Y29udGFpbm1lbnQ6IGZhbHNlLFxuXHRcdGN1cnNvcjogXCJhdXRvXCIsXG5cdFx0Y3Vyc29yQXQ6IGZhbHNlLFxuXHRcdGdyaWQ6IGZhbHNlLFxuXHRcdGhhbmRsZTogZmFsc2UsXG5cdFx0aGVscGVyOiBcIm9yaWdpbmFsXCIsXG5cdFx0aWZyYW1lRml4OiBmYWxzZSxcblx0XHRvcGFjaXR5OiBmYWxzZSxcblx0XHRyZWZyZXNoUG9zaXRpb25zOiBmYWxzZSxcblx0XHRyZXZlcnQ6IGZhbHNlLFxuXHRcdHJldmVydER1cmF0aW9uOiA1MDAsXG5cdFx0c2NvcGU6IFwiZGVmYXVsdFwiLFxuXHRcdHNjcm9sbDogdHJ1ZSxcblx0XHRzY3JvbGxTZW5zaXRpdml0eTogMjAsXG5cdFx0c2Nyb2xsU3BlZWQ6IDIwLFxuXHRcdHNuYXA6IGZhbHNlLFxuXHRcdHNuYXBNb2RlOiBcImJvdGhcIixcblx0XHRzbmFwVG9sZXJhbmNlOiAyMCxcblx0XHRzdGFjazogZmFsc2UsXG5cdFx0ekluZGV4OiBmYWxzZSxcblxuXHRcdC8vIGNhbGxiYWNrc1xuXHRcdGRyYWc6IG51bGwsXG5cdFx0c3RhcnQ6IG51bGwsXG5cdFx0c3RvcDogbnVsbFxuXHR9LFxuXHRfY3JlYXRlOiBmdW5jdGlvbigpIHtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmhlbHBlciA9PT0gXCJvcmlnaW5hbFwiICkge1xuXHRcdFx0dGhpcy5fc2V0UG9zaXRpb25SZWxhdGl2ZSgpO1xuXHRcdH1cblx0XHRpZiAodGhpcy5vcHRpb25zLmFkZENsYXNzZXMpe1xuXHRcdFx0dGhpcy5lbGVtZW50LmFkZENsYXNzKFwidWktZHJhZ2dhYmxlXCIpO1xuXHRcdH1cblx0XHRpZiAodGhpcy5vcHRpb25zLmRpc2FibGVkKXtcblx0XHRcdHRoaXMuZWxlbWVudC5hZGRDbGFzcyhcInVpLWRyYWdnYWJsZS1kaXNhYmxlZFwiKTtcblx0XHR9XG5cdFx0dGhpcy5fc2V0SGFuZGxlQ2xhc3NOYW1lKCk7XG5cblx0XHR0aGlzLl9tb3VzZUluaXQoKTtcblx0fSxcblxuXHRfc2V0T3B0aW9uOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR0aGlzLl9zdXBlcigga2V5LCB2YWx1ZSApO1xuXHRcdGlmICgga2V5ID09PSBcImhhbmRsZVwiICkge1xuXHRcdFx0dGhpcy5fcmVtb3ZlSGFuZGxlQ2xhc3NOYW1lKCk7XG5cdFx0XHR0aGlzLl9zZXRIYW5kbGVDbGFzc05hbWUoKTtcblx0XHR9XG5cdH0sXG5cblx0X2Rlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggKCB0aGlzLmhlbHBlciB8fCB0aGlzLmVsZW1lbnQgKS5pcyggXCIudWktZHJhZ2dhYmxlLWRyYWdnaW5nXCIgKSApIHtcblx0XHRcdHRoaXMuZGVzdHJveU9uQ2xlYXIgPSB0cnVlO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoIFwidWktZHJhZ2dhYmxlIHVpLWRyYWdnYWJsZS1kcmFnZ2luZyB1aS1kcmFnZ2FibGUtZGlzYWJsZWRcIiApO1xuXHRcdHRoaXMuX3JlbW92ZUhhbmRsZUNsYXNzTmFtZSgpO1xuXHRcdHRoaXMuX21vdXNlRGVzdHJveSgpO1xuXHR9LFxuXG5cdF9tb3VzZUNhcHR1cmU6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIG8gPSB0aGlzLm9wdGlvbnM7XG5cblx0XHR0aGlzLl9ibHVyQWN0aXZlRWxlbWVudCggZXZlbnQgKTtcblxuXHRcdC8vIGFtb25nIG90aGVycywgcHJldmVudCBhIGRyYWcgb24gYSByZXNpemFibGUtaGFuZGxlXG5cdFx0aWYgKHRoaXMuaGVscGVyIHx8IG8uZGlzYWJsZWQgfHwgJChldmVudC50YXJnZXQpLmNsb3Nlc3QoXCIudWktcmVzaXphYmxlLWhhbmRsZVwiKS5sZW5ndGggPiAwKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly9RdWl0IGlmIHdlJ3JlIG5vdCBvbiBhIHZhbGlkIGhhbmRsZVxuXHRcdHRoaXMuaGFuZGxlID0gdGhpcy5fZ2V0SGFuZGxlKGV2ZW50KTtcblx0XHRpZiAoIXRoaXMuaGFuZGxlKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dGhpcy5fYmxvY2tGcmFtZXMoIG8uaWZyYW1lRml4ID09PSB0cnVlID8gXCJpZnJhbWVcIiA6IG8uaWZyYW1lRml4ICk7XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9LFxuXG5cdF9ibG9ja0ZyYW1lczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHRoaXMuaWZyYW1lQmxvY2tzID0gdGhpcy5kb2N1bWVudC5maW5kKCBzZWxlY3RvciApLm1hcChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpZnJhbWUgPSAkKCB0aGlzICk7XG5cblx0XHRcdHJldHVybiAkKCBcIjxkaXY+XCIgKVxuXHRcdFx0XHQuY3NzKCBcInBvc2l0aW9uXCIsIFwiYWJzb2x1dGVcIiApXG5cdFx0XHRcdC5hcHBlbmRUbyggaWZyYW1lLnBhcmVudCgpIClcblx0XHRcdFx0Lm91dGVyV2lkdGgoIGlmcmFtZS5vdXRlcldpZHRoKCkgKVxuXHRcdFx0XHQub3V0ZXJIZWlnaHQoIGlmcmFtZS5vdXRlckhlaWdodCgpIClcblx0XHRcdFx0Lm9mZnNldCggaWZyYW1lLm9mZnNldCgpIClbIDAgXTtcblx0XHR9KTtcblx0fSxcblxuXHRfdW5ibG9ja0ZyYW1lczogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCB0aGlzLmlmcmFtZUJsb2NrcyApIHtcblx0XHRcdHRoaXMuaWZyYW1lQmxvY2tzLnJlbW92ZSgpO1xuXHRcdFx0ZGVsZXRlIHRoaXMuaWZyYW1lQmxvY2tzO1xuXHRcdH1cblx0fSxcblxuXHRfYmx1ckFjdGl2ZUVsZW1lbnQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgZG9jdW1lbnQgPSB0aGlzLmRvY3VtZW50WyAwIF07XG5cblx0XHQvLyBPbmx5IG5lZWQgdG8gYmx1ciBpZiB0aGUgZXZlbnQgb2NjdXJyZWQgb24gdGhlIGRyYWdnYWJsZSBpdHNlbGYsIHNlZSAjMTA1Mjdcblx0XHRpZiAoICF0aGlzLmhhbmRsZUVsZW1lbnQuaXMoIGV2ZW50LnRhcmdldCApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIHN1cHBvcnQ6IElFOVxuXHRcdC8vIElFOSB0aHJvd3MgYW4gXCJVbnNwZWNpZmllZCBlcnJvclwiIGFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGZyb20gYW4gPGlmcmFtZT5cblx0XHR0cnkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTksIElFMTBcblx0XHRcdC8vIElmIHRoZSA8Ym9keT4gaXMgYmx1cnJlZCwgSUUgd2lsbCBzd2l0Y2ggd2luZG93cywgc2VlICM5NTIwXG5cdFx0XHRpZiAoIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcImJvZHlcIiApIHtcblxuXHRcdFx0XHQvLyBCbHVyIGFueSBlbGVtZW50IHRoYXQgY3VycmVudGx5IGhhcyBmb2N1cywgc2VlICM0MjYxXG5cdFx0XHRcdCQoIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgKS5ibHVyKCk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoIGVycm9yICkge31cblx0fSxcblxuXHRfbW91c2VTdGFydDogZnVuY3Rpb24oZXZlbnQpIHtcblxuXHRcdHZhciBvID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0Ly9DcmVhdGUgYW5kIGFwcGVuZCB0aGUgdmlzaWJsZSBoZWxwZXJcblx0XHR0aGlzLmhlbHBlciA9IHRoaXMuX2NyZWF0ZUhlbHBlcihldmVudCk7XG5cblx0XHR0aGlzLmhlbHBlci5hZGRDbGFzcyhcInVpLWRyYWdnYWJsZS1kcmFnZ2luZ1wiKTtcblxuXHRcdC8vQ2FjaGUgdGhlIGhlbHBlciBzaXplXG5cdFx0dGhpcy5fY2FjaGVIZWxwZXJQcm9wb3J0aW9ucygpO1xuXG5cdFx0Ly9JZiBkZG1hbmFnZXIgaXMgdXNlZCBmb3IgZHJvcHBhYmxlcywgc2V0IHRoZSBnbG9iYWwgZHJhZ2dhYmxlXG5cdFx0aWYgKCQudWkuZGRtYW5hZ2VyKSB7XG5cdFx0XHQkLnVpLmRkbWFuYWdlci5jdXJyZW50ID0gdGhpcztcblx0XHR9XG5cblx0XHQvKlxuXHRcdCAqIC0gUG9zaXRpb24gZ2VuZXJhdGlvbiAtXG5cdFx0ICogVGhpcyBibG9jayBnZW5lcmF0ZXMgZXZlcnl0aGluZyBwb3NpdGlvbiByZWxhdGVkIC0gaXQncyB0aGUgY29yZSBvZiBkcmFnZ2FibGVzLlxuXHRcdCAqL1xuXG5cdFx0Ly9DYWNoZSB0aGUgbWFyZ2lucyBvZiB0aGUgb3JpZ2luYWwgZWxlbWVudFxuXHRcdHRoaXMuX2NhY2hlTWFyZ2lucygpO1xuXG5cdFx0Ly9TdG9yZSB0aGUgaGVscGVyJ3MgY3NzIHBvc2l0aW9uXG5cdFx0dGhpcy5jc3NQb3NpdGlvbiA9IHRoaXMuaGVscGVyLmNzcyggXCJwb3NpdGlvblwiICk7XG5cdFx0dGhpcy5zY3JvbGxQYXJlbnQgPSB0aGlzLmhlbHBlci5zY3JvbGxQYXJlbnQoIHRydWUgKTtcblx0XHR0aGlzLm9mZnNldFBhcmVudCA9IHRoaXMuaGVscGVyLm9mZnNldFBhcmVudCgpO1xuXHRcdHRoaXMuaGFzRml4ZWRBbmNlc3RvciA9IHRoaXMuaGVscGVyLnBhcmVudHMoKS5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAkKCB0aGlzICkuY3NzKCBcInBvc2l0aW9uXCIgKSA9PT0gXCJmaXhlZFwiO1xuXHRcdFx0fSkubGVuZ3RoID4gMDtcblxuXHRcdC8vVGhlIGVsZW1lbnQncyBhYnNvbHV0ZSBwb3NpdGlvbiBvbiB0aGUgcGFnZSBtaW51cyBtYXJnaW5zXG5cdFx0dGhpcy5wb3NpdGlvbkFicyA9IHRoaXMuZWxlbWVudC5vZmZzZXQoKTtcblx0XHR0aGlzLl9yZWZyZXNoT2Zmc2V0cyggZXZlbnQgKTtcblxuXHRcdC8vR2VuZXJhdGUgdGhlIG9yaWdpbmFsIHBvc2l0aW9uXG5cdFx0dGhpcy5vcmlnaW5hbFBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbiA9IHRoaXMuX2dlbmVyYXRlUG9zaXRpb24oIGV2ZW50LCBmYWxzZSApO1xuXHRcdHRoaXMub3JpZ2luYWxQYWdlWCA9IGV2ZW50LnBhZ2VYO1xuXHRcdHRoaXMub3JpZ2luYWxQYWdlWSA9IGV2ZW50LnBhZ2VZO1xuXG5cdFx0Ly9BZGp1c3QgdGhlIG1vdXNlIG9mZnNldCByZWxhdGl2ZSB0byB0aGUgaGVscGVyIGlmIFwiY3Vyc29yQXRcIiBpcyBzdXBwbGllZFxuXHRcdChvLmN1cnNvckF0ICYmIHRoaXMuX2FkanVzdE9mZnNldEZyb21IZWxwZXIoby5jdXJzb3JBdCkpO1xuXG5cdFx0Ly9TZXQgYSBjb250YWlubWVudCBpZiBnaXZlbiBpbiB0aGUgb3B0aW9uc1xuXHRcdHRoaXMuX3NldENvbnRhaW5tZW50KCk7XG5cblx0XHQvL1RyaWdnZXIgZXZlbnQgKyBjYWxsYmFja3Ncblx0XHRpZiAodGhpcy5fdHJpZ2dlcihcInN0YXJ0XCIsIGV2ZW50KSA9PT0gZmFsc2UpIHtcblx0XHRcdHRoaXMuX2NsZWFyKCk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly9SZWNhY2hlIHRoZSBoZWxwZXIgc2l6ZVxuXHRcdHRoaXMuX2NhY2hlSGVscGVyUHJvcG9ydGlvbnMoKTtcblxuXHRcdC8vUHJlcGFyZSB0aGUgZHJvcHBhYmxlIG9mZnNldHNcblx0XHRpZiAoJC51aS5kZG1hbmFnZXIgJiYgIW8uZHJvcEJlaGF2aW91cikge1xuXHRcdFx0JC51aS5kZG1hbmFnZXIucHJlcGFyZU9mZnNldHModGhpcywgZXZlbnQpO1xuXHRcdH1cblxuXHRcdC8vIFJlc2V0IGhlbHBlcidzIHJpZ2h0L2JvdHRvbSBjc3MgaWYgdGhleSdyZSBzZXQgYW5kIHNldCBleHBsaWNpdCB3aWR0aC9oZWlnaHQgaW5zdGVhZFxuXHRcdC8vIGFzIHRoaXMgcHJldmVudHMgcmVzaXppbmcgb2YgZWxlbWVudHMgd2l0aCByaWdodC9ib3R0b20gc2V0IChzZWUgIzc3NzIpXG5cdFx0dGhpcy5fbm9ybWFsaXplUmlnaHRCb3R0b20oKTtcblxuXHRcdHRoaXMuX21vdXNlRHJhZyhldmVudCwgdHJ1ZSk7IC8vRXhlY3V0ZSB0aGUgZHJhZyBvbmNlIC0gdGhpcyBjYXVzZXMgdGhlIGhlbHBlciBub3QgdG8gYmUgdmlzaWJsZSBiZWZvcmUgZ2V0dGluZyBpdHMgY29ycmVjdCBwb3NpdGlvblxuXG5cdFx0Ly9JZiB0aGUgZGRtYW5hZ2VyIGlzIHVzZWQgZm9yIGRyb3BwYWJsZXMsIGluZm9ybSB0aGUgbWFuYWdlciB0aGF0IGRyYWdnaW5nIGhhcyBzdGFydGVkIChzZWUgIzUwMDMpXG5cdFx0aWYgKCAkLnVpLmRkbWFuYWdlciApIHtcblx0XHRcdCQudWkuZGRtYW5hZ2VyLmRyYWdTdGFydCh0aGlzLCBldmVudCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0X3JlZnJlc2hPZmZzZXRzOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dGhpcy5vZmZzZXQgPSB7XG5cdFx0XHR0b3A6IHRoaXMucG9zaXRpb25BYnMudG9wIC0gdGhpcy5tYXJnaW5zLnRvcCxcblx0XHRcdGxlZnQ6IHRoaXMucG9zaXRpb25BYnMubGVmdCAtIHRoaXMubWFyZ2lucy5sZWZ0LFxuXHRcdFx0c2Nyb2xsOiBmYWxzZSxcblx0XHRcdHBhcmVudDogdGhpcy5fZ2V0UGFyZW50T2Zmc2V0KCksXG5cdFx0XHRyZWxhdGl2ZTogdGhpcy5fZ2V0UmVsYXRpdmVPZmZzZXQoKVxuXHRcdH07XG5cblx0XHR0aGlzLm9mZnNldC5jbGljayA9IHtcblx0XHRcdGxlZnQ6IGV2ZW50LnBhZ2VYIC0gdGhpcy5vZmZzZXQubGVmdCxcblx0XHRcdHRvcDogZXZlbnQucGFnZVkgLSB0aGlzLm9mZnNldC50b3Bcblx0XHR9O1xuXHR9LFxuXG5cdF9tb3VzZURyYWc6IGZ1bmN0aW9uKGV2ZW50LCBub1Byb3BhZ2F0aW9uKSB7XG5cdFx0Ly8gcmVzZXQgYW55IG5lY2Vzc2FyeSBjYWNoZWQgcHJvcGVydGllcyAoc2VlICM1MDA5KVxuXHRcdGlmICggdGhpcy5oYXNGaXhlZEFuY2VzdG9yICkge1xuXHRcdFx0dGhpcy5vZmZzZXQucGFyZW50ID0gdGhpcy5fZ2V0UGFyZW50T2Zmc2V0KCk7XG5cdFx0fVxuXG5cdFx0Ly9Db21wdXRlIHRoZSBoZWxwZXJzIHBvc2l0aW9uXG5cdFx0dGhpcy5wb3NpdGlvbiA9IHRoaXMuX2dlbmVyYXRlUG9zaXRpb24oIGV2ZW50LCB0cnVlICk7XG5cdFx0dGhpcy5wb3NpdGlvbkFicyA9IHRoaXMuX2NvbnZlcnRQb3NpdGlvblRvKFwiYWJzb2x1dGVcIik7XG5cblx0XHQvL0NhbGwgcGx1Z2lucyBhbmQgY2FsbGJhY2tzIGFuZCB1c2UgdGhlIHJlc3VsdGluZyBwb3NpdGlvbiBpZiBzb21ldGhpbmcgaXMgcmV0dXJuZWRcblx0XHRpZiAoIW5vUHJvcGFnYXRpb24pIHtcblx0XHRcdHZhciB1aSA9IHRoaXMuX3VpSGFzaCgpO1xuXHRcdFx0aWYgKHRoaXMuX3RyaWdnZXIoXCJkcmFnXCIsIGV2ZW50LCB1aSkgPT09IGZhbHNlKSB7XG5cdFx0XHRcdHRoaXMuX21vdXNlVXAoe30pO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnBvc2l0aW9uID0gdWkucG9zaXRpb247XG5cdFx0fVxuXG5cdFx0dGhpcy5oZWxwZXJbIDAgXS5zdHlsZS5sZWZ0ID0gdGhpcy5wb3NpdGlvbi5sZWZ0ICsgXCJweFwiO1xuXHRcdHRoaXMuaGVscGVyWyAwIF0uc3R5bGUudG9wID0gdGhpcy5wb3NpdGlvbi50b3AgKyBcInB4XCI7XG5cblx0XHRpZiAoJC51aS5kZG1hbmFnZXIpIHtcblx0XHRcdCQudWkuZGRtYW5hZ2VyLmRyYWcodGhpcywgZXZlbnQpO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRfbW91c2VTdG9wOiBmdW5jdGlvbihldmVudCkge1xuXG5cdFx0Ly9JZiB3ZSBhcmUgdXNpbmcgZHJvcHBhYmxlcywgaW5mb3JtIHRoZSBtYW5hZ2VyIGFib3V0IHRoZSBkcm9wXG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0ZHJvcHBlZCA9IGZhbHNlO1xuXHRcdGlmICgkLnVpLmRkbWFuYWdlciAmJiAhdGhpcy5vcHRpb25zLmRyb3BCZWhhdmlvdXIpIHtcblx0XHRcdGRyb3BwZWQgPSAkLnVpLmRkbWFuYWdlci5kcm9wKHRoaXMsIGV2ZW50KTtcblx0XHR9XG5cblx0XHQvL2lmIGEgZHJvcCBjb21lcyBmcm9tIG91dHNpZGUgKGEgc29ydGFibGUpXG5cdFx0aWYgKHRoaXMuZHJvcHBlZCkge1xuXHRcdFx0ZHJvcHBlZCA9IHRoaXMuZHJvcHBlZDtcblx0XHRcdHRoaXMuZHJvcHBlZCA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmICgodGhpcy5vcHRpb25zLnJldmVydCA9PT0gXCJpbnZhbGlkXCIgJiYgIWRyb3BwZWQpIHx8ICh0aGlzLm9wdGlvbnMucmV2ZXJ0ID09PSBcInZhbGlkXCIgJiYgZHJvcHBlZCkgfHwgdGhpcy5vcHRpb25zLnJldmVydCA9PT0gdHJ1ZSB8fCAoJC5pc0Z1bmN0aW9uKHRoaXMub3B0aW9ucy5yZXZlcnQpICYmIHRoaXMub3B0aW9ucy5yZXZlcnQuY2FsbCh0aGlzLmVsZW1lbnQsIGRyb3BwZWQpKSkge1xuXHRcdFx0JCh0aGlzLmhlbHBlcikuYW5pbWF0ZSh0aGlzLm9yaWdpbmFsUG9zaXRpb24sIHBhcnNlSW50KHRoaXMub3B0aW9ucy5yZXZlcnREdXJhdGlvbiwgMTApLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKHRoYXQuX3RyaWdnZXIoXCJzdG9wXCIsIGV2ZW50KSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHR0aGF0Ll9jbGVhcigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHRoaXMuX3RyaWdnZXIoXCJzdG9wXCIsIGV2ZW50KSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0dGhpcy5fY2xlYXIoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0X21vdXNlVXA6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR0aGlzLl91bmJsb2NrRnJhbWVzKCk7XG5cblx0XHQvL0lmIHRoZSBkZG1hbmFnZXIgaXMgdXNlZCBmb3IgZHJvcHBhYmxlcywgaW5mb3JtIHRoZSBtYW5hZ2VyIHRoYXQgZHJhZ2dpbmcgaGFzIHN0b3BwZWQgKHNlZSAjNTAwMylcblx0XHRpZiAoICQudWkuZGRtYW5hZ2VyICkge1xuXHRcdFx0JC51aS5kZG1hbmFnZXIuZHJhZ1N0b3AodGhpcywgZXZlbnQpO1xuXHRcdH1cblxuXHRcdC8vIE9ubHkgbmVlZCB0byBmb2N1cyBpZiB0aGUgZXZlbnQgb2NjdXJyZWQgb24gdGhlIGRyYWdnYWJsZSBpdHNlbGYsIHNlZSAjMTA1Mjdcblx0XHRpZiAoIHRoaXMuaGFuZGxlRWxlbWVudC5pcyggZXZlbnQudGFyZ2V0ICkgKSB7XG5cdFx0XHQvLyBUaGUgaW50ZXJhY3Rpb24gaXMgb3Zlcjsgd2hldGhlciBvciBub3QgdGhlIGNsaWNrIHJlc3VsdGVkIGluIGEgZHJhZywgZm9jdXMgdGhlIGVsZW1lbnRcblx0XHRcdHRoaXMuZWxlbWVudC5mb2N1cygpO1xuXHRcdH1cblxuXHRcdHJldHVybiAkLnVpLm1vdXNlLnByb3RvdHlwZS5fbW91c2VVcC5jYWxsKHRoaXMsIGV2ZW50KTtcblx0fSxcblxuXHRjYW5jZWw6IGZ1bmN0aW9uKCkge1xuXG5cdFx0aWYgKHRoaXMuaGVscGVyLmlzKFwiLnVpLWRyYWdnYWJsZS1kcmFnZ2luZ1wiKSkge1xuXHRcdFx0dGhpcy5fbW91c2VVcCh7fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2NsZWFyKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRfZ2V0SGFuZGxlOiBmdW5jdGlvbihldmVudCkge1xuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuaGFuZGxlID9cblx0XHRcdCEhJCggZXZlbnQudGFyZ2V0ICkuY2xvc2VzdCggdGhpcy5lbGVtZW50LmZpbmQoIHRoaXMub3B0aW9ucy5oYW5kbGUgKSApLmxlbmd0aCA6XG5cdFx0XHR0cnVlO1xuXHR9LFxuXG5cdF9zZXRIYW5kbGVDbGFzc05hbWU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaGFuZGxlRWxlbWVudCA9IHRoaXMub3B0aW9ucy5oYW5kbGUgP1xuXHRcdFx0dGhpcy5lbGVtZW50LmZpbmQoIHRoaXMub3B0aW9ucy5oYW5kbGUgKSA6IHRoaXMuZWxlbWVudDtcblx0XHR0aGlzLmhhbmRsZUVsZW1lbnQuYWRkQ2xhc3MoIFwidWktZHJhZ2dhYmxlLWhhbmRsZVwiICk7XG5cdH0sXG5cblx0X3JlbW92ZUhhbmRsZUNsYXNzTmFtZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5oYW5kbGVFbGVtZW50LnJlbW92ZUNsYXNzKCBcInVpLWRyYWdnYWJsZS1oYW5kbGVcIiApO1xuXHR9LFxuXG5cdF9jcmVhdGVIZWxwZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cblx0XHR2YXIgbyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdGhlbHBlcklzRnVuY3Rpb24gPSAkLmlzRnVuY3Rpb24oIG8uaGVscGVyICksXG5cdFx0XHRoZWxwZXIgPSBoZWxwZXJJc0Z1bmN0aW9uID9cblx0XHRcdFx0JCggby5oZWxwZXIuYXBwbHkoIHRoaXMuZWxlbWVudFsgMCBdLCBbIGV2ZW50IF0gKSApIDpcblx0XHRcdFx0KCBvLmhlbHBlciA9PT0gXCJjbG9uZVwiID9cblx0XHRcdFx0XHR0aGlzLmVsZW1lbnQuY2xvbmUoKS5yZW1vdmVBdHRyKCBcImlkXCIgKSA6XG5cdFx0XHRcdFx0dGhpcy5lbGVtZW50ICk7XG5cblx0XHRpZiAoIWhlbHBlci5wYXJlbnRzKFwiYm9keVwiKS5sZW5ndGgpIHtcblx0XHRcdGhlbHBlci5hcHBlbmRUbygoby5hcHBlbmRUbyA9PT0gXCJwYXJlbnRcIiA/IHRoaXMuZWxlbWVudFswXS5wYXJlbnROb2RlIDogby5hcHBlbmRUbykpO1xuXHRcdH1cblxuXHRcdC8vIGh0dHA6Ly9idWdzLmpxdWVyeXVpLmNvbS90aWNrZXQvOTQ0NlxuXHRcdC8vIGEgaGVscGVyIGZ1bmN0aW9uIGNhbiByZXR1cm4gdGhlIG9yaWdpbmFsIGVsZW1lbnRcblx0XHQvLyB3aGljaCB3b3VsZG4ndCBoYXZlIGJlZW4gc2V0IHRvIHJlbGF0aXZlIGluIF9jcmVhdGVcblx0XHRpZiAoIGhlbHBlcklzRnVuY3Rpb24gJiYgaGVscGVyWyAwIF0gPT09IHRoaXMuZWxlbWVudFsgMCBdICkge1xuXHRcdFx0dGhpcy5fc2V0UG9zaXRpb25SZWxhdGl2ZSgpO1xuXHRcdH1cblxuXHRcdGlmIChoZWxwZXJbMF0gIT09IHRoaXMuZWxlbWVudFswXSAmJiAhKC8oZml4ZWR8YWJzb2x1dGUpLykudGVzdChoZWxwZXIuY3NzKFwicG9zaXRpb25cIikpKSB7XG5cdFx0XHRoZWxwZXIuY3NzKFwicG9zaXRpb25cIiwgXCJhYnNvbHV0ZVwiKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaGVscGVyO1xuXG5cdH0sXG5cblx0X3NldFBvc2l0aW9uUmVsYXRpdmU6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggISggL14oPzpyfGF8ZikvICkudGVzdCggdGhpcy5lbGVtZW50LmNzcyggXCJwb3NpdGlvblwiICkgKSApIHtcblx0XHRcdHRoaXMuZWxlbWVudFsgMCBdLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuXHRcdH1cblx0fSxcblxuXHRfYWRqdXN0T2Zmc2V0RnJvbUhlbHBlcjogZnVuY3Rpb24ob2JqKSB7XG5cdFx0aWYgKHR5cGVvZiBvYmogPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdG9iaiA9IG9iai5zcGxpdChcIiBcIik7XG5cdFx0fVxuXHRcdGlmICgkLmlzQXJyYXkob2JqKSkge1xuXHRcdFx0b2JqID0geyBsZWZ0OiArb2JqWzBdLCB0b3A6ICtvYmpbMV0gfHwgMCB9O1xuXHRcdH1cblx0XHRpZiAoXCJsZWZ0XCIgaW4gb2JqKSB7XG5cdFx0XHR0aGlzLm9mZnNldC5jbGljay5sZWZ0ID0gb2JqLmxlZnQgKyB0aGlzLm1hcmdpbnMubGVmdDtcblx0XHR9XG5cdFx0aWYgKFwicmlnaHRcIiBpbiBvYmopIHtcblx0XHRcdHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPSB0aGlzLmhlbHBlclByb3BvcnRpb25zLndpZHRoIC0gb2JqLnJpZ2h0ICsgdGhpcy5tYXJnaW5zLmxlZnQ7XG5cdFx0fVxuXHRcdGlmIChcInRvcFwiIGluIG9iaikge1xuXHRcdFx0dGhpcy5vZmZzZXQuY2xpY2sudG9wID0gb2JqLnRvcCArIHRoaXMubWFyZ2lucy50b3A7XG5cdFx0fVxuXHRcdGlmIChcImJvdHRvbVwiIGluIG9iaikge1xuXHRcdFx0dGhpcy5vZmZzZXQuY2xpY2sudG9wID0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQgLSBvYmouYm90dG9tICsgdGhpcy5tYXJnaW5zLnRvcDtcblx0XHR9XG5cdH0sXG5cblx0X2lzUm9vdE5vZGU6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHJldHVybiAoIC8oaHRtbHxib2R5KS9pICkudGVzdCggZWxlbWVudC50YWdOYW1lICkgfHwgZWxlbWVudCA9PT0gdGhpcy5kb2N1bWVudFsgMCBdO1xuXHR9LFxuXG5cdF9nZXRQYXJlbnRPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuXG5cdFx0Ly9HZXQgdGhlIG9mZnNldFBhcmVudCBhbmQgY2FjaGUgaXRzIHBvc2l0aW9uXG5cdFx0dmFyIHBvID0gdGhpcy5vZmZzZXRQYXJlbnQub2Zmc2V0KCksXG5cdFx0XHRkb2N1bWVudCA9IHRoaXMuZG9jdW1lbnRbIDAgXTtcblxuXHRcdC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2Ugd2hlcmUgd2UgbmVlZCB0byBtb2RpZnkgYSBvZmZzZXQgY2FsY3VsYXRlZCBvbiBzdGFydCwgc2luY2UgdGhlIGZvbGxvd2luZyBoYXBwZW5lZDpcblx0XHQvLyAxLiBUaGUgcG9zaXRpb24gb2YgdGhlIGhlbHBlciBpcyBhYnNvbHV0ZSwgc28gaXQncyBwb3NpdGlvbiBpcyBjYWxjdWxhdGVkIGJhc2VkIG9uIHRoZSBuZXh0IHBvc2l0aW9uZWQgcGFyZW50XG5cdFx0Ly8gMi4gVGhlIGFjdHVhbCBvZmZzZXQgcGFyZW50IGlzIGEgY2hpbGQgb2YgdGhlIHNjcm9sbCBwYXJlbnQsIGFuZCB0aGUgc2Nyb2xsIHBhcmVudCBpc24ndCB0aGUgZG9jdW1lbnQsIHdoaWNoIG1lYW5zIHRoYXRcblx0XHQvLyAgICB0aGUgc2Nyb2xsIGlzIGluY2x1ZGVkIGluIHRoZSBpbml0aWFsIGNhbGN1bGF0aW9uIG9mIHRoZSBvZmZzZXQgb2YgdGhlIHBhcmVudCwgYW5kIG5ldmVyIHJlY2FsY3VsYXRlZCB1cG9uIGRyYWdcblx0XHRpZiAodGhpcy5jc3NQb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiICYmIHRoaXMuc2Nyb2xsUGFyZW50WzBdICE9PSBkb2N1bWVudCAmJiAkLmNvbnRhaW5zKHRoaXMuc2Nyb2xsUGFyZW50WzBdLCB0aGlzLm9mZnNldFBhcmVudFswXSkpIHtcblx0XHRcdHBvLmxlZnQgKz0gdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsTGVmdCgpO1xuXHRcdFx0cG8udG9wICs9IHRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCgpO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5faXNSb290Tm9kZSggdGhpcy5vZmZzZXRQYXJlbnRbIDAgXSApICkge1xuXHRcdFx0cG8gPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IHBvLnRvcCArIChwYXJzZUludCh0aGlzLm9mZnNldFBhcmVudC5jc3MoXCJib3JkZXJUb3BXaWR0aFwiKSwgMTApIHx8IDApLFxuXHRcdFx0bGVmdDogcG8ubGVmdCArIChwYXJzZUludCh0aGlzLm9mZnNldFBhcmVudC5jc3MoXCJib3JkZXJMZWZ0V2lkdGhcIiksIDEwKSB8fCAwKVxuXHRcdH07XG5cblx0fSxcblxuXHRfZ2V0UmVsYXRpdmVPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggdGhpcy5jc3NQb3NpdGlvbiAhPT0gXCJyZWxhdGl2ZVwiICkge1xuXHRcdFx0cmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cdFx0fVxuXG5cdFx0dmFyIHAgPSB0aGlzLmVsZW1lbnQucG9zaXRpb24oKSxcblx0XHRcdHNjcm9sbElzUm9vdE5vZGUgPSB0aGlzLl9pc1Jvb3ROb2RlKCB0aGlzLnNjcm9sbFBhcmVudFsgMCBdICk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBwLnRvcCAtICggcGFyc2VJbnQodGhpcy5oZWxwZXIuY3NzKCBcInRvcFwiICksIDEwKSB8fCAwICkgKyAoICFzY3JvbGxJc1Jvb3ROb2RlID8gdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsVG9wKCkgOiAwICksXG5cdFx0XHRsZWZ0OiBwLmxlZnQgLSAoIHBhcnNlSW50KHRoaXMuaGVscGVyLmNzcyggXCJsZWZ0XCIgKSwgMTApIHx8IDAgKSArICggIXNjcm9sbElzUm9vdE5vZGUgPyB0aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0KCkgOiAwIClcblx0XHR9O1xuXG5cdH0sXG5cblx0X2NhY2hlTWFyZ2luczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5tYXJnaW5zID0ge1xuXHRcdFx0bGVmdDogKHBhcnNlSW50KHRoaXMuZWxlbWVudC5jc3MoXCJtYXJnaW5MZWZ0XCIpLCAxMCkgfHwgMCksXG5cdFx0XHR0b3A6IChwYXJzZUludCh0aGlzLmVsZW1lbnQuY3NzKFwibWFyZ2luVG9wXCIpLCAxMCkgfHwgMCksXG5cdFx0XHRyaWdodDogKHBhcnNlSW50KHRoaXMuZWxlbWVudC5jc3MoXCJtYXJnaW5SaWdodFwiKSwgMTApIHx8IDApLFxuXHRcdFx0Ym90dG9tOiAocGFyc2VJbnQodGhpcy5lbGVtZW50LmNzcyhcIm1hcmdpbkJvdHRvbVwiKSwgMTApIHx8IDApXG5cdFx0fTtcblx0fSxcblxuXHRfY2FjaGVIZWxwZXJQcm9wb3J0aW9uczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5oZWxwZXJQcm9wb3J0aW9ucyA9IHtcblx0XHRcdHdpZHRoOiB0aGlzLmhlbHBlci5vdXRlcldpZHRoKCksXG5cdFx0XHRoZWlnaHQ6IHRoaXMuaGVscGVyLm91dGVySGVpZ2h0KClcblx0XHR9O1xuXHR9LFxuXG5cdF9zZXRDb250YWlubWVudDogZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgaXNVc2VyU2Nyb2xsYWJsZSwgYywgY2UsXG5cdFx0XHRvID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0ZG9jdW1lbnQgPSB0aGlzLmRvY3VtZW50WyAwIF07XG5cblx0XHR0aGlzLnJlbGF0aXZlQ29udGFpbmVyID0gbnVsbDtcblxuXHRcdGlmICggIW8uY29udGFpbm1lbnQgKSB7XG5cdFx0XHR0aGlzLmNvbnRhaW5tZW50ID0gbnVsbDtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG8uY29udGFpbm1lbnQgPT09IFwid2luZG93XCIgKSB7XG5cdFx0XHR0aGlzLmNvbnRhaW5tZW50ID0gW1xuXHRcdFx0XHQkKCB3aW5kb3cgKS5zY3JvbGxMZWZ0KCkgLSB0aGlzLm9mZnNldC5yZWxhdGl2ZS5sZWZ0IC0gdGhpcy5vZmZzZXQucGFyZW50LmxlZnQsXG5cdFx0XHRcdCQoIHdpbmRvdyApLnNjcm9sbFRvcCgpIC0gdGhpcy5vZmZzZXQucmVsYXRpdmUudG9wIC0gdGhpcy5vZmZzZXQucGFyZW50LnRvcCxcblx0XHRcdFx0JCggd2luZG93ICkuc2Nyb2xsTGVmdCgpICsgJCggd2luZG93ICkud2lkdGgoKSAtIHRoaXMuaGVscGVyUHJvcG9ydGlvbnMud2lkdGggLSB0aGlzLm1hcmdpbnMubGVmdCxcblx0XHRcdFx0JCggd2luZG93ICkuc2Nyb2xsVG9wKCkgKyAoICQoIHdpbmRvdyApLmhlaWdodCgpIHx8IGRvY3VtZW50LmJvZHkucGFyZW50Tm9kZS5zY3JvbGxIZWlnaHQgKSAtIHRoaXMuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0IC0gdGhpcy5tYXJnaW5zLnRvcFxuXHRcdFx0XTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG8uY29udGFpbm1lbnQgPT09IFwiZG9jdW1lbnRcIikge1xuXHRcdFx0dGhpcy5jb250YWlubWVudCA9IFtcblx0XHRcdFx0MCxcblx0XHRcdFx0MCxcblx0XHRcdFx0JCggZG9jdW1lbnQgKS53aWR0aCgpIC0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCAtIHRoaXMubWFyZ2lucy5sZWZ0LFxuXHRcdFx0XHQoICQoIGRvY3VtZW50ICkuaGVpZ2h0KCkgfHwgZG9jdW1lbnQuYm9keS5wYXJlbnROb2RlLnNjcm9sbEhlaWdodCApIC0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQgLSB0aGlzLm1hcmdpbnMudG9wXG5cdFx0XHRdO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggby5jb250YWlubWVudC5jb25zdHJ1Y3RvciA9PT0gQXJyYXkgKSB7XG5cdFx0XHR0aGlzLmNvbnRhaW5tZW50ID0gby5jb250YWlubWVudDtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG8uY29udGFpbm1lbnQgPT09IFwicGFyZW50XCIgKSB7XG5cdFx0XHRvLmNvbnRhaW5tZW50ID0gdGhpcy5oZWxwZXJbIDAgXS5wYXJlbnROb2RlO1xuXHRcdH1cblxuXHRcdGMgPSAkKCBvLmNvbnRhaW5tZW50ICk7XG5cdFx0Y2UgPSBjWyAwIF07XG5cblx0XHRpZiAoICFjZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpc1VzZXJTY3JvbGxhYmxlID0gLyhzY3JvbGx8YXV0bykvLnRlc3QoIGMuY3NzKCBcIm92ZXJmbG93XCIgKSApO1xuXG5cdFx0dGhpcy5jb250YWlubWVudCA9IFtcblx0XHRcdCggcGFyc2VJbnQoIGMuY3NzKCBcImJvcmRlckxlZnRXaWR0aFwiICksIDEwICkgfHwgMCApICsgKCBwYXJzZUludCggYy5jc3MoIFwicGFkZGluZ0xlZnRcIiApLCAxMCApIHx8IDAgKSxcblx0XHRcdCggcGFyc2VJbnQoIGMuY3NzKCBcImJvcmRlclRvcFdpZHRoXCIgKSwgMTAgKSB8fCAwICkgKyAoIHBhcnNlSW50KCBjLmNzcyggXCJwYWRkaW5nVG9wXCIgKSwgMTAgKSB8fCAwICksXG5cdFx0XHQoIGlzVXNlclNjcm9sbGFibGUgPyBNYXRoLm1heCggY2Uuc2Nyb2xsV2lkdGgsIGNlLm9mZnNldFdpZHRoICkgOiBjZS5vZmZzZXRXaWR0aCApIC1cblx0XHRcdFx0KCBwYXJzZUludCggYy5jc3MoIFwiYm9yZGVyUmlnaHRXaWR0aFwiICksIDEwICkgfHwgMCApIC1cblx0XHRcdFx0KCBwYXJzZUludCggYy5jc3MoIFwicGFkZGluZ1JpZ2h0XCIgKSwgMTAgKSB8fCAwICkgLVxuXHRcdFx0XHR0aGlzLmhlbHBlclByb3BvcnRpb25zLndpZHRoIC1cblx0XHRcdFx0dGhpcy5tYXJnaW5zLmxlZnQgLVxuXHRcdFx0XHR0aGlzLm1hcmdpbnMucmlnaHQsXG5cdFx0XHQoIGlzVXNlclNjcm9sbGFibGUgPyBNYXRoLm1heCggY2Uuc2Nyb2xsSGVpZ2h0LCBjZS5vZmZzZXRIZWlnaHQgKSA6IGNlLm9mZnNldEhlaWdodCApIC1cblx0XHRcdFx0KCBwYXJzZUludCggYy5jc3MoIFwiYm9yZGVyQm90dG9tV2lkdGhcIiApLCAxMCApIHx8IDAgKSAtXG5cdFx0XHRcdCggcGFyc2VJbnQoIGMuY3NzKCBcInBhZGRpbmdCb3R0b21cIiApLCAxMCApIHx8IDAgKSAtXG5cdFx0XHRcdHRoaXMuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0IC1cblx0XHRcdFx0dGhpcy5tYXJnaW5zLnRvcCAtXG5cdFx0XHRcdHRoaXMubWFyZ2lucy5ib3R0b21cblx0XHRdO1xuXHRcdHRoaXMucmVsYXRpdmVDb250YWluZXIgPSBjO1xuXHR9LFxuXG5cdF9jb252ZXJ0UG9zaXRpb25UbzogZnVuY3Rpb24oZCwgcG9zKSB7XG5cblx0XHRpZiAoIXBvcykge1xuXHRcdFx0cG9zID0gdGhpcy5wb3NpdGlvbjtcblx0XHR9XG5cblx0XHR2YXIgbW9kID0gZCA9PT0gXCJhYnNvbHV0ZVwiID8gMSA6IC0xLFxuXHRcdFx0c2Nyb2xsSXNSb290Tm9kZSA9IHRoaXMuX2lzUm9vdE5vZGUoIHRoaXMuc2Nyb2xsUGFyZW50WyAwIF0gKTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IChcblx0XHRcdFx0cG9zLnRvcFx0K1x0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gVGhlIGFic29sdXRlIG1vdXNlIHBvc2l0aW9uXG5cdFx0XHRcdHRoaXMub2Zmc2V0LnJlbGF0aXZlLnRvcCAqIG1vZCArXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IGZvciByZWxhdGl2ZSBwb3NpdGlvbmVkIG5vZGVzOiBSZWxhdGl2ZSBvZmZzZXQgZnJvbSBlbGVtZW50IHRvIG9mZnNldCBwYXJlbnRcblx0XHRcdFx0dGhpcy5vZmZzZXQucGFyZW50LnRvcCAqIG1vZCAtXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBUaGUgb2Zmc2V0UGFyZW50J3Mgb2Zmc2V0IHdpdGhvdXQgYm9yZGVycyAob2Zmc2V0ICsgYm9yZGVyKVxuXHRcdFx0XHQoICggdGhpcy5jc3NQb3NpdGlvbiA9PT0gXCJmaXhlZFwiID8gLXRoaXMub2Zmc2V0LnNjcm9sbC50b3AgOiAoIHNjcm9sbElzUm9vdE5vZGUgPyAwIDogdGhpcy5vZmZzZXQuc2Nyb2xsLnRvcCApICkgKiBtb2QpXG5cdFx0XHQpLFxuXHRcdFx0bGVmdDogKFxuXHRcdFx0XHRwb3MubGVmdCArXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBUaGUgYWJzb2x1dGUgbW91c2UgcG9zaXRpb25cblx0XHRcdFx0dGhpcy5vZmZzZXQucmVsYXRpdmUubGVmdCAqIG1vZCArXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IGZvciByZWxhdGl2ZSBwb3NpdGlvbmVkIG5vZGVzOiBSZWxhdGl2ZSBvZmZzZXQgZnJvbSBlbGVtZW50IHRvIG9mZnNldCBwYXJlbnRcblx0XHRcdFx0dGhpcy5vZmZzZXQucGFyZW50LmxlZnQgKiBtb2RcdC1cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFRoZSBvZmZzZXRQYXJlbnQncyBvZmZzZXQgd2l0aG91dCBib3JkZXJzIChvZmZzZXQgKyBib3JkZXIpXG5cdFx0XHRcdCggKCB0aGlzLmNzc1Bvc2l0aW9uID09PSBcImZpeGVkXCIgPyAtdGhpcy5vZmZzZXQuc2Nyb2xsLmxlZnQgOiAoIHNjcm9sbElzUm9vdE5vZGUgPyAwIDogdGhpcy5vZmZzZXQuc2Nyb2xsLmxlZnQgKSApICogbW9kKVxuXHRcdFx0KVxuXHRcdH07XG5cblx0fSxcblxuXHRfZ2VuZXJhdGVQb3NpdGlvbjogZnVuY3Rpb24oIGV2ZW50LCBjb25zdHJhaW5Qb3NpdGlvbiApIHtcblxuXHRcdHZhciBjb250YWlubWVudCwgY28sIHRvcCwgbGVmdCxcblx0XHRcdG8gPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRzY3JvbGxJc1Jvb3ROb2RlID0gdGhpcy5faXNSb290Tm9kZSggdGhpcy5zY3JvbGxQYXJlbnRbIDAgXSApLFxuXHRcdFx0cGFnZVggPSBldmVudC5wYWdlWCxcblx0XHRcdHBhZ2VZID0gZXZlbnQucGFnZVk7XG5cblx0XHQvLyBDYWNoZSB0aGUgc2Nyb2xsXG5cdFx0aWYgKCAhc2Nyb2xsSXNSb290Tm9kZSB8fCAhdGhpcy5vZmZzZXQuc2Nyb2xsICkge1xuXHRcdFx0dGhpcy5vZmZzZXQuc2Nyb2xsID0ge1xuXHRcdFx0XHR0b3A6IHRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCgpLFxuXHRcdFx0XHRsZWZ0OiB0aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0KClcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Lypcblx0XHQgKiAtIFBvc2l0aW9uIGNvbnN0cmFpbmluZyAtXG5cdFx0ICogQ29uc3RyYWluIHRoZSBwb3NpdGlvbiB0byBhIG1peCBvZiBncmlkLCBjb250YWlubWVudC5cblx0XHQgKi9cblxuXHRcdC8vIElmIHdlIGFyZSBub3QgZHJhZ2dpbmcgeWV0LCB3ZSB3b24ndCBjaGVjayBmb3Igb3B0aW9uc1xuXHRcdGlmICggY29uc3RyYWluUG9zaXRpb24gKSB7XG5cdFx0XHRpZiAoIHRoaXMuY29udGFpbm1lbnQgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5yZWxhdGl2ZUNvbnRhaW5lciApe1xuXHRcdFx0XHRcdGNvID0gdGhpcy5yZWxhdGl2ZUNvbnRhaW5lci5vZmZzZXQoKTtcblx0XHRcdFx0XHRjb250YWlubWVudCA9IFtcblx0XHRcdFx0XHRcdHRoaXMuY29udGFpbm1lbnRbIDAgXSArIGNvLmxlZnQsXG5cdFx0XHRcdFx0XHR0aGlzLmNvbnRhaW5tZW50WyAxIF0gKyBjby50b3AsXG5cdFx0XHRcdFx0XHR0aGlzLmNvbnRhaW5tZW50WyAyIF0gKyBjby5sZWZ0LFxuXHRcdFx0XHRcdFx0dGhpcy5jb250YWlubWVudFsgMyBdICsgY28udG9wXG5cdFx0XHRcdFx0XTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb250YWlubWVudCA9IHRoaXMuY29udGFpbm1lbnQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZXZlbnQucGFnZVggLSB0aGlzLm9mZnNldC5jbGljay5sZWZ0IDwgY29udGFpbm1lbnRbMF0pIHtcblx0XHRcdFx0XHRwYWdlWCA9IGNvbnRhaW5tZW50WzBdICsgdGhpcy5vZmZzZXQuY2xpY2subGVmdDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZXZlbnQucGFnZVkgLSB0aGlzLm9mZnNldC5jbGljay50b3AgPCBjb250YWlubWVudFsxXSkge1xuXHRcdFx0XHRcdHBhZ2VZID0gY29udGFpbm1lbnRbMV0gKyB0aGlzLm9mZnNldC5jbGljay50b3A7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGV2ZW50LnBhZ2VYIC0gdGhpcy5vZmZzZXQuY2xpY2subGVmdCA+IGNvbnRhaW5tZW50WzJdKSB7XG5cdFx0XHRcdFx0cGFnZVggPSBjb250YWlubWVudFsyXSArIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGV2ZW50LnBhZ2VZIC0gdGhpcy5vZmZzZXQuY2xpY2sudG9wID4gY29udGFpbm1lbnRbM10pIHtcblx0XHRcdFx0XHRwYWdlWSA9IGNvbnRhaW5tZW50WzNdICsgdGhpcy5vZmZzZXQuY2xpY2sudG9wO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvLmdyaWQpIHtcblx0XHRcdFx0Ly9DaGVjayBmb3IgZ3JpZCBlbGVtZW50cyBzZXQgdG8gMCB0byBwcmV2ZW50IGRpdmlkZSBieSAwIGVycm9yIGNhdXNpbmcgaW52YWxpZCBhcmd1bWVudCBlcnJvcnMgaW4gSUUgKHNlZSB0aWNrZXQgIzY5NTApXG5cdFx0XHRcdHRvcCA9IG8uZ3JpZFsxXSA/IHRoaXMub3JpZ2luYWxQYWdlWSArIE1hdGgucm91bmQoKHBhZ2VZIC0gdGhpcy5vcmlnaW5hbFBhZ2VZKSAvIG8uZ3JpZFsxXSkgKiBvLmdyaWRbMV0gOiB0aGlzLm9yaWdpbmFsUGFnZVk7XG5cdFx0XHRcdHBhZ2VZID0gY29udGFpbm1lbnQgPyAoKHRvcCAtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA+PSBjb250YWlubWVudFsxXSB8fCB0b3AgLSB0aGlzLm9mZnNldC5jbGljay50b3AgPiBjb250YWlubWVudFszXSkgPyB0b3AgOiAoKHRvcCAtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA+PSBjb250YWlubWVudFsxXSkgPyB0b3AgLSBvLmdyaWRbMV0gOiB0b3AgKyBvLmdyaWRbMV0pKSA6IHRvcDtcblxuXHRcdFx0XHRsZWZ0ID0gby5ncmlkWzBdID8gdGhpcy5vcmlnaW5hbFBhZ2VYICsgTWF0aC5yb3VuZCgocGFnZVggLSB0aGlzLm9yaWdpbmFsUGFnZVgpIC8gby5ncmlkWzBdKSAqIG8uZ3JpZFswXSA6IHRoaXMub3JpZ2luYWxQYWdlWDtcblx0XHRcdFx0cGFnZVggPSBjb250YWlubWVudCA/ICgobGVmdCAtIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPj0gY29udGFpbm1lbnRbMF0gfHwgbGVmdCAtIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPiBjb250YWlubWVudFsyXSkgPyBsZWZ0IDogKChsZWZ0IC0gdGhpcy5vZmZzZXQuY2xpY2subGVmdCA+PSBjb250YWlubWVudFswXSkgPyBsZWZ0IC0gby5ncmlkWzBdIDogbGVmdCArIG8uZ3JpZFswXSkpIDogbGVmdDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBvLmF4aXMgPT09IFwieVwiICkge1xuXHRcdFx0XHRwYWdlWCA9IHRoaXMub3JpZ2luYWxQYWdlWDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBvLmF4aXMgPT09IFwieFwiICkge1xuXHRcdFx0XHRwYWdlWSA9IHRoaXMub3JpZ2luYWxQYWdlWTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiAoXG5cdFx0XHRcdHBhZ2VZIC1cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gVGhlIGFic29sdXRlIG1vdXNlIHBvc2l0aW9uXG5cdFx0XHRcdHRoaXMub2Zmc2V0LmNsaWNrLnRvcFx0LVx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIENsaWNrIG9mZnNldCAocmVsYXRpdmUgdG8gdGhlIGVsZW1lbnQpXG5cdFx0XHRcdHRoaXMub2Zmc2V0LnJlbGF0aXZlLnRvcCAtXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBmb3IgcmVsYXRpdmUgcG9zaXRpb25lZCBub2RlczogUmVsYXRpdmUgb2Zmc2V0IGZyb20gZWxlbWVudCB0byBvZmZzZXQgcGFyZW50XG5cdFx0XHRcdHRoaXMub2Zmc2V0LnBhcmVudC50b3AgK1x0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFRoZSBvZmZzZXRQYXJlbnQncyBvZmZzZXQgd2l0aG91dCBib3JkZXJzIChvZmZzZXQgKyBib3JkZXIpXG5cdFx0XHRcdCggdGhpcy5jc3NQb3NpdGlvbiA9PT0gXCJmaXhlZFwiID8gLXRoaXMub2Zmc2V0LnNjcm9sbC50b3AgOiAoIHNjcm9sbElzUm9vdE5vZGUgPyAwIDogdGhpcy5vZmZzZXQuc2Nyb2xsLnRvcCApIClcblx0XHRcdCksXG5cdFx0XHRsZWZ0OiAoXG5cdFx0XHRcdHBhZ2VYIC1cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gVGhlIGFic29sdXRlIG1vdXNlIHBvc2l0aW9uXG5cdFx0XHRcdHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgLVx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIENsaWNrIG9mZnNldCAocmVsYXRpdmUgdG8gdGhlIGVsZW1lbnQpXG5cdFx0XHRcdHRoaXMub2Zmc2V0LnJlbGF0aXZlLmxlZnQgLVx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgZm9yIHJlbGF0aXZlIHBvc2l0aW9uZWQgbm9kZXM6IFJlbGF0aXZlIG9mZnNldCBmcm9tIGVsZW1lbnQgdG8gb2Zmc2V0IHBhcmVudFxuXHRcdFx0XHR0aGlzLm9mZnNldC5wYXJlbnQubGVmdCArXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gVGhlIG9mZnNldFBhcmVudCdzIG9mZnNldCB3aXRob3V0IGJvcmRlcnMgKG9mZnNldCArIGJvcmRlcilcblx0XHRcdFx0KCB0aGlzLmNzc1Bvc2l0aW9uID09PSBcImZpeGVkXCIgPyAtdGhpcy5vZmZzZXQuc2Nyb2xsLmxlZnQgOiAoIHNjcm9sbElzUm9vdE5vZGUgPyAwIDogdGhpcy5vZmZzZXQuc2Nyb2xsLmxlZnQgKSApXG5cdFx0XHQpXG5cdFx0fTtcblxuXHR9LFxuXG5cdF9jbGVhcjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5oZWxwZXIucmVtb3ZlQ2xhc3MoXCJ1aS1kcmFnZ2FibGUtZHJhZ2dpbmdcIik7XG5cdFx0aWYgKHRoaXMuaGVscGVyWzBdICE9PSB0aGlzLmVsZW1lbnRbMF0gJiYgIXRoaXMuY2FuY2VsSGVscGVyUmVtb3ZhbCkge1xuXHRcdFx0dGhpcy5oZWxwZXIucmVtb3ZlKCk7XG5cdFx0fVxuXHRcdHRoaXMuaGVscGVyID0gbnVsbDtcblx0XHR0aGlzLmNhbmNlbEhlbHBlclJlbW92YWwgPSBmYWxzZTtcblx0XHRpZiAoIHRoaXMuZGVzdHJveU9uQ2xlYXIgKSB7XG5cdFx0XHR0aGlzLmRlc3Ryb3koKTtcblx0XHR9XG5cdH0sXG5cblx0X25vcm1hbGl6ZVJpZ2h0Qm90dG9tOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIHRoaXMub3B0aW9ucy5heGlzICE9PSBcInlcIiAmJiB0aGlzLmhlbHBlci5jc3MoIFwicmlnaHRcIiApICE9PSBcImF1dG9cIiApIHtcblx0XHRcdHRoaXMuaGVscGVyLndpZHRoKCB0aGlzLmhlbHBlci53aWR0aCgpICk7XG5cdFx0XHR0aGlzLmhlbHBlci5jc3MoIFwicmlnaHRcIiwgXCJhdXRvXCIgKTtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuYXhpcyAhPT0gXCJ4XCIgJiYgdGhpcy5oZWxwZXIuY3NzKCBcImJvdHRvbVwiICkgIT09IFwiYXV0b1wiICkge1xuXHRcdFx0dGhpcy5oZWxwZXIuaGVpZ2h0KCB0aGlzLmhlbHBlci5oZWlnaHQoKSApO1xuXHRcdFx0dGhpcy5oZWxwZXIuY3NzKCBcImJvdHRvbVwiLCBcImF1dG9cIiApO1xuXHRcdH1cblx0fSxcblxuXHQvLyBGcm9tIG5vdyBvbiBidWxrIHN0dWZmIC0gbWFpbmx5IGhlbHBlcnNcblxuXHRfdHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGV2ZW50LCB1aSApIHtcblx0XHR1aSA9IHVpIHx8IHRoaXMuX3VpSGFzaCgpO1xuXHRcdCQudWkucGx1Z2luLmNhbGwoIHRoaXMsIHR5cGUsIFsgZXZlbnQsIHVpLCB0aGlzIF0sIHRydWUgKTtcblxuXHRcdC8vIEFic29sdXRlIHBvc2l0aW9uIGFuZCBvZmZzZXQgKHNlZSAjNjg4NCApIGhhdmUgdG8gYmUgcmVjYWxjdWxhdGVkIGFmdGVyIHBsdWdpbnNcblx0XHRpZiAoIC9eKGRyYWd8c3RhcnR8c3RvcCkvLnRlc3QoIHR5cGUgKSApIHtcblx0XHRcdHRoaXMucG9zaXRpb25BYnMgPSB0aGlzLl9jb252ZXJ0UG9zaXRpb25UbyggXCJhYnNvbHV0ZVwiICk7XG5cdFx0XHR1aS5vZmZzZXQgPSB0aGlzLnBvc2l0aW9uQWJzO1xuXHRcdH1cblx0XHRyZXR1cm4gJC5XaWRnZXQucHJvdG90eXBlLl90cmlnZ2VyLmNhbGwoIHRoaXMsIHR5cGUsIGV2ZW50LCB1aSApO1xuXHR9LFxuXG5cdHBsdWdpbnM6IHt9LFxuXG5cdF91aUhhc2g6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRoZWxwZXI6IHRoaXMuaGVscGVyLFxuXHRcdFx0cG9zaXRpb246IHRoaXMucG9zaXRpb24sXG5cdFx0XHRvcmlnaW5hbFBvc2l0aW9uOiB0aGlzLm9yaWdpbmFsUG9zaXRpb24sXG5cdFx0XHRvZmZzZXQ6IHRoaXMucG9zaXRpb25BYnNcblx0XHR9O1xuXHR9XG5cbn0pO1xuXG4kLnVpLnBsdWdpbi5hZGQoIFwiZHJhZ2dhYmxlXCIsIFwiY29ubmVjdFRvU29ydGFibGVcIiwge1xuXHRzdGFydDogZnVuY3Rpb24oIGV2ZW50LCB1aSwgZHJhZ2dhYmxlICkge1xuXHRcdHZhciB1aVNvcnRhYmxlID0gJC5leHRlbmQoIHt9LCB1aSwge1xuXHRcdFx0aXRlbTogZHJhZ2dhYmxlLmVsZW1lbnRcblx0XHR9KTtcblxuXHRcdGRyYWdnYWJsZS5zb3J0YWJsZXMgPSBbXTtcblx0XHQkKCBkcmFnZ2FibGUub3B0aW9ucy5jb25uZWN0VG9Tb3J0YWJsZSApLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc29ydGFibGUgPSAkKCB0aGlzICkuc29ydGFibGUoIFwiaW5zdGFuY2VcIiApO1xuXG5cdFx0XHRpZiAoIHNvcnRhYmxlICYmICFzb3J0YWJsZS5vcHRpb25zLmRpc2FibGVkICkge1xuXHRcdFx0XHRkcmFnZ2FibGUuc29ydGFibGVzLnB1c2goIHNvcnRhYmxlICk7XG5cblx0XHRcdFx0Ly8gcmVmcmVzaFBvc2l0aW9ucyBpcyBjYWxsZWQgYXQgZHJhZyBzdGFydCB0byByZWZyZXNoIHRoZSBjb250YWluZXJDYWNoZVxuXHRcdFx0XHQvLyB3aGljaCBpcyB1c2VkIGluIGRyYWcuIFRoaXMgZW5zdXJlcyBpdCdzIGluaXRpYWxpemVkIGFuZCBzeW5jaHJvbml6ZWRcblx0XHRcdFx0Ly8gd2l0aCBhbnkgY2hhbmdlcyB0aGF0IG1pZ2h0IGhhdmUgaGFwcGVuZWQgb24gdGhlIHBhZ2Ugc2luY2UgaW5pdGlhbGl6YXRpb24uXG5cdFx0XHRcdHNvcnRhYmxlLnJlZnJlc2hQb3NpdGlvbnMoKTtcblx0XHRcdFx0c29ydGFibGUuX3RyaWdnZXIoXCJhY3RpdmF0ZVwiLCBldmVudCwgdWlTb3J0YWJsZSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCBldmVudCwgdWksIGRyYWdnYWJsZSApIHtcblx0XHR2YXIgdWlTb3J0YWJsZSA9ICQuZXh0ZW5kKCB7fSwgdWksIHtcblx0XHRcdGl0ZW06IGRyYWdnYWJsZS5lbGVtZW50XG5cdFx0fSk7XG5cblx0XHRkcmFnZ2FibGUuY2FuY2VsSGVscGVyUmVtb3ZhbCA9IGZhbHNlO1xuXG5cdFx0JC5lYWNoKCBkcmFnZ2FibGUuc29ydGFibGVzLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzb3J0YWJsZSA9IHRoaXM7XG5cblx0XHRcdGlmICggc29ydGFibGUuaXNPdmVyICkge1xuXHRcdFx0XHRzb3J0YWJsZS5pc092ZXIgPSAwO1xuXG5cdFx0XHRcdC8vIEFsbG93IHRoaXMgc29ydGFibGUgdG8gaGFuZGxlIHJlbW92aW5nIHRoZSBoZWxwZXJcblx0XHRcdFx0ZHJhZ2dhYmxlLmNhbmNlbEhlbHBlclJlbW92YWwgPSB0cnVlO1xuXHRcdFx0XHRzb3J0YWJsZS5jYW5jZWxIZWxwZXJSZW1vdmFsID0gZmFsc2U7XG5cblx0XHRcdFx0Ly8gVXNlIF9zdG9yZWRDU1MgVG8gcmVzdG9yZSBwcm9wZXJ0aWVzIGluIHRoZSBzb3J0YWJsZSxcblx0XHRcdFx0Ly8gYXMgdGhpcyBhbHNvIGhhbmRsZXMgcmV2ZXJ0ICgjOTY3NSkgc2luY2UgdGhlIGRyYWdnYWJsZVxuXHRcdFx0XHQvLyBtYXkgaGF2ZSBtb2RpZmllZCB0aGVtIGluIHVuZXhwZWN0ZWQgd2F5cyAoIzg4MDkpXG5cdFx0XHRcdHNvcnRhYmxlLl9zdG9yZWRDU1MgPSB7XG5cdFx0XHRcdFx0cG9zaXRpb246IHNvcnRhYmxlLnBsYWNlaG9sZGVyLmNzcyggXCJwb3NpdGlvblwiICksXG5cdFx0XHRcdFx0dG9wOiBzb3J0YWJsZS5wbGFjZWhvbGRlci5jc3MoIFwidG9wXCIgKSxcblx0XHRcdFx0XHRsZWZ0OiBzb3J0YWJsZS5wbGFjZWhvbGRlci5jc3MoIFwibGVmdFwiIClcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRzb3J0YWJsZS5fbW91c2VTdG9wKGV2ZW50KTtcblxuXHRcdFx0XHQvLyBPbmNlIGRyYWcgaGFzIGVuZGVkLCB0aGUgc29ydGFibGUgc2hvdWxkIHJldHVybiB0byB1c2luZ1xuXHRcdFx0XHQvLyBpdHMgb3JpZ2luYWwgaGVscGVyLCBub3QgdGhlIHNoYXJlZCBoZWxwZXIgZnJvbSBkcmFnZ2FibGVcblx0XHRcdFx0c29ydGFibGUub3B0aW9ucy5oZWxwZXIgPSBzb3J0YWJsZS5vcHRpb25zLl9oZWxwZXI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBQcmV2ZW50IHRoaXMgU29ydGFibGUgZnJvbSByZW1vdmluZyB0aGUgaGVscGVyLlxuXHRcdFx0XHQvLyBIb3dldmVyLCBkb24ndCBzZXQgdGhlIGRyYWdnYWJsZSB0byByZW1vdmUgdGhlIGhlbHBlclxuXHRcdFx0XHQvLyBlaXRoZXIgYXMgYW5vdGhlciBjb25uZWN0ZWQgU29ydGFibGUgbWF5IHlldCBoYW5kbGUgdGhlIHJlbW92YWwuXG5cdFx0XHRcdHNvcnRhYmxlLmNhbmNlbEhlbHBlclJlbW92YWwgPSB0cnVlO1xuXG5cdFx0XHRcdHNvcnRhYmxlLl90cmlnZ2VyKCBcImRlYWN0aXZhdGVcIiwgZXZlbnQsIHVpU29ydGFibGUgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblx0ZHJhZzogZnVuY3Rpb24oIGV2ZW50LCB1aSwgZHJhZ2dhYmxlICkge1xuXHRcdCQuZWFjaCggZHJhZ2dhYmxlLnNvcnRhYmxlcywgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaW5uZXJtb3N0SW50ZXJzZWN0aW5nID0gZmFsc2UsXG5cdFx0XHRcdHNvcnRhYmxlID0gdGhpcztcblxuXHRcdFx0Ly8gQ29weSBvdmVyIHZhcmlhYmxlcyB0aGF0IHNvcnRhYmxlJ3MgX2ludGVyc2VjdHNXaXRoIHVzZXNcblx0XHRcdHNvcnRhYmxlLnBvc2l0aW9uQWJzID0gZHJhZ2dhYmxlLnBvc2l0aW9uQWJzO1xuXHRcdFx0c29ydGFibGUuaGVscGVyUHJvcG9ydGlvbnMgPSBkcmFnZ2FibGUuaGVscGVyUHJvcG9ydGlvbnM7XG5cdFx0XHRzb3J0YWJsZS5vZmZzZXQuY2xpY2sgPSBkcmFnZ2FibGUub2Zmc2V0LmNsaWNrO1xuXG5cdFx0XHRpZiAoIHNvcnRhYmxlLl9pbnRlcnNlY3RzV2l0aCggc29ydGFibGUuY29udGFpbmVyQ2FjaGUgKSApIHtcblx0XHRcdFx0aW5uZXJtb3N0SW50ZXJzZWN0aW5nID0gdHJ1ZTtcblxuXHRcdFx0XHQkLmVhY2goIGRyYWdnYWJsZS5zb3J0YWJsZXMsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdC8vIENvcHkgb3ZlciB2YXJpYWJsZXMgdGhhdCBzb3J0YWJsZSdzIF9pbnRlcnNlY3RzV2l0aCB1c2VzXG5cdFx0XHRcdFx0dGhpcy5wb3NpdGlvbkFicyA9IGRyYWdnYWJsZS5wb3NpdGlvbkFicztcblx0XHRcdFx0XHR0aGlzLmhlbHBlclByb3BvcnRpb25zID0gZHJhZ2dhYmxlLmhlbHBlclByb3BvcnRpb25zO1xuXHRcdFx0XHRcdHRoaXMub2Zmc2V0LmNsaWNrID0gZHJhZ2dhYmxlLm9mZnNldC5jbGljaztcblxuXHRcdFx0XHRcdGlmICggdGhpcyAhPT0gc29ydGFibGUgJiZcblx0XHRcdFx0XHRcdFx0dGhpcy5faW50ZXJzZWN0c1dpdGgoIHRoaXMuY29udGFpbmVyQ2FjaGUgKSAmJlxuXHRcdFx0XHRcdFx0XHQkLmNvbnRhaW5zKCBzb3J0YWJsZS5lbGVtZW50WyAwIF0sIHRoaXMuZWxlbWVudFsgMCBdICkgKSB7XG5cdFx0XHRcdFx0XHRpbm5lcm1vc3RJbnRlcnNlY3RpbmcgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gaW5uZXJtb3N0SW50ZXJzZWN0aW5nO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBpbm5lcm1vc3RJbnRlcnNlY3RpbmcgKSB7XG5cdFx0XHRcdC8vIElmIGl0IGludGVyc2VjdHMsIHdlIHVzZSBhIGxpdHRsZSBpc092ZXIgdmFyaWFibGUgYW5kIHNldCBpdCBvbmNlLFxuXHRcdFx0XHQvLyBzbyB0aGF0IHRoZSBtb3ZlLWluIHN0dWZmIGdldHMgZmlyZWQgb25seSBvbmNlLlxuXHRcdFx0XHRpZiAoICFzb3J0YWJsZS5pc092ZXIgKSB7XG5cdFx0XHRcdFx0c29ydGFibGUuaXNPdmVyID0gMTtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIGRyYWdnYWJsZSdzIHBhcmVudCBpbiBjYXNlIHdlIG5lZWQgdG8gcmVhcHBlbmQgdG8gaXQgbGF0ZXIuXG5cdFx0XHRcdFx0ZHJhZ2dhYmxlLl9wYXJlbnQgPSB1aS5oZWxwZXIucGFyZW50KCk7XG5cblx0XHRcdFx0XHRzb3J0YWJsZS5jdXJyZW50SXRlbSA9IHVpLmhlbHBlclxuXHRcdFx0XHRcdFx0LmFwcGVuZFRvKCBzb3J0YWJsZS5lbGVtZW50IClcblx0XHRcdFx0XHRcdC5kYXRhKCBcInVpLXNvcnRhYmxlLWl0ZW1cIiwgdHJ1ZSApO1xuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgaGVscGVyIG9wdGlvbiB0byBsYXRlciByZXN0b3JlIGl0XG5cdFx0XHRcdFx0c29ydGFibGUub3B0aW9ucy5faGVscGVyID0gc29ydGFibGUub3B0aW9ucy5oZWxwZXI7XG5cblx0XHRcdFx0XHRzb3J0YWJsZS5vcHRpb25zLmhlbHBlciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHVpLmhlbHBlclsgMCBdO1xuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHQvLyBGaXJlIHRoZSBzdGFydCBldmVudHMgb2YgdGhlIHNvcnRhYmxlIHdpdGggb3VyIHBhc3NlZCBicm93c2VyIGV2ZW50LFxuXHRcdFx0XHRcdC8vIGFuZCBvdXIgb3duIGhlbHBlciAoc28gaXQgZG9lc24ndCBjcmVhdGUgYSBuZXcgb25lKVxuXHRcdFx0XHRcdGV2ZW50LnRhcmdldCA9IHNvcnRhYmxlLmN1cnJlbnRJdGVtWyAwIF07XG5cdFx0XHRcdFx0c29ydGFibGUuX21vdXNlQ2FwdHVyZSggZXZlbnQsIHRydWUgKTtcblx0XHRcdFx0XHRzb3J0YWJsZS5fbW91c2VTdGFydCggZXZlbnQsIHRydWUsIHRydWUgKTtcblxuXHRcdFx0XHRcdC8vIEJlY2F1c2UgdGhlIGJyb3dzZXIgZXZlbnQgaXMgd2F5IG9mZiB0aGUgbmV3IGFwcGVuZGVkIHBvcnRsZXQsXG5cdFx0XHRcdFx0Ly8gbW9kaWZ5IG5lY2Vzc2FyeSB2YXJpYWJsZXMgdG8gcmVmbGVjdCB0aGUgY2hhbmdlc1xuXHRcdFx0XHRcdHNvcnRhYmxlLm9mZnNldC5jbGljay50b3AgPSBkcmFnZ2FibGUub2Zmc2V0LmNsaWNrLnRvcDtcblx0XHRcdFx0XHRzb3J0YWJsZS5vZmZzZXQuY2xpY2subGVmdCA9IGRyYWdnYWJsZS5vZmZzZXQuY2xpY2subGVmdDtcblx0XHRcdFx0XHRzb3J0YWJsZS5vZmZzZXQucGFyZW50LmxlZnQgLT0gZHJhZ2dhYmxlLm9mZnNldC5wYXJlbnQubGVmdCAtXG5cdFx0XHRcdFx0XHRzb3J0YWJsZS5vZmZzZXQucGFyZW50LmxlZnQ7XG5cdFx0XHRcdFx0c29ydGFibGUub2Zmc2V0LnBhcmVudC50b3AgLT0gZHJhZ2dhYmxlLm9mZnNldC5wYXJlbnQudG9wIC1cblx0XHRcdFx0XHRcdHNvcnRhYmxlLm9mZnNldC5wYXJlbnQudG9wO1xuXG5cdFx0XHRcdFx0ZHJhZ2dhYmxlLl90cmlnZ2VyKCBcInRvU29ydGFibGVcIiwgZXZlbnQgKTtcblxuXHRcdFx0XHRcdC8vIEluZm9ybSBkcmFnZ2FibGUgdGhhdCB0aGUgaGVscGVyIGlzIGluIGEgdmFsaWQgZHJvcCB6b25lLFxuXHRcdFx0XHRcdC8vIHVzZWQgc29sZWx5IGluIHRoZSByZXZlcnQgb3B0aW9uIHRvIGhhbmRsZSBcInZhbGlkL2ludmFsaWRcIi5cblx0XHRcdFx0XHRkcmFnZ2FibGUuZHJvcHBlZCA9IHNvcnRhYmxlLmVsZW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBOZWVkIHRvIHJlZnJlc2hQb3NpdGlvbnMgb2YgYWxsIHNvcnRhYmxlcyBpbiB0aGUgY2FzZSB0aGF0XG5cdFx0XHRcdFx0Ly8gYWRkaW5nIHRvIG9uZSBzb3J0YWJsZSBjaGFuZ2VzIHRoZSBsb2NhdGlvbiBvZiB0aGUgb3RoZXIgc29ydGFibGVzICgjOTY3NSlcblx0XHRcdFx0XHQkLmVhY2goIGRyYWdnYWJsZS5zb3J0YWJsZXMsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0dGhpcy5yZWZyZXNoUG9zaXRpb25zKCk7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHQvLyBoYWNrIHNvIHJlY2VpdmUvdXBkYXRlIGNhbGxiYWNrcyB3b3JrIChtb3N0bHkpXG5cdFx0XHRcdFx0ZHJhZ2dhYmxlLmN1cnJlbnRJdGVtID0gZHJhZ2dhYmxlLmVsZW1lbnQ7XG5cdFx0XHRcdFx0c29ydGFibGUuZnJvbU91dHNpZGUgPSBkcmFnZ2FibGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHNvcnRhYmxlLmN1cnJlbnRJdGVtICkge1xuXHRcdFx0XHRcdHNvcnRhYmxlLl9tb3VzZURyYWcoIGV2ZW50ICk7XG5cdFx0XHRcdFx0Ly8gQ29weSB0aGUgc29ydGFibGUncyBwb3NpdGlvbiBiZWNhdXNlIHRoZSBkcmFnZ2FibGUncyBjYW4gcG90ZW50aWFsbHkgcmVmbGVjdFxuXHRcdFx0XHRcdC8vIGEgcmVsYXRpdmUgcG9zaXRpb24sIHdoaWxlIHNvcnRhYmxlIGlzIGFsd2F5cyBhYnNvbHV0ZSwgd2hpY2ggdGhlIGRyYWdnZWRcblx0XHRcdFx0XHQvLyBlbGVtZW50IGhhcyBub3cgYmVjb21lLiAoIzg4MDkpXG5cdFx0XHRcdFx0dWkucG9zaXRpb24gPSBzb3J0YWJsZS5wb3NpdGlvbjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gSWYgaXQgZG9lc24ndCBpbnRlcnNlY3Qgd2l0aCB0aGUgc29ydGFibGUsIGFuZCBpdCBpbnRlcnNlY3RlZCBiZWZvcmUsXG5cdFx0XHRcdC8vIHdlIGZha2UgdGhlIGRyYWcgc3RvcCBvZiB0aGUgc29ydGFibGUsIGJ1dCBtYWtlIHN1cmUgaXQgZG9lc24ndCByZW1vdmVcblx0XHRcdFx0Ly8gdGhlIGhlbHBlciBieSB1c2luZyBjYW5jZWxIZWxwZXJSZW1vdmFsLlxuXHRcdFx0XHRpZiAoIHNvcnRhYmxlLmlzT3ZlciApIHtcblxuXHRcdFx0XHRcdHNvcnRhYmxlLmlzT3ZlciA9IDA7XG5cdFx0XHRcdFx0c29ydGFibGUuY2FuY2VsSGVscGVyUmVtb3ZhbCA9IHRydWU7XG5cblx0XHRcdFx0XHQvLyBDYWxsaW5nIHNvcnRhYmxlJ3MgbW91c2VTdG9wIHdvdWxkIHRyaWdnZXIgYSByZXZlcnQsXG5cdFx0XHRcdFx0Ly8gc28gcmV2ZXJ0IG11c3QgYmUgdGVtcG9yYXJpbHkgZmFsc2UgdW50aWwgYWZ0ZXIgbW91c2VTdG9wIGlzIGNhbGxlZC5cblx0XHRcdFx0XHRzb3J0YWJsZS5vcHRpb25zLl9yZXZlcnQgPSBzb3J0YWJsZS5vcHRpb25zLnJldmVydDtcblx0XHRcdFx0XHRzb3J0YWJsZS5vcHRpb25zLnJldmVydCA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0c29ydGFibGUuX3RyaWdnZXIoIFwib3V0XCIsIGV2ZW50LCBzb3J0YWJsZS5fdWlIYXNoKCBzb3J0YWJsZSApICk7XG5cdFx0XHRcdFx0c29ydGFibGUuX21vdXNlU3RvcCggZXZlbnQsIHRydWUgKTtcblxuXHRcdFx0XHRcdC8vIHJlc3RvcmUgc29ydGFibGUgYmVoYXZpb3JzIHRoYXQgd2VyZSBtb2RmaWVkXG5cdFx0XHRcdFx0Ly8gd2hlbiB0aGUgZHJhZ2dhYmxlIGVudGVyZWQgdGhlIHNvcnRhYmxlIGFyZWEgKCM5NDgxKVxuXHRcdFx0XHRcdHNvcnRhYmxlLm9wdGlvbnMucmV2ZXJ0ID0gc29ydGFibGUub3B0aW9ucy5fcmV2ZXJ0O1xuXHRcdFx0XHRcdHNvcnRhYmxlLm9wdGlvbnMuaGVscGVyID0gc29ydGFibGUub3B0aW9ucy5faGVscGVyO1xuXG5cdFx0XHRcdFx0aWYgKCBzb3J0YWJsZS5wbGFjZWhvbGRlciApIHtcblx0XHRcdFx0XHRcdHNvcnRhYmxlLnBsYWNlaG9sZGVyLnJlbW92ZSgpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFJlc3RvcmUgYW5kIHJlY2FsY3VsYXRlIHRoZSBkcmFnZ2FibGUncyBvZmZzZXQgY29uc2lkZXJpbmcgdGhlIHNvcnRhYmxlXG5cdFx0XHRcdFx0Ly8gbWF5IGhhdmUgbW9kaWZpZWQgdGhlbSBpbiB1bmV4cGVjdGVkIHdheXMuICgjODgwOSwgIzEwNjY5KVxuXHRcdFx0XHRcdHVpLmhlbHBlci5hcHBlbmRUbyggZHJhZ2dhYmxlLl9wYXJlbnQgKTtcblx0XHRcdFx0XHRkcmFnZ2FibGUuX3JlZnJlc2hPZmZzZXRzKCBldmVudCApO1xuXHRcdFx0XHRcdHVpLnBvc2l0aW9uID0gZHJhZ2dhYmxlLl9nZW5lcmF0ZVBvc2l0aW9uKCBldmVudCwgdHJ1ZSApO1xuXG5cdFx0XHRcdFx0ZHJhZ2dhYmxlLl90cmlnZ2VyKCBcImZyb21Tb3J0YWJsZVwiLCBldmVudCApO1xuXG5cdFx0XHRcdFx0Ly8gSW5mb3JtIGRyYWdnYWJsZSB0aGF0IHRoZSBoZWxwZXIgaXMgbm8gbG9uZ2VyIGluIGEgdmFsaWQgZHJvcCB6b25lXG5cdFx0XHRcdFx0ZHJhZ2dhYmxlLmRyb3BwZWQgPSBmYWxzZTtcblxuXHRcdFx0XHRcdC8vIE5lZWQgdG8gcmVmcmVzaFBvc2l0aW9ucyBvZiBhbGwgc29ydGFibGVzIGp1c3QgaW4gY2FzZSByZW1vdmluZ1xuXHRcdFx0XHRcdC8vIGZyb20gb25lIHNvcnRhYmxlIGNoYW5nZXMgdGhlIGxvY2F0aW9uIG9mIG90aGVyIHNvcnRhYmxlcyAoIzk2NzUpXG5cdFx0XHRcdFx0JC5lYWNoKCBkcmFnZ2FibGUuc29ydGFibGVzLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHRoaXMucmVmcmVzaFBvc2l0aW9ucygpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG4kLnVpLnBsdWdpbi5hZGQoXCJkcmFnZ2FibGVcIiwgXCJjdXJzb3JcIiwge1xuXHRzdGFydDogZnVuY3Rpb24oIGV2ZW50LCB1aSwgaW5zdGFuY2UgKSB7XG5cdFx0dmFyIHQgPSAkKCBcImJvZHlcIiApLFxuXHRcdFx0byA9IGluc3RhbmNlLm9wdGlvbnM7XG5cblx0XHRpZiAodC5jc3MoXCJjdXJzb3JcIikpIHtcblx0XHRcdG8uX2N1cnNvciA9IHQuY3NzKFwiY3Vyc29yXCIpO1xuXHRcdH1cblx0XHR0LmNzcyhcImN1cnNvclwiLCBvLmN1cnNvcik7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCBldmVudCwgdWksIGluc3RhbmNlICkge1xuXHRcdHZhciBvID0gaW5zdGFuY2Uub3B0aW9ucztcblx0XHRpZiAoby5fY3Vyc29yKSB7XG5cdFx0XHQkKFwiYm9keVwiKS5jc3MoXCJjdXJzb3JcIiwgby5fY3Vyc29yKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4kLnVpLnBsdWdpbi5hZGQoXCJkcmFnZ2FibGVcIiwgXCJvcGFjaXR5XCIsIHtcblx0c3RhcnQ6IGZ1bmN0aW9uKCBldmVudCwgdWksIGluc3RhbmNlICkge1xuXHRcdHZhciB0ID0gJCggdWkuaGVscGVyICksXG5cdFx0XHRvID0gaW5zdGFuY2Uub3B0aW9ucztcblx0XHRpZiAodC5jc3MoXCJvcGFjaXR5XCIpKSB7XG5cdFx0XHRvLl9vcGFjaXR5ID0gdC5jc3MoXCJvcGFjaXR5XCIpO1xuXHRcdH1cblx0XHR0LmNzcyhcIm9wYWNpdHlcIiwgby5vcGFjaXR5KTtcblx0fSxcblx0c3RvcDogZnVuY3Rpb24oIGV2ZW50LCB1aSwgaW5zdGFuY2UgKSB7XG5cdFx0dmFyIG8gPSBpbnN0YW5jZS5vcHRpb25zO1xuXHRcdGlmIChvLl9vcGFjaXR5KSB7XG5cdFx0XHQkKHVpLmhlbHBlcikuY3NzKFwib3BhY2l0eVwiLCBvLl9vcGFjaXR5KTtcblx0XHR9XG5cdH1cbn0pO1xuXG4kLnVpLnBsdWdpbi5hZGQoXCJkcmFnZ2FibGVcIiwgXCJzY3JvbGxcIiwge1xuXHRzdGFydDogZnVuY3Rpb24oIGV2ZW50LCB1aSwgaSApIHtcblx0XHRpZiAoICFpLnNjcm9sbFBhcmVudE5vdEhpZGRlbiApIHtcblx0XHRcdGkuc2Nyb2xsUGFyZW50Tm90SGlkZGVuID0gaS5oZWxwZXIuc2Nyb2xsUGFyZW50KCBmYWxzZSApO1xuXHRcdH1cblxuXHRcdGlmICggaS5zY3JvbGxQYXJlbnROb3RIaWRkZW5bIDAgXSAhPT0gaS5kb2N1bWVudFsgMCBdICYmIGkuc2Nyb2xsUGFyZW50Tm90SGlkZGVuWyAwIF0udGFnTmFtZSAhPT0gXCJIVE1MXCIgKSB7XG5cdFx0XHRpLm92ZXJmbG93T2Zmc2V0ID0gaS5zY3JvbGxQYXJlbnROb3RIaWRkZW4ub2Zmc2V0KCk7XG5cdFx0fVxuXHR9LFxuXHRkcmFnOiBmdW5jdGlvbiggZXZlbnQsIHVpLCBpICApIHtcblxuXHRcdHZhciBvID0gaS5vcHRpb25zLFxuXHRcdFx0c2Nyb2xsZWQgPSBmYWxzZSxcblx0XHRcdHNjcm9sbFBhcmVudCA9IGkuc2Nyb2xsUGFyZW50Tm90SGlkZGVuWyAwIF0sXG5cdFx0XHRkb2N1bWVudCA9IGkuZG9jdW1lbnRbIDAgXTtcblxuXHRcdGlmICggc2Nyb2xsUGFyZW50ICE9PSBkb2N1bWVudCAmJiBzY3JvbGxQYXJlbnQudGFnTmFtZSAhPT0gXCJIVE1MXCIgKSB7XG5cdFx0XHRpZiAoICFvLmF4aXMgfHwgby5heGlzICE9PSBcInhcIiApIHtcblx0XHRcdFx0aWYgKCAoIGkub3ZlcmZsb3dPZmZzZXQudG9wICsgc2Nyb2xsUGFyZW50Lm9mZnNldEhlaWdodCApIC0gZXZlbnQucGFnZVkgPCBvLnNjcm9sbFNlbnNpdGl2aXR5ICkge1xuXHRcdFx0XHRcdHNjcm9sbFBhcmVudC5zY3JvbGxUb3AgPSBzY3JvbGxlZCA9IHNjcm9sbFBhcmVudC5zY3JvbGxUb3AgKyBvLnNjcm9sbFNwZWVkO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBldmVudC5wYWdlWSAtIGkub3ZlcmZsb3dPZmZzZXQudG9wIDwgby5zY3JvbGxTZW5zaXRpdml0eSApIHtcblx0XHRcdFx0XHRzY3JvbGxQYXJlbnQuc2Nyb2xsVG9wID0gc2Nyb2xsZWQgPSBzY3JvbGxQYXJlbnQuc2Nyb2xsVG9wIC0gby5zY3JvbGxTcGVlZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICFvLmF4aXMgfHwgby5heGlzICE9PSBcInlcIiApIHtcblx0XHRcdFx0aWYgKCAoIGkub3ZlcmZsb3dPZmZzZXQubGVmdCArIHNjcm9sbFBhcmVudC5vZmZzZXRXaWR0aCApIC0gZXZlbnQucGFnZVggPCBvLnNjcm9sbFNlbnNpdGl2aXR5ICkge1xuXHRcdFx0XHRcdHNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0ID0gc2Nyb2xsZWQgPSBzY3JvbGxQYXJlbnQuc2Nyb2xsTGVmdCArIG8uc2Nyb2xsU3BlZWQ7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIGV2ZW50LnBhZ2VYIC0gaS5vdmVyZmxvd09mZnNldC5sZWZ0IDwgby5zY3JvbGxTZW5zaXRpdml0eSApIHtcblx0XHRcdFx0XHRzY3JvbGxQYXJlbnQuc2Nyb2xsTGVmdCA9IHNjcm9sbGVkID0gc2Nyb2xsUGFyZW50LnNjcm9sbExlZnQgLSBvLnNjcm9sbFNwZWVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRpZiAoIW8uYXhpcyB8fCBvLmF4aXMgIT09IFwieFwiKSB7XG5cdFx0XHRcdGlmIChldmVudC5wYWdlWSAtICQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpIDwgby5zY3JvbGxTZW5zaXRpdml0eSkge1xuXHRcdFx0XHRcdHNjcm9sbGVkID0gJChkb2N1bWVudCkuc2Nyb2xsVG9wKCQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpIC0gby5zY3JvbGxTcGVlZCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoJCh3aW5kb3cpLmhlaWdodCgpIC0gKGV2ZW50LnBhZ2VZIC0gJChkb2N1bWVudCkuc2Nyb2xsVG9wKCkpIDwgby5zY3JvbGxTZW5zaXRpdml0eSkge1xuXHRcdFx0XHRcdHNjcm9sbGVkID0gJChkb2N1bWVudCkuc2Nyb2xsVG9wKCQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpICsgby5zY3JvbGxTcGVlZCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCFvLmF4aXMgfHwgby5heGlzICE9PSBcInlcIikge1xuXHRcdFx0XHRpZiAoZXZlbnQucGFnZVggLSAkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkgPCBvLnNjcm9sbFNlbnNpdGl2aXR5KSB7XG5cdFx0XHRcdFx0c2Nyb2xsZWQgPSAkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCQoZG9jdW1lbnQpLnNjcm9sbExlZnQoKSAtIG8uc2Nyb2xsU3BlZWQpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCQod2luZG93KS53aWR0aCgpIC0gKGV2ZW50LnBhZ2VYIC0gJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgpKSA8IG8uc2Nyb2xsU2Vuc2l0aXZpdHkpIHtcblx0XHRcdFx0XHRzY3JvbGxlZCA9ICQoZG9jdW1lbnQpLnNjcm9sbExlZnQoJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgpICsgby5zY3JvbGxTcGVlZCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmIChzY3JvbGxlZCAhPT0gZmFsc2UgJiYgJC51aS5kZG1hbmFnZXIgJiYgIW8uZHJvcEJlaGF2aW91cikge1xuXHRcdFx0JC51aS5kZG1hbmFnZXIucHJlcGFyZU9mZnNldHMoaSwgZXZlbnQpO1xuXHRcdH1cblxuXHR9XG59KTtcblxuJC51aS5wbHVnaW4uYWRkKFwiZHJhZ2dhYmxlXCIsIFwic25hcFwiLCB7XG5cdHN0YXJ0OiBmdW5jdGlvbiggZXZlbnQsIHVpLCBpICkge1xuXG5cdFx0dmFyIG8gPSBpLm9wdGlvbnM7XG5cblx0XHRpLnNuYXBFbGVtZW50cyA9IFtdO1xuXG5cdFx0JChvLnNuYXAuY29uc3RydWN0b3IgIT09IFN0cmluZyA/ICggby5zbmFwLml0ZW1zIHx8IFwiOmRhdGEodWktZHJhZ2dhYmxlKVwiICkgOiBvLnNuYXApLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgJHQgPSAkKHRoaXMpLFxuXHRcdFx0XHQkbyA9ICR0Lm9mZnNldCgpO1xuXHRcdFx0aWYgKHRoaXMgIT09IGkuZWxlbWVudFswXSkge1xuXHRcdFx0XHRpLnNuYXBFbGVtZW50cy5wdXNoKHtcblx0XHRcdFx0XHRpdGVtOiB0aGlzLFxuXHRcdFx0XHRcdHdpZHRoOiAkdC5vdXRlcldpZHRoKCksIGhlaWdodDogJHQub3V0ZXJIZWlnaHQoKSxcblx0XHRcdFx0XHR0b3A6ICRvLnRvcCwgbGVmdDogJG8ubGVmdFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHR9LFxuXHRkcmFnOiBmdW5jdGlvbiggZXZlbnQsIHVpLCBpbnN0ICkge1xuXG5cdFx0dmFyIHRzLCBicywgbHMsIHJzLCBsLCByLCB0LCBiLCBpLCBmaXJzdCxcblx0XHRcdG8gPSBpbnN0Lm9wdGlvbnMsXG5cdFx0XHRkID0gby5zbmFwVG9sZXJhbmNlLFxuXHRcdFx0eDEgPSB1aS5vZmZzZXQubGVmdCwgeDIgPSB4MSArIGluc3QuaGVscGVyUHJvcG9ydGlvbnMud2lkdGgsXG5cdFx0XHR5MSA9IHVpLm9mZnNldC50b3AsIHkyID0geTEgKyBpbnN0LmhlbHBlclByb3BvcnRpb25zLmhlaWdodDtcblxuXHRcdGZvciAoaSA9IGluc3Quc25hcEVsZW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKXtcblxuXHRcdFx0bCA9IGluc3Quc25hcEVsZW1lbnRzW2ldLmxlZnQgLSBpbnN0Lm1hcmdpbnMubGVmdDtcblx0XHRcdHIgPSBsICsgaW5zdC5zbmFwRWxlbWVudHNbaV0ud2lkdGg7XG5cdFx0XHR0ID0gaW5zdC5zbmFwRWxlbWVudHNbaV0udG9wIC0gaW5zdC5tYXJnaW5zLnRvcDtcblx0XHRcdGIgPSB0ICsgaW5zdC5zbmFwRWxlbWVudHNbaV0uaGVpZ2h0O1xuXG5cdFx0XHRpZiAoIHgyIDwgbCAtIGQgfHwgeDEgPiByICsgZCB8fCB5MiA8IHQgLSBkIHx8IHkxID4gYiArIGQgfHwgISQuY29udGFpbnMoIGluc3Quc25hcEVsZW1lbnRzWyBpIF0uaXRlbS5vd25lckRvY3VtZW50LCBpbnN0LnNuYXBFbGVtZW50c1sgaSBdLml0ZW0gKSApIHtcblx0XHRcdFx0aWYgKGluc3Quc25hcEVsZW1lbnRzW2ldLnNuYXBwaW5nKSB7XG5cdFx0XHRcdFx0KGluc3Qub3B0aW9ucy5zbmFwLnJlbGVhc2UgJiYgaW5zdC5vcHRpb25zLnNuYXAucmVsZWFzZS5jYWxsKGluc3QuZWxlbWVudCwgZXZlbnQsICQuZXh0ZW5kKGluc3QuX3VpSGFzaCgpLCB7IHNuYXBJdGVtOiBpbnN0LnNuYXBFbGVtZW50c1tpXS5pdGVtIH0pKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5zdC5zbmFwRWxlbWVudHNbaV0uc25hcHBpbmcgPSBmYWxzZTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvLnNuYXBNb2RlICE9PSBcImlubmVyXCIpIHtcblx0XHRcdFx0dHMgPSBNYXRoLmFicyh0IC0geTIpIDw9IGQ7XG5cdFx0XHRcdGJzID0gTWF0aC5hYnMoYiAtIHkxKSA8PSBkO1xuXHRcdFx0XHRscyA9IE1hdGguYWJzKGwgLSB4MikgPD0gZDtcblx0XHRcdFx0cnMgPSBNYXRoLmFicyhyIC0geDEpIDw9IGQ7XG5cdFx0XHRcdGlmICh0cykge1xuXHRcdFx0XHRcdHVpLnBvc2l0aW9uLnRvcCA9IGluc3QuX2NvbnZlcnRQb3NpdGlvblRvKFwicmVsYXRpdmVcIiwgeyB0b3A6IHQgLSBpbnN0LmhlbHBlclByb3BvcnRpb25zLmhlaWdodCwgbGVmdDogMCB9KS50b3A7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGJzKSB7XG5cdFx0XHRcdFx0dWkucG9zaXRpb24udG9wID0gaW5zdC5fY29udmVydFBvc2l0aW9uVG8oXCJyZWxhdGl2ZVwiLCB7IHRvcDogYiwgbGVmdDogMCB9KS50b3A7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGxzKSB7XG5cdFx0XHRcdFx0dWkucG9zaXRpb24ubGVmdCA9IGluc3QuX2NvbnZlcnRQb3NpdGlvblRvKFwicmVsYXRpdmVcIiwgeyB0b3A6IDAsIGxlZnQ6IGwgLSBpbnN0LmhlbHBlclByb3BvcnRpb25zLndpZHRoIH0pLmxlZnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHJzKSB7XG5cdFx0XHRcdFx0dWkucG9zaXRpb24ubGVmdCA9IGluc3QuX2NvbnZlcnRQb3NpdGlvblRvKFwicmVsYXRpdmVcIiwgeyB0b3A6IDAsIGxlZnQ6IHIgfSkubGVmdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmaXJzdCA9ICh0cyB8fCBicyB8fCBscyB8fCBycyk7XG5cblx0XHRcdGlmIChvLnNuYXBNb2RlICE9PSBcIm91dGVyXCIpIHtcblx0XHRcdFx0dHMgPSBNYXRoLmFicyh0IC0geTEpIDw9IGQ7XG5cdFx0XHRcdGJzID0gTWF0aC5hYnMoYiAtIHkyKSA8PSBkO1xuXHRcdFx0XHRscyA9IE1hdGguYWJzKGwgLSB4MSkgPD0gZDtcblx0XHRcdFx0cnMgPSBNYXRoLmFicyhyIC0geDIpIDw9IGQ7XG5cdFx0XHRcdGlmICh0cykge1xuXHRcdFx0XHRcdHVpLnBvc2l0aW9uLnRvcCA9IGluc3QuX2NvbnZlcnRQb3NpdGlvblRvKFwicmVsYXRpdmVcIiwgeyB0b3A6IHQsIGxlZnQ6IDAgfSkudG9wO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChicykge1xuXHRcdFx0XHRcdHVpLnBvc2l0aW9uLnRvcCA9IGluc3QuX2NvbnZlcnRQb3NpdGlvblRvKFwicmVsYXRpdmVcIiwgeyB0b3A6IGIgLSBpbnN0LmhlbHBlclByb3BvcnRpb25zLmhlaWdodCwgbGVmdDogMCB9KS50b3A7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGxzKSB7XG5cdFx0XHRcdFx0dWkucG9zaXRpb24ubGVmdCA9IGluc3QuX2NvbnZlcnRQb3NpdGlvblRvKFwicmVsYXRpdmVcIiwgeyB0b3A6IDAsIGxlZnQ6IGwgfSkubGVmdDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocnMpIHtcblx0XHRcdFx0XHR1aS5wb3NpdGlvbi5sZWZ0ID0gaW5zdC5fY29udmVydFBvc2l0aW9uVG8oXCJyZWxhdGl2ZVwiLCB7IHRvcDogMCwgbGVmdDogciAtIGluc3QuaGVscGVyUHJvcG9ydGlvbnMud2lkdGggfSkubGVmdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWluc3Quc25hcEVsZW1lbnRzW2ldLnNuYXBwaW5nICYmICh0cyB8fCBicyB8fCBscyB8fCBycyB8fCBmaXJzdCkpIHtcblx0XHRcdFx0KGluc3Qub3B0aW9ucy5zbmFwLnNuYXAgJiYgaW5zdC5vcHRpb25zLnNuYXAuc25hcC5jYWxsKGluc3QuZWxlbWVudCwgZXZlbnQsICQuZXh0ZW5kKGluc3QuX3VpSGFzaCgpLCB7IHNuYXBJdGVtOiBpbnN0LnNuYXBFbGVtZW50c1tpXS5pdGVtIH0pKSk7XG5cdFx0XHR9XG5cdFx0XHRpbnN0LnNuYXBFbGVtZW50c1tpXS5zbmFwcGluZyA9ICh0cyB8fCBicyB8fCBscyB8fCBycyB8fCBmaXJzdCk7XG5cblx0XHR9XG5cblx0fVxufSk7XG5cbiQudWkucGx1Z2luLmFkZChcImRyYWdnYWJsZVwiLCBcInN0YWNrXCIsIHtcblx0c3RhcnQ6IGZ1bmN0aW9uKCBldmVudCwgdWksIGluc3RhbmNlICkge1xuXHRcdHZhciBtaW4sXG5cdFx0XHRvID0gaW5zdGFuY2Uub3B0aW9ucyxcblx0XHRcdGdyb3VwID0gJC5tYWtlQXJyYXkoJChvLnN0YWNrKSkuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRcdHJldHVybiAocGFyc2VJbnQoJChhKS5jc3MoXCJ6SW5kZXhcIiksIDEwKSB8fCAwKSAtIChwYXJzZUludCgkKGIpLmNzcyhcInpJbmRleFwiKSwgMTApIHx8IDApO1xuXHRcdFx0fSk7XG5cblx0XHRpZiAoIWdyb3VwLmxlbmd0aCkgeyByZXR1cm47IH1cblxuXHRcdG1pbiA9IHBhcnNlSW50KCQoZ3JvdXBbMF0pLmNzcyhcInpJbmRleFwiKSwgMTApIHx8IDA7XG5cdFx0JChncm91cCkuZWFjaChmdW5jdGlvbihpKSB7XG5cdFx0XHQkKHRoaXMpLmNzcyhcInpJbmRleFwiLCBtaW4gKyBpKTtcblx0XHR9KTtcblx0XHR0aGlzLmNzcyhcInpJbmRleFwiLCAobWluICsgZ3JvdXAubGVuZ3RoKSk7XG5cdH1cbn0pO1xuXG4kLnVpLnBsdWdpbi5hZGQoXCJkcmFnZ2FibGVcIiwgXCJ6SW5kZXhcIiwge1xuXHRzdGFydDogZnVuY3Rpb24oIGV2ZW50LCB1aSwgaW5zdGFuY2UgKSB7XG5cdFx0dmFyIHQgPSAkKCB1aS5oZWxwZXIgKSxcblx0XHRcdG8gPSBpbnN0YW5jZS5vcHRpb25zO1xuXG5cdFx0aWYgKHQuY3NzKFwiekluZGV4XCIpKSB7XG5cdFx0XHRvLl96SW5kZXggPSB0LmNzcyhcInpJbmRleFwiKTtcblx0XHR9XG5cdFx0dC5jc3MoXCJ6SW5kZXhcIiwgby56SW5kZXgpO1xuXHR9LFxuXHRzdG9wOiBmdW5jdGlvbiggZXZlbnQsIHVpLCBpbnN0YW5jZSApIHtcblx0XHR2YXIgbyA9IGluc3RhbmNlLm9wdGlvbnM7XG5cblx0XHRpZiAoby5fekluZGV4KSB7XG5cdFx0XHQkKHVpLmhlbHBlcikuY3NzKFwiekluZGV4XCIsIG8uX3pJbmRleCk7XG5cdFx0fVxuXHR9XG59KTtcblxucmV0dXJuICQudWkuZHJhZ2dhYmxlO1xuXG59KSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vanF1ZXJ5LXVpL3VpL2RyYWdnYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTA3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDUiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 1084:
/* unknown exports provided */
/*!************************************************************!*\
  !*** ./~/magnific-popup/dist/jquery.magnific-popup.min.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(__webpack_provided_window_dot_jQuery) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! Magnific Popup - v1.1.0 - 2016-02-20\n* http://dimsemenov.com/plugins/magnific-popup/\n* Copyright (c) 2016 Dmitry Semenov; */\n!function(a){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ 41)], __WEBPACK_AMD_DEFINE_FACTORY__ = (a),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):a(\"object\"==typeof exports?require(\"jquery\"):window.jQuery||window.Zepto)}(function(a){var b,c,d,e,f,g,h=\"Close\",i=\"BeforeClose\",j=\"AfterClose\",k=\"BeforeAppend\",l=\"MarkupParse\",m=\"Open\",n=\"Change\",o=\"mfp\",p=\".\"+o,q=\"mfp-ready\",r=\"mfp-removing\",s=\"mfp-prevent-close\",t=function(){},u=!!__webpack_provided_window_dot_jQuery,v=a(window),w=function(a,c){b.ev.on(o+a+p,c)},x=function(b,c,d,e){var f=document.createElement(\"div\");return f.className=\"mfp-\"+b,d&&(f.innerHTML=d),e?c&&c.appendChild(f):(f=a(f),c&&f.appendTo(c)),f},y=function(c,d){b.ev.triggerHandler(o+c,d),b.st.callbacks&&(c=c.charAt(0).toLowerCase()+c.slice(1),b.st.callbacks[c]&&b.st.callbacks[c].apply(b,a.isArray(d)?d:[d]))},z=function(c){return c===g&&b.currTemplate.closeBtn||(b.currTemplate.closeBtn=a(b.st.closeMarkup.replace(\"%title%\",b.st.tClose)),g=c),b.currTemplate.closeBtn},A=function(){a.magnificPopup.instance||(b=new t,b.init(),a.magnificPopup.instance=b)},B=function(){var a=document.createElement(\"p\").style,b=[\"ms\",\"O\",\"Moz\",\"Webkit\"];if(void 0!==a.transition)return!0;for(;b.length;)if(b.pop()+\"Transition\"in a)return!0;return!1};t.prototype={constructor:t,init:function(){var c=navigator.appVersion;b.isLowIE=b.isIE8=document.all&&!document.addEventListener,b.isAndroid=/android/gi.test(c),b.isIOS=/iphone|ipad|ipod/gi.test(c),b.supportsTransition=B(),b.probablyMobile=b.isAndroid||b.isIOS||/(Opera Mini)|Kindle|webOS|BlackBerry|(Opera Mobi)|(Windows Phone)|IEMobile/i.test(navigator.userAgent),d=a(document),b.popupsCache={}},open:function(c){var e;if(c.isObj===!1){b.items=c.items.toArray(),b.index=0;var g,h=c.items;for(e=0;e<h.length;e++)if(g=h[e],g.parsed&&(g=g.el[0]),g===c.el[0]){b.index=e;break}}else b.items=a.isArray(c.items)?c.items:[c.items],b.index=c.index||0;if(b.isOpen)return void b.updateItemHTML();b.types=[],f=\"\",c.mainEl&&c.mainEl.length?b.ev=c.mainEl.eq(0):b.ev=d,c.key?(b.popupsCache[c.key]||(b.popupsCache[c.key]={}),b.currTemplate=b.popupsCache[c.key]):b.currTemplate={},b.st=a.extend(!0,{},a.magnificPopup.defaults,c),b.fixedContentPos=\"auto\"===b.st.fixedContentPos?!b.probablyMobile:b.st.fixedContentPos,b.st.modal&&(b.st.closeOnContentClick=!1,b.st.closeOnBgClick=!1,b.st.showCloseBtn=!1,b.st.enableEscapeKey=!1),b.bgOverlay||(b.bgOverlay=x(\"bg\").on(\"click\"+p,function(){b.close()}),b.wrap=x(\"wrap\").attr(\"tabindex\",-1).on(\"click\"+p,function(a){b._checkIfClose(a.target)&&b.close()}),b.container=x(\"container\",b.wrap)),b.contentContainer=x(\"content\"),b.st.preloader&&(b.preloader=x(\"preloader\",b.container,b.st.tLoading));var i=a.magnificPopup.modules;for(e=0;e<i.length;e++){var j=i[e];j=j.charAt(0).toUpperCase()+j.slice(1),b[\"init\"+j].call(b)}y(\"BeforeOpen\"),b.st.showCloseBtn&&(b.st.closeBtnInside?(w(l,function(a,b,c,d){c.close_replaceWith=z(d.type)}),f+=\" mfp-close-btn-in\"):b.wrap.append(z())),b.st.alignTop&&(f+=\" mfp-align-top\"),b.fixedContentPos?b.wrap.css({overflow:b.st.overflowY,overflowX:\"hidden\",overflowY:b.st.overflowY}):b.wrap.css({top:v.scrollTop(),position:\"absolute\"}),(b.st.fixedBgPos===!1||\"auto\"===b.st.fixedBgPos&&!b.fixedContentPos)&&b.bgOverlay.css({height:d.height(),position:\"absolute\"}),b.st.enableEscapeKey&&d.on(\"keyup\"+p,function(a){27===a.keyCode&&b.close()}),v.on(\"resize\"+p,function(){b.updateSize()}),b.st.closeOnContentClick||(f+=\" mfp-auto-cursor\"),f&&b.wrap.addClass(f);var k=b.wH=v.height(),n={};if(b.fixedContentPos&&b._hasScrollBar(k)){var o=b._getScrollbarSize();o&&(n.marginRight=o)}b.fixedContentPos&&(b.isIE7?a(\"body, html\").css(\"overflow\",\"hidden\"):n.overflow=\"hidden\");var r=b.st.mainClass;return b.isIE7&&(r+=\" mfp-ie7\"),r&&b._addClassToMFP(r),b.updateItemHTML(),y(\"BuildControls\"),a(\"html\").css(n),b.bgOverlay.add(b.wrap).prependTo(b.st.prependTo||a(document.body)),b._lastFocusedEl=document.activeElement,setTimeout(function(){b.content?(b._addClassToMFP(q),b._setFocus()):b.bgOverlay.addClass(q),d.on(\"focusin\"+p,b._onFocusIn)},16),b.isOpen=!0,b.updateSize(k),y(m),c},close:function(){b.isOpen&&(y(i),b.isOpen=!1,b.st.removalDelay&&!b.isLowIE&&b.supportsTransition?(b._addClassToMFP(r),setTimeout(function(){b._close()},b.st.removalDelay)):b._close())},_close:function(){y(h);var c=r+\" \"+q+\" \";if(b.bgOverlay.detach(),b.wrap.detach(),b.container.empty(),b.st.mainClass&&(c+=b.st.mainClass+\" \"),b._removeClassFromMFP(c),b.fixedContentPos){var e={marginRight:\"\"};b.isIE7?a(\"body, html\").css(\"overflow\",\"\"):e.overflow=\"\",a(\"html\").css(e)}d.off(\"keyup\"+p+\" focusin\"+p),b.ev.off(p),b.wrap.attr(\"class\",\"mfp-wrap\").removeAttr(\"style\"),b.bgOverlay.attr(\"class\",\"mfp-bg\"),b.container.attr(\"class\",\"mfp-container\"),!b.st.showCloseBtn||b.st.closeBtnInside&&b.currTemplate[b.currItem.type]!==!0||b.currTemplate.closeBtn&&b.currTemplate.closeBtn.detach(),b.st.autoFocusLast&&b._lastFocusedEl&&a(b._lastFocusedEl).focus(),b.currItem=null,b.content=null,b.currTemplate=null,b.prevHeight=0,y(j)},updateSize:function(a){if(b.isIOS){var c=document.documentElement.clientWidth/window.innerWidth,d=window.innerHeight*c;b.wrap.css(\"height\",d),b.wH=d}else b.wH=a||v.height();b.fixedContentPos||b.wrap.css(\"height\",b.wH),y(\"Resize\")},updateItemHTML:function(){var c=b.items[b.index];b.contentContainer.detach(),b.content&&b.content.detach(),c.parsed||(c=b.parseEl(b.index));var d=c.type;if(y(\"BeforeChange\",[b.currItem?b.currItem.type:\"\",d]),b.currItem=c,!b.currTemplate[d]){var f=b.st[d]?b.st[d].markup:!1;y(\"FirstMarkupParse\",f),f?b.currTemplate[d]=a(f):b.currTemplate[d]=!0}e&&e!==c.type&&b.container.removeClass(\"mfp-\"+e+\"-holder\");var g=b[\"get\"+d.charAt(0).toUpperCase()+d.slice(1)](c,b.currTemplate[d]);b.appendContent(g,d),c.preloaded=!0,y(n,c),e=c.type,b.container.prepend(b.contentContainer),y(\"AfterChange\")},appendContent:function(a,c){b.content=a,a?b.st.showCloseBtn&&b.st.closeBtnInside&&b.currTemplate[c]===!0?b.content.find(\".mfp-close\").length||b.content.append(z()):b.content=a:b.content=\"\",y(k),b.container.addClass(\"mfp-\"+c+\"-holder\"),b.contentContainer.append(b.content)},parseEl:function(c){var d,e=b.items[c];if(e.tagName?e={el:a(e)}:(d=e.type,e={data:e,src:e.src}),e.el){for(var f=b.types,g=0;g<f.length;g++)if(e.el.hasClass(\"mfp-\"+f[g])){d=f[g];break}e.src=e.el.attr(\"data-mfp-src\"),e.src||(e.src=e.el.attr(\"href\"))}return e.type=d||b.st.type||\"inline\",e.index=c,e.parsed=!0,b.items[c]=e,y(\"ElementParse\",e),b.items[c]},addGroup:function(a,c){var d=function(d){d.mfpEl=this,b._openClick(d,a,c)};c||(c={});var e=\"click.magnificPopup\";c.mainEl=a,c.items?(c.isObj=!0,a.off(e).on(e,d)):(c.isObj=!1,c.delegate?a.off(e).on(e,c.delegate,d):(c.items=a,a.off(e).on(e,d)))},_openClick:function(c,d,e){var f=void 0!==e.midClick?e.midClick:a.magnificPopup.defaults.midClick;if(f||!(2===c.which||c.ctrlKey||c.metaKey||c.altKey||c.shiftKey)){var g=void 0!==e.disableOn?e.disableOn:a.magnificPopup.defaults.disableOn;if(g)if(a.isFunction(g)){if(!g.call(b))return!0}else if(v.width()<g)return!0;c.type&&(c.preventDefault(),b.isOpen&&c.stopPropagation()),e.el=a(c.mfpEl),e.delegate&&(e.items=d.find(e.delegate)),b.open(e)}},updateStatus:function(a,d){if(b.preloader){c!==a&&b.container.removeClass(\"mfp-s-\"+c),d||\"loading\"!==a||(d=b.st.tLoading);var e={status:a,text:d};y(\"UpdateStatus\",e),a=e.status,d=e.text,b.preloader.html(d),b.preloader.find(\"a\").on(\"click\",function(a){a.stopImmediatePropagation()}),b.container.addClass(\"mfp-s-\"+a),c=a}},_checkIfClose:function(c){if(!a(c).hasClass(s)){var d=b.st.closeOnContentClick,e=b.st.closeOnBgClick;if(d&&e)return!0;if(!b.content||a(c).hasClass(\"mfp-close\")||b.preloader&&c===b.preloader[0])return!0;if(c===b.content[0]||a.contains(b.content[0],c)){if(d)return!0}else if(e&&a.contains(document,c))return!0;return!1}},_addClassToMFP:function(a){b.bgOverlay.addClass(a),b.wrap.addClass(a)},_removeClassFromMFP:function(a){this.bgOverlay.removeClass(a),b.wrap.removeClass(a)},_hasScrollBar:function(a){return(b.isIE7?d.height():document.body.scrollHeight)>(a||v.height())},_setFocus:function(){(b.st.focus?b.content.find(b.st.focus).eq(0):b.wrap).focus()},_onFocusIn:function(c){return c.target===b.wrap[0]||a.contains(b.wrap[0],c.target)?void 0:(b._setFocus(),!1)},_parseMarkup:function(b,c,d){var e;d.data&&(c=a.extend(d.data,c)),y(l,[b,c,d]),a.each(c,function(c,d){if(void 0===d||d===!1)return!0;if(e=c.split(\"_\"),e.length>1){var f=b.find(p+\"-\"+e[0]);if(f.length>0){var g=e[1];\"replaceWith\"===g?f[0]!==d[0]&&f.replaceWith(d):\"img\"===g?f.is(\"img\")?f.attr(\"src\",d):f.replaceWith(a(\"<img>\").attr(\"src\",d).attr(\"class\",f.attr(\"class\"))):f.attr(e[1],d)}}else b.find(p+\"-\"+c).html(d)})},_getScrollbarSize:function(){if(void 0===b.scrollbarSize){var a=document.createElement(\"div\");a.style.cssText=\"width: 99px; height: 99px; overflow: scroll; position: absolute; top: -9999px;\",document.body.appendChild(a),b.scrollbarSize=a.offsetWidth-a.clientWidth,document.body.removeChild(a)}return b.scrollbarSize}},a.magnificPopup={instance:null,proto:t.prototype,modules:[],open:function(b,c){return A(),b=b?a.extend(!0,{},b):{},b.isObj=!0,b.index=c||0,this.instance.open(b)},close:function(){return a.magnificPopup.instance&&a.magnificPopup.instance.close()},registerModule:function(b,c){c.options&&(a.magnificPopup.defaults[b]=c.options),a.extend(this.proto,c.proto),this.modules.push(b)},defaults:{disableOn:0,key:null,midClick:!1,mainClass:\"\",preloader:!0,focus:\"\",closeOnContentClick:!1,closeOnBgClick:!0,closeBtnInside:!0,showCloseBtn:!0,enableEscapeKey:!0,modal:!1,alignTop:!1,removalDelay:0,prependTo:null,fixedContentPos:\"auto\",fixedBgPos:\"auto\",overflowY:\"auto\",closeMarkup:'<button title=\"%title%\" type=\"button\" class=\"mfp-close\">&#215;</button>',tClose:\"Close (Esc)\",tLoading:\"Loading...\",autoFocusLast:!0}},a.fn.magnificPopup=function(c){A();var d=a(this);if(\"string\"==typeof c)if(\"open\"===c){var e,f=u?d.data(\"magnificPopup\"):d[0].magnificPopup,g=parseInt(arguments[1],10)||0;f.items?e=f.items[g]:(e=d,f.delegate&&(e=e.find(f.delegate)),e=e.eq(g)),b._openClick({mfpEl:e},d,f)}else b.isOpen&&b[c].apply(b,Array.prototype.slice.call(arguments,1));else c=a.extend(!0,{},c),u?d.data(\"magnificPopup\",c):d[0].magnificPopup=c,b.addGroup(d,c);return d};var C,D,E,F=\"inline\",G=function(){E&&(D.after(E.addClass(C)).detach(),E=null)};a.magnificPopup.registerModule(F,{options:{hiddenClass:\"hide\",markup:\"\",tNotFound:\"Content not found\"},proto:{initInline:function(){b.types.push(F),w(h+\".\"+F,function(){G()})},getInline:function(c,d){if(G(),c.src){var e=b.st.inline,f=a(c.src);if(f.length){var g=f[0].parentNode;g&&g.tagName&&(D||(C=e.hiddenClass,D=x(C),C=\"mfp-\"+C),E=f.after(D).detach().removeClass(C)),b.updateStatus(\"ready\")}else b.updateStatus(\"error\",e.tNotFound),f=a(\"<div>\");return c.inlineElement=f,f}return b.updateStatus(\"ready\"),b._parseMarkup(d,{},c),d}}});var H,I=\"ajax\",J=function(){H&&a(document.body).removeClass(H)},K=function(){J(),b.req&&b.req.abort()};a.magnificPopup.registerModule(I,{options:{settings:null,cursor:\"mfp-ajax-cur\",tError:'<a href=\"%url%\">The content</a> could not be loaded.'},proto:{initAjax:function(){b.types.push(I),H=b.st.ajax.cursor,w(h+\".\"+I,K),w(\"BeforeChange.\"+I,K)},getAjax:function(c){H&&a(document.body).addClass(H),b.updateStatus(\"loading\");var d=a.extend({url:c.src,success:function(d,e,f){var g={data:d,xhr:f};y(\"ParseAjax\",g),b.appendContent(a(g.data),I),c.finished=!0,J(),b._setFocus(),setTimeout(function(){b.wrap.addClass(q)},16),b.updateStatus(\"ready\"),y(\"AjaxContentAdded\")},error:function(){J(),c.finished=c.loadError=!0,b.updateStatus(\"error\",b.st.ajax.tError.replace(\"%url%\",c.src))}},b.st.ajax.settings);return b.req=a.ajax(d),\"\"}}});var L,M=function(c){if(c.data&&void 0!==c.data.title)return c.data.title;var d=b.st.image.titleSrc;if(d){if(a.isFunction(d))return d.call(b,c);if(c.el)return c.el.attr(d)||\"\"}return\"\"};a.magnificPopup.registerModule(\"image\",{options:{markup:'<div class=\"mfp-figure\"><div class=\"mfp-close\"></div><figure><div class=\"mfp-img\"></div><figcaption><div class=\"mfp-bottom-bar\"><div class=\"mfp-title\"></div><div class=\"mfp-counter\"></div></div></figcaption></figure></div>',cursor:\"mfp-zoom-out-cur\",titleSrc:\"title\",verticalFit:!0,tError:'<a href=\"%url%\">The image</a> could not be loaded.'},proto:{initImage:function(){var c=b.st.image,d=\".image\";b.types.push(\"image\"),w(m+d,function(){\"image\"===b.currItem.type&&c.cursor&&a(document.body).addClass(c.cursor)}),w(h+d,function(){c.cursor&&a(document.body).removeClass(c.cursor),v.off(\"resize\"+p)}),w(\"Resize\"+d,b.resizeImage),b.isLowIE&&w(\"AfterChange\",b.resizeImage)},resizeImage:function(){var a=b.currItem;if(a&&a.img&&b.st.image.verticalFit){var c=0;b.isLowIE&&(c=parseInt(a.img.css(\"padding-top\"),10)+parseInt(a.img.css(\"padding-bottom\"),10)),a.img.css(\"max-height\",b.wH-c)}},_onImageHasSize:function(a){a.img&&(a.hasSize=!0,L&&clearInterval(L),a.isCheckingImgSize=!1,y(\"ImageHasSize\",a),a.imgHidden&&(b.content&&b.content.removeClass(\"mfp-loading\"),a.imgHidden=!1))},findImageSize:function(a){var c=0,d=a.img[0],e=function(f){L&&clearInterval(L),L=setInterval(function(){return d.naturalWidth>0?void b._onImageHasSize(a):(c>200&&clearInterval(L),c++,void(3===c?e(10):40===c?e(50):100===c&&e(500)))},f)};e(1)},getImage:function(c,d){var e=0,f=function(){c&&(c.img[0].complete?(c.img.off(\".mfploader\"),c===b.currItem&&(b._onImageHasSize(c),b.updateStatus(\"ready\")),c.hasSize=!0,c.loaded=!0,y(\"ImageLoadComplete\")):(e++,200>e?setTimeout(f,100):g()))},g=function(){c&&(c.img.off(\".mfploader\"),c===b.currItem&&(b._onImageHasSize(c),b.updateStatus(\"error\",h.tError.replace(\"%url%\",c.src))),c.hasSize=!0,c.loaded=!0,c.loadError=!0)},h=b.st.image,i=d.find(\".mfp-img\");if(i.length){var j=document.createElement(\"img\");j.className=\"mfp-img\",c.el&&c.el.find(\"img\").length&&(j.alt=c.el.find(\"img\").attr(\"alt\")),c.img=a(j).on(\"load.mfploader\",f).on(\"error.mfploader\",g),j.src=c.src,i.is(\"img\")&&(c.img=c.img.clone()),j=c.img[0],j.naturalWidth>0?c.hasSize=!0:j.width||(c.hasSize=!1)}return b._parseMarkup(d,{title:M(c),img_replaceWith:c.img},c),b.resizeImage(),c.hasSize?(L&&clearInterval(L),c.loadError?(d.addClass(\"mfp-loading\"),b.updateStatus(\"error\",h.tError.replace(\"%url%\",c.src))):(d.removeClass(\"mfp-loading\"),b.updateStatus(\"ready\")),d):(b.updateStatus(\"loading\"),c.loading=!0,c.hasSize||(c.imgHidden=!0,d.addClass(\"mfp-loading\"),b.findImageSize(c)),d)}}});var N,O=function(){return void 0===N&&(N=void 0!==document.createElement(\"p\").style.MozTransform),N};a.magnificPopup.registerModule(\"zoom\",{options:{enabled:!1,easing:\"ease-in-out\",duration:300,opener:function(a){return a.is(\"img\")?a:a.find(\"img\")}},proto:{initZoom:function(){var a,c=b.st.zoom,d=\".zoom\";if(c.enabled&&b.supportsTransition){var e,f,g=c.duration,j=function(a){var b=a.clone().removeAttr(\"style\").removeAttr(\"class\").addClass(\"mfp-animated-image\"),d=\"all \"+c.duration/1e3+\"s \"+c.easing,e={position:\"fixed\",zIndex:9999,left:0,top:0,\"-webkit-backface-visibility\":\"hidden\"},f=\"transition\";return e[\"-webkit-\"+f]=e[\"-moz-\"+f]=e[\"-o-\"+f]=e[f]=d,b.css(e),b},k=function(){b.content.css(\"visibility\",\"visible\")};w(\"BuildControls\"+d,function(){if(b._allowZoom()){if(clearTimeout(e),b.content.css(\"visibility\",\"hidden\"),a=b._getItemToZoom(),!a)return void k();f=j(a),f.css(b._getOffset()),b.wrap.append(f),e=setTimeout(function(){f.css(b._getOffset(!0)),e=setTimeout(function(){k(),setTimeout(function(){f.remove(),a=f=null,y(\"ZoomAnimationEnded\")},16)},g)},16)}}),w(i+d,function(){if(b._allowZoom()){if(clearTimeout(e),b.st.removalDelay=g,!a){if(a=b._getItemToZoom(),!a)return;f=j(a)}f.css(b._getOffset(!0)),b.wrap.append(f),b.content.css(\"visibility\",\"hidden\"),setTimeout(function(){f.css(b._getOffset())},16)}}),w(h+d,function(){b._allowZoom()&&(k(),f&&f.remove(),a=null)})}},_allowZoom:function(){return\"image\"===b.currItem.type},_getItemToZoom:function(){return b.currItem.hasSize?b.currItem.img:!1},_getOffset:function(c){var d;d=c?b.currItem.img:b.st.zoom.opener(b.currItem.el||b.currItem);var e=d.offset(),f=parseInt(d.css(\"padding-top\"),10),g=parseInt(d.css(\"padding-bottom\"),10);e.top-=a(window).scrollTop()-f;var h={width:d.width(),height:(u?d.innerHeight():d[0].offsetHeight)-g-f};return O()?h[\"-moz-transform\"]=h.transform=\"translate(\"+e.left+\"px,\"+e.top+\"px)\":(h.left=e.left,h.top=e.top),h}}});var P=\"iframe\",Q=\"//about:blank\",R=function(a){if(b.currTemplate[P]){var c=b.currTemplate[P].find(\"iframe\");c.length&&(a||(c[0].src=Q),b.isIE8&&c.css(\"display\",a?\"block\":\"none\"))}};a.magnificPopup.registerModule(P,{options:{markup:'<div class=\"mfp-iframe-scaler\"><div class=\"mfp-close\"></div><iframe class=\"mfp-iframe\" src=\"//about:blank\" frameborder=\"0\" allowfullscreen></iframe></div>',srcAction:\"iframe_src\",patterns:{youtube:{index:\"youtube.com\",id:\"v=\",src:\"//www.youtube.com/embed/%id%?autoplay=1\"},vimeo:{index:\"vimeo.com/\",id:\"/\",src:\"//player.vimeo.com/video/%id%?autoplay=1\"},gmaps:{index:\"//maps.google.\",src:\"%id%&output=embed\"}}},proto:{initIframe:function(){b.types.push(P),w(\"BeforeChange\",function(a,b,c){b!==c&&(b===P?R():c===P&&R(!0))}),w(h+\".\"+P,function(){R()})},getIframe:function(c,d){var e=c.src,f=b.st.iframe;a.each(f.patterns,function(){return e.indexOf(this.index)>-1?(this.id&&(e=\"string\"==typeof this.id?e.substr(e.lastIndexOf(this.id)+this.id.length,e.length):this.id.call(this,e)),e=this.src.replace(\"%id%\",e),!1):void 0});var g={};return f.srcAction&&(g[f.srcAction]=e),b._parseMarkup(d,g,c),b.updateStatus(\"ready\"),d}}});var S=function(a){var c=b.items.length;return a>c-1?a-c:0>a?c+a:a},T=function(a,b,c){return a.replace(/%curr%/gi,b+1).replace(/%total%/gi,c)};a.magnificPopup.registerModule(\"gallery\",{options:{enabled:!1,arrowMarkup:'<button title=\"%title%\" type=\"button\" class=\"mfp-arrow mfp-arrow-%dir%\"></button>',preload:[0,2],navigateByImgClick:!0,arrows:!0,tPrev:\"Previous (Left arrow key)\",tNext:\"Next (Right arrow key)\",tCounter:\"%curr% of %total%\"},proto:{initGallery:function(){var c=b.st.gallery,e=\".mfp-gallery\";return b.direction=!0,c&&c.enabled?(f+=\" mfp-gallery\",w(m+e,function(){c.navigateByImgClick&&b.wrap.on(\"click\"+e,\".mfp-img\",function(){return b.items.length>1?(b.next(),!1):void 0}),d.on(\"keydown\"+e,function(a){37===a.keyCode?b.prev():39===a.keyCode&&b.next()})}),w(\"UpdateStatus\"+e,function(a,c){c.text&&(c.text=T(c.text,b.currItem.index,b.items.length))}),w(l+e,function(a,d,e,f){var g=b.items.length;e.counter=g>1?T(c.tCounter,f.index,g):\"\"}),w(\"BuildControls\"+e,function(){if(b.items.length>1&&c.arrows&&!b.arrowLeft){var d=c.arrowMarkup,e=b.arrowLeft=a(d.replace(/%title%/gi,c.tPrev).replace(/%dir%/gi,\"left\")).addClass(s),f=b.arrowRight=a(d.replace(/%title%/gi,c.tNext).replace(/%dir%/gi,\"right\")).addClass(s);e.click(function(){b.prev()}),f.click(function(){b.next()}),b.container.append(e.add(f))}}),w(n+e,function(){b._preloadTimeout&&clearTimeout(b._preloadTimeout),b._preloadTimeout=setTimeout(function(){b.preloadNearbyImages(),b._preloadTimeout=null},16)}),void w(h+e,function(){d.off(e),b.wrap.off(\"click\"+e),b.arrowRight=b.arrowLeft=null})):!1},next:function(){b.direction=!0,b.index=S(b.index+1),b.updateItemHTML()},prev:function(){b.direction=!1,b.index=S(b.index-1),b.updateItemHTML()},goTo:function(a){b.direction=a>=b.index,b.index=a,b.updateItemHTML()},preloadNearbyImages:function(){var a,c=b.st.gallery.preload,d=Math.min(c[0],b.items.length),e=Math.min(c[1],b.items.length);for(a=1;a<=(b.direction?e:d);a++)b._preloadItem(b.index+a);for(a=1;a<=(b.direction?d:e);a++)b._preloadItem(b.index-a)},_preloadItem:function(c){if(c=S(c),!b.items[c].preloaded){var d=b.items[c];d.parsed||(d=b.parseEl(c)),y(\"LazyLoad\",d),\"image\"===d.type&&(d.img=a('<img class=\"mfp-img\" />').on(\"load.mfploader\",function(){d.hasSize=!0}).on(\"error.mfploader\",function(){d.hasSize=!0,d.loadError=!0,y(\"LazyLoadError\",d)}).attr(\"src\",d.src)),d.preloaded=!0}}}});var U=\"retina\";a.magnificPopup.registerModule(U,{options:{replaceSrc:function(a){return a.src.replace(/\\.\\w+$/,function(a){return\"@2x\"+a})},ratio:1},proto:{initRetina:function(){if(window.devicePixelRatio>1){var a=b.st.retina,c=a.ratio;c=isNaN(c)?c():c,c>1&&(w(\"ImageHasSize.\"+U,function(a,b){b.img.css({\"max-width\":b.img[0].naturalWidth/c,width:\"100%\"})}),w(\"ElementParse.\"+U,function(b,d){d.src=a.replaceSrc(d,c)}))}}}}),A()});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! jquery */ 41)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA4NC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vbWFnbmlmaWMtcG9wdXAvZGlzdC9qcXVlcnkubWFnbmlmaWMtcG9wdXAubWluLmpzPzhiYjkiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIE1hZ25pZmljIFBvcHVwIC0gdjEuMS4wIC0gMjAxNi0wMi0yMFxuKiBodHRwOi8vZGltc2VtZW5vdi5jb20vcGx1Z2lucy9tYWduaWZpYy1wb3B1cC9cbiogQ29weXJpZ2h0IChjKSAyMDE2IERtaXRyeSBTZW1lbm92OyAqL1xuIWZ1bmN0aW9uKGEpe1wiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1wianF1ZXJ5XCJdLGEpOmEoXCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/cmVxdWlyZShcImpxdWVyeVwiKTp3aW5kb3cualF1ZXJ5fHx3aW5kb3cuWmVwdG8pfShmdW5jdGlvbihhKXt2YXIgYixjLGQsZSxmLGcsaD1cIkNsb3NlXCIsaT1cIkJlZm9yZUNsb3NlXCIsaj1cIkFmdGVyQ2xvc2VcIixrPVwiQmVmb3JlQXBwZW5kXCIsbD1cIk1hcmt1cFBhcnNlXCIsbT1cIk9wZW5cIixuPVwiQ2hhbmdlXCIsbz1cIm1mcFwiLHA9XCIuXCIrbyxxPVwibWZwLXJlYWR5XCIscj1cIm1mcC1yZW1vdmluZ1wiLHM9XCJtZnAtcHJldmVudC1jbG9zZVwiLHQ9ZnVuY3Rpb24oKXt9LHU9ISF3aW5kb3cualF1ZXJ5LHY9YSh3aW5kb3cpLHc9ZnVuY3Rpb24oYSxjKXtiLmV2Lm9uKG8rYStwLGMpfSx4PWZ1bmN0aW9uKGIsYyxkLGUpe3ZhciBmPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7cmV0dXJuIGYuY2xhc3NOYW1lPVwibWZwLVwiK2IsZCYmKGYuaW5uZXJIVE1MPWQpLGU/YyYmYy5hcHBlbmRDaGlsZChmKTooZj1hKGYpLGMmJmYuYXBwZW5kVG8oYykpLGZ9LHk9ZnVuY3Rpb24oYyxkKXtiLmV2LnRyaWdnZXJIYW5kbGVyKG8rYyxkKSxiLnN0LmNhbGxiYWNrcyYmKGM9Yy5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKStjLnNsaWNlKDEpLGIuc3QuY2FsbGJhY2tzW2NdJiZiLnN0LmNhbGxiYWNrc1tjXS5hcHBseShiLGEuaXNBcnJheShkKT9kOltkXSkpfSx6PWZ1bmN0aW9uKGMpe3JldHVybiBjPT09ZyYmYi5jdXJyVGVtcGxhdGUuY2xvc2VCdG58fChiLmN1cnJUZW1wbGF0ZS5jbG9zZUJ0bj1hKGIuc3QuY2xvc2VNYXJrdXAucmVwbGFjZShcIiV0aXRsZSVcIixiLnN0LnRDbG9zZSkpLGc9YyksYi5jdXJyVGVtcGxhdGUuY2xvc2VCdG59LEE9ZnVuY3Rpb24oKXthLm1hZ25pZmljUG9wdXAuaW5zdGFuY2V8fChiPW5ldyB0LGIuaW5pdCgpLGEubWFnbmlmaWNQb3B1cC5pbnN0YW5jZT1iKX0sQj1mdW5jdGlvbigpe3ZhciBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwXCIpLnN0eWxlLGI9W1wibXNcIixcIk9cIixcIk1velwiLFwiV2Via2l0XCJdO2lmKHZvaWQgMCE9PWEudHJhbnNpdGlvbilyZXR1cm4hMDtmb3IoO2IubGVuZ3RoOylpZihiLnBvcCgpK1wiVHJhbnNpdGlvblwiaW4gYSlyZXR1cm4hMDtyZXR1cm4hMX07dC5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOnQsaW5pdDpmdW5jdGlvbigpe3ZhciBjPW5hdmlnYXRvci5hcHBWZXJzaW9uO2IuaXNMb3dJRT1iLmlzSUU4PWRvY3VtZW50LmFsbCYmIWRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIsYi5pc0FuZHJvaWQ9L2FuZHJvaWQvZ2kudGVzdChjKSxiLmlzSU9TPS9pcGhvbmV8aXBhZHxpcG9kL2dpLnRlc3QoYyksYi5zdXBwb3J0c1RyYW5zaXRpb249QigpLGIucHJvYmFibHlNb2JpbGU9Yi5pc0FuZHJvaWR8fGIuaXNJT1N8fC8oT3BlcmEgTWluaSl8S2luZGxlfHdlYk9TfEJsYWNrQmVycnl8KE9wZXJhIE1vYmkpfChXaW5kb3dzIFBob25lKXxJRU1vYmlsZS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCksZD1hKGRvY3VtZW50KSxiLnBvcHVwc0NhY2hlPXt9fSxvcGVuOmZ1bmN0aW9uKGMpe3ZhciBlO2lmKGMuaXNPYmo9PT0hMSl7Yi5pdGVtcz1jLml0ZW1zLnRvQXJyYXkoKSxiLmluZGV4PTA7dmFyIGcsaD1jLml0ZW1zO2ZvcihlPTA7ZTxoLmxlbmd0aDtlKyspaWYoZz1oW2VdLGcucGFyc2VkJiYoZz1nLmVsWzBdKSxnPT09Yy5lbFswXSl7Yi5pbmRleD1lO2JyZWFrfX1lbHNlIGIuaXRlbXM9YS5pc0FycmF5KGMuaXRlbXMpP2MuaXRlbXM6W2MuaXRlbXNdLGIuaW5kZXg9Yy5pbmRleHx8MDtpZihiLmlzT3BlbilyZXR1cm4gdm9pZCBiLnVwZGF0ZUl0ZW1IVE1MKCk7Yi50eXBlcz1bXSxmPVwiXCIsYy5tYWluRWwmJmMubWFpbkVsLmxlbmd0aD9iLmV2PWMubWFpbkVsLmVxKDApOmIuZXY9ZCxjLmtleT8oYi5wb3B1cHNDYWNoZVtjLmtleV18fChiLnBvcHVwc0NhY2hlW2Mua2V5XT17fSksYi5jdXJyVGVtcGxhdGU9Yi5wb3B1cHNDYWNoZVtjLmtleV0pOmIuY3VyclRlbXBsYXRlPXt9LGIuc3Q9YS5leHRlbmQoITAse30sYS5tYWduaWZpY1BvcHVwLmRlZmF1bHRzLGMpLGIuZml4ZWRDb250ZW50UG9zPVwiYXV0b1wiPT09Yi5zdC5maXhlZENvbnRlbnRQb3M/IWIucHJvYmFibHlNb2JpbGU6Yi5zdC5maXhlZENvbnRlbnRQb3MsYi5zdC5tb2RhbCYmKGIuc3QuY2xvc2VPbkNvbnRlbnRDbGljaz0hMSxiLnN0LmNsb3NlT25CZ0NsaWNrPSExLGIuc3Quc2hvd0Nsb3NlQnRuPSExLGIuc3QuZW5hYmxlRXNjYXBlS2V5PSExKSxiLmJnT3ZlcmxheXx8KGIuYmdPdmVybGF5PXgoXCJiZ1wiKS5vbihcImNsaWNrXCIrcCxmdW5jdGlvbigpe2IuY2xvc2UoKX0pLGIud3JhcD14KFwid3JhcFwiKS5hdHRyKFwidGFiaW5kZXhcIiwtMSkub24oXCJjbGlja1wiK3AsZnVuY3Rpb24oYSl7Yi5fY2hlY2tJZkNsb3NlKGEudGFyZ2V0KSYmYi5jbG9zZSgpfSksYi5jb250YWluZXI9eChcImNvbnRhaW5lclwiLGIud3JhcCkpLGIuY29udGVudENvbnRhaW5lcj14KFwiY29udGVudFwiKSxiLnN0LnByZWxvYWRlciYmKGIucHJlbG9hZGVyPXgoXCJwcmVsb2FkZXJcIixiLmNvbnRhaW5lcixiLnN0LnRMb2FkaW5nKSk7dmFyIGk9YS5tYWduaWZpY1BvcHVwLm1vZHVsZXM7Zm9yKGU9MDtlPGkubGVuZ3RoO2UrKyl7dmFyIGo9aVtlXTtqPWouY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrai5zbGljZSgxKSxiW1wiaW5pdFwiK2pdLmNhbGwoYil9eShcIkJlZm9yZU9wZW5cIiksYi5zdC5zaG93Q2xvc2VCdG4mJihiLnN0LmNsb3NlQnRuSW5zaWRlPyh3KGwsZnVuY3Rpb24oYSxiLGMsZCl7Yy5jbG9zZV9yZXBsYWNlV2l0aD16KGQudHlwZSl9KSxmKz1cIiBtZnAtY2xvc2UtYnRuLWluXCIpOmIud3JhcC5hcHBlbmQoeigpKSksYi5zdC5hbGlnblRvcCYmKGYrPVwiIG1mcC1hbGlnbi10b3BcIiksYi5maXhlZENvbnRlbnRQb3M/Yi53cmFwLmNzcyh7b3ZlcmZsb3c6Yi5zdC5vdmVyZmxvd1ksb3ZlcmZsb3dYOlwiaGlkZGVuXCIsb3ZlcmZsb3dZOmIuc3Qub3ZlcmZsb3dZfSk6Yi53cmFwLmNzcyh7dG9wOnYuc2Nyb2xsVG9wKCkscG9zaXRpb246XCJhYnNvbHV0ZVwifSksKGIuc3QuZml4ZWRCZ1Bvcz09PSExfHxcImF1dG9cIj09PWIuc3QuZml4ZWRCZ1BvcyYmIWIuZml4ZWRDb250ZW50UG9zKSYmYi5iZ092ZXJsYXkuY3NzKHtoZWlnaHQ6ZC5oZWlnaHQoKSxwb3NpdGlvbjpcImFic29sdXRlXCJ9KSxiLnN0LmVuYWJsZUVzY2FwZUtleSYmZC5vbihcImtleXVwXCIrcCxmdW5jdGlvbihhKXsyNz09PWEua2V5Q29kZSYmYi5jbG9zZSgpfSksdi5vbihcInJlc2l6ZVwiK3AsZnVuY3Rpb24oKXtiLnVwZGF0ZVNpemUoKX0pLGIuc3QuY2xvc2VPbkNvbnRlbnRDbGlja3x8KGYrPVwiIG1mcC1hdXRvLWN1cnNvclwiKSxmJiZiLndyYXAuYWRkQ2xhc3MoZik7dmFyIGs9Yi53SD12LmhlaWdodCgpLG49e307aWYoYi5maXhlZENvbnRlbnRQb3MmJmIuX2hhc1Njcm9sbEJhcihrKSl7dmFyIG89Yi5fZ2V0U2Nyb2xsYmFyU2l6ZSgpO28mJihuLm1hcmdpblJpZ2h0PW8pfWIuZml4ZWRDb250ZW50UG9zJiYoYi5pc0lFNz9hKFwiYm9keSwgaHRtbFwiKS5jc3MoXCJvdmVyZmxvd1wiLFwiaGlkZGVuXCIpOm4ub3ZlcmZsb3c9XCJoaWRkZW5cIik7dmFyIHI9Yi5zdC5tYWluQ2xhc3M7cmV0dXJuIGIuaXNJRTcmJihyKz1cIiBtZnAtaWU3XCIpLHImJmIuX2FkZENsYXNzVG9NRlAociksYi51cGRhdGVJdGVtSFRNTCgpLHkoXCJCdWlsZENvbnRyb2xzXCIpLGEoXCJodG1sXCIpLmNzcyhuKSxiLmJnT3ZlcmxheS5hZGQoYi53cmFwKS5wcmVwZW5kVG8oYi5zdC5wcmVwZW5kVG98fGEoZG9jdW1lbnQuYm9keSkpLGIuX2xhc3RGb2N1c2VkRWw9ZG9jdW1lbnQuYWN0aXZlRWxlbWVudCxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Yi5jb250ZW50PyhiLl9hZGRDbGFzc1RvTUZQKHEpLGIuX3NldEZvY3VzKCkpOmIuYmdPdmVybGF5LmFkZENsYXNzKHEpLGQub24oXCJmb2N1c2luXCIrcCxiLl9vbkZvY3VzSW4pfSwxNiksYi5pc09wZW49ITAsYi51cGRhdGVTaXplKGspLHkobSksY30sY2xvc2U6ZnVuY3Rpb24oKXtiLmlzT3BlbiYmKHkoaSksYi5pc09wZW49ITEsYi5zdC5yZW1vdmFsRGVsYXkmJiFiLmlzTG93SUUmJmIuc3VwcG9ydHNUcmFuc2l0aW9uPyhiLl9hZGRDbGFzc1RvTUZQKHIpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtiLl9jbG9zZSgpfSxiLnN0LnJlbW92YWxEZWxheSkpOmIuX2Nsb3NlKCkpfSxfY2xvc2U6ZnVuY3Rpb24oKXt5KGgpO3ZhciBjPXIrXCIgXCIrcStcIiBcIjtpZihiLmJnT3ZlcmxheS5kZXRhY2goKSxiLndyYXAuZGV0YWNoKCksYi5jb250YWluZXIuZW1wdHkoKSxiLnN0Lm1haW5DbGFzcyYmKGMrPWIuc3QubWFpbkNsYXNzK1wiIFwiKSxiLl9yZW1vdmVDbGFzc0Zyb21NRlAoYyksYi5maXhlZENvbnRlbnRQb3Mpe3ZhciBlPXttYXJnaW5SaWdodDpcIlwifTtiLmlzSUU3P2EoXCJib2R5LCBodG1sXCIpLmNzcyhcIm92ZXJmbG93XCIsXCJcIik6ZS5vdmVyZmxvdz1cIlwiLGEoXCJodG1sXCIpLmNzcyhlKX1kLm9mZihcImtleXVwXCIrcCtcIiBmb2N1c2luXCIrcCksYi5ldi5vZmYocCksYi53cmFwLmF0dHIoXCJjbGFzc1wiLFwibWZwLXdyYXBcIikucmVtb3ZlQXR0cihcInN0eWxlXCIpLGIuYmdPdmVybGF5LmF0dHIoXCJjbGFzc1wiLFwibWZwLWJnXCIpLGIuY29udGFpbmVyLmF0dHIoXCJjbGFzc1wiLFwibWZwLWNvbnRhaW5lclwiKSwhYi5zdC5zaG93Q2xvc2VCdG58fGIuc3QuY2xvc2VCdG5JbnNpZGUmJmIuY3VyclRlbXBsYXRlW2IuY3Vyckl0ZW0udHlwZV0hPT0hMHx8Yi5jdXJyVGVtcGxhdGUuY2xvc2VCdG4mJmIuY3VyclRlbXBsYXRlLmNsb3NlQnRuLmRldGFjaCgpLGIuc3QuYXV0b0ZvY3VzTGFzdCYmYi5fbGFzdEZvY3VzZWRFbCYmYShiLl9sYXN0Rm9jdXNlZEVsKS5mb2N1cygpLGIuY3Vyckl0ZW09bnVsbCxiLmNvbnRlbnQ9bnVsbCxiLmN1cnJUZW1wbGF0ZT1udWxsLGIucHJldkhlaWdodD0wLHkoail9LHVwZGF0ZVNpemU6ZnVuY3Rpb24oYSl7aWYoYi5pc0lPUyl7dmFyIGM9ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoL3dpbmRvdy5pbm5lcldpZHRoLGQ9d2luZG93LmlubmVySGVpZ2h0KmM7Yi53cmFwLmNzcyhcImhlaWdodFwiLGQpLGIud0g9ZH1lbHNlIGIud0g9YXx8di5oZWlnaHQoKTtiLmZpeGVkQ29udGVudFBvc3x8Yi53cmFwLmNzcyhcImhlaWdodFwiLGIud0gpLHkoXCJSZXNpemVcIil9LHVwZGF0ZUl0ZW1IVE1MOmZ1bmN0aW9uKCl7dmFyIGM9Yi5pdGVtc1tiLmluZGV4XTtiLmNvbnRlbnRDb250YWluZXIuZGV0YWNoKCksYi5jb250ZW50JiZiLmNvbnRlbnQuZGV0YWNoKCksYy5wYXJzZWR8fChjPWIucGFyc2VFbChiLmluZGV4KSk7dmFyIGQ9Yy50eXBlO2lmKHkoXCJCZWZvcmVDaGFuZ2VcIixbYi5jdXJySXRlbT9iLmN1cnJJdGVtLnR5cGU6XCJcIixkXSksYi5jdXJySXRlbT1jLCFiLmN1cnJUZW1wbGF0ZVtkXSl7dmFyIGY9Yi5zdFtkXT9iLnN0W2RdLm1hcmt1cDohMTt5KFwiRmlyc3RNYXJrdXBQYXJzZVwiLGYpLGY/Yi5jdXJyVGVtcGxhdGVbZF09YShmKTpiLmN1cnJUZW1wbGF0ZVtkXT0hMH1lJiZlIT09Yy50eXBlJiZiLmNvbnRhaW5lci5yZW1vdmVDbGFzcyhcIm1mcC1cIitlK1wiLWhvbGRlclwiKTt2YXIgZz1iW1wiZ2V0XCIrZC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStkLnNsaWNlKDEpXShjLGIuY3VyclRlbXBsYXRlW2RdKTtiLmFwcGVuZENvbnRlbnQoZyxkKSxjLnByZWxvYWRlZD0hMCx5KG4sYyksZT1jLnR5cGUsYi5jb250YWluZXIucHJlcGVuZChiLmNvbnRlbnRDb250YWluZXIpLHkoXCJBZnRlckNoYW5nZVwiKX0sYXBwZW5kQ29udGVudDpmdW5jdGlvbihhLGMpe2IuY29udGVudD1hLGE/Yi5zdC5zaG93Q2xvc2VCdG4mJmIuc3QuY2xvc2VCdG5JbnNpZGUmJmIuY3VyclRlbXBsYXRlW2NdPT09ITA/Yi5jb250ZW50LmZpbmQoXCIubWZwLWNsb3NlXCIpLmxlbmd0aHx8Yi5jb250ZW50LmFwcGVuZCh6KCkpOmIuY29udGVudD1hOmIuY29udGVudD1cIlwiLHkoayksYi5jb250YWluZXIuYWRkQ2xhc3MoXCJtZnAtXCIrYytcIi1ob2xkZXJcIiksYi5jb250ZW50Q29udGFpbmVyLmFwcGVuZChiLmNvbnRlbnQpfSxwYXJzZUVsOmZ1bmN0aW9uKGMpe3ZhciBkLGU9Yi5pdGVtc1tjXTtpZihlLnRhZ05hbWU/ZT17ZWw6YShlKX06KGQ9ZS50eXBlLGU9e2RhdGE6ZSxzcmM6ZS5zcmN9KSxlLmVsKXtmb3IodmFyIGY9Yi50eXBlcyxnPTA7ZzxmLmxlbmd0aDtnKyspaWYoZS5lbC5oYXNDbGFzcyhcIm1mcC1cIitmW2ddKSl7ZD1mW2ddO2JyZWFrfWUuc3JjPWUuZWwuYXR0cihcImRhdGEtbWZwLXNyY1wiKSxlLnNyY3x8KGUuc3JjPWUuZWwuYXR0cihcImhyZWZcIikpfXJldHVybiBlLnR5cGU9ZHx8Yi5zdC50eXBlfHxcImlubGluZVwiLGUuaW5kZXg9YyxlLnBhcnNlZD0hMCxiLml0ZW1zW2NdPWUseShcIkVsZW1lbnRQYXJzZVwiLGUpLGIuaXRlbXNbY119LGFkZEdyb3VwOmZ1bmN0aW9uKGEsYyl7dmFyIGQ9ZnVuY3Rpb24oZCl7ZC5tZnBFbD10aGlzLGIuX29wZW5DbGljayhkLGEsYyl9O2N8fChjPXt9KTt2YXIgZT1cImNsaWNrLm1hZ25pZmljUG9wdXBcIjtjLm1haW5FbD1hLGMuaXRlbXM/KGMuaXNPYmo9ITAsYS5vZmYoZSkub24oZSxkKSk6KGMuaXNPYmo9ITEsYy5kZWxlZ2F0ZT9hLm9mZihlKS5vbihlLGMuZGVsZWdhdGUsZCk6KGMuaXRlbXM9YSxhLm9mZihlKS5vbihlLGQpKSl9LF9vcGVuQ2xpY2s6ZnVuY3Rpb24oYyxkLGUpe3ZhciBmPXZvaWQgMCE9PWUubWlkQ2xpY2s/ZS5taWRDbGljazphLm1hZ25pZmljUG9wdXAuZGVmYXVsdHMubWlkQ2xpY2s7aWYoZnx8ISgyPT09Yy53aGljaHx8Yy5jdHJsS2V5fHxjLm1ldGFLZXl8fGMuYWx0S2V5fHxjLnNoaWZ0S2V5KSl7dmFyIGc9dm9pZCAwIT09ZS5kaXNhYmxlT24/ZS5kaXNhYmxlT246YS5tYWduaWZpY1BvcHVwLmRlZmF1bHRzLmRpc2FibGVPbjtpZihnKWlmKGEuaXNGdW5jdGlvbihnKSl7aWYoIWcuY2FsbChiKSlyZXR1cm4hMH1lbHNlIGlmKHYud2lkdGgoKTxnKXJldHVybiEwO2MudHlwZSYmKGMucHJldmVudERlZmF1bHQoKSxiLmlzT3BlbiYmYy5zdG9wUHJvcGFnYXRpb24oKSksZS5lbD1hKGMubWZwRWwpLGUuZGVsZWdhdGUmJihlLml0ZW1zPWQuZmluZChlLmRlbGVnYXRlKSksYi5vcGVuKGUpfX0sdXBkYXRlU3RhdHVzOmZ1bmN0aW9uKGEsZCl7aWYoYi5wcmVsb2FkZXIpe2MhPT1hJiZiLmNvbnRhaW5lci5yZW1vdmVDbGFzcyhcIm1mcC1zLVwiK2MpLGR8fFwibG9hZGluZ1wiIT09YXx8KGQ9Yi5zdC50TG9hZGluZyk7dmFyIGU9e3N0YXR1czphLHRleHQ6ZH07eShcIlVwZGF0ZVN0YXR1c1wiLGUpLGE9ZS5zdGF0dXMsZD1lLnRleHQsYi5wcmVsb2FkZXIuaHRtbChkKSxiLnByZWxvYWRlci5maW5kKFwiYVwiKS5vbihcImNsaWNrXCIsZnVuY3Rpb24oYSl7YS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKX0pLGIuY29udGFpbmVyLmFkZENsYXNzKFwibWZwLXMtXCIrYSksYz1hfX0sX2NoZWNrSWZDbG9zZTpmdW5jdGlvbihjKXtpZighYShjKS5oYXNDbGFzcyhzKSl7dmFyIGQ9Yi5zdC5jbG9zZU9uQ29udGVudENsaWNrLGU9Yi5zdC5jbG9zZU9uQmdDbGljaztpZihkJiZlKXJldHVybiEwO2lmKCFiLmNvbnRlbnR8fGEoYykuaGFzQ2xhc3MoXCJtZnAtY2xvc2VcIil8fGIucHJlbG9hZGVyJiZjPT09Yi5wcmVsb2FkZXJbMF0pcmV0dXJuITA7aWYoYz09PWIuY29udGVudFswXXx8YS5jb250YWlucyhiLmNvbnRlbnRbMF0sYykpe2lmKGQpcmV0dXJuITB9ZWxzZSBpZihlJiZhLmNvbnRhaW5zKGRvY3VtZW50LGMpKXJldHVybiEwO3JldHVybiExfX0sX2FkZENsYXNzVG9NRlA6ZnVuY3Rpb24oYSl7Yi5iZ092ZXJsYXkuYWRkQ2xhc3MoYSksYi53cmFwLmFkZENsYXNzKGEpfSxfcmVtb3ZlQ2xhc3NGcm9tTUZQOmZ1bmN0aW9uKGEpe3RoaXMuYmdPdmVybGF5LnJlbW92ZUNsYXNzKGEpLGIud3JhcC5yZW1vdmVDbGFzcyhhKX0sX2hhc1Njcm9sbEJhcjpmdW5jdGlvbihhKXtyZXR1cm4oYi5pc0lFNz9kLmhlaWdodCgpOmRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0KT4oYXx8di5oZWlnaHQoKSl9LF9zZXRGb2N1czpmdW5jdGlvbigpeyhiLnN0LmZvY3VzP2IuY29udGVudC5maW5kKGIuc3QuZm9jdXMpLmVxKDApOmIud3JhcCkuZm9jdXMoKX0sX29uRm9jdXNJbjpmdW5jdGlvbihjKXtyZXR1cm4gYy50YXJnZXQ9PT1iLndyYXBbMF18fGEuY29udGFpbnMoYi53cmFwWzBdLGMudGFyZ2V0KT92b2lkIDA6KGIuX3NldEZvY3VzKCksITEpfSxfcGFyc2VNYXJrdXA6ZnVuY3Rpb24oYixjLGQpe3ZhciBlO2QuZGF0YSYmKGM9YS5leHRlbmQoZC5kYXRhLGMpKSx5KGwsW2IsYyxkXSksYS5lYWNoKGMsZnVuY3Rpb24oYyxkKXtpZih2b2lkIDA9PT1kfHxkPT09ITEpcmV0dXJuITA7aWYoZT1jLnNwbGl0KFwiX1wiKSxlLmxlbmd0aD4xKXt2YXIgZj1iLmZpbmQocCtcIi1cIitlWzBdKTtpZihmLmxlbmd0aD4wKXt2YXIgZz1lWzFdO1wicmVwbGFjZVdpdGhcIj09PWc/ZlswXSE9PWRbMF0mJmYucmVwbGFjZVdpdGgoZCk6XCJpbWdcIj09PWc/Zi5pcyhcImltZ1wiKT9mLmF0dHIoXCJzcmNcIixkKTpmLnJlcGxhY2VXaXRoKGEoXCI8aW1nPlwiKS5hdHRyKFwic3JjXCIsZCkuYXR0cihcImNsYXNzXCIsZi5hdHRyKFwiY2xhc3NcIikpKTpmLmF0dHIoZVsxXSxkKX19ZWxzZSBiLmZpbmQocCtcIi1cIitjKS5odG1sKGQpfSl9LF9nZXRTY3JvbGxiYXJTaXplOmZ1bmN0aW9uKCl7aWYodm9pZCAwPT09Yi5zY3JvbGxiYXJTaXplKXt2YXIgYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2Euc3R5bGUuY3NzVGV4dD1cIndpZHRoOiA5OXB4OyBoZWlnaHQ6IDk5cHg7IG92ZXJmbG93OiBzY3JvbGw7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAtOTk5OXB4O1wiLGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYSksYi5zY3JvbGxiYXJTaXplPWEub2Zmc2V0V2lkdGgtYS5jbGllbnRXaWR0aCxkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGEpfXJldHVybiBiLnNjcm9sbGJhclNpemV9fSxhLm1hZ25pZmljUG9wdXA9e2luc3RhbmNlOm51bGwscHJvdG86dC5wcm90b3R5cGUsbW9kdWxlczpbXSxvcGVuOmZ1bmN0aW9uKGIsYyl7cmV0dXJuIEEoKSxiPWI/YS5leHRlbmQoITAse30sYik6e30sYi5pc09iaj0hMCxiLmluZGV4PWN8fDAsdGhpcy5pbnN0YW5jZS5vcGVuKGIpfSxjbG9zZTpmdW5jdGlvbigpe3JldHVybiBhLm1hZ25pZmljUG9wdXAuaW5zdGFuY2UmJmEubWFnbmlmaWNQb3B1cC5pbnN0YW5jZS5jbG9zZSgpfSxyZWdpc3Rlck1vZHVsZTpmdW5jdGlvbihiLGMpe2Mub3B0aW9ucyYmKGEubWFnbmlmaWNQb3B1cC5kZWZhdWx0c1tiXT1jLm9wdGlvbnMpLGEuZXh0ZW5kKHRoaXMucHJvdG8sYy5wcm90byksdGhpcy5tb2R1bGVzLnB1c2goYil9LGRlZmF1bHRzOntkaXNhYmxlT246MCxrZXk6bnVsbCxtaWRDbGljazohMSxtYWluQ2xhc3M6XCJcIixwcmVsb2FkZXI6ITAsZm9jdXM6XCJcIixjbG9zZU9uQ29udGVudENsaWNrOiExLGNsb3NlT25CZ0NsaWNrOiEwLGNsb3NlQnRuSW5zaWRlOiEwLHNob3dDbG9zZUJ0bjohMCxlbmFibGVFc2NhcGVLZXk6ITAsbW9kYWw6ITEsYWxpZ25Ub3A6ITEscmVtb3ZhbERlbGF5OjAscHJlcGVuZFRvOm51bGwsZml4ZWRDb250ZW50UG9zOlwiYXV0b1wiLGZpeGVkQmdQb3M6XCJhdXRvXCIsb3ZlcmZsb3dZOlwiYXV0b1wiLGNsb3NlTWFya3VwOic8YnV0dG9uIHRpdGxlPVwiJXRpdGxlJVwiIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIm1mcC1jbG9zZVwiPiYjMjE1OzwvYnV0dG9uPicsdENsb3NlOlwiQ2xvc2UgKEVzYylcIix0TG9hZGluZzpcIkxvYWRpbmcuLi5cIixhdXRvRm9jdXNMYXN0OiEwfX0sYS5mbi5tYWduaWZpY1BvcHVwPWZ1bmN0aW9uKGMpe0EoKTt2YXIgZD1hKHRoaXMpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBjKWlmKFwib3BlblwiPT09Yyl7dmFyIGUsZj11P2QuZGF0YShcIm1hZ25pZmljUG9wdXBcIik6ZFswXS5tYWduaWZpY1BvcHVwLGc9cGFyc2VJbnQoYXJndW1lbnRzWzFdLDEwKXx8MDtmLml0ZW1zP2U9Zi5pdGVtc1tnXTooZT1kLGYuZGVsZWdhdGUmJihlPWUuZmluZChmLmRlbGVnYXRlKSksZT1lLmVxKGcpKSxiLl9vcGVuQ2xpY2soe21mcEVsOmV9LGQsZil9ZWxzZSBiLmlzT3BlbiYmYltjXS5hcHBseShiLEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKSk7ZWxzZSBjPWEuZXh0ZW5kKCEwLHt9LGMpLHU/ZC5kYXRhKFwibWFnbmlmaWNQb3B1cFwiLGMpOmRbMF0ubWFnbmlmaWNQb3B1cD1jLGIuYWRkR3JvdXAoZCxjKTtyZXR1cm4gZH07dmFyIEMsRCxFLEY9XCJpbmxpbmVcIixHPWZ1bmN0aW9uKCl7RSYmKEQuYWZ0ZXIoRS5hZGRDbGFzcyhDKSkuZGV0YWNoKCksRT1udWxsKX07YS5tYWduaWZpY1BvcHVwLnJlZ2lzdGVyTW9kdWxlKEYse29wdGlvbnM6e2hpZGRlbkNsYXNzOlwiaGlkZVwiLG1hcmt1cDpcIlwiLHROb3RGb3VuZDpcIkNvbnRlbnQgbm90IGZvdW5kXCJ9LHByb3RvOntpbml0SW5saW5lOmZ1bmN0aW9uKCl7Yi50eXBlcy5wdXNoKEYpLHcoaCtcIi5cIitGLGZ1bmN0aW9uKCl7RygpfSl9LGdldElubGluZTpmdW5jdGlvbihjLGQpe2lmKEcoKSxjLnNyYyl7dmFyIGU9Yi5zdC5pbmxpbmUsZj1hKGMuc3JjKTtpZihmLmxlbmd0aCl7dmFyIGc9ZlswXS5wYXJlbnROb2RlO2cmJmcudGFnTmFtZSYmKER8fChDPWUuaGlkZGVuQ2xhc3MsRD14KEMpLEM9XCJtZnAtXCIrQyksRT1mLmFmdGVyKEQpLmRldGFjaCgpLnJlbW92ZUNsYXNzKEMpKSxiLnVwZGF0ZVN0YXR1cyhcInJlYWR5XCIpfWVsc2UgYi51cGRhdGVTdGF0dXMoXCJlcnJvclwiLGUudE5vdEZvdW5kKSxmPWEoXCI8ZGl2PlwiKTtyZXR1cm4gYy5pbmxpbmVFbGVtZW50PWYsZn1yZXR1cm4gYi51cGRhdGVTdGF0dXMoXCJyZWFkeVwiKSxiLl9wYXJzZU1hcmt1cChkLHt9LGMpLGR9fX0pO3ZhciBILEk9XCJhamF4XCIsSj1mdW5jdGlvbigpe0gmJmEoZG9jdW1lbnQuYm9keSkucmVtb3ZlQ2xhc3MoSCl9LEs9ZnVuY3Rpb24oKXtKKCksYi5yZXEmJmIucmVxLmFib3J0KCl9O2EubWFnbmlmaWNQb3B1cC5yZWdpc3Rlck1vZHVsZShJLHtvcHRpb25zOntzZXR0aW5nczpudWxsLGN1cnNvcjpcIm1mcC1hamF4LWN1clwiLHRFcnJvcjonPGEgaHJlZj1cIiV1cmwlXCI+VGhlIGNvbnRlbnQ8L2E+IGNvdWxkIG5vdCBiZSBsb2FkZWQuJ30scHJvdG86e2luaXRBamF4OmZ1bmN0aW9uKCl7Yi50eXBlcy5wdXNoKEkpLEg9Yi5zdC5hamF4LmN1cnNvcix3KGgrXCIuXCIrSSxLKSx3KFwiQmVmb3JlQ2hhbmdlLlwiK0ksSyl9LGdldEFqYXg6ZnVuY3Rpb24oYyl7SCYmYShkb2N1bWVudC5ib2R5KS5hZGRDbGFzcyhIKSxiLnVwZGF0ZVN0YXR1cyhcImxvYWRpbmdcIik7dmFyIGQ9YS5leHRlbmQoe3VybDpjLnNyYyxzdWNjZXNzOmZ1bmN0aW9uKGQsZSxmKXt2YXIgZz17ZGF0YTpkLHhocjpmfTt5KFwiUGFyc2VBamF4XCIsZyksYi5hcHBlbmRDb250ZW50KGEoZy5kYXRhKSxJKSxjLmZpbmlzaGVkPSEwLEooKSxiLl9zZXRGb2N1cygpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtiLndyYXAuYWRkQ2xhc3MocSl9LDE2KSxiLnVwZGF0ZVN0YXR1cyhcInJlYWR5XCIpLHkoXCJBamF4Q29udGVudEFkZGVkXCIpfSxlcnJvcjpmdW5jdGlvbigpe0ooKSxjLmZpbmlzaGVkPWMubG9hZEVycm9yPSEwLGIudXBkYXRlU3RhdHVzKFwiZXJyb3JcIixiLnN0LmFqYXgudEVycm9yLnJlcGxhY2UoXCIldXJsJVwiLGMuc3JjKSl9fSxiLnN0LmFqYXguc2V0dGluZ3MpO3JldHVybiBiLnJlcT1hLmFqYXgoZCksXCJcIn19fSk7dmFyIEwsTT1mdW5jdGlvbihjKXtpZihjLmRhdGEmJnZvaWQgMCE9PWMuZGF0YS50aXRsZSlyZXR1cm4gYy5kYXRhLnRpdGxlO3ZhciBkPWIuc3QuaW1hZ2UudGl0bGVTcmM7aWYoZCl7aWYoYS5pc0Z1bmN0aW9uKGQpKXJldHVybiBkLmNhbGwoYixjKTtpZihjLmVsKXJldHVybiBjLmVsLmF0dHIoZCl8fFwiXCJ9cmV0dXJuXCJcIn07YS5tYWduaWZpY1BvcHVwLnJlZ2lzdGVyTW9kdWxlKFwiaW1hZ2VcIix7b3B0aW9uczp7bWFya3VwOic8ZGl2IGNsYXNzPVwibWZwLWZpZ3VyZVwiPjxkaXYgY2xhc3M9XCJtZnAtY2xvc2VcIj48L2Rpdj48ZmlndXJlPjxkaXYgY2xhc3M9XCJtZnAtaW1nXCI+PC9kaXY+PGZpZ2NhcHRpb24+PGRpdiBjbGFzcz1cIm1mcC1ib3R0b20tYmFyXCI+PGRpdiBjbGFzcz1cIm1mcC10aXRsZVwiPjwvZGl2PjxkaXYgY2xhc3M9XCJtZnAtY291bnRlclwiPjwvZGl2PjwvZGl2PjwvZmlnY2FwdGlvbj48L2ZpZ3VyZT48L2Rpdj4nLGN1cnNvcjpcIm1mcC16b29tLW91dC1jdXJcIix0aXRsZVNyYzpcInRpdGxlXCIsdmVydGljYWxGaXQ6ITAsdEVycm9yOic8YSBocmVmPVwiJXVybCVcIj5UaGUgaW1hZ2U8L2E+IGNvdWxkIG5vdCBiZSBsb2FkZWQuJ30scHJvdG86e2luaXRJbWFnZTpmdW5jdGlvbigpe3ZhciBjPWIuc3QuaW1hZ2UsZD1cIi5pbWFnZVwiO2IudHlwZXMucHVzaChcImltYWdlXCIpLHcobStkLGZ1bmN0aW9uKCl7XCJpbWFnZVwiPT09Yi5jdXJySXRlbS50eXBlJiZjLmN1cnNvciYmYShkb2N1bWVudC5ib2R5KS5hZGRDbGFzcyhjLmN1cnNvcil9KSx3KGgrZCxmdW5jdGlvbigpe2MuY3Vyc29yJiZhKGRvY3VtZW50LmJvZHkpLnJlbW92ZUNsYXNzKGMuY3Vyc29yKSx2Lm9mZihcInJlc2l6ZVwiK3ApfSksdyhcIlJlc2l6ZVwiK2QsYi5yZXNpemVJbWFnZSksYi5pc0xvd0lFJiZ3KFwiQWZ0ZXJDaGFuZ2VcIixiLnJlc2l6ZUltYWdlKX0scmVzaXplSW1hZ2U6ZnVuY3Rpb24oKXt2YXIgYT1iLmN1cnJJdGVtO2lmKGEmJmEuaW1nJiZiLnN0LmltYWdlLnZlcnRpY2FsRml0KXt2YXIgYz0wO2IuaXNMb3dJRSYmKGM9cGFyc2VJbnQoYS5pbWcuY3NzKFwicGFkZGluZy10b3BcIiksMTApK3BhcnNlSW50KGEuaW1nLmNzcyhcInBhZGRpbmctYm90dG9tXCIpLDEwKSksYS5pbWcuY3NzKFwibWF4LWhlaWdodFwiLGIud0gtYyl9fSxfb25JbWFnZUhhc1NpemU6ZnVuY3Rpb24oYSl7YS5pbWcmJihhLmhhc1NpemU9ITAsTCYmY2xlYXJJbnRlcnZhbChMKSxhLmlzQ2hlY2tpbmdJbWdTaXplPSExLHkoXCJJbWFnZUhhc1NpemVcIixhKSxhLmltZ0hpZGRlbiYmKGIuY29udGVudCYmYi5jb250ZW50LnJlbW92ZUNsYXNzKFwibWZwLWxvYWRpbmdcIiksYS5pbWdIaWRkZW49ITEpKX0sZmluZEltYWdlU2l6ZTpmdW5jdGlvbihhKXt2YXIgYz0wLGQ9YS5pbWdbMF0sZT1mdW5jdGlvbihmKXtMJiZjbGVhckludGVydmFsKEwpLEw9c2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXtyZXR1cm4gZC5uYXR1cmFsV2lkdGg+MD92b2lkIGIuX29uSW1hZ2VIYXNTaXplKGEpOihjPjIwMCYmY2xlYXJJbnRlcnZhbChMKSxjKyssdm9pZCgzPT09Yz9lKDEwKTo0MD09PWM/ZSg1MCk6MTAwPT09YyYmZSg1MDApKSl9LGYpfTtlKDEpfSxnZXRJbWFnZTpmdW5jdGlvbihjLGQpe3ZhciBlPTAsZj1mdW5jdGlvbigpe2MmJihjLmltZ1swXS5jb21wbGV0ZT8oYy5pbWcub2ZmKFwiLm1mcGxvYWRlclwiKSxjPT09Yi5jdXJySXRlbSYmKGIuX29uSW1hZ2VIYXNTaXplKGMpLGIudXBkYXRlU3RhdHVzKFwicmVhZHlcIikpLGMuaGFzU2l6ZT0hMCxjLmxvYWRlZD0hMCx5KFwiSW1hZ2VMb2FkQ29tcGxldGVcIikpOihlKyssMjAwPmU/c2V0VGltZW91dChmLDEwMCk6ZygpKSl9LGc9ZnVuY3Rpb24oKXtjJiYoYy5pbWcub2ZmKFwiLm1mcGxvYWRlclwiKSxjPT09Yi5jdXJySXRlbSYmKGIuX29uSW1hZ2VIYXNTaXplKGMpLGIudXBkYXRlU3RhdHVzKFwiZXJyb3JcIixoLnRFcnJvci5yZXBsYWNlKFwiJXVybCVcIixjLnNyYykpKSxjLmhhc1NpemU9ITAsYy5sb2FkZWQ9ITAsYy5sb2FkRXJyb3I9ITApfSxoPWIuc3QuaW1hZ2UsaT1kLmZpbmQoXCIubWZwLWltZ1wiKTtpZihpLmxlbmd0aCl7dmFyIGo9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtqLmNsYXNzTmFtZT1cIm1mcC1pbWdcIixjLmVsJiZjLmVsLmZpbmQoXCJpbWdcIikubGVuZ3RoJiYoai5hbHQ9Yy5lbC5maW5kKFwiaW1nXCIpLmF0dHIoXCJhbHRcIikpLGMuaW1nPWEoaikub24oXCJsb2FkLm1mcGxvYWRlclwiLGYpLm9uKFwiZXJyb3IubWZwbG9hZGVyXCIsZyksai5zcmM9Yy5zcmMsaS5pcyhcImltZ1wiKSYmKGMuaW1nPWMuaW1nLmNsb25lKCkpLGo9Yy5pbWdbMF0sai5uYXR1cmFsV2lkdGg+MD9jLmhhc1NpemU9ITA6ai53aWR0aHx8KGMuaGFzU2l6ZT0hMSl9cmV0dXJuIGIuX3BhcnNlTWFya3VwKGQse3RpdGxlOk0oYyksaW1nX3JlcGxhY2VXaXRoOmMuaW1nfSxjKSxiLnJlc2l6ZUltYWdlKCksYy5oYXNTaXplPyhMJiZjbGVhckludGVydmFsKEwpLGMubG9hZEVycm9yPyhkLmFkZENsYXNzKFwibWZwLWxvYWRpbmdcIiksYi51cGRhdGVTdGF0dXMoXCJlcnJvclwiLGgudEVycm9yLnJlcGxhY2UoXCIldXJsJVwiLGMuc3JjKSkpOihkLnJlbW92ZUNsYXNzKFwibWZwLWxvYWRpbmdcIiksYi51cGRhdGVTdGF0dXMoXCJyZWFkeVwiKSksZCk6KGIudXBkYXRlU3RhdHVzKFwibG9hZGluZ1wiKSxjLmxvYWRpbmc9ITAsYy5oYXNTaXplfHwoYy5pbWdIaWRkZW49ITAsZC5hZGRDbGFzcyhcIm1mcC1sb2FkaW5nXCIpLGIuZmluZEltYWdlU2l6ZShjKSksZCl9fX0pO3ZhciBOLE89ZnVuY3Rpb24oKXtyZXR1cm4gdm9pZCAwPT09TiYmKE49dm9pZCAwIT09ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIikuc3R5bGUuTW96VHJhbnNmb3JtKSxOfTthLm1hZ25pZmljUG9wdXAucmVnaXN0ZXJNb2R1bGUoXCJ6b29tXCIse29wdGlvbnM6e2VuYWJsZWQ6ITEsZWFzaW5nOlwiZWFzZS1pbi1vdXRcIixkdXJhdGlvbjozMDAsb3BlbmVyOmZ1bmN0aW9uKGEpe3JldHVybiBhLmlzKFwiaW1nXCIpP2E6YS5maW5kKFwiaW1nXCIpfX0scHJvdG86e2luaXRab29tOmZ1bmN0aW9uKCl7dmFyIGEsYz1iLnN0Lnpvb20sZD1cIi56b29tXCI7aWYoYy5lbmFibGVkJiZiLnN1cHBvcnRzVHJhbnNpdGlvbil7dmFyIGUsZixnPWMuZHVyYXRpb24saj1mdW5jdGlvbihhKXt2YXIgYj1hLmNsb25lKCkucmVtb3ZlQXR0cihcInN0eWxlXCIpLnJlbW92ZUF0dHIoXCJjbGFzc1wiKS5hZGRDbGFzcyhcIm1mcC1hbmltYXRlZC1pbWFnZVwiKSxkPVwiYWxsIFwiK2MuZHVyYXRpb24vMWUzK1wicyBcIitjLmVhc2luZyxlPXtwb3NpdGlvbjpcImZpeGVkXCIsekluZGV4Ojk5OTksbGVmdDowLHRvcDowLFwiLXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5XCI6XCJoaWRkZW5cIn0sZj1cInRyYW5zaXRpb25cIjtyZXR1cm4gZVtcIi13ZWJraXQtXCIrZl09ZVtcIi1tb3otXCIrZl09ZVtcIi1vLVwiK2ZdPWVbZl09ZCxiLmNzcyhlKSxifSxrPWZ1bmN0aW9uKCl7Yi5jb250ZW50LmNzcyhcInZpc2liaWxpdHlcIixcInZpc2libGVcIil9O3coXCJCdWlsZENvbnRyb2xzXCIrZCxmdW5jdGlvbigpe2lmKGIuX2FsbG93Wm9vbSgpKXtpZihjbGVhclRpbWVvdXQoZSksYi5jb250ZW50LmNzcyhcInZpc2liaWxpdHlcIixcImhpZGRlblwiKSxhPWIuX2dldEl0ZW1Ub1pvb20oKSwhYSlyZXR1cm4gdm9pZCBrKCk7Zj1qKGEpLGYuY3NzKGIuX2dldE9mZnNldCgpKSxiLndyYXAuYXBwZW5kKGYpLGU9c2V0VGltZW91dChmdW5jdGlvbigpe2YuY3NzKGIuX2dldE9mZnNldCghMCkpLGU9c2V0VGltZW91dChmdW5jdGlvbigpe2soKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Zi5yZW1vdmUoKSxhPWY9bnVsbCx5KFwiWm9vbUFuaW1hdGlvbkVuZGVkXCIpfSwxNil9LGcpfSwxNil9fSksdyhpK2QsZnVuY3Rpb24oKXtpZihiLl9hbGxvd1pvb20oKSl7aWYoY2xlYXJUaW1lb3V0KGUpLGIuc3QucmVtb3ZhbERlbGF5PWcsIWEpe2lmKGE9Yi5fZ2V0SXRlbVRvWm9vbSgpLCFhKXJldHVybjtmPWooYSl9Zi5jc3MoYi5fZ2V0T2Zmc2V0KCEwKSksYi53cmFwLmFwcGVuZChmKSxiLmNvbnRlbnQuY3NzKFwidmlzaWJpbGl0eVwiLFwiaGlkZGVuXCIpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtmLmNzcyhiLl9nZXRPZmZzZXQoKSl9LDE2KX19KSx3KGgrZCxmdW5jdGlvbigpe2IuX2FsbG93Wm9vbSgpJiYoaygpLGYmJmYucmVtb3ZlKCksYT1udWxsKX0pfX0sX2FsbG93Wm9vbTpmdW5jdGlvbigpe3JldHVyblwiaW1hZ2VcIj09PWIuY3Vyckl0ZW0udHlwZX0sX2dldEl0ZW1Ub1pvb206ZnVuY3Rpb24oKXtyZXR1cm4gYi5jdXJySXRlbS5oYXNTaXplP2IuY3Vyckl0ZW0uaW1nOiExfSxfZ2V0T2Zmc2V0OmZ1bmN0aW9uKGMpe3ZhciBkO2Q9Yz9iLmN1cnJJdGVtLmltZzpiLnN0Lnpvb20ub3BlbmVyKGIuY3Vyckl0ZW0uZWx8fGIuY3Vyckl0ZW0pO3ZhciBlPWQub2Zmc2V0KCksZj1wYXJzZUludChkLmNzcyhcInBhZGRpbmctdG9wXCIpLDEwKSxnPXBhcnNlSW50KGQuY3NzKFwicGFkZGluZy1ib3R0b21cIiksMTApO2UudG9wLT1hKHdpbmRvdykuc2Nyb2xsVG9wKCktZjt2YXIgaD17d2lkdGg6ZC53aWR0aCgpLGhlaWdodDoodT9kLmlubmVySGVpZ2h0KCk6ZFswXS5vZmZzZXRIZWlnaHQpLWctZn07cmV0dXJuIE8oKT9oW1wiLW1vei10cmFuc2Zvcm1cIl09aC50cmFuc2Zvcm09XCJ0cmFuc2xhdGUoXCIrZS5sZWZ0K1wicHgsXCIrZS50b3ArXCJweClcIjooaC5sZWZ0PWUubGVmdCxoLnRvcD1lLnRvcCksaH19fSk7dmFyIFA9XCJpZnJhbWVcIixRPVwiLy9hYm91dDpibGFua1wiLFI9ZnVuY3Rpb24oYSl7aWYoYi5jdXJyVGVtcGxhdGVbUF0pe3ZhciBjPWIuY3VyclRlbXBsYXRlW1BdLmZpbmQoXCJpZnJhbWVcIik7Yy5sZW5ndGgmJihhfHwoY1swXS5zcmM9USksYi5pc0lFOCYmYy5jc3MoXCJkaXNwbGF5XCIsYT9cImJsb2NrXCI6XCJub25lXCIpKX19O2EubWFnbmlmaWNQb3B1cC5yZWdpc3Rlck1vZHVsZShQLHtvcHRpb25zOnttYXJrdXA6JzxkaXYgY2xhc3M9XCJtZnAtaWZyYW1lLXNjYWxlclwiPjxkaXYgY2xhc3M9XCJtZnAtY2xvc2VcIj48L2Rpdj48aWZyYW1lIGNsYXNzPVwibWZwLWlmcmFtZVwiIHNyYz1cIi8vYWJvdXQ6YmxhbmtcIiBmcmFtZWJvcmRlcj1cIjBcIiBhbGxvd2Z1bGxzY3JlZW4+PC9pZnJhbWU+PC9kaXY+JyxzcmNBY3Rpb246XCJpZnJhbWVfc3JjXCIscGF0dGVybnM6e3lvdXR1YmU6e2luZGV4OlwieW91dHViZS5jb21cIixpZDpcInY9XCIsc3JjOlwiLy93d3cueW91dHViZS5jb20vZW1iZWQvJWlkJT9hdXRvcGxheT0xXCJ9LHZpbWVvOntpbmRleDpcInZpbWVvLmNvbS9cIixpZDpcIi9cIixzcmM6XCIvL3BsYXllci52aW1lby5jb20vdmlkZW8vJWlkJT9hdXRvcGxheT0xXCJ9LGdtYXBzOntpbmRleDpcIi8vbWFwcy5nb29nbGUuXCIsc3JjOlwiJWlkJSZvdXRwdXQ9ZW1iZWRcIn19fSxwcm90bzp7aW5pdElmcmFtZTpmdW5jdGlvbigpe2IudHlwZXMucHVzaChQKSx3KFwiQmVmb3JlQ2hhbmdlXCIsZnVuY3Rpb24oYSxiLGMpe2IhPT1jJiYoYj09PVA/UigpOmM9PT1QJiZSKCEwKSl9KSx3KGgrXCIuXCIrUCxmdW5jdGlvbigpe1IoKX0pfSxnZXRJZnJhbWU6ZnVuY3Rpb24oYyxkKXt2YXIgZT1jLnNyYyxmPWIuc3QuaWZyYW1lO2EuZWFjaChmLnBhdHRlcm5zLGZ1bmN0aW9uKCl7cmV0dXJuIGUuaW5kZXhPZih0aGlzLmluZGV4KT4tMT8odGhpcy5pZCYmKGU9XCJzdHJpbmdcIj09dHlwZW9mIHRoaXMuaWQ/ZS5zdWJzdHIoZS5sYXN0SW5kZXhPZih0aGlzLmlkKSt0aGlzLmlkLmxlbmd0aCxlLmxlbmd0aCk6dGhpcy5pZC5jYWxsKHRoaXMsZSkpLGU9dGhpcy5zcmMucmVwbGFjZShcIiVpZCVcIixlKSwhMSk6dm9pZCAwfSk7dmFyIGc9e307cmV0dXJuIGYuc3JjQWN0aW9uJiYoZ1tmLnNyY0FjdGlvbl09ZSksYi5fcGFyc2VNYXJrdXAoZCxnLGMpLGIudXBkYXRlU3RhdHVzKFwicmVhZHlcIiksZH19fSk7dmFyIFM9ZnVuY3Rpb24oYSl7dmFyIGM9Yi5pdGVtcy5sZW5ndGg7cmV0dXJuIGE+Yy0xP2EtYzowPmE/YythOmF9LFQ9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBhLnJlcGxhY2UoLyVjdXJyJS9naSxiKzEpLnJlcGxhY2UoLyV0b3RhbCUvZ2ksYyl9O2EubWFnbmlmaWNQb3B1cC5yZWdpc3Rlck1vZHVsZShcImdhbGxlcnlcIix7b3B0aW9uczp7ZW5hYmxlZDohMSxhcnJvd01hcmt1cDonPGJ1dHRvbiB0aXRsZT1cIiV0aXRsZSVcIiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJtZnAtYXJyb3cgbWZwLWFycm93LSVkaXIlXCI+PC9idXR0b24+JyxwcmVsb2FkOlswLDJdLG5hdmlnYXRlQnlJbWdDbGljazohMCxhcnJvd3M6ITAsdFByZXY6XCJQcmV2aW91cyAoTGVmdCBhcnJvdyBrZXkpXCIsdE5leHQ6XCJOZXh0IChSaWdodCBhcnJvdyBrZXkpXCIsdENvdW50ZXI6XCIlY3VyciUgb2YgJXRvdGFsJVwifSxwcm90bzp7aW5pdEdhbGxlcnk6ZnVuY3Rpb24oKXt2YXIgYz1iLnN0LmdhbGxlcnksZT1cIi5tZnAtZ2FsbGVyeVwiO3JldHVybiBiLmRpcmVjdGlvbj0hMCxjJiZjLmVuYWJsZWQ/KGYrPVwiIG1mcC1nYWxsZXJ5XCIsdyhtK2UsZnVuY3Rpb24oKXtjLm5hdmlnYXRlQnlJbWdDbGljayYmYi53cmFwLm9uKFwiY2xpY2tcIitlLFwiLm1mcC1pbWdcIixmdW5jdGlvbigpe3JldHVybiBiLml0ZW1zLmxlbmd0aD4xPyhiLm5leHQoKSwhMSk6dm9pZCAwfSksZC5vbihcImtleWRvd25cIitlLGZ1bmN0aW9uKGEpezM3PT09YS5rZXlDb2RlP2IucHJldigpOjM5PT09YS5rZXlDb2RlJiZiLm5leHQoKX0pfSksdyhcIlVwZGF0ZVN0YXR1c1wiK2UsZnVuY3Rpb24oYSxjKXtjLnRleHQmJihjLnRleHQ9VChjLnRleHQsYi5jdXJySXRlbS5pbmRleCxiLml0ZW1zLmxlbmd0aCkpfSksdyhsK2UsZnVuY3Rpb24oYSxkLGUsZil7dmFyIGc9Yi5pdGVtcy5sZW5ndGg7ZS5jb3VudGVyPWc+MT9UKGMudENvdW50ZXIsZi5pbmRleCxnKTpcIlwifSksdyhcIkJ1aWxkQ29udHJvbHNcIitlLGZ1bmN0aW9uKCl7aWYoYi5pdGVtcy5sZW5ndGg+MSYmYy5hcnJvd3MmJiFiLmFycm93TGVmdCl7dmFyIGQ9Yy5hcnJvd01hcmt1cCxlPWIuYXJyb3dMZWZ0PWEoZC5yZXBsYWNlKC8ldGl0bGUlL2dpLGMudFByZXYpLnJlcGxhY2UoLyVkaXIlL2dpLFwibGVmdFwiKSkuYWRkQ2xhc3MocyksZj1iLmFycm93UmlnaHQ9YShkLnJlcGxhY2UoLyV0aXRsZSUvZ2ksYy50TmV4dCkucmVwbGFjZSgvJWRpciUvZ2ksXCJyaWdodFwiKSkuYWRkQ2xhc3Mocyk7ZS5jbGljayhmdW5jdGlvbigpe2IucHJldigpfSksZi5jbGljayhmdW5jdGlvbigpe2IubmV4dCgpfSksYi5jb250YWluZXIuYXBwZW5kKGUuYWRkKGYpKX19KSx3KG4rZSxmdW5jdGlvbigpe2IuX3ByZWxvYWRUaW1lb3V0JiZjbGVhclRpbWVvdXQoYi5fcHJlbG9hZFRpbWVvdXQpLGIuX3ByZWxvYWRUaW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24oKXtiLnByZWxvYWROZWFyYnlJbWFnZXMoKSxiLl9wcmVsb2FkVGltZW91dD1udWxsfSwxNil9KSx2b2lkIHcoaCtlLGZ1bmN0aW9uKCl7ZC5vZmYoZSksYi53cmFwLm9mZihcImNsaWNrXCIrZSksYi5hcnJvd1JpZ2h0PWIuYXJyb3dMZWZ0PW51bGx9KSk6ITF9LG5leHQ6ZnVuY3Rpb24oKXtiLmRpcmVjdGlvbj0hMCxiLmluZGV4PVMoYi5pbmRleCsxKSxiLnVwZGF0ZUl0ZW1IVE1MKCl9LHByZXY6ZnVuY3Rpb24oKXtiLmRpcmVjdGlvbj0hMSxiLmluZGV4PVMoYi5pbmRleC0xKSxiLnVwZGF0ZUl0ZW1IVE1MKCl9LGdvVG86ZnVuY3Rpb24oYSl7Yi5kaXJlY3Rpb249YT49Yi5pbmRleCxiLmluZGV4PWEsYi51cGRhdGVJdGVtSFRNTCgpfSxwcmVsb2FkTmVhcmJ5SW1hZ2VzOmZ1bmN0aW9uKCl7dmFyIGEsYz1iLnN0LmdhbGxlcnkucHJlbG9hZCxkPU1hdGgubWluKGNbMF0sYi5pdGVtcy5sZW5ndGgpLGU9TWF0aC5taW4oY1sxXSxiLml0ZW1zLmxlbmd0aCk7Zm9yKGE9MTthPD0oYi5kaXJlY3Rpb24/ZTpkKTthKyspYi5fcHJlbG9hZEl0ZW0oYi5pbmRleCthKTtmb3IoYT0xO2E8PShiLmRpcmVjdGlvbj9kOmUpO2ErKyliLl9wcmVsb2FkSXRlbShiLmluZGV4LWEpfSxfcHJlbG9hZEl0ZW06ZnVuY3Rpb24oYyl7aWYoYz1TKGMpLCFiLml0ZW1zW2NdLnByZWxvYWRlZCl7dmFyIGQ9Yi5pdGVtc1tjXTtkLnBhcnNlZHx8KGQ9Yi5wYXJzZUVsKGMpKSx5KFwiTGF6eUxvYWRcIixkKSxcImltYWdlXCI9PT1kLnR5cGUmJihkLmltZz1hKCc8aW1nIGNsYXNzPVwibWZwLWltZ1wiIC8+Jykub24oXCJsb2FkLm1mcGxvYWRlclwiLGZ1bmN0aW9uKCl7ZC5oYXNTaXplPSEwfSkub24oXCJlcnJvci5tZnBsb2FkZXJcIixmdW5jdGlvbigpe2QuaGFzU2l6ZT0hMCxkLmxvYWRFcnJvcj0hMCx5KFwiTGF6eUxvYWRFcnJvclwiLGQpfSkuYXR0cihcInNyY1wiLGQuc3JjKSksZC5wcmVsb2FkZWQ9ITB9fX19KTt2YXIgVT1cInJldGluYVwiO2EubWFnbmlmaWNQb3B1cC5yZWdpc3Rlck1vZHVsZShVLHtvcHRpb25zOntyZXBsYWNlU3JjOmZ1bmN0aW9uKGEpe3JldHVybiBhLnNyYy5yZXBsYWNlKC9cXC5cXHcrJC8sZnVuY3Rpb24oYSl7cmV0dXJuXCJAMnhcIithfSl9LHJhdGlvOjF9LHByb3RvOntpbml0UmV0aW5hOmZ1bmN0aW9uKCl7aWYod2luZG93LmRldmljZVBpeGVsUmF0aW8+MSl7dmFyIGE9Yi5zdC5yZXRpbmEsYz1hLnJhdGlvO2M9aXNOYU4oYyk/YygpOmMsYz4xJiYodyhcIkltYWdlSGFzU2l6ZS5cIitVLGZ1bmN0aW9uKGEsYil7Yi5pbWcuY3NzKHtcIm1heC13aWR0aFwiOmIuaW1nWzBdLm5hdHVyYWxXaWR0aC9jLHdpZHRoOlwiMTAwJVwifSl9KSx3KFwiRWxlbWVudFBhcnNlLlwiK1UsZnVuY3Rpb24oYixkKXtkLnNyYz1hLnJlcGxhY2VTcmMoZCxjKX0pKX19fX0pLEEoKX0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tYWduaWZpYy1wb3B1cC9kaXN0L2pxdWVyeS5tYWduaWZpYy1wb3B1cC5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDEwODRcbi8vIG1vZHVsZSBjaHVua3MgPSA1Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 1122:
/* unknown exports provided */
/* all exports used */
/*!****************************************************!*\
  !*** ./src/app/extra/calendar/calendar.style.scss ***!
  \****************************************************/
/***/ (function(module, exports) {

eval("module.exports = \"/*!\\n * FullCalendar v3.0.1 Stylesheet\\n * Docs & License: http://fullcalendar.io/\\n * (c) 2016 Adam Shaw\\n */\\n.fc {\\n  direction: ltr;\\n  text-align: left; }\\n\\n.fc-rtl {\\n  text-align: right; }\\n\\nbody .fc {\\n  /* extra precedence to overcome jqui */\\n  font-size: 1em; }\\n\\n/* Colors\\n--------------------------------------------------------------------------------------------------*/\\n.fc-unthemed th,\\n.fc-unthemed td,\\n.fc-unthemed thead,\\n.fc-unthemed tbody,\\n.fc-unthemed .fc-divider,\\n.fc-unthemed .fc-row,\\n.fc-unthemed .fc-content,\\n.fc-unthemed .fc-popover,\\n.fc-unthemed .fc-list-view,\\n.fc-unthemed .fc-list-heading td {\\n  border-color: #ddd; }\\n\\n.fc-unthemed .fc-popover {\\n  background-color: #fff; }\\n\\n.fc-unthemed .fc-divider,\\n.fc-unthemed .fc-popover .fc-header,\\n.fc-unthemed .fc-list-heading td {\\n  background: #eee; }\\n\\n.fc-unthemed .fc-popover .fc-header .fc-close {\\n  color: #666; }\\n\\n.fc-unthemed .fc-today {\\n  background: #fcf8e3; }\\n\\n.fc-highlight {\\n  /* when user is selecting cells */\\n  background: #bce8f1;\\n  opacity: .3; }\\n\\n.fc-bgevent {\\n  /* default look for background events */\\n  background: #8fdf82;\\n  opacity: .3; }\\n\\n.fc-nonbusiness {\\n  /* default look for non-business-hours areas */\\n  /* will inherit .fc-bgevent's styles */\\n  background: #d7d7d7; }\\n\\n/* Icons (inline elements with styled text that mock arrow icons)\\n--------------------------------------------------------------------------------------------------*/\\n.fc-icon {\\n  display: inline-block;\\n  height: 1em;\\n  line-height: 1em;\\n  font-size: 1em;\\n  text-align: center;\\n  overflow: hidden;\\n  font-family: \\\"Courier New\\\", Courier, monospace;\\n  /* don't allow browser text-selection */\\n  -webkit-touch-callout: none;\\n  -webkit-user-select: none;\\n  -khtml-user-select: none;\\n  -moz-user-select: none;\\n  -ms-user-select: none;\\n  user-select: none; }\\n\\n/*\\nAcceptable font-family overrides for individual icons:\\n\\t\\\"Arial\\\", sans-serif\\n\\t\\\"Times New Roman\\\", serif\\n\\nNOTE: use percentage font sizes or else old IE chokes\\n*/\\n.fc-icon:after {\\n  position: relative; }\\n\\n.fc-icon-left-single-arrow:after {\\n  content: \\\"\\\\02039\\\";\\n  font-weight: bold;\\n  font-size: 200%;\\n  top: -7%; }\\n\\n.fc-icon-right-single-arrow:after {\\n  content: \\\"\\\\0203A\\\";\\n  font-weight: bold;\\n  font-size: 200%;\\n  top: -7%; }\\n\\n.fc-icon-left-double-arrow:after {\\n  content: \\\"\\\\000AB\\\";\\n  font-size: 160%;\\n  top: -7%; }\\n\\n.fc-icon-right-double-arrow:after {\\n  content: \\\"\\\\000BB\\\";\\n  font-size: 160%;\\n  top: -7%; }\\n\\n.fc-icon-left-triangle:after {\\n  content: \\\"\\\\25C4\\\";\\n  font-size: 125%;\\n  top: 3%; }\\n\\n.fc-icon-right-triangle:after {\\n  content: \\\"\\\\25BA\\\";\\n  font-size: 125%;\\n  top: 3%; }\\n\\n.fc-icon-down-triangle:after {\\n  content: \\\"\\\\25BC\\\";\\n  font-size: 125%;\\n  top: 2%; }\\n\\n.fc-icon-x:after {\\n  content: \\\"\\\\000D7\\\";\\n  font-size: 200%;\\n  top: 6%; }\\n\\n/* Buttons (styled <button> tags, normalized to work cross-browser)\\n--------------------------------------------------------------------------------------------------*/\\n.fc button {\\n  /* force height to include the border and padding */\\n  -moz-box-sizing: border-box;\\n  -webkit-box-sizing: border-box;\\n  box-sizing: border-box;\\n  /* dimensions */\\n  margin: 0;\\n  height: 2.1em;\\n  padding: 0 .6em;\\n  /* text & cursor */\\n  font-size: 1em;\\n  /* normalize */\\n  white-space: nowrap;\\n  cursor: pointer; }\\n\\n/* Firefox has an annoying inner border */\\n.fc button::-moz-focus-inner {\\n  margin: 0;\\n  padding: 0; }\\n\\n.fc-state-default {\\n  /* non-theme */\\n  border: 1px solid; }\\n\\n.fc-state-default.fc-corner-left {\\n  /* non-theme */\\n  border-top-left-radius: 4px;\\n  border-bottom-left-radius: 4px; }\\n\\n.fc-state-default.fc-corner-right {\\n  /* non-theme */\\n  border-top-right-radius: 4px;\\n  border-bottom-right-radius: 4px; }\\n\\n/* icons in buttons */\\n.fc button .fc-icon {\\n  /* non-theme */\\n  position: relative;\\n  top: -0.05em;\\n  /* seems to be a good adjustment across browsers */\\n  margin: 0 .2em;\\n  vertical-align: middle; }\\n\\n/*\\n  button states\\n  borrowed from twitter bootstrap (http://twitter.github.com/bootstrap/)\\n*/\\n.fc-state-default {\\n  background-color: #f5f5f5;\\n  background-image: -moz-linear-gradient(top, #ffffff, #e6e6e6);\\n  background-image: -webkit-gradient(linear, 0 0, 0 100%, from(#ffffff), to(#e6e6e6));\\n  background-image: -webkit-linear-gradient(top, #ffffff, #e6e6e6);\\n  background-image: -o-linear-gradient(top, #ffffff, #e6e6e6);\\n  background-image: linear-gradient(to bottom, #ffffff, #e6e6e6);\\n  background-repeat: repeat-x;\\n  border-color: #e6e6e6 #e6e6e6 #bfbfbf;\\n  border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);\\n  color: #333;\\n  text-shadow: 0 1px 1px rgba(255, 255, 255, 0.75);\\n  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05); }\\n\\n.fc-state-hover,\\n.fc-state-down,\\n.fc-state-active,\\n.fc-state-disabled {\\n  color: #333333;\\n  background-color: #e6e6e6; }\\n\\n.fc-state-hover {\\n  color: #333333;\\n  text-decoration: none;\\n  background-position: 0 -15px;\\n  -webkit-transition: background-position 0.1s linear;\\n  -moz-transition: background-position 0.1s linear;\\n  -o-transition: background-position 0.1s linear;\\n  transition: background-position 0.1s linear; }\\n\\n.fc-state-down,\\n.fc-state-active {\\n  background-color: #cccccc;\\n  background-image: none;\\n  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05); }\\n\\n.fc-state-disabled {\\n  cursor: default;\\n  background-image: none;\\n  opacity: 0.65;\\n  box-shadow: none; }\\n\\n/* Buttons Groups\\n--------------------------------------------------------------------------------------------------*/\\n.fc-button-group {\\n  display: inline-block; }\\n\\n/*\\nevery button that is not first in a button group should scootch over one pixel and cover the\\nprevious button's border...\\n*/\\n.fc .fc-button-group > * {\\n  /* extra precedence b/c buttons have margin set to zero */\\n  float: left;\\n  margin: 0 0 0 -1px; }\\n\\n.fc .fc-button-group > :first-child {\\n  /* same */\\n  margin-left: 0; }\\n\\n/* Popover\\n--------------------------------------------------------------------------------------------------*/\\n.fc-popover {\\n  position: absolute;\\n  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15); }\\n\\n.fc-popover .fc-header {\\n  /* TODO: be more consistent with fc-head/fc-body */\\n  padding: 2px 4px; }\\n\\n.fc-popover .fc-header .fc-title {\\n  margin: 0 2px; }\\n\\n.fc-popover .fc-header .fc-close {\\n  cursor: pointer; }\\n\\n.fc-ltr .fc-popover .fc-header .fc-title,\\n.fc-rtl .fc-popover .fc-header .fc-close {\\n  float: left; }\\n\\n.fc-rtl .fc-popover .fc-header .fc-title,\\n.fc-ltr .fc-popover .fc-header .fc-close {\\n  float: right; }\\n\\n/* unthemed */\\n.fc-unthemed .fc-popover {\\n  border-width: 1px;\\n  border-style: solid; }\\n\\n.fc-unthemed .fc-popover .fc-header .fc-close {\\n  font-size: .9em;\\n  margin-top: 2px; }\\n\\n/* jqui themed */\\n.fc-popover > .ui-widget-header + .ui-widget-content {\\n  border-top: 0;\\n  /* where they meet, let the header have the border */ }\\n\\n/* Misc Reusable Components\\n--------------------------------------------------------------------------------------------------*/\\n.fc-divider {\\n  border-style: solid;\\n  border-width: 1px; }\\n\\nhr.fc-divider {\\n  height: 0;\\n  margin: 0;\\n  padding: 0 0 2px;\\n  /* height is unreliable across browsers, so use padding */\\n  border-width: 1px 0; }\\n\\n.fc-clear {\\n  clear: both; }\\n\\n.fc-bg,\\n.fc-bgevent-skeleton,\\n.fc-highlight-skeleton,\\n.fc-helper-skeleton {\\n  /* these element should always cling to top-left/right corners */\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  right: 0; }\\n\\n.fc-bg {\\n  bottom: 0;\\n  /* strech bg to bottom edge */ }\\n\\n.fc-bg table {\\n  height: 100%;\\n  /* strech bg to bottom edge */ }\\n\\n/* Tables\\n--------------------------------------------------------------------------------------------------*/\\n.fc table {\\n  width: 100%;\\n  box-sizing: border-box;\\n  /* fix scrollbar issue in firefox */\\n  table-layout: fixed;\\n  border-collapse: collapse;\\n  border-spacing: 0;\\n  font-size: 1em;\\n  /* normalize cross-browser */ }\\n\\n.fc th {\\n  text-align: center; }\\n\\n.fc th,\\n.fc td {\\n  border-style: solid;\\n  border-width: 1px;\\n  padding: 0;\\n  vertical-align: top; }\\n\\n.fc td.fc-today {\\n  border-style: double;\\n  /* overcome neighboring borders */ }\\n\\n/* Internal Nav Links\\n--------------------------------------------------------------------------------------------------*/\\na[data-goto] {\\n  cursor: pointer; }\\n\\na[data-goto]:hover {\\n  text-decoration: underline; }\\n\\n/* Fake Table Rows\\n--------------------------------------------------------------------------------------------------*/\\n.fc .fc-row {\\n  /* extra precedence to overcome themes w/ .ui-widget-content forcing a 1px border */\\n  /* no visible border by default. but make available if need be (scrollbar width compensation) */\\n  border-style: solid;\\n  border-width: 0; }\\n\\n.fc-row table {\\n  /* don't put left/right border on anything within a fake row.\\n\\t   the outer tbody will worry about this */\\n  border-left: 0 hidden transparent;\\n  border-right: 0 hidden transparent;\\n  /* no bottom borders on rows */\\n  border-bottom: 0 hidden transparent; }\\n\\n.fc-row:first-child table {\\n  border-top: 0 hidden transparent;\\n  /* no top border on first row */ }\\n\\n/* Day Row (used within the header and the DayGrid)\\n--------------------------------------------------------------------------------------------------*/\\n.fc-row {\\n  position: relative; }\\n\\n.fc-row .fc-bg {\\n  z-index: 1; }\\n\\n/* highlighting cells & background event skeleton */\\n.fc-row .fc-bgevent-skeleton,\\n.fc-row .fc-highlight-skeleton {\\n  bottom: 0;\\n  /* stretch skeleton to bottom of row */ }\\n\\n.fc-row .fc-bgevent-skeleton table,\\n.fc-row .fc-highlight-skeleton table {\\n  height: 100%;\\n  /* stretch skeleton to bottom of row */ }\\n\\n.fc-row .fc-highlight-skeleton td,\\n.fc-row .fc-bgevent-skeleton td {\\n  border-color: transparent; }\\n\\n.fc-row .fc-bgevent-skeleton {\\n  z-index: 2; }\\n\\n.fc-row .fc-highlight-skeleton {\\n  z-index: 3; }\\n\\n/*\\nrow content (which contains day/week numbers and events) as well as \\\"helper\\\" (which contains\\ntemporary rendered events).\\n*/\\n.fc-row .fc-content-skeleton {\\n  position: relative;\\n  z-index: 4;\\n  padding-bottom: 2px;\\n  /* matches the space above the events */ }\\n\\n.fc-row .fc-helper-skeleton {\\n  z-index: 5; }\\n\\n.fc-row .fc-content-skeleton td,\\n.fc-row .fc-helper-skeleton td {\\n  /* see-through to the background below */\\n  background: none;\\n  /* in case <td>s are globally styled */\\n  border-color: transparent;\\n  /* don't put a border between events and/or the day number */\\n  border-bottom: 0; }\\n\\n.fc-row .fc-content-skeleton tbody td,\\n.fc-row .fc-helper-skeleton tbody td {\\n  /* don't put a border between event cells */\\n  border-top: 0; }\\n\\n/* Scrolling Container\\n--------------------------------------------------------------------------------------------------*/\\n.fc-scroller {\\n  -webkit-overflow-scrolling: touch; }\\n\\n/* TODO: move to agenda/basic */\\n.fc-scroller > .fc-day-grid,\\n.fc-scroller > .fc-time-grid {\\n  position: relative;\\n  /* re-scope all positions */\\n  width: 100%;\\n  /* hack to force re-sizing this inner element when scrollbars appear/disappear */ }\\n\\n/* Global Event Styles\\n--------------------------------------------------------------------------------------------------*/\\n.fc-event {\\n  position: relative;\\n  /* for resize handle and other inner positioning */\\n  display: block;\\n  /* make the <a> tag block */\\n  font-size: .85em;\\n  line-height: 1.3;\\n  border-radius: 3px;\\n  border: 1px solid #3a87ad;\\n  /* default BORDER color */\\n  font-weight: normal;\\n  /* undo jqui's ui-widget-header bold */ }\\n\\n.fc-event,\\n.fc-event-dot {\\n  background-color: #3a87ad;\\n  /* default BACKGROUND color */ }\\n\\n/* overpower some of bootstrap's and jqui's styles on <a> tags */\\n.fc-event,\\n.fc-event:hover,\\n.ui-widget .fc-event {\\n  color: #fff;\\n  /* default TEXT color */\\n  text-decoration: none;\\n  /* if <a> has an href */ }\\n\\n.fc-event[href],\\n.fc-event.fc-draggable {\\n  cursor: pointer;\\n  /* give events with links and draggable events a hand mouse pointer */ }\\n\\n.fc-not-allowed,\\n.fc-not-allowed .fc-event {\\n  /* to override an event's custom cursor */\\n  cursor: not-allowed; }\\n\\n.fc-event .fc-bg {\\n  /* the generic .fc-bg already does position */\\n  z-index: 1;\\n  background: #fff;\\n  opacity: .25; }\\n\\n.fc-event .fc-content {\\n  position: relative;\\n  z-index: 2; }\\n\\n/* resizer (cursor AND touch devices) */\\n.fc-event .fc-resizer {\\n  position: absolute;\\n  z-index: 4; }\\n\\n/* resizer (touch devices) */\\n.fc-event .fc-resizer {\\n  display: none; }\\n\\n.fc-event.fc-allow-mouse-resize .fc-resizer,\\n.fc-event.fc-selected .fc-resizer {\\n  /* only show when hovering or selected (with touch) */\\n  display: block; }\\n\\n/* hit area */\\n.fc-event.fc-selected .fc-resizer:before {\\n  /* 40x40 touch area */\\n  content: \\\"\\\";\\n  position: absolute;\\n  z-index: 9999;\\n  /* user of this util can scope within a lower z-index */\\n  top: 50%;\\n  left: 50%;\\n  width: 40px;\\n  height: 40px;\\n  margin-left: -20px;\\n  margin-top: -20px; }\\n\\n/* Event Selection (only for touch devices)\\n--------------------------------------------------------------------------------------------------*/\\n.fc-event.fc-selected {\\n  z-index: 9999 !important;\\n  /* overcomes inline z-index */\\n  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2); }\\n\\n.fc-event.fc-selected.fc-dragging {\\n  box-shadow: 0 2px 7px rgba(0, 0, 0, 0.3); }\\n\\n/* Horizontal Events\\n--------------------------------------------------------------------------------------------------*/\\n/* bigger touch area when selected */\\n.fc-h-event.fc-selected:before {\\n  content: \\\"\\\";\\n  position: absolute;\\n  z-index: 3;\\n  /* below resizers */\\n  top: -10px;\\n  bottom: -10px;\\n  left: 0;\\n  right: 0; }\\n\\n/* events that are continuing to/from another week. kill rounded corners and butt up against edge */\\n.fc-ltr .fc-h-event.fc-not-start,\\n.fc-rtl .fc-h-event.fc-not-end {\\n  margin-left: 0;\\n  border-left-width: 0;\\n  padding-left: 1px;\\n  /* replace the border with padding */\\n  border-top-left-radius: 0;\\n  border-bottom-left-radius: 0; }\\n\\n.fc-ltr .fc-h-event.fc-not-end,\\n.fc-rtl .fc-h-event.fc-not-start {\\n  margin-right: 0;\\n  border-right-width: 0;\\n  padding-right: 1px;\\n  /* replace the border with padding */\\n  border-top-right-radius: 0;\\n  border-bottom-right-radius: 0; }\\n\\n/* resizer (cursor AND touch devices) */\\n/* left resizer  */\\n.fc-ltr .fc-h-event .fc-start-resizer,\\n.fc-rtl .fc-h-event .fc-end-resizer {\\n  cursor: w-resize;\\n  left: -1px;\\n  /* overcome border */ }\\n\\n/* right resizer */\\n.fc-ltr .fc-h-event .fc-end-resizer,\\n.fc-rtl .fc-h-event .fc-start-resizer {\\n  cursor: e-resize;\\n  right: -1px;\\n  /* overcome border */ }\\n\\n/* resizer (mouse devices) */\\n.fc-h-event.fc-allow-mouse-resize .fc-resizer {\\n  width: 7px;\\n  top: -1px;\\n  /* overcome top border */\\n  bottom: -1px;\\n  /* overcome bottom border */ }\\n\\n/* resizer (touch devices) */\\n.fc-h-event.fc-selected .fc-resizer {\\n  /* 8x8 little dot */\\n  border-radius: 4px;\\n  border-width: 1px;\\n  width: 6px;\\n  height: 6px;\\n  border-style: solid;\\n  border-color: inherit;\\n  background: #fff;\\n  /* vertically center */\\n  top: 50%;\\n  margin-top: -4px; }\\n\\n/* left resizer  */\\n.fc-ltr .fc-h-event.fc-selected .fc-start-resizer,\\n.fc-rtl .fc-h-event.fc-selected .fc-end-resizer {\\n  margin-left: -4px;\\n  /* centers the 8x8 dot on the left edge */ }\\n\\n/* right resizer */\\n.fc-ltr .fc-h-event.fc-selected .fc-end-resizer,\\n.fc-rtl .fc-h-event.fc-selected .fc-start-resizer {\\n  margin-right: -4px;\\n  /* centers the 8x8 dot on the right edge */ }\\n\\n/* DayGrid events\\n----------------------------------------------------------------------------------------------------\\nWe use the full \\\"fc-day-grid-event\\\" class instead of using descendants because the event won't\\nbe a descendant of the grid when it is being dragged.\\n*/\\n.fc-day-grid-event {\\n  margin: 1px 2px 0;\\n  /* spacing between events and edges */\\n  padding: 0 1px; }\\n\\ntr:first-child > td > .fc-day-grid-event {\\n  margin-top: 2px;\\n  /* a little bit more space before the first event */ }\\n\\n.fc-day-grid-event.fc-selected:after {\\n  content: \\\"\\\";\\n  position: absolute;\\n  z-index: 1;\\n  /* same z-index as fc-bg, behind text */\\n  /* overcome the borders */\\n  top: -1px;\\n  right: -1px;\\n  bottom: -1px;\\n  left: -1px;\\n  /* darkening effect */\\n  background: #000;\\n  opacity: .25; }\\n\\n.fc-day-grid-event .fc-content {\\n  /* force events to be one-line tall */\\n  white-space: nowrap;\\n  overflow: hidden; }\\n\\n.fc-day-grid-event .fc-time {\\n  font-weight: bold; }\\n\\n/* resizer (cursor devices) */\\n/* left resizer  */\\n.fc-ltr .fc-day-grid-event.fc-allow-mouse-resize .fc-start-resizer,\\n.fc-rtl .fc-day-grid-event.fc-allow-mouse-resize .fc-end-resizer {\\n  margin-left: -2px;\\n  /* to the day cell's edge */ }\\n\\n/* right resizer */\\n.fc-ltr .fc-day-grid-event.fc-allow-mouse-resize .fc-end-resizer,\\n.fc-rtl .fc-day-grid-event.fc-allow-mouse-resize .fc-start-resizer {\\n  margin-right: -2px;\\n  /* to the day cell's edge */ }\\n\\n/* Event Limiting\\n--------------------------------------------------------------------------------------------------*/\\n/* \\\"more\\\" link that represents hidden events */\\na.fc-more {\\n  margin: 1px 3px;\\n  font-size: .85em;\\n  cursor: pointer;\\n  text-decoration: none; }\\n\\na.fc-more:hover {\\n  text-decoration: underline; }\\n\\n.fc-limited {\\n  /* rows and cells that are hidden because of a \\\"more\\\" link */\\n  display: none; }\\n\\n/* popover that appears when \\\"more\\\" link is clicked */\\n.fc-day-grid .fc-row {\\n  z-index: 1;\\n  /* make the \\\"more\\\" popover one higher than this */ }\\n\\n.fc-more-popover {\\n  z-index: 2;\\n  width: 220px; }\\n\\n.fc-more-popover .fc-event-container {\\n  padding: 10px; }\\n\\n/* Now Indicator\\n--------------------------------------------------------------------------------------------------*/\\n.fc-now-indicator {\\n  position: absolute;\\n  border: 0 solid red; }\\n\\n/* Utilities\\n--------------------------------------------------------------------------------------------------*/\\n.fc-unselectable {\\n  -webkit-user-select: none;\\n  -khtml-user-select: none;\\n  -moz-user-select: none;\\n  -ms-user-select: none;\\n  user-select: none;\\n  -webkit-touch-callout: none;\\n  -webkit-tap-highlight-color: transparent; }\\n\\n/* Toolbar\\n--------------------------------------------------------------------------------------------------*/\\n.fc-toolbar {\\n  text-align: center;\\n  margin-bottom: 1em; }\\n\\n.fc-toolbar .fc-left {\\n  float: left; }\\n\\n.fc-toolbar .fc-right {\\n  float: right; }\\n\\n.fc-toolbar .fc-center {\\n  display: inline-block; }\\n\\n/* the things within each left/right/center section */\\n.fc .fc-toolbar > * > * {\\n  /* extra precedence to override button border margins */\\n  float: left;\\n  margin-left: .75em; }\\n\\n/* the first thing within each left/center/right section */\\n.fc .fc-toolbar > * > :first-child {\\n  /* extra precedence to override button border margins */\\n  margin-left: 0; }\\n\\n/* title text */\\n.fc-toolbar h2 {\\n  margin: 0; }\\n\\n/* button layering (for border precedence) */\\n.fc-toolbar button {\\n  position: relative; }\\n\\n.fc-toolbar .fc-state-hover,\\n.fc-toolbar .ui-state-hover {\\n  z-index: 2; }\\n\\n.fc-toolbar .fc-state-down {\\n  z-index: 3; }\\n\\n.fc-toolbar .fc-state-active,\\n.fc-toolbar .ui-state-active {\\n  z-index: 4; }\\n\\n.fc-toolbar button:focus {\\n  z-index: 5; }\\n\\n/* View Structure\\n--------------------------------------------------------------------------------------------------*/\\n/* undo twitter bootstrap's box-sizing rules. normalizes positioning techniques */\\n/* don't do this for the toolbar because we'll want bootstrap to style those buttons as some pt */\\n.fc-view-container *,\\n.fc-view-container *:before,\\n.fc-view-container *:after {\\n  -webkit-box-sizing: content-box;\\n  -moz-box-sizing: content-box;\\n  box-sizing: content-box; }\\n\\n.fc-view,\\n.fc-view > table {\\n  /* so dragged elements can be above the view's main element */\\n  position: relative;\\n  z-index: 1; }\\n\\n/* BasicView\\n--------------------------------------------------------------------------------------------------*/\\n/* day row structure */\\n.fc-basicWeek-view .fc-content-skeleton,\\n.fc-basicDay-view .fc-content-skeleton {\\n  /* there may be week numbers in these views, so no padding-top */\\n  padding-bottom: 1em;\\n  /* ensure a space at bottom of cell for user selecting/clicking */ }\\n\\n.fc-basic-view .fc-body .fc-row {\\n  min-height: 4em;\\n  /* ensure that all rows are at least this tall */ }\\n\\n/* a \\\"rigid\\\" row will take up a constant amount of height because content-skeleton is absolute */\\n.fc-row.fc-rigid {\\n  overflow: hidden; }\\n\\n.fc-row.fc-rigid .fc-content-skeleton {\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  right: 0; }\\n\\n/* week and day number styling */\\n.fc-day-top.fc-other-month {\\n  opacity: 0.3; }\\n\\n.fc-basic-view .fc-week-number,\\n.fc-basic-view .fc-day-number {\\n  padding: 2px; }\\n\\n.fc-basic-view th.fc-week-number,\\n.fc-basic-view th.fc-day-number {\\n  padding: 0 2px;\\n  /* column headers can't have as much v space */ }\\n\\n.fc-ltr .fc-basic-view .fc-day-top .fc-day-number {\\n  float: right; }\\n\\n.fc-rtl .fc-basic-view .fc-day-top .fc-day-number {\\n  float: left; }\\n\\n.fc-ltr .fc-basic-view .fc-day-top .fc-week-number {\\n  float: left;\\n  border-radius: 0 0 3px 0; }\\n\\n.fc-rtl .fc-basic-view .fc-day-top .fc-week-number {\\n  float: right;\\n  border-radius: 0 0 0 3px; }\\n\\n.fc-basic-view .fc-day-top .fc-week-number {\\n  min-width: 1.5em;\\n  text-align: center;\\n  background-color: #f2f2f2;\\n  color: #808080; }\\n\\n/* when week/day number have own column */\\n.fc-basic-view td.fc-week-number {\\n  text-align: center; }\\n\\n.fc-basic-view td.fc-week-number > * {\\n  /* work around the way we do column resizing and ensure a minimum width */\\n  display: inline-block;\\n  min-width: 1.25em; }\\n\\n/* AgendaView all-day area\\n--------------------------------------------------------------------------------------------------*/\\n.fc-agenda-view .fc-day-grid {\\n  position: relative;\\n  z-index: 2;\\n  /* so the \\\"more..\\\" popover will be over the time grid */ }\\n\\n.fc-agenda-view .fc-day-grid .fc-row {\\n  min-height: 3em;\\n  /* all-day section will never get shorter than this */ }\\n\\n.fc-agenda-view .fc-day-grid .fc-row .fc-content-skeleton {\\n  padding-bottom: 1em;\\n  /* give space underneath events for clicking/selecting days */ }\\n\\n/* TimeGrid axis running down the side (for both the all-day area and the slot area)\\n--------------------------------------------------------------------------------------------------*/\\n.fc .fc-axis {\\n  /* .fc to overcome default cell styles */\\n  vertical-align: middle;\\n  padding: 0 4px;\\n  white-space: nowrap; }\\n\\n.fc-ltr .fc-axis {\\n  text-align: right; }\\n\\n.fc-rtl .fc-axis {\\n  text-align: left; }\\n\\n.ui-widget td.fc-axis {\\n  font-weight: normal;\\n  /* overcome jqui theme making it bold */ }\\n\\n/* TimeGrid Structure\\n--------------------------------------------------------------------------------------------------*/\\n.fc-time-grid-container,\\n.fc-time-grid {\\n  /* so slats/bg/content/etc positions get scoped within here */\\n  position: relative;\\n  z-index: 1; }\\n\\n.fc-time-grid {\\n  min-height: 100%;\\n  /* so if height setting is 'auto', .fc-bg stretches to fill height */ }\\n\\n.fc-time-grid table {\\n  /* don't put outer borders on slats/bg/content/etc */\\n  border: 0 hidden transparent; }\\n\\n.fc-time-grid > .fc-bg {\\n  z-index: 1; }\\n\\n.fc-time-grid .fc-slats,\\n.fc-time-grid > hr {\\n  /* the <hr> AgendaView injects when grid is shorter than scroller */\\n  position: relative;\\n  z-index: 2; }\\n\\n.fc-time-grid .fc-content-col {\\n  position: relative;\\n  /* because now-indicator lives directly inside */ }\\n\\n.fc-time-grid .fc-content-skeleton {\\n  position: absolute;\\n  z-index: 3;\\n  top: 0;\\n  left: 0;\\n  right: 0; }\\n\\n/* divs within a cell within the fc-content-skeleton */\\n.fc-time-grid .fc-business-container {\\n  position: relative;\\n  z-index: 1; }\\n\\n.fc-time-grid .fc-bgevent-container {\\n  position: relative;\\n  z-index: 2; }\\n\\n.fc-time-grid .fc-highlight-container {\\n  position: relative;\\n  z-index: 3; }\\n\\n.fc-time-grid .fc-event-container {\\n  position: relative;\\n  z-index: 4; }\\n\\n.fc-time-grid .fc-now-indicator-line {\\n  z-index: 5; }\\n\\n.fc-time-grid .fc-helper-container {\\n  /* also is fc-event-container */\\n  position: relative;\\n  z-index: 6; }\\n\\n/* TimeGrid Slats (lines that run horizontally)\\n--------------------------------------------------------------------------------------------------*/\\n.fc-time-grid .fc-slats td {\\n  height: 1.5em;\\n  border-bottom: 0;\\n  /* each cell is responsible for its top border */ }\\n\\n.fc-time-grid .fc-slats .fc-minor td {\\n  border-top-style: dotted; }\\n\\n.fc-time-grid .fc-slats .ui-widget-content {\\n  /* for jqui theme */\\n  background: none;\\n  /* see through to fc-bg */ }\\n\\n/* TimeGrid Highlighting Slots\\n--------------------------------------------------------------------------------------------------*/\\n.fc-time-grid .fc-highlight-container {\\n  /* a div within a cell within the fc-highlight-skeleton */\\n  position: relative;\\n  /* scopes the left/right of the fc-highlight to be in the column */ }\\n\\n.fc-time-grid .fc-highlight {\\n  position: absolute;\\n  left: 0;\\n  right: 0;\\n  /* top and bottom will be in by JS */ }\\n\\n/* TimeGrid Event Containment\\n--------------------------------------------------------------------------------------------------*/\\n.fc-ltr .fc-time-grid .fc-event-container {\\n  /* space on the sides of events for LTR (default) */\\n  margin: 0 2.5% 0 2px; }\\n\\n.fc-rtl .fc-time-grid .fc-event-container {\\n  /* space on the sides of events for RTL */\\n  margin: 0 2px 0 2.5%; }\\n\\n.fc-time-grid .fc-event,\\n.fc-time-grid .fc-bgevent {\\n  position: absolute;\\n  z-index: 1;\\n  /* scope inner z-index's */ }\\n\\n.fc-time-grid .fc-bgevent {\\n  /* background events always span full width */\\n  left: 0;\\n  right: 0; }\\n\\n/* Generic Vertical Event\\n--------------------------------------------------------------------------------------------------*/\\n.fc-v-event.fc-not-start {\\n  /* events that are continuing from another day */\\n  /* replace space made by the top border with padding */\\n  border-top-width: 0;\\n  padding-top: 1px;\\n  /* remove top rounded corners */\\n  border-top-left-radius: 0;\\n  border-top-right-radius: 0; }\\n\\n.fc-v-event.fc-not-end {\\n  /* replace space made by the top border with padding */\\n  border-bottom-width: 0;\\n  padding-bottom: 1px;\\n  /* remove bottom rounded corners */\\n  border-bottom-left-radius: 0;\\n  border-bottom-right-radius: 0; }\\n\\n/* TimeGrid Event Styling\\n----------------------------------------------------------------------------------------------------\\nWe use the full \\\"fc-time-grid-event\\\" class instead of using descendants because the event won't\\nbe a descendant of the grid when it is being dragged.\\n*/\\n.fc-time-grid-event {\\n  overflow: hidden;\\n  /* don't let the bg flow over rounded corners */ }\\n\\n.fc-time-grid-event.fc-selected {\\n  /* need to allow touch resizers to extend outside event's bounding box */\\n  /* common fc-selected styles hide the fc-bg, so don't need this anyway */\\n  overflow: visible; }\\n\\n.fc-time-grid-event.fc-selected .fc-bg {\\n  display: none;\\n  /* hide semi-white background, to appear darker */ }\\n\\n.fc-time-grid-event .fc-content {\\n  overflow: hidden;\\n  /* for when .fc-selected */ }\\n\\n.fc-time-grid-event .fc-time,\\n.fc-time-grid-event .fc-title {\\n  padding: 0 1px; }\\n\\n.fc-time-grid-event .fc-time {\\n  font-size: .85em;\\n  white-space: nowrap; }\\n\\n/* short mode, where time and title are on the same line */\\n.fc-time-grid-event.fc-short .fc-content {\\n  /* don't wrap to second line (now that contents will be inline) */\\n  white-space: nowrap; }\\n\\n.fc-time-grid-event.fc-short .fc-time,\\n.fc-time-grid-event.fc-short .fc-title {\\n  /* put the time and title on the same line */\\n  display: inline-block;\\n  vertical-align: top; }\\n\\n.fc-time-grid-event.fc-short .fc-time span {\\n  display: none;\\n  /* don't display the full time text... */ }\\n\\n.fc-time-grid-event.fc-short .fc-time:before {\\n  content: attr(data-start);\\n  /* ...instead, display only the start time */ }\\n\\n.fc-time-grid-event.fc-short .fc-time:after {\\n  content: \\\"\\\\000A0-\\\\000A0\\\";\\n  /* seperate with a dash, wrapped in nbsp's */ }\\n\\n.fc-time-grid-event.fc-short .fc-title {\\n  font-size: .85em;\\n  /* make the title text the same size as the time */\\n  padding: 0;\\n  /* undo padding from above */ }\\n\\n/* resizer (cursor device) */\\n.fc-time-grid-event.fc-allow-mouse-resize .fc-resizer {\\n  left: 0;\\n  right: 0;\\n  bottom: 0;\\n  height: 8px;\\n  overflow: hidden;\\n  line-height: 8px;\\n  font-size: 11px;\\n  font-family: monospace;\\n  text-align: center;\\n  cursor: s-resize; }\\n\\n.fc-time-grid-event.fc-allow-mouse-resize .fc-resizer:after {\\n  content: \\\"=\\\"; }\\n\\n/* resizer (touch device) */\\n.fc-time-grid-event.fc-selected .fc-resizer {\\n  /* 10x10 dot */\\n  border-radius: 5px;\\n  border-width: 1px;\\n  width: 8px;\\n  height: 8px;\\n  border-style: solid;\\n  border-color: inherit;\\n  background: #fff;\\n  /* horizontally center */\\n  left: 50%;\\n  margin-left: -5px;\\n  /* center on the bottom edge */\\n  bottom: -5px; }\\n\\n/* Now Indicator\\n--------------------------------------------------------------------------------------------------*/\\n.fc-time-grid .fc-now-indicator-line {\\n  border-top-width: 1px;\\n  left: 0;\\n  right: 0; }\\n\\n/* arrow on axis */\\n.fc-time-grid .fc-now-indicator-arrow {\\n  margin-top: -5px;\\n  /* vertically center on top coordinate */ }\\n\\n.fc-ltr .fc-time-grid .fc-now-indicator-arrow {\\n  left: 0;\\n  /* triangle pointing right... */\\n  border-width: 5px 0 5px 6px;\\n  border-top-color: transparent;\\n  border-bottom-color: transparent; }\\n\\n.fc-rtl .fc-time-grid .fc-now-indicator-arrow {\\n  right: 0;\\n  /* triangle pointing left... */\\n  border-width: 5px 6px 5px 0;\\n  border-top-color: transparent;\\n  border-bottom-color: transparent; }\\n\\n/* List View\\n--------------------------------------------------------------------------------------------------*/\\n/* possibly reusable */\\n.fc-event-dot {\\n  display: inline-block;\\n  width: 10px;\\n  height: 10px;\\n  border-radius: 5px; }\\n\\n/* view wrapper */\\n.fc-rtl .fc-list-view {\\n  direction: rtl;\\n  /* unlike core views, leverage browser RTL */ }\\n\\n.fc-list-view {\\n  border-width: 1px;\\n  border-style: solid; }\\n\\n/* table resets */\\n.fc .fc-list-table {\\n  table-layout: auto;\\n  /* for shrinkwrapping cell content */ }\\n\\n.fc-list-table td {\\n  border-width: 1px 0 0;\\n  padding: 8px 14px; }\\n\\n.fc-list-table tr:first-child td {\\n  border-top-width: 0; }\\n\\n/* day headings with the list */\\n.fc-list-heading {\\n  border-bottom-width: 1px; }\\n\\n.fc-list-heading td {\\n  font-weight: bold; }\\n\\n.fc-ltr .fc-list-heading-main {\\n  float: left; }\\n\\n.fc-ltr .fc-list-heading-alt {\\n  float: right; }\\n\\n.fc-rtl .fc-list-heading-main {\\n  float: right; }\\n\\n.fc-rtl .fc-list-heading-alt {\\n  float: left; }\\n\\n/* event list items */\\n.fc-list-item.fc-has-url {\\n  cursor: pointer;\\n  /* whole row will be clickable */ }\\n\\n.fc-list-item:hover td {\\n  background-color: #f5f5f5; }\\n\\n.fc-list-item-marker,\\n.fc-list-item-time {\\n  white-space: nowrap;\\n  width: 1px; }\\n\\n/* make the dot closer to the event title */\\n.fc-ltr .fc-list-item-marker {\\n  padding-right: 0; }\\n\\n.fc-rtl .fc-list-item-marker {\\n  padding-left: 0; }\\n\\n.fc-list-item-title a {\\n  /* every event title cell has an <a> tag */\\n  text-decoration: none;\\n  color: inherit; }\\n\\n.fc-list-item-title a[href]:hover {\\n  /* hover effect only on titles with hrefs */\\n  text-decoration: underline; }\\n\\n/* message when no events */\\n.fc-list-empty-wrap2 {\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  right: 0;\\n  bottom: 0; }\\n\\n.fc-list-empty-wrap1 {\\n  width: 100%;\\n  height: 100%;\\n  display: table; }\\n\\n.fc-list-empty {\\n  display: table-cell;\\n  vertical-align: middle;\\n  text-align: center; }\\n\\n.fc-unthemed .fc-list-empty {\\n  /* theme will provide own background */\\n  background-color: #eee; }\\n\\n/**************************/\\n/* Full Calendar Override */\\n/**************************/\\n.fc-grid th {\\n  text-transform: uppercase; }\\n\\n.fc-event {\\n  padding: 2px 3px;\\n  border: none;\\n  font-weight: 400;\\n  background-color: #ddd;\\n  color: #555555; }\\n\\n.fc-today {\\n  background-color: #fff1b8; }\\n\\na.fc-event {\\n  height: auto;\\n  line-height: 1.5; }\\n\\n/***********************************/\\n/**      Full Calendar Custom     **/\\n/***********************************/\\n.full-calendar {\\n  margin-top: 10px; }\\n\\n.calendar-controls .btn {\\n  font-size: 13px; }\\n\\n.calendar-external-events {\\n  margin-top: 20px; }\\n  .calendar-external-events .external-event {\\n    margin: 10px 0;\\n    padding: 6px;\\n    font-size: 13px;\\n    cursor: pointer;\\n    border-radius: 0.25rem;\\n    background-color: #fff;\\n    border: 1px solid #bbb; }\\n\\n@media (min-width: 1200px) {\\n  .widget-calendar {\\n    margin-top: -100px; } }\\n\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEyMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvZXh0cmEvY2FsZW5kYXIvY2FsZW5kYXIuc3R5bGUuc2Nzcz9hMDM0Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIvKiFcXG4gKiBGdWxsQ2FsZW5kYXIgdjMuMC4xIFN0eWxlc2hlZXRcXG4gKiBEb2NzICYgTGljZW5zZTogaHR0cDovL2Z1bGxjYWxlbmRhci5pby9cXG4gKiAoYykgMjAxNiBBZGFtIFNoYXdcXG4gKi9cXG4uZmMge1xcbiAgZGlyZWN0aW9uOiBsdHI7XFxuICB0ZXh0LWFsaWduOiBsZWZ0OyB9XFxuXFxuLmZjLXJ0bCB7XFxuICB0ZXh0LWFsaWduOiByaWdodDsgfVxcblxcbmJvZHkgLmZjIHtcXG4gIC8qIGV4dHJhIHByZWNlZGVuY2UgdG8gb3ZlcmNvbWUganF1aSAqL1xcbiAgZm9udC1zaXplOiAxZW07IH1cXG5cXG4vKiBDb2xvcnNcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuLmZjLXVudGhlbWVkIHRoLFxcbi5mYy11bnRoZW1lZCB0ZCxcXG4uZmMtdW50aGVtZWQgdGhlYWQsXFxuLmZjLXVudGhlbWVkIHRib2R5LFxcbi5mYy11bnRoZW1lZCAuZmMtZGl2aWRlcixcXG4uZmMtdW50aGVtZWQgLmZjLXJvdyxcXG4uZmMtdW50aGVtZWQgLmZjLWNvbnRlbnQsXFxuLmZjLXVudGhlbWVkIC5mYy1wb3BvdmVyLFxcbi5mYy11bnRoZW1lZCAuZmMtbGlzdC12aWV3LFxcbi5mYy11bnRoZW1lZCAuZmMtbGlzdC1oZWFkaW5nIHRkIHtcXG4gIGJvcmRlci1jb2xvcjogI2RkZDsgfVxcblxcbi5mYy11bnRoZW1lZCAuZmMtcG9wb3ZlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmOyB9XFxuXFxuLmZjLXVudGhlbWVkIC5mYy1kaXZpZGVyLFxcbi5mYy11bnRoZW1lZCAuZmMtcG9wb3ZlciAuZmMtaGVhZGVyLFxcbi5mYy11bnRoZW1lZCAuZmMtbGlzdC1oZWFkaW5nIHRkIHtcXG4gIGJhY2tncm91bmQ6ICNlZWU7IH1cXG5cXG4uZmMtdW50aGVtZWQgLmZjLXBvcG92ZXIgLmZjLWhlYWRlciAuZmMtY2xvc2Uge1xcbiAgY29sb3I6ICM2NjY7IH1cXG5cXG4uZmMtdW50aGVtZWQgLmZjLXRvZGF5IHtcXG4gIGJhY2tncm91bmQ6ICNmY2Y4ZTM7IH1cXG5cXG4uZmMtaGlnaGxpZ2h0IHtcXG4gIC8qIHdoZW4gdXNlciBpcyBzZWxlY3RpbmcgY2VsbHMgKi9cXG4gIGJhY2tncm91bmQ6ICNiY2U4ZjE7XFxuICBvcGFjaXR5OiAuMzsgfVxcblxcbi5mYy1iZ2V2ZW50IHtcXG4gIC8qIGRlZmF1bHQgbG9vayBmb3IgYmFja2dyb3VuZCBldmVudHMgKi9cXG4gIGJhY2tncm91bmQ6ICM4ZmRmODI7XFxuICBvcGFjaXR5OiAuMzsgfVxcblxcbi5mYy1ub25idXNpbmVzcyB7XFxuICAvKiBkZWZhdWx0IGxvb2sgZm9yIG5vbi1idXNpbmVzcy1ob3VycyBhcmVhcyAqL1xcbiAgLyogd2lsbCBpbmhlcml0IC5mYy1iZ2V2ZW50J3Mgc3R5bGVzICovXFxuICBiYWNrZ3JvdW5kOiAjZDdkN2Q3OyB9XFxuXFxuLyogSWNvbnMgKGlubGluZSBlbGVtZW50cyB3aXRoIHN0eWxlZCB0ZXh0IHRoYXQgbW9jayBhcnJvdyBpY29ucylcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuLmZjLWljb24ge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgaGVpZ2h0OiAxZW07XFxuICBsaW5lLWhlaWdodDogMWVtO1xcbiAgZm9udC1zaXplOiAxZW07XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgZm9udC1mYW1pbHk6IFxcXCJDb3VyaWVyIE5ld1xcXCIsIENvdXJpZXIsIG1vbm9zcGFjZTtcXG4gIC8qIGRvbid0IGFsbG93IGJyb3dzZXIgdGV4dC1zZWxlY3Rpb24gKi9cXG4gIC13ZWJraXQtdG91Y2gtY2FsbG91dDogbm9uZTtcXG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAta2h0bWwtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbiAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7IH1cXG5cXG4vKlxcbkFjY2VwdGFibGUgZm9udC1mYW1pbHkgb3ZlcnJpZGVzIGZvciBpbmRpdmlkdWFsIGljb25zOlxcblxcdFxcXCJBcmlhbFxcXCIsIHNhbnMtc2VyaWZcXG5cXHRcXFwiVGltZXMgTmV3IFJvbWFuXFxcIiwgc2VyaWZcXG5cXG5OT1RFOiB1c2UgcGVyY2VudGFnZSBmb250IHNpemVzIG9yIGVsc2Ugb2xkIElFIGNob2tlc1xcbiovXFxuLmZjLWljb246YWZ0ZXIge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlOyB9XFxuXFxuLmZjLWljb24tbGVmdC1zaW5nbGUtYXJyb3c6YWZ0ZXIge1xcbiAgY29udGVudDogXFxcIlxcXFwwMjAzOVxcXCI7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIGZvbnQtc2l6ZTogMjAwJTtcXG4gIHRvcDogLTclOyB9XFxuXFxuLmZjLWljb24tcmlnaHQtc2luZ2xlLWFycm93OmFmdGVyIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFxcMDIwM0FcXFwiO1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICBmb250LXNpemU6IDIwMCU7XFxuICB0b3A6IC03JTsgfVxcblxcbi5mYy1pY29uLWxlZnQtZG91YmxlLWFycm93OmFmdGVyIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFxcMDAwQUJcXFwiO1xcbiAgZm9udC1zaXplOiAxNjAlO1xcbiAgdG9wOiAtNyU7IH1cXG5cXG4uZmMtaWNvbi1yaWdodC1kb3VibGUtYXJyb3c6YWZ0ZXIge1xcbiAgY29udGVudDogXFxcIlxcXFwwMDBCQlxcXCI7XFxuICBmb250LXNpemU6IDE2MCU7XFxuICB0b3A6IC03JTsgfVxcblxcbi5mYy1pY29uLWxlZnQtdHJpYW5nbGU6YWZ0ZXIge1xcbiAgY29udGVudDogXFxcIlxcXFwyNUM0XFxcIjtcXG4gIGZvbnQtc2l6ZTogMTI1JTtcXG4gIHRvcDogMyU7IH1cXG5cXG4uZmMtaWNvbi1yaWdodC10cmlhbmdsZTphZnRlciB7XFxuICBjb250ZW50OiBcXFwiXFxcXDI1QkFcXFwiO1xcbiAgZm9udC1zaXplOiAxMjUlO1xcbiAgdG9wOiAzJTsgfVxcblxcbi5mYy1pY29uLWRvd24tdHJpYW5nbGU6YWZ0ZXIge1xcbiAgY29udGVudDogXFxcIlxcXFwyNUJDXFxcIjtcXG4gIGZvbnQtc2l6ZTogMTI1JTtcXG4gIHRvcDogMiU7IH1cXG5cXG4uZmMtaWNvbi14OmFmdGVyIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFxcMDAwRDdcXFwiO1xcbiAgZm9udC1zaXplOiAyMDAlO1xcbiAgdG9wOiA2JTsgfVxcblxcbi8qIEJ1dHRvbnMgKHN0eWxlZCA8YnV0dG9uPiB0YWdzLCBub3JtYWxpemVkIHRvIHdvcmsgY3Jvc3MtYnJvd3NlcilcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuLmZjIGJ1dHRvbiB7XFxuICAvKiBmb3JjZSBoZWlnaHQgdG8gaW5jbHVkZSB0aGUgYm9yZGVyIGFuZCBwYWRkaW5nICovXFxuICAtbW96LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAtd2Via2l0LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgLyogZGltZW5zaW9ucyAqL1xcbiAgbWFyZ2luOiAwO1xcbiAgaGVpZ2h0OiAyLjFlbTtcXG4gIHBhZGRpbmc6IDAgLjZlbTtcXG4gIC8qIHRleHQgJiBjdXJzb3IgKi9cXG4gIGZvbnQtc2l6ZTogMWVtO1xcbiAgLyogbm9ybWFsaXplICovXFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbiAgY3Vyc29yOiBwb2ludGVyOyB9XFxuXFxuLyogRmlyZWZveCBoYXMgYW4gYW5ub3lpbmcgaW5uZXIgYm9yZGVyICovXFxuLmZjIGJ1dHRvbjo6LW1vei1mb2N1cy1pbm5lciB7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAwOyB9XFxuXFxuLmZjLXN0YXRlLWRlZmF1bHQge1xcbiAgLyogbm9uLXRoZW1lICovXFxuICBib3JkZXI6IDFweCBzb2xpZDsgfVxcblxcbi5mYy1zdGF0ZS1kZWZhdWx0LmZjLWNvcm5lci1sZWZ0IHtcXG4gIC8qIG5vbi10aGVtZSAqL1xcbiAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogNHB4O1xcbiAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogNHB4OyB9XFxuXFxuLmZjLXN0YXRlLWRlZmF1bHQuZmMtY29ybmVyLXJpZ2h0IHtcXG4gIC8qIG5vbi10aGVtZSAqL1xcbiAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDRweDtcXG4gIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiA0cHg7IH1cXG5cXG4vKiBpY29ucyBpbiBidXR0b25zICovXFxuLmZjIGJ1dHRvbiAuZmMtaWNvbiB7XFxuICAvKiBub24tdGhlbWUgKi9cXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHRvcDogLTAuMDVlbTtcXG4gIC8qIHNlZW1zIHRvIGJlIGEgZ29vZCBhZGp1c3RtZW50IGFjcm9zcyBicm93c2VycyAqL1xcbiAgbWFyZ2luOiAwIC4yZW07XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOyB9XFxuXFxuLypcXG4gIGJ1dHRvbiBzdGF0ZXNcXG4gIGJvcnJvd2VkIGZyb20gdHdpdHRlciBib290c3RyYXAgKGh0dHA6Ly90d2l0dGVyLmdpdGh1Yi5jb20vYm9vdHN0cmFwLylcXG4qL1xcbi5mYy1zdGF0ZS1kZWZhdWx0IHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmNWY1ZjU7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiAtbW96LWxpbmVhci1ncmFkaWVudCh0b3AsICNmZmZmZmYsICNlNmU2ZTYpO1xcbiAgYmFja2dyb3VuZC1pbWFnZTogLXdlYmtpdC1ncmFkaWVudChsaW5lYXIsIDAgMCwgMCAxMDAlLCBmcm9tKCNmZmZmZmYpLCB0bygjZTZlNmU2KSk7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiAtd2Via2l0LWxpbmVhci1ncmFkaWVudCh0b3AsICNmZmZmZmYsICNlNmU2ZTYpO1xcbiAgYmFja2dyb3VuZC1pbWFnZTogLW8tbGluZWFyLWdyYWRpZW50KHRvcCwgI2ZmZmZmZiwgI2U2ZTZlNik7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiBsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLCAjZmZmZmZmLCAjZTZlNmU2KTtcXG4gIGJhY2tncm91bmQtcmVwZWF0OiByZXBlYXQteDtcXG4gIGJvcmRlci1jb2xvcjogI2U2ZTZlNiAjZTZlNmU2ICNiZmJmYmY7XFxuICBib3JkZXItY29sb3I6IHJnYmEoMCwgMCwgMCwgMC4xKSByZ2JhKDAsIDAsIDAsIDAuMSkgcmdiYSgwLCAwLCAwLCAwLjI1KTtcXG4gIGNvbG9yOiAjMzMzO1xcbiAgdGV4dC1zaGFkb3c6IDAgMXB4IDFweCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNzUpO1xcbiAgYm94LXNoYWRvdzogaW5zZXQgMCAxcHggMCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDAgMXB4IDJweCByZ2JhKDAsIDAsIDAsIDAuMDUpOyB9XFxuXFxuLmZjLXN0YXRlLWhvdmVyLFxcbi5mYy1zdGF0ZS1kb3duLFxcbi5mYy1zdGF0ZS1hY3RpdmUsXFxuLmZjLXN0YXRlLWRpc2FibGVkIHtcXG4gIGNvbG9yOiAjMzMzMzMzO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2U2ZTZlNjsgfVxcblxcbi5mYy1zdGF0ZS1ob3ZlciB7XFxuICBjb2xvcjogIzMzMzMzMztcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gIGJhY2tncm91bmQtcG9zaXRpb246IDAgLTE1cHg7XFxuICAtd2Via2l0LXRyYW5zaXRpb246IGJhY2tncm91bmQtcG9zaXRpb24gMC4xcyBsaW5lYXI7XFxuICAtbW96LXRyYW5zaXRpb246IGJhY2tncm91bmQtcG9zaXRpb24gMC4xcyBsaW5lYXI7XFxuICAtby10cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLXBvc2l0aW9uIDAuMXMgbGluZWFyO1xcbiAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1wb3NpdGlvbiAwLjFzIGxpbmVhcjsgfVxcblxcbi5mYy1zdGF0ZS1kb3duLFxcbi5mYy1zdGF0ZS1hY3RpdmUge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2NjY2NjYztcXG4gIGJhY2tncm91bmQtaW1hZ2U6IG5vbmU7XFxuICBib3gtc2hhZG93OiBpbnNldCAwIDJweCA0cHggcmdiYSgwLCAwLCAwLCAwLjE1KSwgMCAxcHggMnB4IHJnYmEoMCwgMCwgMCwgMC4wNSk7IH1cXG5cXG4uZmMtc3RhdGUtZGlzYWJsZWQge1xcbiAgY3Vyc29yOiBkZWZhdWx0O1xcbiAgYmFja2dyb3VuZC1pbWFnZTogbm9uZTtcXG4gIG9wYWNpdHk6IDAuNjU7XFxuICBib3gtc2hhZG93OiBub25lOyB9XFxuXFxuLyogQnV0dG9ucyBHcm91cHNcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuLmZjLWJ1dHRvbi1ncm91cCB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IH1cXG5cXG4vKlxcbmV2ZXJ5IGJ1dHRvbiB0aGF0IGlzIG5vdCBmaXJzdCBpbiBhIGJ1dHRvbiBncm91cCBzaG91bGQgc2Nvb3RjaCBvdmVyIG9uZSBwaXhlbCBhbmQgY292ZXIgdGhlXFxucHJldmlvdXMgYnV0dG9uJ3MgYm9yZGVyLi4uXFxuKi9cXG4uZmMgLmZjLWJ1dHRvbi1ncm91cCA+ICoge1xcbiAgLyogZXh0cmEgcHJlY2VkZW5jZSBiL2MgYnV0dG9ucyBoYXZlIG1hcmdpbiBzZXQgdG8gemVybyAqL1xcbiAgZmxvYXQ6IGxlZnQ7XFxuICBtYXJnaW46IDAgMCAwIC0xcHg7IH1cXG5cXG4uZmMgLmZjLWJ1dHRvbi1ncm91cCA+IDpmaXJzdC1jaGlsZCB7XFxuICAvKiBzYW1lICovXFxuICBtYXJnaW4tbGVmdDogMDsgfVxcblxcbi8qIFBvcG92ZXJcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuLmZjLXBvcG92ZXIge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgYm94LXNoYWRvdzogMCAycHggNnB4IHJnYmEoMCwgMCwgMCwgMC4xNSk7IH1cXG5cXG4uZmMtcG9wb3ZlciAuZmMtaGVhZGVyIHtcXG4gIC8qIFRPRE86IGJlIG1vcmUgY29uc2lzdGVudCB3aXRoIGZjLWhlYWQvZmMtYm9keSAqL1xcbiAgcGFkZGluZzogMnB4IDRweDsgfVxcblxcbi5mYy1wb3BvdmVyIC5mYy1oZWFkZXIgLmZjLXRpdGxlIHtcXG4gIG1hcmdpbjogMCAycHg7IH1cXG5cXG4uZmMtcG9wb3ZlciAuZmMtaGVhZGVyIC5mYy1jbG9zZSB7XFxuICBjdXJzb3I6IHBvaW50ZXI7IH1cXG5cXG4uZmMtbHRyIC5mYy1wb3BvdmVyIC5mYy1oZWFkZXIgLmZjLXRpdGxlLFxcbi5mYy1ydGwgLmZjLXBvcG92ZXIgLmZjLWhlYWRlciAuZmMtY2xvc2Uge1xcbiAgZmxvYXQ6IGxlZnQ7IH1cXG5cXG4uZmMtcnRsIC5mYy1wb3BvdmVyIC5mYy1oZWFkZXIgLmZjLXRpdGxlLFxcbi5mYy1sdHIgLmZjLXBvcG92ZXIgLmZjLWhlYWRlciAuZmMtY2xvc2Uge1xcbiAgZmxvYXQ6IHJpZ2h0OyB9XFxuXFxuLyogdW50aGVtZWQgKi9cXG4uZmMtdW50aGVtZWQgLmZjLXBvcG92ZXIge1xcbiAgYm9yZGVyLXdpZHRoOiAxcHg7XFxuICBib3JkZXItc3R5bGU6IHNvbGlkOyB9XFxuXFxuLmZjLXVudGhlbWVkIC5mYy1wb3BvdmVyIC5mYy1oZWFkZXIgLmZjLWNsb3NlIHtcXG4gIGZvbnQtc2l6ZTogLjllbTtcXG4gIG1hcmdpbi10b3A6IDJweDsgfVxcblxcbi8qIGpxdWkgdGhlbWVkICovXFxuLmZjLXBvcG92ZXIgPiAudWktd2lkZ2V0LWhlYWRlciArIC51aS13aWRnZXQtY29udGVudCB7XFxuICBib3JkZXItdG9wOiAwO1xcbiAgLyogd2hlcmUgdGhleSBtZWV0LCBsZXQgdGhlIGhlYWRlciBoYXZlIHRoZSBib3JkZXIgKi8gfVxcblxcbi8qIE1pc2MgUmV1c2FibGUgQ29tcG9uZW50c1xcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG4uZmMtZGl2aWRlciB7XFxuICBib3JkZXItc3R5bGU6IHNvbGlkO1xcbiAgYm9yZGVyLXdpZHRoOiAxcHg7IH1cXG5cXG5oci5mYy1kaXZpZGVyIHtcXG4gIGhlaWdodDogMDtcXG4gIG1hcmdpbjogMDtcXG4gIHBhZGRpbmc6IDAgMCAycHg7XFxuICAvKiBoZWlnaHQgaXMgdW5yZWxpYWJsZSBhY3Jvc3MgYnJvd3NlcnMsIHNvIHVzZSBwYWRkaW5nICovXFxuICBib3JkZXItd2lkdGg6IDFweCAwOyB9XFxuXFxuLmZjLWNsZWFyIHtcXG4gIGNsZWFyOiBib3RoOyB9XFxuXFxuLmZjLWJnLFxcbi5mYy1iZ2V2ZW50LXNrZWxldG9uLFxcbi5mYy1oaWdobGlnaHQtc2tlbGV0b24sXFxuLmZjLWhlbHBlci1za2VsZXRvbiB7XFxuICAvKiB0aGVzZSBlbGVtZW50IHNob3VsZCBhbHdheXMgY2xpbmcgdG8gdG9wLWxlZnQvcmlnaHQgY29ybmVycyAqL1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogMDtcXG4gIHJpZ2h0OiAwOyB9XFxuXFxuLmZjLWJnIHtcXG4gIGJvdHRvbTogMDtcXG4gIC8qIHN0cmVjaCBiZyB0byBib3R0b20gZWRnZSAqLyB9XFxuXFxuLmZjLWJnIHRhYmxlIHtcXG4gIGhlaWdodDogMTAwJTtcXG4gIC8qIHN0cmVjaCBiZyB0byBib3R0b20gZWRnZSAqLyB9XFxuXFxuLyogVGFibGVzXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcbi5mYyB0YWJsZSB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAvKiBmaXggc2Nyb2xsYmFyIGlzc3VlIGluIGZpcmVmb3ggKi9cXG4gIHRhYmxlLWxheW91dDogZml4ZWQ7XFxuICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbiAgYm9yZGVyLXNwYWNpbmc6IDA7XFxuICBmb250LXNpemU6IDFlbTtcXG4gIC8qIG5vcm1hbGl6ZSBjcm9zcy1icm93c2VyICovIH1cXG5cXG4uZmMgdGgge1xcbiAgdGV4dC1hbGlnbjogY2VudGVyOyB9XFxuXFxuLmZjIHRoLFxcbi5mYyB0ZCB7XFxuICBib3JkZXItc3R5bGU6IHNvbGlkO1xcbiAgYm9yZGVyLXdpZHRoOiAxcHg7XFxuICBwYWRkaW5nOiAwO1xcbiAgdmVydGljYWwtYWxpZ246IHRvcDsgfVxcblxcbi5mYyB0ZC5mYy10b2RheSB7XFxuICBib3JkZXItc3R5bGU6IGRvdWJsZTtcXG4gIC8qIG92ZXJjb21lIG5laWdoYm9yaW5nIGJvcmRlcnMgKi8gfVxcblxcbi8qIEludGVybmFsIE5hdiBMaW5rc1xcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5hW2RhdGEtZ290b10ge1xcbiAgY3Vyc29yOiBwb2ludGVyOyB9XFxuXFxuYVtkYXRhLWdvdG9dOmhvdmVyIHtcXG4gIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lOyB9XFxuXFxuLyogRmFrZSBUYWJsZSBSb3dzXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcbi5mYyAuZmMtcm93IHtcXG4gIC8qIGV4dHJhIHByZWNlZGVuY2UgdG8gb3ZlcmNvbWUgdGhlbWVzIHcvIC51aS13aWRnZXQtY29udGVudCBmb3JjaW5nIGEgMXB4IGJvcmRlciAqL1xcbiAgLyogbm8gdmlzaWJsZSBib3JkZXIgYnkgZGVmYXVsdC4gYnV0IG1ha2UgYXZhaWxhYmxlIGlmIG5lZWQgYmUgKHNjcm9sbGJhciB3aWR0aCBjb21wZW5zYXRpb24pICovXFxuICBib3JkZXItc3R5bGU6IHNvbGlkO1xcbiAgYm9yZGVyLXdpZHRoOiAwOyB9XFxuXFxuLmZjLXJvdyB0YWJsZSB7XFxuICAvKiBkb24ndCBwdXQgbGVmdC9yaWdodCBib3JkZXIgb24gYW55dGhpbmcgd2l0aGluIGEgZmFrZSByb3cuXFxuXFx0ICAgdGhlIG91dGVyIHRib2R5IHdpbGwgd29ycnkgYWJvdXQgdGhpcyAqL1xcbiAgYm9yZGVyLWxlZnQ6IDAgaGlkZGVuIHRyYW5zcGFyZW50O1xcbiAgYm9yZGVyLXJpZ2h0OiAwIGhpZGRlbiB0cmFuc3BhcmVudDtcXG4gIC8qIG5vIGJvdHRvbSBib3JkZXJzIG9uIHJvd3MgKi9cXG4gIGJvcmRlci1ib3R0b206IDAgaGlkZGVuIHRyYW5zcGFyZW50OyB9XFxuXFxuLmZjLXJvdzpmaXJzdC1jaGlsZCB0YWJsZSB7XFxuICBib3JkZXItdG9wOiAwIGhpZGRlbiB0cmFuc3BhcmVudDtcXG4gIC8qIG5vIHRvcCBib3JkZXIgb24gZmlyc3Qgcm93ICovIH1cXG5cXG4vKiBEYXkgUm93ICh1c2VkIHdpdGhpbiB0aGUgaGVhZGVyIGFuZCB0aGUgRGF5R3JpZClcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuLmZjLXJvdyB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7IH1cXG5cXG4uZmMtcm93IC5mYy1iZyB7XFxuICB6LWluZGV4OiAxOyB9XFxuXFxuLyogaGlnaGxpZ2h0aW5nIGNlbGxzICYgYmFja2dyb3VuZCBldmVudCBza2VsZXRvbiAqL1xcbi5mYy1yb3cgLmZjLWJnZXZlbnQtc2tlbGV0b24sXFxuLmZjLXJvdyAuZmMtaGlnaGxpZ2h0LXNrZWxldG9uIHtcXG4gIGJvdHRvbTogMDtcXG4gIC8qIHN0cmV0Y2ggc2tlbGV0b24gdG8gYm90dG9tIG9mIHJvdyAqLyB9XFxuXFxuLmZjLXJvdyAuZmMtYmdldmVudC1za2VsZXRvbiB0YWJsZSxcXG4uZmMtcm93IC5mYy1oaWdobGlnaHQtc2tlbGV0b24gdGFibGUge1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgLyogc3RyZXRjaCBza2VsZXRvbiB0byBib3R0b20gb2Ygcm93ICovIH1cXG5cXG4uZmMtcm93IC5mYy1oaWdobGlnaHQtc2tlbGV0b24gdGQsXFxuLmZjLXJvdyAuZmMtYmdldmVudC1za2VsZXRvbiB0ZCB7XFxuICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50OyB9XFxuXFxuLmZjLXJvdyAuZmMtYmdldmVudC1za2VsZXRvbiB7XFxuICB6LWluZGV4OiAyOyB9XFxuXFxuLmZjLXJvdyAuZmMtaGlnaGxpZ2h0LXNrZWxldG9uIHtcXG4gIHotaW5kZXg6IDM7IH1cXG5cXG4vKlxcbnJvdyBjb250ZW50ICh3aGljaCBjb250YWlucyBkYXkvd2VlayBudW1iZXJzIGFuZCBldmVudHMpIGFzIHdlbGwgYXMgXFxcImhlbHBlclxcXCIgKHdoaWNoIGNvbnRhaW5zXFxudGVtcG9yYXJ5IHJlbmRlcmVkIGV2ZW50cykuXFxuKi9cXG4uZmMtcm93IC5mYy1jb250ZW50LXNrZWxldG9uIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHotaW5kZXg6IDQ7XFxuICBwYWRkaW5nLWJvdHRvbTogMnB4O1xcbiAgLyogbWF0Y2hlcyB0aGUgc3BhY2UgYWJvdmUgdGhlIGV2ZW50cyAqLyB9XFxuXFxuLmZjLXJvdyAuZmMtaGVscGVyLXNrZWxldG9uIHtcXG4gIHotaW5kZXg6IDU7IH1cXG5cXG4uZmMtcm93IC5mYy1jb250ZW50LXNrZWxldG9uIHRkLFxcbi5mYy1yb3cgLmZjLWhlbHBlci1za2VsZXRvbiB0ZCB7XFxuICAvKiBzZWUtdGhyb3VnaCB0byB0aGUgYmFja2dyb3VuZCBiZWxvdyAqL1xcbiAgYmFja2dyb3VuZDogbm9uZTtcXG4gIC8qIGluIGNhc2UgPHRkPnMgYXJlIGdsb2JhbGx5IHN0eWxlZCAqL1xcbiAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gIC8qIGRvbid0IHB1dCBhIGJvcmRlciBiZXR3ZWVuIGV2ZW50cyBhbmQvb3IgdGhlIGRheSBudW1iZXIgKi9cXG4gIGJvcmRlci1ib3R0b206IDA7IH1cXG5cXG4uZmMtcm93IC5mYy1jb250ZW50LXNrZWxldG9uIHRib2R5IHRkLFxcbi5mYy1yb3cgLmZjLWhlbHBlci1za2VsZXRvbiB0Ym9keSB0ZCB7XFxuICAvKiBkb24ndCBwdXQgYSBib3JkZXIgYmV0d2VlbiBldmVudCBjZWxscyAqL1xcbiAgYm9yZGVyLXRvcDogMDsgfVxcblxcbi8qIFNjcm9sbGluZyBDb250YWluZXJcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuLmZjLXNjcm9sbGVyIHtcXG4gIC13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOiB0b3VjaDsgfVxcblxcbi8qIFRPRE86IG1vdmUgdG8gYWdlbmRhL2Jhc2ljICovXFxuLmZjLXNjcm9sbGVyID4gLmZjLWRheS1ncmlkLFxcbi5mYy1zY3JvbGxlciA+IC5mYy10aW1lLWdyaWQge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgLyogcmUtc2NvcGUgYWxsIHBvc2l0aW9ucyAqL1xcbiAgd2lkdGg6IDEwMCU7XFxuICAvKiBoYWNrIHRvIGZvcmNlIHJlLXNpemluZyB0aGlzIGlubmVyIGVsZW1lbnQgd2hlbiBzY3JvbGxiYXJzIGFwcGVhci9kaXNhcHBlYXIgKi8gfVxcblxcbi8qIEdsb2JhbCBFdmVudCBTdHlsZXNcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuLmZjLWV2ZW50IHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIC8qIGZvciByZXNpemUgaGFuZGxlIGFuZCBvdGhlciBpbm5lciBwb3NpdGlvbmluZyAqL1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICAvKiBtYWtlIHRoZSA8YT4gdGFnIGJsb2NrICovXFxuICBmb250LXNpemU6IC44NWVtO1xcbiAgbGluZS1oZWlnaHQ6IDEuMztcXG4gIGJvcmRlci1yYWRpdXM6IDNweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICMzYTg3YWQ7XFxuICAvKiBkZWZhdWx0IEJPUkRFUiBjb2xvciAqL1xcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXG4gIC8qIHVuZG8ganF1aSdzIHVpLXdpZGdldC1oZWFkZXIgYm9sZCAqLyB9XFxuXFxuLmZjLWV2ZW50LFxcbi5mYy1ldmVudC1kb3Qge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzNhODdhZDtcXG4gIC8qIGRlZmF1bHQgQkFDS0dST1VORCBjb2xvciAqLyB9XFxuXFxuLyogb3ZlcnBvd2VyIHNvbWUgb2YgYm9vdHN0cmFwJ3MgYW5kIGpxdWkncyBzdHlsZXMgb24gPGE+IHRhZ3MgKi9cXG4uZmMtZXZlbnQsXFxuLmZjLWV2ZW50OmhvdmVyLFxcbi51aS13aWRnZXQgLmZjLWV2ZW50IHtcXG4gIGNvbG9yOiAjZmZmO1xcbiAgLyogZGVmYXVsdCBURVhUIGNvbG9yICovXFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICAvKiBpZiA8YT4gaGFzIGFuIGhyZWYgKi8gfVxcblxcbi5mYy1ldmVudFtocmVmXSxcXG4uZmMtZXZlbnQuZmMtZHJhZ2dhYmxlIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIC8qIGdpdmUgZXZlbnRzIHdpdGggbGlua3MgYW5kIGRyYWdnYWJsZSBldmVudHMgYSBoYW5kIG1vdXNlIHBvaW50ZXIgKi8gfVxcblxcbi5mYy1ub3QtYWxsb3dlZCxcXG4uZmMtbm90LWFsbG93ZWQgLmZjLWV2ZW50IHtcXG4gIC8qIHRvIG92ZXJyaWRlIGFuIGV2ZW50J3MgY3VzdG9tIGN1cnNvciAqL1xcbiAgY3Vyc29yOiBub3QtYWxsb3dlZDsgfVxcblxcbi5mYy1ldmVudCAuZmMtYmcge1xcbiAgLyogdGhlIGdlbmVyaWMgLmZjLWJnIGFscmVhZHkgZG9lcyBwb3NpdGlvbiAqL1xcbiAgei1pbmRleDogMTtcXG4gIGJhY2tncm91bmQ6ICNmZmY7XFxuICBvcGFjaXR5OiAuMjU7IH1cXG5cXG4uZmMtZXZlbnQgLmZjLWNvbnRlbnQge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgei1pbmRleDogMjsgfVxcblxcbi8qIHJlc2l6ZXIgKGN1cnNvciBBTkQgdG91Y2ggZGV2aWNlcykgKi9cXG4uZmMtZXZlbnQgLmZjLXJlc2l6ZXIge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgei1pbmRleDogNDsgfVxcblxcbi8qIHJlc2l6ZXIgKHRvdWNoIGRldmljZXMpICovXFxuLmZjLWV2ZW50IC5mYy1yZXNpemVyIHtcXG4gIGRpc3BsYXk6IG5vbmU7IH1cXG5cXG4uZmMtZXZlbnQuZmMtYWxsb3ctbW91c2UtcmVzaXplIC5mYy1yZXNpemVyLFxcbi5mYy1ldmVudC5mYy1zZWxlY3RlZCAuZmMtcmVzaXplciB7XFxuICAvKiBvbmx5IHNob3cgd2hlbiBob3ZlcmluZyBvciBzZWxlY3RlZCAod2l0aCB0b3VjaCkgKi9cXG4gIGRpc3BsYXk6IGJsb2NrOyB9XFxuXFxuLyogaGl0IGFyZWEgKi9cXG4uZmMtZXZlbnQuZmMtc2VsZWN0ZWQgLmZjLXJlc2l6ZXI6YmVmb3JlIHtcXG4gIC8qIDQweDQwIHRvdWNoIGFyZWEgKi9cXG4gIGNvbnRlbnQ6IFxcXCJcXFwiO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgei1pbmRleDogOTk5OTtcXG4gIC8qIHVzZXIgb2YgdGhpcyB1dGlsIGNhbiBzY29wZSB3aXRoaW4gYSBsb3dlciB6LWluZGV4ICovXFxuICB0b3A6IDUwJTtcXG4gIGxlZnQ6IDUwJTtcXG4gIHdpZHRoOiA0MHB4O1xcbiAgaGVpZ2h0OiA0MHB4O1xcbiAgbWFyZ2luLWxlZnQ6IC0yMHB4O1xcbiAgbWFyZ2luLXRvcDogLTIwcHg7IH1cXG5cXG4vKiBFdmVudCBTZWxlY3Rpb24gKG9ubHkgZm9yIHRvdWNoIGRldmljZXMpXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcbi5mYy1ldmVudC5mYy1zZWxlY3RlZCB7XFxuICB6LWluZGV4OiA5OTk5ICFpbXBvcnRhbnQ7XFxuICAvKiBvdmVyY29tZXMgaW5saW5lIHotaW5kZXggKi9cXG4gIGJveC1zaGFkb3c6IDAgMnB4IDVweCByZ2JhKDAsIDAsIDAsIDAuMik7IH1cXG5cXG4uZmMtZXZlbnQuZmMtc2VsZWN0ZWQuZmMtZHJhZ2dpbmcge1xcbiAgYm94LXNoYWRvdzogMCAycHggN3B4IHJnYmEoMCwgMCwgMCwgMC4zKTsgfVxcblxcbi8qIEhvcml6b250YWwgRXZlbnRzXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcbi8qIGJpZ2dlciB0b3VjaCBhcmVhIHdoZW4gc2VsZWN0ZWQgKi9cXG4uZmMtaC1ldmVudC5mYy1zZWxlY3RlZDpiZWZvcmUge1xcbiAgY29udGVudDogXFxcIlxcXCI7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB6LWluZGV4OiAzO1xcbiAgLyogYmVsb3cgcmVzaXplcnMgKi9cXG4gIHRvcDogLTEwcHg7XFxuICBib3R0b206IC0xMHB4O1xcbiAgbGVmdDogMDtcXG4gIHJpZ2h0OiAwOyB9XFxuXFxuLyogZXZlbnRzIHRoYXQgYXJlIGNvbnRpbnVpbmcgdG8vZnJvbSBhbm90aGVyIHdlZWsuIGtpbGwgcm91bmRlZCBjb3JuZXJzIGFuZCBidXR0IHVwIGFnYWluc3QgZWRnZSAqL1xcbi5mYy1sdHIgLmZjLWgtZXZlbnQuZmMtbm90LXN0YXJ0LFxcbi5mYy1ydGwgLmZjLWgtZXZlbnQuZmMtbm90LWVuZCB7XFxuICBtYXJnaW4tbGVmdDogMDtcXG4gIGJvcmRlci1sZWZ0LXdpZHRoOiAwO1xcbiAgcGFkZGluZy1sZWZ0OiAxcHg7XFxuICAvKiByZXBsYWNlIHRoZSBib3JkZXIgd2l0aCBwYWRkaW5nICovXFxuICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAwO1xcbiAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogMDsgfVxcblxcbi5mYy1sdHIgLmZjLWgtZXZlbnQuZmMtbm90LWVuZCxcXG4uZmMtcnRsIC5mYy1oLWV2ZW50LmZjLW5vdC1zdGFydCB7XFxuICBtYXJnaW4tcmlnaHQ6IDA7XFxuICBib3JkZXItcmlnaHQtd2lkdGg6IDA7XFxuICBwYWRkaW5nLXJpZ2h0OiAxcHg7XFxuICAvKiByZXBsYWNlIHRoZSBib3JkZXIgd2l0aCBwYWRkaW5nICovXFxuICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMDtcXG4gIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAwOyB9XFxuXFxuLyogcmVzaXplciAoY3Vyc29yIEFORCB0b3VjaCBkZXZpY2VzKSAqL1xcbi8qIGxlZnQgcmVzaXplciAgKi9cXG4uZmMtbHRyIC5mYy1oLWV2ZW50IC5mYy1zdGFydC1yZXNpemVyLFxcbi5mYy1ydGwgLmZjLWgtZXZlbnQgLmZjLWVuZC1yZXNpemVyIHtcXG4gIGN1cnNvcjogdy1yZXNpemU7XFxuICBsZWZ0OiAtMXB4O1xcbiAgLyogb3ZlcmNvbWUgYm9yZGVyICovIH1cXG5cXG4vKiByaWdodCByZXNpemVyICovXFxuLmZjLWx0ciAuZmMtaC1ldmVudCAuZmMtZW5kLXJlc2l6ZXIsXFxuLmZjLXJ0bCAuZmMtaC1ldmVudCAuZmMtc3RhcnQtcmVzaXplciB7XFxuICBjdXJzb3I6IGUtcmVzaXplO1xcbiAgcmlnaHQ6IC0xcHg7XFxuICAvKiBvdmVyY29tZSBib3JkZXIgKi8gfVxcblxcbi8qIHJlc2l6ZXIgKG1vdXNlIGRldmljZXMpICovXFxuLmZjLWgtZXZlbnQuZmMtYWxsb3ctbW91c2UtcmVzaXplIC5mYy1yZXNpemVyIHtcXG4gIHdpZHRoOiA3cHg7XFxuICB0b3A6IC0xcHg7XFxuICAvKiBvdmVyY29tZSB0b3AgYm9yZGVyICovXFxuICBib3R0b206IC0xcHg7XFxuICAvKiBvdmVyY29tZSBib3R0b20gYm9yZGVyICovIH1cXG5cXG4vKiByZXNpemVyICh0b3VjaCBkZXZpY2VzKSAqL1xcbi5mYy1oLWV2ZW50LmZjLXNlbGVjdGVkIC5mYy1yZXNpemVyIHtcXG4gIC8qIDh4OCBsaXR0bGUgZG90ICovXFxuICBib3JkZXItcmFkaXVzOiA0cHg7XFxuICBib3JkZXItd2lkdGg6IDFweDtcXG4gIHdpZHRoOiA2cHg7XFxuICBoZWlnaHQ6IDZweDtcXG4gIGJvcmRlci1zdHlsZTogc29saWQ7XFxuICBib3JkZXItY29sb3I6IGluaGVyaXQ7XFxuICBiYWNrZ3JvdW5kOiAjZmZmO1xcbiAgLyogdmVydGljYWxseSBjZW50ZXIgKi9cXG4gIHRvcDogNTAlO1xcbiAgbWFyZ2luLXRvcDogLTRweDsgfVxcblxcbi8qIGxlZnQgcmVzaXplciAgKi9cXG4uZmMtbHRyIC5mYy1oLWV2ZW50LmZjLXNlbGVjdGVkIC5mYy1zdGFydC1yZXNpemVyLFxcbi5mYy1ydGwgLmZjLWgtZXZlbnQuZmMtc2VsZWN0ZWQgLmZjLWVuZC1yZXNpemVyIHtcXG4gIG1hcmdpbi1sZWZ0OiAtNHB4O1xcbiAgLyogY2VudGVycyB0aGUgOHg4IGRvdCBvbiB0aGUgbGVmdCBlZGdlICovIH1cXG5cXG4vKiByaWdodCByZXNpemVyICovXFxuLmZjLWx0ciAuZmMtaC1ldmVudC5mYy1zZWxlY3RlZCAuZmMtZW5kLXJlc2l6ZXIsXFxuLmZjLXJ0bCAuZmMtaC1ldmVudC5mYy1zZWxlY3RlZCAuZmMtc3RhcnQtcmVzaXplciB7XFxuICBtYXJnaW4tcmlnaHQ6IC00cHg7XFxuICAvKiBjZW50ZXJzIHRoZSA4eDggZG90IG9uIHRoZSByaWdodCBlZGdlICovIH1cXG5cXG4vKiBEYXlHcmlkIGV2ZW50c1xcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5XZSB1c2UgdGhlIGZ1bGwgXFxcImZjLWRheS1ncmlkLWV2ZW50XFxcIiBjbGFzcyBpbnN0ZWFkIG9mIHVzaW5nIGRlc2NlbmRhbnRzIGJlY2F1c2UgdGhlIGV2ZW50IHdvbid0XFxuYmUgYSBkZXNjZW5kYW50IG9mIHRoZSBncmlkIHdoZW4gaXQgaXMgYmVpbmcgZHJhZ2dlZC5cXG4qL1xcbi5mYy1kYXktZ3JpZC1ldmVudCB7XFxuICBtYXJnaW46IDFweCAycHggMDtcXG4gIC8qIHNwYWNpbmcgYmV0d2VlbiBldmVudHMgYW5kIGVkZ2VzICovXFxuICBwYWRkaW5nOiAwIDFweDsgfVxcblxcbnRyOmZpcnN0LWNoaWxkID4gdGQgPiAuZmMtZGF5LWdyaWQtZXZlbnQge1xcbiAgbWFyZ2luLXRvcDogMnB4O1xcbiAgLyogYSBsaXR0bGUgYml0IG1vcmUgc3BhY2UgYmVmb3JlIHRoZSBmaXJzdCBldmVudCAqLyB9XFxuXFxuLmZjLWRheS1ncmlkLWV2ZW50LmZjLXNlbGVjdGVkOmFmdGVyIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFwiO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgei1pbmRleDogMTtcXG4gIC8qIHNhbWUgei1pbmRleCBhcyBmYy1iZywgYmVoaW5kIHRleHQgKi9cXG4gIC8qIG92ZXJjb21lIHRoZSBib3JkZXJzICovXFxuICB0b3A6IC0xcHg7XFxuICByaWdodDogLTFweDtcXG4gIGJvdHRvbTogLTFweDtcXG4gIGxlZnQ6IC0xcHg7XFxuICAvKiBkYXJrZW5pbmcgZWZmZWN0ICovXFxuICBiYWNrZ3JvdW5kOiAjMDAwO1xcbiAgb3BhY2l0eTogLjI1OyB9XFxuXFxuLmZjLWRheS1ncmlkLWV2ZW50IC5mYy1jb250ZW50IHtcXG4gIC8qIGZvcmNlIGV2ZW50cyB0byBiZSBvbmUtbGluZSB0YWxsICovXFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjsgfVxcblxcbi5mYy1kYXktZ3JpZC1ldmVudCAuZmMtdGltZSB7XFxuICBmb250LXdlaWdodDogYm9sZDsgfVxcblxcbi8qIHJlc2l6ZXIgKGN1cnNvciBkZXZpY2VzKSAqL1xcbi8qIGxlZnQgcmVzaXplciAgKi9cXG4uZmMtbHRyIC5mYy1kYXktZ3JpZC1ldmVudC5mYy1hbGxvdy1tb3VzZS1yZXNpemUgLmZjLXN0YXJ0LXJlc2l6ZXIsXFxuLmZjLXJ0bCAuZmMtZGF5LWdyaWQtZXZlbnQuZmMtYWxsb3ctbW91c2UtcmVzaXplIC5mYy1lbmQtcmVzaXplciB7XFxuICBtYXJnaW4tbGVmdDogLTJweDtcXG4gIC8qIHRvIHRoZSBkYXkgY2VsbCdzIGVkZ2UgKi8gfVxcblxcbi8qIHJpZ2h0IHJlc2l6ZXIgKi9cXG4uZmMtbHRyIC5mYy1kYXktZ3JpZC1ldmVudC5mYy1hbGxvdy1tb3VzZS1yZXNpemUgLmZjLWVuZC1yZXNpemVyLFxcbi5mYy1ydGwgLmZjLWRheS1ncmlkLWV2ZW50LmZjLWFsbG93LW1vdXNlLXJlc2l6ZSAuZmMtc3RhcnQtcmVzaXplciB7XFxuICBtYXJnaW4tcmlnaHQ6IC0ycHg7XFxuICAvKiB0byB0aGUgZGF5IGNlbGwncyBlZGdlICovIH1cXG5cXG4vKiBFdmVudCBMaW1pdGluZ1xcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG4vKiBcXFwibW9yZVxcXCIgbGluayB0aGF0IHJlcHJlc2VudHMgaGlkZGVuIGV2ZW50cyAqL1xcbmEuZmMtbW9yZSB7XFxuICBtYXJnaW46IDFweCAzcHg7XFxuICBmb250LXNpemU6IC44NWVtO1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lOyB9XFxuXFxuYS5mYy1tb3JlOmhvdmVyIHtcXG4gIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lOyB9XFxuXFxuLmZjLWxpbWl0ZWQge1xcbiAgLyogcm93cyBhbmQgY2VsbHMgdGhhdCBhcmUgaGlkZGVuIGJlY2F1c2Ugb2YgYSBcXFwibW9yZVxcXCIgbGluayAqL1xcbiAgZGlzcGxheTogbm9uZTsgfVxcblxcbi8qIHBvcG92ZXIgdGhhdCBhcHBlYXJzIHdoZW4gXFxcIm1vcmVcXFwiIGxpbmsgaXMgY2xpY2tlZCAqL1xcbi5mYy1kYXktZ3JpZCAuZmMtcm93IHtcXG4gIHotaW5kZXg6IDE7XFxuICAvKiBtYWtlIHRoZSBcXFwibW9yZVxcXCIgcG9wb3ZlciBvbmUgaGlnaGVyIHRoYW4gdGhpcyAqLyB9XFxuXFxuLmZjLW1vcmUtcG9wb3ZlciB7XFxuICB6LWluZGV4OiAyO1xcbiAgd2lkdGg6IDIyMHB4OyB9XFxuXFxuLmZjLW1vcmUtcG9wb3ZlciAuZmMtZXZlbnQtY29udGFpbmVyIHtcXG4gIHBhZGRpbmc6IDEwcHg7IH1cXG5cXG4vKiBOb3cgSW5kaWNhdG9yXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcbi5mYy1ub3ctaW5kaWNhdG9yIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGJvcmRlcjogMCBzb2xpZCByZWQ7IH1cXG5cXG4vKiBVdGlsaXRpZXNcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuLmZjLXVuc2VsZWN0YWJsZSB7XFxuICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbiAgLWtodG1sLXVzZXItc2VsZWN0OiBub25lO1xcbiAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcXG4gIHVzZXItc2VsZWN0OiBub25lO1xcbiAgLXdlYmtpdC10b3VjaC1jYWxsb3V0OiBub25lO1xcbiAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiB0cmFuc3BhcmVudDsgfVxcblxcbi8qIFRvb2xiYXJcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuLmZjLXRvb2xiYXIge1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgbWFyZ2luLWJvdHRvbTogMWVtOyB9XFxuXFxuLmZjLXRvb2xiYXIgLmZjLWxlZnQge1xcbiAgZmxvYXQ6IGxlZnQ7IH1cXG5cXG4uZmMtdG9vbGJhciAuZmMtcmlnaHQge1xcbiAgZmxvYXQ6IHJpZ2h0OyB9XFxuXFxuLmZjLXRvb2xiYXIgLmZjLWNlbnRlciB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IH1cXG5cXG4vKiB0aGUgdGhpbmdzIHdpdGhpbiBlYWNoIGxlZnQvcmlnaHQvY2VudGVyIHNlY3Rpb24gKi9cXG4uZmMgLmZjLXRvb2xiYXIgPiAqID4gKiB7XFxuICAvKiBleHRyYSBwcmVjZWRlbmNlIHRvIG92ZXJyaWRlIGJ1dHRvbiBib3JkZXIgbWFyZ2lucyAqL1xcbiAgZmxvYXQ6IGxlZnQ7XFxuICBtYXJnaW4tbGVmdDogLjc1ZW07IH1cXG5cXG4vKiB0aGUgZmlyc3QgdGhpbmcgd2l0aGluIGVhY2ggbGVmdC9jZW50ZXIvcmlnaHQgc2VjdGlvbiAqL1xcbi5mYyAuZmMtdG9vbGJhciA+ICogPiA6Zmlyc3QtY2hpbGQge1xcbiAgLyogZXh0cmEgcHJlY2VkZW5jZSB0byBvdmVycmlkZSBidXR0b24gYm9yZGVyIG1hcmdpbnMgKi9cXG4gIG1hcmdpbi1sZWZ0OiAwOyB9XFxuXFxuLyogdGl0bGUgdGV4dCAqL1xcbi5mYy10b29sYmFyIGgyIHtcXG4gIG1hcmdpbjogMDsgfVxcblxcbi8qIGJ1dHRvbiBsYXllcmluZyAoZm9yIGJvcmRlciBwcmVjZWRlbmNlKSAqL1xcbi5mYy10b29sYmFyIGJ1dHRvbiB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7IH1cXG5cXG4uZmMtdG9vbGJhciAuZmMtc3RhdGUtaG92ZXIsXFxuLmZjLXRvb2xiYXIgLnVpLXN0YXRlLWhvdmVyIHtcXG4gIHotaW5kZXg6IDI7IH1cXG5cXG4uZmMtdG9vbGJhciAuZmMtc3RhdGUtZG93biB7XFxuICB6LWluZGV4OiAzOyB9XFxuXFxuLmZjLXRvb2xiYXIgLmZjLXN0YXRlLWFjdGl2ZSxcXG4uZmMtdG9vbGJhciAudWktc3RhdGUtYWN0aXZlIHtcXG4gIHotaW5kZXg6IDQ7IH1cXG5cXG4uZmMtdG9vbGJhciBidXR0b246Zm9jdXMge1xcbiAgei1pbmRleDogNTsgfVxcblxcbi8qIFZpZXcgU3RydWN0dXJlXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcbi8qIHVuZG8gdHdpdHRlciBib290c3RyYXAncyBib3gtc2l6aW5nIHJ1bGVzLiBub3JtYWxpemVzIHBvc2l0aW9uaW5nIHRlY2huaXF1ZXMgKi9cXG4vKiBkb24ndCBkbyB0aGlzIGZvciB0aGUgdG9vbGJhciBiZWNhdXNlIHdlJ2xsIHdhbnQgYm9vdHN0cmFwIHRvIHN0eWxlIHRob3NlIGJ1dHRvbnMgYXMgc29tZSBwdCAqL1xcbi5mYy12aWV3LWNvbnRhaW5lciAqLFxcbi5mYy12aWV3LWNvbnRhaW5lciAqOmJlZm9yZSxcXG4uZmMtdmlldy1jb250YWluZXIgKjphZnRlciB7XFxuICAtd2Via2l0LWJveC1zaXppbmc6IGNvbnRlbnQtYm94O1xcbiAgLW1vei1ib3gtc2l6aW5nOiBjb250ZW50LWJveDtcXG4gIGJveC1zaXppbmc6IGNvbnRlbnQtYm94OyB9XFxuXFxuLmZjLXZpZXcsXFxuLmZjLXZpZXcgPiB0YWJsZSB7XFxuICAvKiBzbyBkcmFnZ2VkIGVsZW1lbnRzIGNhbiBiZSBhYm92ZSB0aGUgdmlldydzIG1haW4gZWxlbWVudCAqL1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgei1pbmRleDogMTsgfVxcblxcbi8qIEJhc2ljVmlld1xcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG4vKiBkYXkgcm93IHN0cnVjdHVyZSAqL1xcbi5mYy1iYXNpY1dlZWstdmlldyAuZmMtY29udGVudC1za2VsZXRvbixcXG4uZmMtYmFzaWNEYXktdmlldyAuZmMtY29udGVudC1za2VsZXRvbiB7XFxuICAvKiB0aGVyZSBtYXkgYmUgd2VlayBudW1iZXJzIGluIHRoZXNlIHZpZXdzLCBzbyBubyBwYWRkaW5nLXRvcCAqL1xcbiAgcGFkZGluZy1ib3R0b206IDFlbTtcXG4gIC8qIGVuc3VyZSBhIHNwYWNlIGF0IGJvdHRvbSBvZiBjZWxsIGZvciB1c2VyIHNlbGVjdGluZy9jbGlja2luZyAqLyB9XFxuXFxuLmZjLWJhc2ljLXZpZXcgLmZjLWJvZHkgLmZjLXJvdyB7XFxuICBtaW4taGVpZ2h0OiA0ZW07XFxuICAvKiBlbnN1cmUgdGhhdCBhbGwgcm93cyBhcmUgYXQgbGVhc3QgdGhpcyB0YWxsICovIH1cXG5cXG4vKiBhIFxcXCJyaWdpZFxcXCIgcm93IHdpbGwgdGFrZSB1cCBhIGNvbnN0YW50IGFtb3VudCBvZiBoZWlnaHQgYmVjYXVzZSBjb250ZW50LXNrZWxldG9uIGlzIGFic29sdXRlICovXFxuLmZjLXJvdy5mYy1yaWdpZCB7XFxuICBvdmVyZmxvdzogaGlkZGVuOyB9XFxuXFxuLmZjLXJvdy5mYy1yaWdpZCAuZmMtY29udGVudC1za2VsZXRvbiB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAwO1xcbiAgcmlnaHQ6IDA7IH1cXG5cXG4vKiB3ZWVrIGFuZCBkYXkgbnVtYmVyIHN0eWxpbmcgKi9cXG4uZmMtZGF5LXRvcC5mYy1vdGhlci1tb250aCB7XFxuICBvcGFjaXR5OiAwLjM7IH1cXG5cXG4uZmMtYmFzaWMtdmlldyAuZmMtd2Vlay1udW1iZXIsXFxuLmZjLWJhc2ljLXZpZXcgLmZjLWRheS1udW1iZXIge1xcbiAgcGFkZGluZzogMnB4OyB9XFxuXFxuLmZjLWJhc2ljLXZpZXcgdGguZmMtd2Vlay1udW1iZXIsXFxuLmZjLWJhc2ljLXZpZXcgdGguZmMtZGF5LW51bWJlciB7XFxuICBwYWRkaW5nOiAwIDJweDtcXG4gIC8qIGNvbHVtbiBoZWFkZXJzIGNhbid0IGhhdmUgYXMgbXVjaCB2IHNwYWNlICovIH1cXG5cXG4uZmMtbHRyIC5mYy1iYXNpYy12aWV3IC5mYy1kYXktdG9wIC5mYy1kYXktbnVtYmVyIHtcXG4gIGZsb2F0OiByaWdodDsgfVxcblxcbi5mYy1ydGwgLmZjLWJhc2ljLXZpZXcgLmZjLWRheS10b3AgLmZjLWRheS1udW1iZXIge1xcbiAgZmxvYXQ6IGxlZnQ7IH1cXG5cXG4uZmMtbHRyIC5mYy1iYXNpYy12aWV3IC5mYy1kYXktdG9wIC5mYy13ZWVrLW51bWJlciB7XFxuICBmbG9hdDogbGVmdDtcXG4gIGJvcmRlci1yYWRpdXM6IDAgMCAzcHggMDsgfVxcblxcbi5mYy1ydGwgLmZjLWJhc2ljLXZpZXcgLmZjLWRheS10b3AgLmZjLXdlZWstbnVtYmVyIHtcXG4gIGZsb2F0OiByaWdodDtcXG4gIGJvcmRlci1yYWRpdXM6IDAgMCAwIDNweDsgfVxcblxcbi5mYy1iYXNpYy12aWV3IC5mYy1kYXktdG9wIC5mYy13ZWVrLW51bWJlciB7XFxuICBtaW4td2lkdGg6IDEuNWVtO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2YyZjJmMjtcXG4gIGNvbG9yOiAjODA4MDgwOyB9XFxuXFxuLyogd2hlbiB3ZWVrL2RheSBudW1iZXIgaGF2ZSBvd24gY29sdW1uICovXFxuLmZjLWJhc2ljLXZpZXcgdGQuZmMtd2Vlay1udW1iZXIge1xcbiAgdGV4dC1hbGlnbjogY2VudGVyOyB9XFxuXFxuLmZjLWJhc2ljLXZpZXcgdGQuZmMtd2Vlay1udW1iZXIgPiAqIHtcXG4gIC8qIHdvcmsgYXJvdW5kIHRoZSB3YXkgd2UgZG8gY29sdW1uIHJlc2l6aW5nIGFuZCBlbnN1cmUgYSBtaW5pbXVtIHdpZHRoICovXFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBtaW4td2lkdGg6IDEuMjVlbTsgfVxcblxcbi8qIEFnZW5kYVZpZXcgYWxsLWRheSBhcmVhXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcbi5mYy1hZ2VuZGEtdmlldyAuZmMtZGF5LWdyaWQge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgei1pbmRleDogMjtcXG4gIC8qIHNvIHRoZSBcXFwibW9yZS4uXFxcIiBwb3BvdmVyIHdpbGwgYmUgb3ZlciB0aGUgdGltZSBncmlkICovIH1cXG5cXG4uZmMtYWdlbmRhLXZpZXcgLmZjLWRheS1ncmlkIC5mYy1yb3cge1xcbiAgbWluLWhlaWdodDogM2VtO1xcbiAgLyogYWxsLWRheSBzZWN0aW9uIHdpbGwgbmV2ZXIgZ2V0IHNob3J0ZXIgdGhhbiB0aGlzICovIH1cXG5cXG4uZmMtYWdlbmRhLXZpZXcgLmZjLWRheS1ncmlkIC5mYy1yb3cgLmZjLWNvbnRlbnQtc2tlbGV0b24ge1xcbiAgcGFkZGluZy1ib3R0b206IDFlbTtcXG4gIC8qIGdpdmUgc3BhY2UgdW5kZXJuZWF0aCBldmVudHMgZm9yIGNsaWNraW5nL3NlbGVjdGluZyBkYXlzICovIH1cXG5cXG4vKiBUaW1lR3JpZCBheGlzIHJ1bm5pbmcgZG93biB0aGUgc2lkZSAoZm9yIGJvdGggdGhlIGFsbC1kYXkgYXJlYSBhbmQgdGhlIHNsb3QgYXJlYSlcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuLmZjIC5mYy1heGlzIHtcXG4gIC8qIC5mYyB0byBvdmVyY29tZSBkZWZhdWx0IGNlbGwgc3R5bGVzICovXFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgcGFkZGluZzogMCA0cHg7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwOyB9XFxuXFxuLmZjLWx0ciAuZmMtYXhpcyB7XFxuICB0ZXh0LWFsaWduOiByaWdodDsgfVxcblxcbi5mYy1ydGwgLmZjLWF4aXMge1xcbiAgdGV4dC1hbGlnbjogbGVmdDsgfVxcblxcbi51aS13aWRnZXQgdGQuZmMtYXhpcyB7XFxuICBmb250LXdlaWdodDogbm9ybWFsO1xcbiAgLyogb3ZlcmNvbWUganF1aSB0aGVtZSBtYWtpbmcgaXQgYm9sZCAqLyB9XFxuXFxuLyogVGltZUdyaWQgU3RydWN0dXJlXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcbi5mYy10aW1lLWdyaWQtY29udGFpbmVyLFxcbi5mYy10aW1lLWdyaWQge1xcbiAgLyogc28gc2xhdHMvYmcvY29udGVudC9ldGMgcG9zaXRpb25zIGdldCBzY29wZWQgd2l0aGluIGhlcmUgKi9cXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHotaW5kZXg6IDE7IH1cXG5cXG4uZmMtdGltZS1ncmlkIHtcXG4gIG1pbi1oZWlnaHQ6IDEwMCU7XFxuICAvKiBzbyBpZiBoZWlnaHQgc2V0dGluZyBpcyAnYXV0bycsIC5mYy1iZyBzdHJldGNoZXMgdG8gZmlsbCBoZWlnaHQgKi8gfVxcblxcbi5mYy10aW1lLWdyaWQgdGFibGUge1xcbiAgLyogZG9uJ3QgcHV0IG91dGVyIGJvcmRlcnMgb24gc2xhdHMvYmcvY29udGVudC9ldGMgKi9cXG4gIGJvcmRlcjogMCBoaWRkZW4gdHJhbnNwYXJlbnQ7IH1cXG5cXG4uZmMtdGltZS1ncmlkID4gLmZjLWJnIHtcXG4gIHotaW5kZXg6IDE7IH1cXG5cXG4uZmMtdGltZS1ncmlkIC5mYy1zbGF0cyxcXG4uZmMtdGltZS1ncmlkID4gaHIge1xcbiAgLyogdGhlIDxocj4gQWdlbmRhVmlldyBpbmplY3RzIHdoZW4gZ3JpZCBpcyBzaG9ydGVyIHRoYW4gc2Nyb2xsZXIgKi9cXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHotaW5kZXg6IDI7IH1cXG5cXG4uZmMtdGltZS1ncmlkIC5mYy1jb250ZW50LWNvbCB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAvKiBiZWNhdXNlIG5vdy1pbmRpY2F0b3IgbGl2ZXMgZGlyZWN0bHkgaW5zaWRlICovIH1cXG5cXG4uZmMtdGltZS1ncmlkIC5mYy1jb250ZW50LXNrZWxldG9uIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHotaW5kZXg6IDM7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAwO1xcbiAgcmlnaHQ6IDA7IH1cXG5cXG4vKiBkaXZzIHdpdGhpbiBhIGNlbGwgd2l0aGluIHRoZSBmYy1jb250ZW50LXNrZWxldG9uICovXFxuLmZjLXRpbWUtZ3JpZCAuZmMtYnVzaW5lc3MtY29udGFpbmVyIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHotaW5kZXg6IDE7IH1cXG5cXG4uZmMtdGltZS1ncmlkIC5mYy1iZ2V2ZW50LWNvbnRhaW5lciB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB6LWluZGV4OiAyOyB9XFxuXFxuLmZjLXRpbWUtZ3JpZCAuZmMtaGlnaGxpZ2h0LWNvbnRhaW5lciB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB6LWluZGV4OiAzOyB9XFxuXFxuLmZjLXRpbWUtZ3JpZCAuZmMtZXZlbnQtY29udGFpbmVyIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHotaW5kZXg6IDQ7IH1cXG5cXG4uZmMtdGltZS1ncmlkIC5mYy1ub3ctaW5kaWNhdG9yLWxpbmUge1xcbiAgei1pbmRleDogNTsgfVxcblxcbi5mYy10aW1lLWdyaWQgLmZjLWhlbHBlci1jb250YWluZXIge1xcbiAgLyogYWxzbyBpcyBmYy1ldmVudC1jb250YWluZXIgKi9cXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHotaW5kZXg6IDY7IH1cXG5cXG4vKiBUaW1lR3JpZCBTbGF0cyAobGluZXMgdGhhdCBydW4gaG9yaXpvbnRhbGx5KVxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG4uZmMtdGltZS1ncmlkIC5mYy1zbGF0cyB0ZCB7XFxuICBoZWlnaHQ6IDEuNWVtO1xcbiAgYm9yZGVyLWJvdHRvbTogMDtcXG4gIC8qIGVhY2ggY2VsbCBpcyByZXNwb25zaWJsZSBmb3IgaXRzIHRvcCBib3JkZXIgKi8gfVxcblxcbi5mYy10aW1lLWdyaWQgLmZjLXNsYXRzIC5mYy1taW5vciB0ZCB7XFxuICBib3JkZXItdG9wLXN0eWxlOiBkb3R0ZWQ7IH1cXG5cXG4uZmMtdGltZS1ncmlkIC5mYy1zbGF0cyAudWktd2lkZ2V0LWNvbnRlbnQge1xcbiAgLyogZm9yIGpxdWkgdGhlbWUgKi9cXG4gIGJhY2tncm91bmQ6IG5vbmU7XFxuICAvKiBzZWUgdGhyb3VnaCB0byBmYy1iZyAqLyB9XFxuXFxuLyogVGltZUdyaWQgSGlnaGxpZ2h0aW5nIFNsb3RzXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcbi5mYy10aW1lLWdyaWQgLmZjLWhpZ2hsaWdodC1jb250YWluZXIge1xcbiAgLyogYSBkaXYgd2l0aGluIGEgY2VsbCB3aXRoaW4gdGhlIGZjLWhpZ2hsaWdodC1za2VsZXRvbiAqL1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgLyogc2NvcGVzIHRoZSBsZWZ0L3JpZ2h0IG9mIHRoZSBmYy1oaWdobGlnaHQgdG8gYmUgaW4gdGhlIGNvbHVtbiAqLyB9XFxuXFxuLmZjLXRpbWUtZ3JpZCAuZmMtaGlnaGxpZ2h0IHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGxlZnQ6IDA7XFxuICByaWdodDogMDtcXG4gIC8qIHRvcCBhbmQgYm90dG9tIHdpbGwgYmUgaW4gYnkgSlMgKi8gfVxcblxcbi8qIFRpbWVHcmlkIEV2ZW50IENvbnRhaW5tZW50XFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcbi5mYy1sdHIgLmZjLXRpbWUtZ3JpZCAuZmMtZXZlbnQtY29udGFpbmVyIHtcXG4gIC8qIHNwYWNlIG9uIHRoZSBzaWRlcyBvZiBldmVudHMgZm9yIExUUiAoZGVmYXVsdCkgKi9cXG4gIG1hcmdpbjogMCAyLjUlIDAgMnB4OyB9XFxuXFxuLmZjLXJ0bCAuZmMtdGltZS1ncmlkIC5mYy1ldmVudC1jb250YWluZXIge1xcbiAgLyogc3BhY2Ugb24gdGhlIHNpZGVzIG9mIGV2ZW50cyBmb3IgUlRMICovXFxuICBtYXJnaW46IDAgMnB4IDAgMi41JTsgfVxcblxcbi5mYy10aW1lLWdyaWQgLmZjLWV2ZW50LFxcbi5mYy10aW1lLWdyaWQgLmZjLWJnZXZlbnQge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgei1pbmRleDogMTtcXG4gIC8qIHNjb3BlIGlubmVyIHotaW5kZXgncyAqLyB9XFxuXFxuLmZjLXRpbWUtZ3JpZCAuZmMtYmdldmVudCB7XFxuICAvKiBiYWNrZ3JvdW5kIGV2ZW50cyBhbHdheXMgc3BhbiBmdWxsIHdpZHRoICovXFxuICBsZWZ0OiAwO1xcbiAgcmlnaHQ6IDA7IH1cXG5cXG4vKiBHZW5lcmljIFZlcnRpY2FsIEV2ZW50XFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcbi5mYy12LWV2ZW50LmZjLW5vdC1zdGFydCB7XFxuICAvKiBldmVudHMgdGhhdCBhcmUgY29udGludWluZyBmcm9tIGFub3RoZXIgZGF5ICovXFxuICAvKiByZXBsYWNlIHNwYWNlIG1hZGUgYnkgdGhlIHRvcCBib3JkZXIgd2l0aCBwYWRkaW5nICovXFxuICBib3JkZXItdG9wLXdpZHRoOiAwO1xcbiAgcGFkZGluZy10b3A6IDFweDtcXG4gIC8qIHJlbW92ZSB0b3Agcm91bmRlZCBjb3JuZXJzICovXFxuICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAwO1xcbiAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDA7IH1cXG5cXG4uZmMtdi1ldmVudC5mYy1ub3QtZW5kIHtcXG4gIC8qIHJlcGxhY2Ugc3BhY2UgbWFkZSBieSB0aGUgdG9wIGJvcmRlciB3aXRoIHBhZGRpbmcgKi9cXG4gIGJvcmRlci1ib3R0b20td2lkdGg6IDA7XFxuICBwYWRkaW5nLWJvdHRvbTogMXB4O1xcbiAgLyogcmVtb3ZlIGJvdHRvbSByb3VuZGVkIGNvcm5lcnMgKi9cXG4gIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDA7XFxuICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogMDsgfVxcblxcbi8qIFRpbWVHcmlkIEV2ZW50IFN0eWxpbmdcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuV2UgdXNlIHRoZSBmdWxsIFxcXCJmYy10aW1lLWdyaWQtZXZlbnRcXFwiIGNsYXNzIGluc3RlYWQgb2YgdXNpbmcgZGVzY2VuZGFudHMgYmVjYXVzZSB0aGUgZXZlbnQgd29uJ3RcXG5iZSBhIGRlc2NlbmRhbnQgb2YgdGhlIGdyaWQgd2hlbiBpdCBpcyBiZWluZyBkcmFnZ2VkLlxcbiovXFxuLmZjLXRpbWUtZ3JpZC1ldmVudCB7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgLyogZG9uJ3QgbGV0IHRoZSBiZyBmbG93IG92ZXIgcm91bmRlZCBjb3JuZXJzICovIH1cXG5cXG4uZmMtdGltZS1ncmlkLWV2ZW50LmZjLXNlbGVjdGVkIHtcXG4gIC8qIG5lZWQgdG8gYWxsb3cgdG91Y2ggcmVzaXplcnMgdG8gZXh0ZW5kIG91dHNpZGUgZXZlbnQncyBib3VuZGluZyBib3ggKi9cXG4gIC8qIGNvbW1vbiBmYy1zZWxlY3RlZCBzdHlsZXMgaGlkZSB0aGUgZmMtYmcsIHNvIGRvbid0IG5lZWQgdGhpcyBhbnl3YXkgKi9cXG4gIG92ZXJmbG93OiB2aXNpYmxlOyB9XFxuXFxuLmZjLXRpbWUtZ3JpZC1ldmVudC5mYy1zZWxlY3RlZCAuZmMtYmcge1xcbiAgZGlzcGxheTogbm9uZTtcXG4gIC8qIGhpZGUgc2VtaS13aGl0ZSBiYWNrZ3JvdW5kLCB0byBhcHBlYXIgZGFya2VyICovIH1cXG5cXG4uZmMtdGltZS1ncmlkLWV2ZW50IC5mYy1jb250ZW50IHtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICAvKiBmb3Igd2hlbiAuZmMtc2VsZWN0ZWQgKi8gfVxcblxcbi5mYy10aW1lLWdyaWQtZXZlbnQgLmZjLXRpbWUsXFxuLmZjLXRpbWUtZ3JpZC1ldmVudCAuZmMtdGl0bGUge1xcbiAgcGFkZGluZzogMCAxcHg7IH1cXG5cXG4uZmMtdGltZS1ncmlkLWV2ZW50IC5mYy10aW1lIHtcXG4gIGZvbnQtc2l6ZTogLjg1ZW07XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwOyB9XFxuXFxuLyogc2hvcnQgbW9kZSwgd2hlcmUgdGltZSBhbmQgdGl0bGUgYXJlIG9uIHRoZSBzYW1lIGxpbmUgKi9cXG4uZmMtdGltZS1ncmlkLWV2ZW50LmZjLXNob3J0IC5mYy1jb250ZW50IHtcXG4gIC8qIGRvbid0IHdyYXAgdG8gc2Vjb25kIGxpbmUgKG5vdyB0aGF0IGNvbnRlbnRzIHdpbGwgYmUgaW5saW5lKSAqL1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDsgfVxcblxcbi5mYy10aW1lLWdyaWQtZXZlbnQuZmMtc2hvcnQgLmZjLXRpbWUsXFxuLmZjLXRpbWUtZ3JpZC1ldmVudC5mYy1zaG9ydCAuZmMtdGl0bGUge1xcbiAgLyogcHV0IHRoZSB0aW1lIGFuZCB0aXRsZSBvbiB0aGUgc2FtZSBsaW5lICovXFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICB2ZXJ0aWNhbC1hbGlnbjogdG9wOyB9XFxuXFxuLmZjLXRpbWUtZ3JpZC1ldmVudC5mYy1zaG9ydCAuZmMtdGltZSBzcGFuIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxuICAvKiBkb24ndCBkaXNwbGF5IHRoZSBmdWxsIHRpbWUgdGV4dC4uLiAqLyB9XFxuXFxuLmZjLXRpbWUtZ3JpZC1ldmVudC5mYy1zaG9ydCAuZmMtdGltZTpiZWZvcmUge1xcbiAgY29udGVudDogYXR0cihkYXRhLXN0YXJ0KTtcXG4gIC8qIC4uLmluc3RlYWQsIGRpc3BsYXkgb25seSB0aGUgc3RhcnQgdGltZSAqLyB9XFxuXFxuLmZjLXRpbWUtZ3JpZC1ldmVudC5mYy1zaG9ydCAuZmMtdGltZTphZnRlciB7XFxuICBjb250ZW50OiBcXFwiXFxcXDAwMEEwLVxcXFwwMDBBMFxcXCI7XFxuICAvKiBzZXBlcmF0ZSB3aXRoIGEgZGFzaCwgd3JhcHBlZCBpbiBuYnNwJ3MgKi8gfVxcblxcbi5mYy10aW1lLWdyaWQtZXZlbnQuZmMtc2hvcnQgLmZjLXRpdGxlIHtcXG4gIGZvbnQtc2l6ZTogLjg1ZW07XFxuICAvKiBtYWtlIHRoZSB0aXRsZSB0ZXh0IHRoZSBzYW1lIHNpemUgYXMgdGhlIHRpbWUgKi9cXG4gIHBhZGRpbmc6IDA7XFxuICAvKiB1bmRvIHBhZGRpbmcgZnJvbSBhYm92ZSAqLyB9XFxuXFxuLyogcmVzaXplciAoY3Vyc29yIGRldmljZSkgKi9cXG4uZmMtdGltZS1ncmlkLWV2ZW50LmZjLWFsbG93LW1vdXNlLXJlc2l6ZSAuZmMtcmVzaXplciB7XFxuICBsZWZ0OiAwO1xcbiAgcmlnaHQ6IDA7XFxuICBib3R0b206IDA7XFxuICBoZWlnaHQ6IDhweDtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICBsaW5lLWhlaWdodDogOHB4O1xcbiAgZm9udC1zaXplOiAxMXB4O1xcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGN1cnNvcjogcy1yZXNpemU7IH1cXG5cXG4uZmMtdGltZS1ncmlkLWV2ZW50LmZjLWFsbG93LW1vdXNlLXJlc2l6ZSAuZmMtcmVzaXplcjphZnRlciB7XFxuICBjb250ZW50OiBcXFwiPVxcXCI7IH1cXG5cXG4vKiByZXNpemVyICh0b3VjaCBkZXZpY2UpICovXFxuLmZjLXRpbWUtZ3JpZC1ldmVudC5mYy1zZWxlY3RlZCAuZmMtcmVzaXplciB7XFxuICAvKiAxMHgxMCBkb3QgKi9cXG4gIGJvcmRlci1yYWRpdXM6IDVweDtcXG4gIGJvcmRlci13aWR0aDogMXB4O1xcbiAgd2lkdGg6IDhweDtcXG4gIGhlaWdodDogOHB4O1xcbiAgYm9yZGVyLXN0eWxlOiBzb2xpZDtcXG4gIGJvcmRlci1jb2xvcjogaW5oZXJpdDtcXG4gIGJhY2tncm91bmQ6ICNmZmY7XFxuICAvKiBob3Jpem9udGFsbHkgY2VudGVyICovXFxuICBsZWZ0OiA1MCU7XFxuICBtYXJnaW4tbGVmdDogLTVweDtcXG4gIC8qIGNlbnRlciBvbiB0aGUgYm90dG9tIGVkZ2UgKi9cXG4gIGJvdHRvbTogLTVweDsgfVxcblxcbi8qIE5vdyBJbmRpY2F0b3JcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuLmZjLXRpbWUtZ3JpZCAuZmMtbm93LWluZGljYXRvci1saW5lIHtcXG4gIGJvcmRlci10b3Atd2lkdGg6IDFweDtcXG4gIGxlZnQ6IDA7XFxuICByaWdodDogMDsgfVxcblxcbi8qIGFycm93IG9uIGF4aXMgKi9cXG4uZmMtdGltZS1ncmlkIC5mYy1ub3ctaW5kaWNhdG9yLWFycm93IHtcXG4gIG1hcmdpbi10b3A6IC01cHg7XFxuICAvKiB2ZXJ0aWNhbGx5IGNlbnRlciBvbiB0b3AgY29vcmRpbmF0ZSAqLyB9XFxuXFxuLmZjLWx0ciAuZmMtdGltZS1ncmlkIC5mYy1ub3ctaW5kaWNhdG9yLWFycm93IHtcXG4gIGxlZnQ6IDA7XFxuICAvKiB0cmlhbmdsZSBwb2ludGluZyByaWdodC4uLiAqL1xcbiAgYm9yZGVyLXdpZHRoOiA1cHggMCA1cHggNnB4O1xcbiAgYm9yZGVyLXRvcC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICBib3JkZXItYm90dG9tLWNvbG9yOiB0cmFuc3BhcmVudDsgfVxcblxcbi5mYy1ydGwgLmZjLXRpbWUtZ3JpZCAuZmMtbm93LWluZGljYXRvci1hcnJvdyB7XFxuICByaWdodDogMDtcXG4gIC8qIHRyaWFuZ2xlIHBvaW50aW5nIGxlZnQuLi4gKi9cXG4gIGJvcmRlci13aWR0aDogNXB4IDZweCA1cHggMDtcXG4gIGJvcmRlci10b3AtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgYm9yZGVyLWJvdHRvbS1jb2xvcjogdHJhbnNwYXJlbnQ7IH1cXG5cXG4vKiBMaXN0IFZpZXdcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuLyogcG9zc2libHkgcmV1c2FibGUgKi9cXG4uZmMtZXZlbnQtZG90IHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIHdpZHRoOiAxMHB4O1xcbiAgaGVpZ2h0OiAxMHB4O1xcbiAgYm9yZGVyLXJhZGl1czogNXB4OyB9XFxuXFxuLyogdmlldyB3cmFwcGVyICovXFxuLmZjLXJ0bCAuZmMtbGlzdC12aWV3IHtcXG4gIGRpcmVjdGlvbjogcnRsO1xcbiAgLyogdW5saWtlIGNvcmUgdmlld3MsIGxldmVyYWdlIGJyb3dzZXIgUlRMICovIH1cXG5cXG4uZmMtbGlzdC12aWV3IHtcXG4gIGJvcmRlci13aWR0aDogMXB4O1xcbiAgYm9yZGVyLXN0eWxlOiBzb2xpZDsgfVxcblxcbi8qIHRhYmxlIHJlc2V0cyAqL1xcbi5mYyAuZmMtbGlzdC10YWJsZSB7XFxuICB0YWJsZS1sYXlvdXQ6IGF1dG87XFxuICAvKiBmb3Igc2hyaW5rd3JhcHBpbmcgY2VsbCBjb250ZW50ICovIH1cXG5cXG4uZmMtbGlzdC10YWJsZSB0ZCB7XFxuICBib3JkZXItd2lkdGg6IDFweCAwIDA7XFxuICBwYWRkaW5nOiA4cHggMTRweDsgfVxcblxcbi5mYy1saXN0LXRhYmxlIHRyOmZpcnN0LWNoaWxkIHRkIHtcXG4gIGJvcmRlci10b3Atd2lkdGg6IDA7IH1cXG5cXG4vKiBkYXkgaGVhZGluZ3Mgd2l0aCB0aGUgbGlzdCAqL1xcbi5mYy1saXN0LWhlYWRpbmcge1xcbiAgYm9yZGVyLWJvdHRvbS13aWR0aDogMXB4OyB9XFxuXFxuLmZjLWxpc3QtaGVhZGluZyB0ZCB7XFxuICBmb250LXdlaWdodDogYm9sZDsgfVxcblxcbi5mYy1sdHIgLmZjLWxpc3QtaGVhZGluZy1tYWluIHtcXG4gIGZsb2F0OiBsZWZ0OyB9XFxuXFxuLmZjLWx0ciAuZmMtbGlzdC1oZWFkaW5nLWFsdCB7XFxuICBmbG9hdDogcmlnaHQ7IH1cXG5cXG4uZmMtcnRsIC5mYy1saXN0LWhlYWRpbmctbWFpbiB7XFxuICBmbG9hdDogcmlnaHQ7IH1cXG5cXG4uZmMtcnRsIC5mYy1saXN0LWhlYWRpbmctYWx0IHtcXG4gIGZsb2F0OiBsZWZ0OyB9XFxuXFxuLyogZXZlbnQgbGlzdCBpdGVtcyAqL1xcbi5mYy1saXN0LWl0ZW0uZmMtaGFzLXVybCB7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICAvKiB3aG9sZSByb3cgd2lsbCBiZSBjbGlja2FibGUgKi8gfVxcblxcbi5mYy1saXN0LWl0ZW06aG92ZXIgdGQge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2Y1ZjVmNTsgfVxcblxcbi5mYy1saXN0LWl0ZW0tbWFya2VyLFxcbi5mYy1saXN0LWl0ZW0tdGltZSB7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbiAgd2lkdGg6IDFweDsgfVxcblxcbi8qIG1ha2UgdGhlIGRvdCBjbG9zZXIgdG8gdGhlIGV2ZW50IHRpdGxlICovXFxuLmZjLWx0ciAuZmMtbGlzdC1pdGVtLW1hcmtlciB7XFxuICBwYWRkaW5nLXJpZ2h0OiAwOyB9XFxuXFxuLmZjLXJ0bCAuZmMtbGlzdC1pdGVtLW1hcmtlciB7XFxuICBwYWRkaW5nLWxlZnQ6IDA7IH1cXG5cXG4uZmMtbGlzdC1pdGVtLXRpdGxlIGEge1xcbiAgLyogZXZlcnkgZXZlbnQgdGl0bGUgY2VsbCBoYXMgYW4gPGE+IHRhZyAqL1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgY29sb3I6IGluaGVyaXQ7IH1cXG5cXG4uZmMtbGlzdC1pdGVtLXRpdGxlIGFbaHJlZl06aG92ZXIge1xcbiAgLyogaG92ZXIgZWZmZWN0IG9ubHkgb24gdGl0bGVzIHdpdGggaHJlZnMgKi9cXG4gIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lOyB9XFxuXFxuLyogbWVzc2FnZSB3aGVuIG5vIGV2ZW50cyAqL1xcbi5mYy1saXN0LWVtcHR5LXdyYXAyIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMDtcXG4gIGxlZnQ6IDA7XFxuICByaWdodDogMDtcXG4gIGJvdHRvbTogMDsgfVxcblxcbi5mYy1saXN0LWVtcHR5LXdyYXAxIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgZGlzcGxheTogdGFibGU7IH1cXG5cXG4uZmMtbGlzdC1lbXB0eSB7XFxuICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjsgfVxcblxcbi5mYy11bnRoZW1lZCAuZmMtbGlzdC1lbXB0eSB7XFxuICAvKiB0aGVtZSB3aWxsIHByb3ZpZGUgb3duIGJhY2tncm91bmQgKi9cXG4gIGJhY2tncm91bmQtY29sb3I6ICNlZWU7IH1cXG5cXG4vKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyogRnVsbCBDYWxlbmRhciBPdmVycmlkZSAqL1xcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4uZmMtZ3JpZCB0aCB7XFxuICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlOyB9XFxuXFxuLmZjLWV2ZW50IHtcXG4gIHBhZGRpbmc6IDJweCAzcHg7XFxuICBib3JkZXI6IG5vbmU7XFxuICBmb250LXdlaWdodDogNDAwO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2RkZDtcXG4gIGNvbG9yOiAjNTU1NTU1OyB9XFxuXFxuLmZjLXRvZGF5IHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmYxYjg7IH1cXG5cXG5hLmZjLWV2ZW50IHtcXG4gIGhlaWdodDogYXV0bztcXG4gIGxpbmUtaGVpZ2h0OiAxLjU7IH1cXG5cXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyoqICAgICAgRnVsbCBDYWxlbmRhciBDdXN0b20gICAgICoqL1xcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4uZnVsbC1jYWxlbmRhciB7XFxuICBtYXJnaW4tdG9wOiAxMHB4OyB9XFxuXFxuLmNhbGVuZGFyLWNvbnRyb2xzIC5idG4ge1xcbiAgZm9udC1zaXplOiAxM3B4OyB9XFxuXFxuLmNhbGVuZGFyLWV4dGVybmFsLWV2ZW50cyB7XFxuICBtYXJnaW4tdG9wOiAyMHB4OyB9XFxuICAuY2FsZW5kYXItZXh0ZXJuYWwtZXZlbnRzIC5leHRlcm5hbC1ldmVudCB7XFxuICAgIG1hcmdpbjogMTBweCAwO1xcbiAgICBwYWRkaW5nOiA2cHg7XFxuICAgIGZvbnQtc2l6ZTogMTNweDtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICBib3JkZXItcmFkaXVzOiAwLjI1cmVtO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjYmJiOyB9XFxuXFxuQG1lZGlhIChtaW4td2lkdGg6IDEyMDBweCkge1xcbiAgLndpZGdldC1jYWxlbmRhciB7XFxuICAgIG1hcmdpbi10b3A6IC0xMDBweDsgfSB9XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvZXh0cmEvY2FsZW5kYXIvY2FsZW5kYXIuc3R5bGUuc2Nzc1xuLy8gbW9kdWxlIGlkID0gMTEyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDUiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 1123:
/* unknown exports provided */
/* all exports used */
/*!**************************************************!*\
  !*** ./src/app/extra/gallery/gallery.style.scss ***!
  \**************************************************/
/***/ (function(module, exports) {

eval("module.exports = \"/* Magnific Popup CSS */\\n.mfp-bg {\\n  top: 0;\\n  left: 0;\\n  width: 100%;\\n  height: 100%;\\n  z-index: 1042;\\n  overflow: hidden;\\n  position: fixed;\\n  background: #0b0b0b;\\n  opacity: 0.8; }\\n\\n.mfp-wrap {\\n  top: 0;\\n  left: 0;\\n  width: 100%;\\n  height: 100%;\\n  z-index: 1043;\\n  position: fixed;\\n  outline: none !important;\\n  -webkit-backface-visibility: hidden; }\\n\\n.mfp-container {\\n  text-align: center;\\n  position: absolute;\\n  width: 100%;\\n  height: 100%;\\n  left: 0;\\n  top: 0;\\n  padding: 0 8px;\\n  box-sizing: border-box; }\\n\\n.mfp-container:before {\\n  content: '';\\n  display: inline-block;\\n  height: 100%;\\n  vertical-align: middle; }\\n\\n.mfp-align-top .mfp-container:before {\\n  display: none; }\\n\\n.mfp-content {\\n  position: relative;\\n  display: inline-block;\\n  vertical-align: middle;\\n  margin: 0 auto;\\n  text-align: left;\\n  z-index: 1045; }\\n\\n.mfp-inline-holder .mfp-content,\\n.mfp-ajax-holder .mfp-content {\\n  width: 100%;\\n  cursor: auto; }\\n\\n.mfp-ajax-cur {\\n  cursor: progress; }\\n\\n.mfp-zoom-out-cur, .mfp-zoom-out-cur .mfp-image-holder .mfp-close {\\n  cursor: -moz-zoom-out;\\n  cursor: -webkit-zoom-out;\\n  cursor: zoom-out; }\\n\\n.mfp-zoom {\\n  cursor: pointer;\\n  cursor: -webkit-zoom-in;\\n  cursor: -moz-zoom-in;\\n  cursor: zoom-in; }\\n\\n.mfp-auto-cursor .mfp-content {\\n  cursor: auto; }\\n\\n.mfp-close,\\n.mfp-arrow,\\n.mfp-preloader,\\n.mfp-counter {\\n  -webkit-user-select: none;\\n  -moz-user-select: none;\\n  user-select: none; }\\n\\n.mfp-loading.mfp-figure {\\n  display: none; }\\n\\n.mfp-hide {\\n  display: none !important; }\\n\\n.mfp-preloader {\\n  color: #CCC;\\n  position: absolute;\\n  top: 50%;\\n  width: auto;\\n  text-align: center;\\n  margin-top: -0.8em;\\n  left: 8px;\\n  right: 8px;\\n  z-index: 1044; }\\n\\n.mfp-preloader a {\\n  color: #CCC; }\\n\\n.mfp-preloader a:hover {\\n  color: #FFF; }\\n\\n.mfp-s-ready .mfp-preloader {\\n  display: none; }\\n\\n.mfp-s-error .mfp-content {\\n  display: none; }\\n\\nbutton.mfp-close,\\nbutton.mfp-arrow {\\n  overflow: visible;\\n  cursor: pointer;\\n  background: transparent;\\n  border: 0;\\n  -webkit-appearance: none;\\n  display: block;\\n  outline: none;\\n  padding: 0;\\n  z-index: 1046;\\n  box-shadow: none;\\n  touch-action: manipulation; }\\n\\nbutton::-moz-focus-inner {\\n  padding: 0;\\n  border: 0; }\\n\\n.mfp-close {\\n  width: 44px;\\n  height: 44px;\\n  line-height: 44px;\\n  position: absolute;\\n  right: 0;\\n  top: 0;\\n  text-decoration: none;\\n  text-align: center;\\n  opacity: 0.65;\\n  padding: 0 0 18px 10px;\\n  color: #FFF;\\n  font-style: normal;\\n  font-size: 28px;\\n  font-family: Arial, Baskerville, monospace; }\\n\\n.mfp-close:hover,\\n.mfp-close:focus {\\n  opacity: 1; }\\n\\n.mfp-close:active {\\n  top: 1px; }\\n\\n.mfp-close-btn-in .mfp-close {\\n  color: #333; }\\n\\n.mfp-image-holder .mfp-close,\\n.mfp-iframe-holder .mfp-close {\\n  color: #FFF;\\n  right: -6px;\\n  text-align: right;\\n  padding-right: 6px;\\n  width: 100%; }\\n\\n.mfp-counter {\\n  position: absolute;\\n  top: 0;\\n  right: 0;\\n  color: #CCC;\\n  font-size: 12px;\\n  line-height: 18px;\\n  white-space: nowrap; }\\n\\n.mfp-arrow {\\n  position: absolute;\\n  opacity: 0.65;\\n  margin: 0;\\n  top: 50%;\\n  margin-top: -55px;\\n  padding: 0;\\n  width: 90px;\\n  height: 110px;\\n  -webkit-tap-highlight-color: transparent; }\\n\\n.mfp-arrow:active {\\n  margin-top: -54px; }\\n\\n.mfp-arrow:hover,\\n.mfp-arrow:focus {\\n  opacity: 1; }\\n\\n.mfp-arrow:before,\\n.mfp-arrow:after {\\n  content: '';\\n  display: block;\\n  width: 0;\\n  height: 0;\\n  position: absolute;\\n  left: 0;\\n  top: 0;\\n  margin-top: 35px;\\n  margin-left: 35px;\\n  border: medium inset transparent; }\\n\\n.mfp-arrow:after {\\n  border-top-width: 13px;\\n  border-bottom-width: 13px;\\n  top: 8px; }\\n\\n.mfp-arrow:before {\\n  border-top-width: 21px;\\n  border-bottom-width: 21px;\\n  opacity: 0.7; }\\n\\n.mfp-arrow-left {\\n  left: 0; }\\n\\n.mfp-arrow-left:after {\\n  border-right: 17px solid #FFF;\\n  margin-left: 31px; }\\n\\n.mfp-arrow-left:before {\\n  margin-left: 25px;\\n  border-right: 27px solid #3F3F3F; }\\n\\n.mfp-arrow-right {\\n  right: 0; }\\n\\n.mfp-arrow-right:after {\\n  border-left: 17px solid #FFF;\\n  margin-left: 39px; }\\n\\n.mfp-arrow-right:before {\\n  border-left: 27px solid #3F3F3F; }\\n\\n.mfp-iframe-holder {\\n  padding-top: 40px;\\n  padding-bottom: 40px; }\\n\\n.mfp-iframe-holder .mfp-content {\\n  line-height: 0;\\n  width: 100%;\\n  max-width: 900px; }\\n\\n.mfp-iframe-holder .mfp-close {\\n  top: -40px; }\\n\\n.mfp-iframe-scaler {\\n  width: 100%;\\n  height: 0;\\n  overflow: hidden;\\n  padding-top: 56.25%; }\\n\\n.mfp-iframe-scaler iframe {\\n  position: absolute;\\n  display: block;\\n  top: 0;\\n  left: 0;\\n  width: 100%;\\n  height: 100%;\\n  box-shadow: 0 0 8px rgba(0, 0, 0, 0.6);\\n  background: #000; }\\n\\n/* Main image in popup */\\nimg.mfp-img {\\n  width: auto;\\n  max-width: 100%;\\n  height: auto;\\n  display: block;\\n  line-height: 0;\\n  box-sizing: border-box;\\n  padding: 40px 0 40px;\\n  margin: 0 auto; }\\n\\n/* The shadow behind the image */\\n.mfp-figure {\\n  line-height: 0; }\\n\\n.mfp-figure:after {\\n  content: '';\\n  position: absolute;\\n  left: 0;\\n  top: 40px;\\n  bottom: 40px;\\n  display: block;\\n  right: 0;\\n  width: auto;\\n  height: auto;\\n  z-index: -1;\\n  box-shadow: 0 0 8px rgba(0, 0, 0, 0.6);\\n  background: #444; }\\n\\n.mfp-figure small {\\n  color: #BDBDBD;\\n  display: block;\\n  font-size: 12px;\\n  line-height: 14px; }\\n\\n.mfp-figure figure {\\n  margin: 0; }\\n\\n.mfp-bottom-bar {\\n  margin-top: -36px;\\n  position: absolute;\\n  top: 100%;\\n  left: 0;\\n  width: 100%;\\n  cursor: auto; }\\n\\n.mfp-title {\\n  text-align: left;\\n  line-height: 18px;\\n  color: #F3F3F3;\\n  word-wrap: break-word;\\n  padding-right: 36px; }\\n\\n.mfp-image-holder .mfp-content {\\n  max-width: 100%; }\\n\\n.mfp-gallery .mfp-image-holder .mfp-figure {\\n  cursor: pointer; }\\n\\n@media screen and (max-width: 800px) and (orientation: landscape), screen and (max-height: 300px) {\\n  /**\\n       * Remove all paddings around the image on small screen\\n       */\\n  .mfp-img-mobile .mfp-image-holder {\\n    padding-left: 0;\\n    padding-right: 0; }\\n  .mfp-img-mobile img.mfp-img {\\n    padding: 0; }\\n  .mfp-img-mobile .mfp-figure:after {\\n    top: 0;\\n    bottom: 0; }\\n  .mfp-img-mobile .mfp-figure small {\\n    display: inline;\\n    margin-left: 5px; }\\n  .mfp-img-mobile .mfp-bottom-bar {\\n    background: rgba(0, 0, 0, 0.6);\\n    bottom: 0;\\n    margin: 0;\\n    top: auto;\\n    padding: 3px 5px;\\n    position: fixed;\\n    box-sizing: border-box; }\\n  .mfp-img-mobile .mfp-bottom-bar:empty {\\n    padding: 0; }\\n  .mfp-img-mobile .mfp-counter {\\n    right: 5px;\\n    top: 3px; }\\n  .mfp-img-mobile .mfp-close {\\n    top: 0;\\n    right: 0;\\n    width: 35px;\\n    height: 35px;\\n    line-height: 35px;\\n    background: rgba(0, 0, 0, 0.6);\\n    position: fixed;\\n    text-align: center;\\n    padding: 0; } }\\n\\n@media all and (max-width: 900px) {\\n  .mfp-arrow {\\n    -webkit-transform: scale(0.75);\\n    transform: scale(0.75); }\\n  .mfp-arrow-left {\\n    -webkit-transform-origin: 0;\\n    transform-origin: 0; }\\n  .mfp-arrow-right {\\n    -webkit-transform-origin: 100%;\\n    transform-origin: 100%; }\\n  .mfp-container {\\n    padding-left: 6px;\\n    padding-right: 6px; } }\\n\\n.bs3-row {\\n  margin-left: -15px;\\n  margin-right: -15px; }\\n  .bs3-row::after {\\n    content: \\\"\\\";\\n    display: table;\\n    clear: both; }\\n\\n.bs3-col-xs-1, .bs3-col-xs-2, .bs3-col-xs-3, .bs3-col-xs-4, .bs3-col-xs-5, .bs3-col-xs-6, .bs3-col-xs-7, .bs3-col-xs-8, .bs3-col-xs-9, .bs3-col-xs-10, .bs3-col-xs-11, .bs3-col-xs-12, .bs3-col-sm-1, .bs3-col-sm-2, .bs3-col-sm-3, .bs3-col-sm-4, .bs3-col-sm-5, .bs3-col-sm-6, .bs3-col-sm-7, .bs3-col-sm-8, .bs3-col-sm-9, .bs3-col-sm-10, .bs3-col-sm-11, .bs3-col-sm-12, .bs3-col-md-1, .bs3-col-md-2, .bs3-col-md-3, .bs3-col-md-4, .bs3-col-md-5, .bs3-col-md-6, .bs3-col-md-7, .bs3-col-md-8, .bs3-col-md-9, .bs3-col-md-10, .bs3-col-md-11, .bs3-col-md-12, .bs3-col-lg-1, .bs3-col-lg-2, .bs3-col-lg-3, .bs3-col-lg-4, .bs3-col-lg-5, .bs3-col-lg-6, .bs3-col-lg-7, .bs3-col-lg-8, .bs3-col-lg-9, .bs3-col-lg-10, .bs3-col-lg-11, .bs3-col-lg-12, .bs3-col-xl-1, .bs3-col-xl-2, .bs3-col-xl-3, .bs3-col-xl-4, .bs3-col-xl-5, .bs3-col-xl-6, .bs3-col-xl-7, .bs3-col-xl-8, .bs3-col-xl-9, .bs3-col-xl-10, .bs3-col-xl-11, .bs3-col-xl-12 {\\n  position: relative;\\n  min-height: 1px;\\n  padding-left: 15px;\\n  padding-right: 15px; }\\n\\n.bs3-col-xs-1, .bs3-col-xs-2, .bs3-col-xs-3, .bs3-col-xs-4, .bs3-col-xs-5, .bs3-col-xs-6, .bs3-col-xs-7, .bs3-col-xs-8, .bs3-col-xs-9, .bs3-col-xs-10, .bs3-col-xs-11, .bs3-col-xs-12 {\\n  float: left; }\\n\\n.bs3-col-xs-1 {\\n  width: 8.33333%; }\\n\\n.bs3-col-xs-2 {\\n  width: 16.66667%; }\\n\\n.bs3-col-xs-3 {\\n  width: 25%; }\\n\\n.bs3-col-xs-4 {\\n  width: 33.33333%; }\\n\\n.bs3-col-xs-5 {\\n  width: 41.66667%; }\\n\\n.bs3-col-xs-6 {\\n  width: 50%; }\\n\\n.bs3-col-xs-7 {\\n  width: 58.33333%; }\\n\\n.bs3-col-xs-8 {\\n  width: 66.66667%; }\\n\\n.bs3-col-xs-9 {\\n  width: 75%; }\\n\\n.bs3-col-xs-10 {\\n  width: 83.33333%; }\\n\\n.bs3-col-xs-11 {\\n  width: 91.66667%; }\\n\\n.bs3-col-xs-12 {\\n  width: 100%; }\\n\\n.bs3-col-xs-pull-0 {\\n  right: auto; }\\n\\n.bs3-col-xs-pull-1 {\\n  right: 8.33333%; }\\n\\n.bs3-col-xs-pull-2 {\\n  right: 16.66667%; }\\n\\n.bs3-col-xs-pull-3 {\\n  right: 25%; }\\n\\n.bs3-col-xs-pull-4 {\\n  right: 33.33333%; }\\n\\n.bs3-col-xs-pull-5 {\\n  right: 41.66667%; }\\n\\n.bs3-col-xs-pull-6 {\\n  right: 50%; }\\n\\n.bs3-col-xs-pull-7 {\\n  right: 58.33333%; }\\n\\n.bs3-col-xs-pull-8 {\\n  right: 66.66667%; }\\n\\n.bs3-col-xs-pull-9 {\\n  right: 75%; }\\n\\n.bs3-col-xs-pull-10 {\\n  right: 83.33333%; }\\n\\n.bs3-col-xs-pull-11 {\\n  right: 91.66667%; }\\n\\n.bs3-col-xs-pull-12 {\\n  right: 100%; }\\n\\n.bs3-col-xs-push-0 {\\n  left: auto; }\\n\\n.bs3-col-xs-push-1 {\\n  left: 8.33333%; }\\n\\n.bs3-col-xs-push-2 {\\n  left: 16.66667%; }\\n\\n.bs3-col-xs-push-3 {\\n  left: 25%; }\\n\\n.bs3-col-xs-push-4 {\\n  left: 33.33333%; }\\n\\n.bs3-col-xs-push-5 {\\n  left: 41.66667%; }\\n\\n.bs3-col-xs-push-6 {\\n  left: 50%; }\\n\\n.bs3-col-xs-push-7 {\\n  left: 58.33333%; }\\n\\n.bs3-col-xs-push-8 {\\n  left: 66.66667%; }\\n\\n.bs3-col-xs-push-9 {\\n  left: 75%; }\\n\\n.bs3-col-xs-push-10 {\\n  left: 83.33333%; }\\n\\n.bs3-col-xs-push-11 {\\n  left: 91.66667%; }\\n\\n.bs3-col-xs-push-12 {\\n  left: 100%; }\\n\\n.bs3-col-xs-offset-0 {\\n  margin-left: 0%; }\\n\\n.bs3-col-xs-offset-1 {\\n  margin-left: 8.33333%; }\\n\\n.bs3-col-xs-offset-2 {\\n  margin-left: 16.66667%; }\\n\\n.bs3-col-xs-offset-3 {\\n  margin-left: 25%; }\\n\\n.bs3-col-xs-offset-4 {\\n  margin-left: 33.33333%; }\\n\\n.bs3-col-xs-offset-5 {\\n  margin-left: 41.66667%; }\\n\\n.bs3-col-xs-offset-6 {\\n  margin-left: 50%; }\\n\\n.bs3-col-xs-offset-7 {\\n  margin-left: 58.33333%; }\\n\\n.bs3-col-xs-offset-8 {\\n  margin-left: 66.66667%; }\\n\\n.bs3-col-xs-offset-9 {\\n  margin-left: 75%; }\\n\\n.bs3-col-xs-offset-10 {\\n  margin-left: 83.33333%; }\\n\\n.bs3-col-xs-offset-11 {\\n  margin-left: 91.66667%; }\\n\\n.bs3-col-xs-offset-12 {\\n  margin-left: 100%; }\\n\\n@media (min-width: 576px) {\\n  .bs3-col-sm-1, .bs3-col-sm-2, .bs3-col-sm-3, .bs3-col-sm-4, .bs3-col-sm-5, .bs3-col-sm-6, .bs3-col-sm-7, .bs3-col-sm-8, .bs3-col-sm-9, .bs3-col-sm-10, .bs3-col-sm-11, .bs3-col-sm-12 {\\n    float: left; }\\n  .bs3-col-sm-1 {\\n    width: 8.33333%; }\\n  .bs3-col-sm-2 {\\n    width: 16.66667%; }\\n  .bs3-col-sm-3 {\\n    width: 25%; }\\n  .bs3-col-sm-4 {\\n    width: 33.33333%; }\\n  .bs3-col-sm-5 {\\n    width: 41.66667%; }\\n  .bs3-col-sm-6 {\\n    width: 50%; }\\n  .bs3-col-sm-7 {\\n    width: 58.33333%; }\\n  .bs3-col-sm-8 {\\n    width: 66.66667%; }\\n  .bs3-col-sm-9 {\\n    width: 75%; }\\n  .bs3-col-sm-10 {\\n    width: 83.33333%; }\\n  .bs3-col-sm-11 {\\n    width: 91.66667%; }\\n  .bs3-col-sm-12 {\\n    width: 100%; }\\n  .bs3-col-sm-pull-0 {\\n    right: auto; }\\n  .bs3-col-sm-pull-1 {\\n    right: 8.33333%; }\\n  .bs3-col-sm-pull-2 {\\n    right: 16.66667%; }\\n  .bs3-col-sm-pull-3 {\\n    right: 25%; }\\n  .bs3-col-sm-pull-4 {\\n    right: 33.33333%; }\\n  .bs3-col-sm-pull-5 {\\n    right: 41.66667%; }\\n  .bs3-col-sm-pull-6 {\\n    right: 50%; }\\n  .bs3-col-sm-pull-7 {\\n    right: 58.33333%; }\\n  .bs3-col-sm-pull-8 {\\n    right: 66.66667%; }\\n  .bs3-col-sm-pull-9 {\\n    right: 75%; }\\n  .bs3-col-sm-pull-10 {\\n    right: 83.33333%; }\\n  .bs3-col-sm-pull-11 {\\n    right: 91.66667%; }\\n  .bs3-col-sm-pull-12 {\\n    right: 100%; }\\n  .bs3-col-sm-push-0 {\\n    left: auto; }\\n  .bs3-col-sm-push-1 {\\n    left: 8.33333%; }\\n  .bs3-col-sm-push-2 {\\n    left: 16.66667%; }\\n  .bs3-col-sm-push-3 {\\n    left: 25%; }\\n  .bs3-col-sm-push-4 {\\n    left: 33.33333%; }\\n  .bs3-col-sm-push-5 {\\n    left: 41.66667%; }\\n  .bs3-col-sm-push-6 {\\n    left: 50%; }\\n  .bs3-col-sm-push-7 {\\n    left: 58.33333%; }\\n  .bs3-col-sm-push-8 {\\n    left: 66.66667%; }\\n  .bs3-col-sm-push-9 {\\n    left: 75%; }\\n  .bs3-col-sm-push-10 {\\n    left: 83.33333%; }\\n  .bs3-col-sm-push-11 {\\n    left: 91.66667%; }\\n  .bs3-col-sm-push-12 {\\n    left: 100%; }\\n  .bs3-col-sm-offset-0 {\\n    margin-left: 0%; }\\n  .bs3-col-sm-offset-1 {\\n    margin-left: 8.33333%; }\\n  .bs3-col-sm-offset-2 {\\n    margin-left: 16.66667%; }\\n  .bs3-col-sm-offset-3 {\\n    margin-left: 25%; }\\n  .bs3-col-sm-offset-4 {\\n    margin-left: 33.33333%; }\\n  .bs3-col-sm-offset-5 {\\n    margin-left: 41.66667%; }\\n  .bs3-col-sm-offset-6 {\\n    margin-left: 50%; }\\n  .bs3-col-sm-offset-7 {\\n    margin-left: 58.33333%; }\\n  .bs3-col-sm-offset-8 {\\n    margin-left: 66.66667%; }\\n  .bs3-col-sm-offset-9 {\\n    margin-left: 75%; }\\n  .bs3-col-sm-offset-10 {\\n    margin-left: 83.33333%; }\\n  .bs3-col-sm-offset-11 {\\n    margin-left: 91.66667%; }\\n  .bs3-col-sm-offset-12 {\\n    margin-left: 100%; } }\\n\\n@media (min-width: 768px) {\\n  .bs3-col-md-1, .bs3-col-md-2, .bs3-col-md-3, .bs3-col-md-4, .bs3-col-md-5, .bs3-col-md-6, .bs3-col-md-7, .bs3-col-md-8, .bs3-col-md-9, .bs3-col-md-10, .bs3-col-md-11, .bs3-col-md-12 {\\n    float: left; }\\n  .bs3-col-md-1 {\\n    width: 8.33333%; }\\n  .bs3-col-md-2 {\\n    width: 16.66667%; }\\n  .bs3-col-md-3 {\\n    width: 25%; }\\n  .bs3-col-md-4 {\\n    width: 33.33333%; }\\n  .bs3-col-md-5 {\\n    width: 41.66667%; }\\n  .bs3-col-md-6 {\\n    width: 50%; }\\n  .bs3-col-md-7 {\\n    width: 58.33333%; }\\n  .bs3-col-md-8 {\\n    width: 66.66667%; }\\n  .bs3-col-md-9 {\\n    width: 75%; }\\n  .bs3-col-md-10 {\\n    width: 83.33333%; }\\n  .bs3-col-md-11 {\\n    width: 91.66667%; }\\n  .bs3-col-md-12 {\\n    width: 100%; }\\n  .bs3-col-md-pull-0 {\\n    right: auto; }\\n  .bs3-col-md-pull-1 {\\n    right: 8.33333%; }\\n  .bs3-col-md-pull-2 {\\n    right: 16.66667%; }\\n  .bs3-col-md-pull-3 {\\n    right: 25%; }\\n  .bs3-col-md-pull-4 {\\n    right: 33.33333%; }\\n  .bs3-col-md-pull-5 {\\n    right: 41.66667%; }\\n  .bs3-col-md-pull-6 {\\n    right: 50%; }\\n  .bs3-col-md-pull-7 {\\n    right: 58.33333%; }\\n  .bs3-col-md-pull-8 {\\n    right: 66.66667%; }\\n  .bs3-col-md-pull-9 {\\n    right: 75%; }\\n  .bs3-col-md-pull-10 {\\n    right: 83.33333%; }\\n  .bs3-col-md-pull-11 {\\n    right: 91.66667%; }\\n  .bs3-col-md-pull-12 {\\n    right: 100%; }\\n  .bs3-col-md-push-0 {\\n    left: auto; }\\n  .bs3-col-md-push-1 {\\n    left: 8.33333%; }\\n  .bs3-col-md-push-2 {\\n    left: 16.66667%; }\\n  .bs3-col-md-push-3 {\\n    left: 25%; }\\n  .bs3-col-md-push-4 {\\n    left: 33.33333%; }\\n  .bs3-col-md-push-5 {\\n    left: 41.66667%; }\\n  .bs3-col-md-push-6 {\\n    left: 50%; }\\n  .bs3-col-md-push-7 {\\n    left: 58.33333%; }\\n  .bs3-col-md-push-8 {\\n    left: 66.66667%; }\\n  .bs3-col-md-push-9 {\\n    left: 75%; }\\n  .bs3-col-md-push-10 {\\n    left: 83.33333%; }\\n  .bs3-col-md-push-11 {\\n    left: 91.66667%; }\\n  .bs3-col-md-push-12 {\\n    left: 100%; }\\n  .bs3-col-md-offset-0 {\\n    margin-left: 0%; }\\n  .bs3-col-md-offset-1 {\\n    margin-left: 8.33333%; }\\n  .bs3-col-md-offset-2 {\\n    margin-left: 16.66667%; }\\n  .bs3-col-md-offset-3 {\\n    margin-left: 25%; }\\n  .bs3-col-md-offset-4 {\\n    margin-left: 33.33333%; }\\n  .bs3-col-md-offset-5 {\\n    margin-left: 41.66667%; }\\n  .bs3-col-md-offset-6 {\\n    margin-left: 50%; }\\n  .bs3-col-md-offset-7 {\\n    margin-left: 58.33333%; }\\n  .bs3-col-md-offset-8 {\\n    margin-left: 66.66667%; }\\n  .bs3-col-md-offset-9 {\\n    margin-left: 75%; }\\n  .bs3-col-md-offset-10 {\\n    margin-left: 83.33333%; }\\n  .bs3-col-md-offset-11 {\\n    margin-left: 91.66667%; }\\n  .bs3-col-md-offset-12 {\\n    margin-left: 100%; } }\\n\\n@media (min-width: 992px) {\\n  .bs3-col-lg-1, .bs3-col-lg-2, .bs3-col-lg-3, .bs3-col-lg-4, .bs3-col-lg-5, .bs3-col-lg-6, .bs3-col-lg-7, .bs3-col-lg-8, .bs3-col-lg-9, .bs3-col-lg-10, .bs3-col-lg-11, .bs3-col-lg-12 {\\n    float: left; }\\n  .bs3-col-lg-1 {\\n    width: 8.33333%; }\\n  .bs3-col-lg-2 {\\n    width: 16.66667%; }\\n  .bs3-col-lg-3 {\\n    width: 25%; }\\n  .bs3-col-lg-4 {\\n    width: 33.33333%; }\\n  .bs3-col-lg-5 {\\n    width: 41.66667%; }\\n  .bs3-col-lg-6 {\\n    width: 50%; }\\n  .bs3-col-lg-7 {\\n    width: 58.33333%; }\\n  .bs3-col-lg-8 {\\n    width: 66.66667%; }\\n  .bs3-col-lg-9 {\\n    width: 75%; }\\n  .bs3-col-lg-10 {\\n    width: 83.33333%; }\\n  .bs3-col-lg-11 {\\n    width: 91.66667%; }\\n  .bs3-col-lg-12 {\\n    width: 100%; }\\n  .bs3-col-lg-pull-0 {\\n    right: auto; }\\n  .bs3-col-lg-pull-1 {\\n    right: 8.33333%; }\\n  .bs3-col-lg-pull-2 {\\n    right: 16.66667%; }\\n  .bs3-col-lg-pull-3 {\\n    right: 25%; }\\n  .bs3-col-lg-pull-4 {\\n    right: 33.33333%; }\\n  .bs3-col-lg-pull-5 {\\n    right: 41.66667%; }\\n  .bs3-col-lg-pull-6 {\\n    right: 50%; }\\n  .bs3-col-lg-pull-7 {\\n    right: 58.33333%; }\\n  .bs3-col-lg-pull-8 {\\n    right: 66.66667%; }\\n  .bs3-col-lg-pull-9 {\\n    right: 75%; }\\n  .bs3-col-lg-pull-10 {\\n    right: 83.33333%; }\\n  .bs3-col-lg-pull-11 {\\n    right: 91.66667%; }\\n  .bs3-col-lg-pull-12 {\\n    right: 100%; }\\n  .bs3-col-lg-push-0 {\\n    left: auto; }\\n  .bs3-col-lg-push-1 {\\n    left: 8.33333%; }\\n  .bs3-col-lg-push-2 {\\n    left: 16.66667%; }\\n  .bs3-col-lg-push-3 {\\n    left: 25%; }\\n  .bs3-col-lg-push-4 {\\n    left: 33.33333%; }\\n  .bs3-col-lg-push-5 {\\n    left: 41.66667%; }\\n  .bs3-col-lg-push-6 {\\n    left: 50%; }\\n  .bs3-col-lg-push-7 {\\n    left: 58.33333%; }\\n  .bs3-col-lg-push-8 {\\n    left: 66.66667%; }\\n  .bs3-col-lg-push-9 {\\n    left: 75%; }\\n  .bs3-col-lg-push-10 {\\n    left: 83.33333%; }\\n  .bs3-col-lg-push-11 {\\n    left: 91.66667%; }\\n  .bs3-col-lg-push-12 {\\n    left: 100%; }\\n  .bs3-col-lg-offset-0 {\\n    margin-left: 0%; }\\n  .bs3-col-lg-offset-1 {\\n    margin-left: 8.33333%; }\\n  .bs3-col-lg-offset-2 {\\n    margin-left: 16.66667%; }\\n  .bs3-col-lg-offset-3 {\\n    margin-left: 25%; }\\n  .bs3-col-lg-offset-4 {\\n    margin-left: 33.33333%; }\\n  .bs3-col-lg-offset-5 {\\n    margin-left: 41.66667%; }\\n  .bs3-col-lg-offset-6 {\\n    margin-left: 50%; }\\n  .bs3-col-lg-offset-7 {\\n    margin-left: 58.33333%; }\\n  .bs3-col-lg-offset-8 {\\n    margin-left: 66.66667%; }\\n  .bs3-col-lg-offset-9 {\\n    margin-left: 75%; }\\n  .bs3-col-lg-offset-10 {\\n    margin-left: 83.33333%; }\\n  .bs3-col-lg-offset-11 {\\n    margin-left: 91.66667%; }\\n  .bs3-col-lg-offset-12 {\\n    margin-left: 100%; } }\\n\\n@media (min-width: 1200px) {\\n  .bs3-col-xl-1, .bs3-col-xl-2, .bs3-col-xl-3, .bs3-col-xl-4, .bs3-col-xl-5, .bs3-col-xl-6, .bs3-col-xl-7, .bs3-col-xl-8, .bs3-col-xl-9, .bs3-col-xl-10, .bs3-col-xl-11, .bs3-col-xl-12 {\\n    float: left; }\\n  .bs3-col-xl-1 {\\n    width: 8.33333%; }\\n  .bs3-col-xl-2 {\\n    width: 16.66667%; }\\n  .bs3-col-xl-3 {\\n    width: 25%; }\\n  .bs3-col-xl-4 {\\n    width: 33.33333%; }\\n  .bs3-col-xl-5 {\\n    width: 41.66667%; }\\n  .bs3-col-xl-6 {\\n    width: 50%; }\\n  .bs3-col-xl-7 {\\n    width: 58.33333%; }\\n  .bs3-col-xl-8 {\\n    width: 66.66667%; }\\n  .bs3-col-xl-9 {\\n    width: 75%; }\\n  .bs3-col-xl-10 {\\n    width: 83.33333%; }\\n  .bs3-col-xl-11 {\\n    width: 91.66667%; }\\n  .bs3-col-xl-12 {\\n    width: 100%; }\\n  .bs3-col-xl-pull-0 {\\n    right: auto; }\\n  .bs3-col-xl-pull-1 {\\n    right: 8.33333%; }\\n  .bs3-col-xl-pull-2 {\\n    right: 16.66667%; }\\n  .bs3-col-xl-pull-3 {\\n    right: 25%; }\\n  .bs3-col-xl-pull-4 {\\n    right: 33.33333%; }\\n  .bs3-col-xl-pull-5 {\\n    right: 41.66667%; }\\n  .bs3-col-xl-pull-6 {\\n    right: 50%; }\\n  .bs3-col-xl-pull-7 {\\n    right: 58.33333%; }\\n  .bs3-col-xl-pull-8 {\\n    right: 66.66667%; }\\n  .bs3-col-xl-pull-9 {\\n    right: 75%; }\\n  .bs3-col-xl-pull-10 {\\n    right: 83.33333%; }\\n  .bs3-col-xl-pull-11 {\\n    right: 91.66667%; }\\n  .bs3-col-xl-pull-12 {\\n    right: 100%; }\\n  .bs3-col-xl-push-0 {\\n    left: auto; }\\n  .bs3-col-xl-push-1 {\\n    left: 8.33333%; }\\n  .bs3-col-xl-push-2 {\\n    left: 16.66667%; }\\n  .bs3-col-xl-push-3 {\\n    left: 25%; }\\n  .bs3-col-xl-push-4 {\\n    left: 33.33333%; }\\n  .bs3-col-xl-push-5 {\\n    left: 41.66667%; }\\n  .bs3-col-xl-push-6 {\\n    left: 50%; }\\n  .bs3-col-xl-push-7 {\\n    left: 58.33333%; }\\n  .bs3-col-xl-push-8 {\\n    left: 66.66667%; }\\n  .bs3-col-xl-push-9 {\\n    left: 75%; }\\n  .bs3-col-xl-push-10 {\\n    left: 83.33333%; }\\n  .bs3-col-xl-push-11 {\\n    left: 91.66667%; }\\n  .bs3-col-xl-push-12 {\\n    left: 100%; }\\n  .bs3-col-xl-offset-0 {\\n    margin-left: 0%; }\\n  .bs3-col-xl-offset-1 {\\n    margin-left: 8.33333%; }\\n  .bs3-col-xl-offset-2 {\\n    margin-left: 16.66667%; }\\n  .bs3-col-xl-offset-3 {\\n    margin-left: 25%; }\\n  .bs3-col-xl-offset-4 {\\n    margin-left: 33.33333%; }\\n  .bs3-col-xl-offset-5 {\\n    margin-left: 41.66667%; }\\n  .bs3-col-xl-offset-6 {\\n    margin-left: 50%; }\\n  .bs3-col-xl-offset-7 {\\n    margin-left: 58.33333%; }\\n  .bs3-col-xl-offset-8 {\\n    margin-left: 66.66667%; }\\n  .bs3-col-xl-offset-9 {\\n    margin-left: 75%; }\\n  .bs3-col-xl-offset-10 {\\n    margin-left: 83.33333%; }\\n  .bs3-col-xl-offset-11 {\\n    margin-left: 91.66667%; }\\n  .bs3-col-xl-offset-12 {\\n    margin-left: 100%; } }\\n\\n/***********************************/\\n/**          Post Links           **/\\n/***********************************/\\n.post-links {\\n  margin-bottom: 0;\\n  font-size: 0.875rem;\\n  padding-left: 0; }\\n  .post-links::after {\\n    content: \\\"\\\";\\n    display: table;\\n    clear: both; }\\n  .post-links > li {\\n    float: left;\\n    list-style: none; }\\n    .post-links > li + li:before {\\n      color: #999;\\n      content: \\\"\\\\25cf\\\";\\n      padding: 0 8px; }\\n    .post-links > li > a {\\n      text-decoration: none;\\n      color: #999999; }\\n      .post-links > li > a:hover {\\n        color: #999999; }\\n  .post-links.no-separator > li + li {\\n    margin-left: 12px; }\\n    .post-links.no-separator > li + li:before {\\n      content: normal; }\\n\\n/***********************************/\\n/**            Gallery            **/\\n/***********************************/\\n.gallery .img-thumbnail figcaption {\\n  margin: 0.8571rem 0.5714rem 0.8571rem 0.5714rem; }\\n\\n.gallery .img-thumbnail a {\\n  display: inline-block;\\n  overflow: hidden;\\n  max-width: 100%; }\\n  .gallery .img-thumbnail a > img {\\n    transition: transform .15s ease;\\n    max-width: 100%; }\\n\\n.gallery .img-thumbnail:hover a > img {\\n  transform: scale(1.1, 1.1); }\\n\\n.gallery .post-links > li > a {\\n  display: inline; }\\n\\n.gallery > div {\\n  max-width: 100%; }\\n\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEyMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvZXh0cmEvZ2FsbGVyeS9nYWxsZXJ5LnN0eWxlLnNjc3M/NjM0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiLyogTWFnbmlmaWMgUG9wdXAgQ1NTICovXFxuLm1mcC1iZyB7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAwO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICB6LWluZGV4OiAxMDQyO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIGJhY2tncm91bmQ6ICMwYjBiMGI7XFxuICBvcGFjaXR5OiAwLjg7IH1cXG5cXG4ubWZwLXdyYXAge1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogMDtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgei1pbmRleDogMTA0MztcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIG91dGxpbmU6IG5vbmUgIWltcG9ydGFudDtcXG4gIC13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuOyB9XFxuXFxuLm1mcC1jb250YWluZXIge1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBsZWZ0OiAwO1xcbiAgdG9wOiAwO1xcbiAgcGFkZGluZzogMCA4cHg7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94OyB9XFxuXFxuLm1mcC1jb250YWluZXI6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6ICcnO1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTsgfVxcblxcbi5tZnAtYWxpZ24tdG9wIC5tZnAtY29udGFpbmVyOmJlZm9yZSB7XFxuICBkaXNwbGF5OiBub25lOyB9XFxuXFxuLm1mcC1jb250ZW50IHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICBtYXJnaW46IDAgYXV0bztcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxuICB6LWluZGV4OiAxMDQ1OyB9XFxuXFxuLm1mcC1pbmxpbmUtaG9sZGVyIC5tZnAtY29udGVudCxcXG4ubWZwLWFqYXgtaG9sZGVyIC5tZnAtY29udGVudCB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGN1cnNvcjogYXV0bzsgfVxcblxcbi5tZnAtYWpheC1jdXIge1xcbiAgY3Vyc29yOiBwcm9ncmVzczsgfVxcblxcbi5tZnAtem9vbS1vdXQtY3VyLCAubWZwLXpvb20tb3V0LWN1ciAubWZwLWltYWdlLWhvbGRlciAubWZwLWNsb3NlIHtcXG4gIGN1cnNvcjogLW1vei16b29tLW91dDtcXG4gIGN1cnNvcjogLXdlYmtpdC16b29tLW91dDtcXG4gIGN1cnNvcjogem9vbS1vdXQ7IH1cXG5cXG4ubWZwLXpvb20ge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgY3Vyc29yOiAtd2Via2l0LXpvb20taW47XFxuICBjdXJzb3I6IC1tb3otem9vbS1pbjtcXG4gIGN1cnNvcjogem9vbS1pbjsgfVxcblxcbi5tZnAtYXV0by1jdXJzb3IgLm1mcC1jb250ZW50IHtcXG4gIGN1cnNvcjogYXV0bzsgfVxcblxcbi5tZnAtY2xvc2UsXFxuLm1mcC1hcnJvdyxcXG4ubWZwLXByZWxvYWRlcixcXG4ubWZwLWNvdW50ZXIge1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuICB1c2VyLXNlbGVjdDogbm9uZTsgfVxcblxcbi5tZnAtbG9hZGluZy5tZnAtZmlndXJlIHtcXG4gIGRpc3BsYXk6IG5vbmU7IH1cXG5cXG4ubWZwLWhpZGUge1xcbiAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50OyB9XFxuXFxuLm1mcC1wcmVsb2FkZXIge1xcbiAgY29sb3I6ICNDQ0M7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDUwJTtcXG4gIHdpZHRoOiBhdXRvO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgbWFyZ2luLXRvcDogLTAuOGVtO1xcbiAgbGVmdDogOHB4O1xcbiAgcmlnaHQ6IDhweDtcXG4gIHotaW5kZXg6IDEwNDQ7IH1cXG5cXG4ubWZwLXByZWxvYWRlciBhIHtcXG4gIGNvbG9yOiAjQ0NDOyB9XFxuXFxuLm1mcC1wcmVsb2FkZXIgYTpob3ZlciB7XFxuICBjb2xvcjogI0ZGRjsgfVxcblxcbi5tZnAtcy1yZWFkeSAubWZwLXByZWxvYWRlciB7XFxuICBkaXNwbGF5OiBub25lOyB9XFxuXFxuLm1mcC1zLWVycm9yIC5tZnAtY29udGVudCB7XFxuICBkaXNwbGF5OiBub25lOyB9XFxuXFxuYnV0dG9uLm1mcC1jbG9zZSxcXG5idXR0b24ubWZwLWFycm93IHtcXG4gIG92ZXJmbG93OiB2aXNpYmxlO1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxuICBib3JkZXI6IDA7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIG91dGxpbmU6IG5vbmU7XFxuICBwYWRkaW5nOiAwO1xcbiAgei1pbmRleDogMTA0NjtcXG4gIGJveC1zaGFkb3c6IG5vbmU7XFxuICB0b3VjaC1hY3Rpb246IG1hbmlwdWxhdGlvbjsgfVxcblxcbmJ1dHRvbjo6LW1vei1mb2N1cy1pbm5lciB7XFxuICBwYWRkaW5nOiAwO1xcbiAgYm9yZGVyOiAwOyB9XFxuXFxuLm1mcC1jbG9zZSB7XFxuICB3aWR0aDogNDRweDtcXG4gIGhlaWdodDogNDRweDtcXG4gIGxpbmUtaGVpZ2h0OiA0NHB4O1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgcmlnaHQ6IDA7XFxuICB0b3A6IDA7XFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBvcGFjaXR5OiAwLjY1O1xcbiAgcGFkZGluZzogMCAwIDE4cHggMTBweDtcXG4gIGNvbG9yOiAjRkZGO1xcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xcbiAgZm9udC1zaXplOiAyOHB4O1xcbiAgZm9udC1mYW1pbHk6IEFyaWFsLCBCYXNrZXJ2aWxsZSwgbW9ub3NwYWNlOyB9XFxuXFxuLm1mcC1jbG9zZTpob3ZlcixcXG4ubWZwLWNsb3NlOmZvY3VzIHtcXG4gIG9wYWNpdHk6IDE7IH1cXG5cXG4ubWZwLWNsb3NlOmFjdGl2ZSB7XFxuICB0b3A6IDFweDsgfVxcblxcbi5tZnAtY2xvc2UtYnRuLWluIC5tZnAtY2xvc2Uge1xcbiAgY29sb3I6ICMzMzM7IH1cXG5cXG4ubWZwLWltYWdlLWhvbGRlciAubWZwLWNsb3NlLFxcbi5tZnAtaWZyYW1lLWhvbGRlciAubWZwLWNsb3NlIHtcXG4gIGNvbG9yOiAjRkZGO1xcbiAgcmlnaHQ6IC02cHg7XFxuICB0ZXh0LWFsaWduOiByaWdodDtcXG4gIHBhZGRpbmctcmlnaHQ6IDZweDtcXG4gIHdpZHRoOiAxMDAlOyB9XFxuXFxuLm1mcC1jb3VudGVyIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMDtcXG4gIHJpZ2h0OiAwO1xcbiAgY29sb3I6ICNDQ0M7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBsaW5lLWhlaWdodDogMThweDtcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7IH1cXG5cXG4ubWZwLWFycm93IHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIG9wYWNpdHk6IDAuNjU7XFxuICBtYXJnaW46IDA7XFxuICB0b3A6IDUwJTtcXG4gIG1hcmdpbi10b3A6IC01NXB4O1xcbiAgcGFkZGluZzogMDtcXG4gIHdpZHRoOiA5MHB4O1xcbiAgaGVpZ2h0OiAxMTBweDtcXG4gIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogdHJhbnNwYXJlbnQ7IH1cXG5cXG4ubWZwLWFycm93OmFjdGl2ZSB7XFxuICBtYXJnaW4tdG9wOiAtNTRweDsgfVxcblxcbi5tZnAtYXJyb3c6aG92ZXIsXFxuLm1mcC1hcnJvdzpmb2N1cyB7XFxuICBvcGFjaXR5OiAxOyB9XFxuXFxuLm1mcC1hcnJvdzpiZWZvcmUsXFxuLm1mcC1hcnJvdzphZnRlciB7XFxuICBjb250ZW50OiAnJztcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgd2lkdGg6IDA7XFxuICBoZWlnaHQ6IDA7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBsZWZ0OiAwO1xcbiAgdG9wOiAwO1xcbiAgbWFyZ2luLXRvcDogMzVweDtcXG4gIG1hcmdpbi1sZWZ0OiAzNXB4O1xcbiAgYm9yZGVyOiBtZWRpdW0gaW5zZXQgdHJhbnNwYXJlbnQ7IH1cXG5cXG4ubWZwLWFycm93OmFmdGVyIHtcXG4gIGJvcmRlci10b3Atd2lkdGg6IDEzcHg7XFxuICBib3JkZXItYm90dG9tLXdpZHRoOiAxM3B4O1xcbiAgdG9wOiA4cHg7IH1cXG5cXG4ubWZwLWFycm93OmJlZm9yZSB7XFxuICBib3JkZXItdG9wLXdpZHRoOiAyMXB4O1xcbiAgYm9yZGVyLWJvdHRvbS13aWR0aDogMjFweDtcXG4gIG9wYWNpdHk6IDAuNzsgfVxcblxcbi5tZnAtYXJyb3ctbGVmdCB7XFxuICBsZWZ0OiAwOyB9XFxuXFxuLm1mcC1hcnJvdy1sZWZ0OmFmdGVyIHtcXG4gIGJvcmRlci1yaWdodDogMTdweCBzb2xpZCAjRkZGO1xcbiAgbWFyZ2luLWxlZnQ6IDMxcHg7IH1cXG5cXG4ubWZwLWFycm93LWxlZnQ6YmVmb3JlIHtcXG4gIG1hcmdpbi1sZWZ0OiAyNXB4O1xcbiAgYm9yZGVyLXJpZ2h0OiAyN3B4IHNvbGlkICMzRjNGM0Y7IH1cXG5cXG4ubWZwLWFycm93LXJpZ2h0IHtcXG4gIHJpZ2h0OiAwOyB9XFxuXFxuLm1mcC1hcnJvdy1yaWdodDphZnRlciB7XFxuICBib3JkZXItbGVmdDogMTdweCBzb2xpZCAjRkZGO1xcbiAgbWFyZ2luLWxlZnQ6IDM5cHg7IH1cXG5cXG4ubWZwLWFycm93LXJpZ2h0OmJlZm9yZSB7XFxuICBib3JkZXItbGVmdDogMjdweCBzb2xpZCAjM0YzRjNGOyB9XFxuXFxuLm1mcC1pZnJhbWUtaG9sZGVyIHtcXG4gIHBhZGRpbmctdG9wOiA0MHB4O1xcbiAgcGFkZGluZy1ib3R0b206IDQwcHg7IH1cXG5cXG4ubWZwLWlmcmFtZS1ob2xkZXIgLm1mcC1jb250ZW50IHtcXG4gIGxpbmUtaGVpZ2h0OiAwO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBtYXgtd2lkdGg6IDkwMHB4OyB9XFxuXFxuLm1mcC1pZnJhbWUtaG9sZGVyIC5tZnAtY2xvc2Uge1xcbiAgdG9wOiAtNDBweDsgfVxcblxcbi5tZnAtaWZyYW1lLXNjYWxlciB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMDtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICBwYWRkaW5nLXRvcDogNTYuMjUlOyB9XFxuXFxuLm1mcC1pZnJhbWUtc2NhbGVyIGlmcmFtZSB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIHRvcDogMDtcXG4gIGxlZnQ6IDA7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIGJveC1zaGFkb3c6IDAgMCA4cHggcmdiYSgwLCAwLCAwLCAwLjYpO1xcbiAgYmFja2dyb3VuZDogIzAwMDsgfVxcblxcbi8qIE1haW4gaW1hZ2UgaW4gcG9wdXAgKi9cXG5pbWcubWZwLWltZyB7XFxuICB3aWR0aDogYXV0bztcXG4gIG1heC13aWR0aDogMTAwJTtcXG4gIGhlaWdodDogYXV0bztcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgbGluZS1oZWlnaHQ6IDA7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgcGFkZGluZzogNDBweCAwIDQwcHg7XFxuICBtYXJnaW46IDAgYXV0bzsgfVxcblxcbi8qIFRoZSBzaGFkb3cgYmVoaW5kIHRoZSBpbWFnZSAqL1xcbi5tZnAtZmlndXJlIHtcXG4gIGxpbmUtaGVpZ2h0OiAwOyB9XFxuXFxuLm1mcC1maWd1cmU6YWZ0ZXIge1xcbiAgY29udGVudDogJyc7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBsZWZ0OiAwO1xcbiAgdG9wOiA0MHB4O1xcbiAgYm90dG9tOiA0MHB4O1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICByaWdodDogMDtcXG4gIHdpZHRoOiBhdXRvO1xcbiAgaGVpZ2h0OiBhdXRvO1xcbiAgei1pbmRleDogLTE7XFxuICBib3gtc2hhZG93OiAwIDAgOHB4IHJnYmEoMCwgMCwgMCwgMC42KTtcXG4gIGJhY2tncm91bmQ6ICM0NDQ7IH1cXG5cXG4ubWZwLWZpZ3VyZSBzbWFsbCB7XFxuICBjb2xvcjogI0JEQkRCRDtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgbGluZS1oZWlnaHQ6IDE0cHg7IH1cXG5cXG4ubWZwLWZpZ3VyZSBmaWd1cmUge1xcbiAgbWFyZ2luOiAwOyB9XFxuXFxuLm1mcC1ib3R0b20tYmFyIHtcXG4gIG1hcmdpbi10b3A6IC0zNnB4O1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAxMDAlO1xcbiAgbGVmdDogMDtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgY3Vyc29yOiBhdXRvOyB9XFxuXFxuLm1mcC10aXRsZSB7XFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgbGluZS1oZWlnaHQ6IDE4cHg7XFxuICBjb2xvcjogI0YzRjNGMztcXG4gIHdvcmQtd3JhcDogYnJlYWstd29yZDtcXG4gIHBhZGRpbmctcmlnaHQ6IDM2cHg7IH1cXG5cXG4ubWZwLWltYWdlLWhvbGRlciAubWZwLWNvbnRlbnQge1xcbiAgbWF4LXdpZHRoOiAxMDAlOyB9XFxuXFxuLm1mcC1nYWxsZXJ5IC5tZnAtaW1hZ2UtaG9sZGVyIC5tZnAtZmlndXJlIHtcXG4gIGN1cnNvcjogcG9pbnRlcjsgfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDgwMHB4KSBhbmQgKG9yaWVudGF0aW9uOiBsYW5kc2NhcGUpLCBzY3JlZW4gYW5kIChtYXgtaGVpZ2h0OiAzMDBweCkge1xcbiAgLyoqXFxuICAgICAgICogUmVtb3ZlIGFsbCBwYWRkaW5ncyBhcm91bmQgdGhlIGltYWdlIG9uIHNtYWxsIHNjcmVlblxcbiAgICAgICAqL1xcbiAgLm1mcC1pbWctbW9iaWxlIC5tZnAtaW1hZ2UtaG9sZGVyIHtcXG4gICAgcGFkZGluZy1sZWZ0OiAwO1xcbiAgICBwYWRkaW5nLXJpZ2h0OiAwOyB9XFxuICAubWZwLWltZy1tb2JpbGUgaW1nLm1mcC1pbWcge1xcbiAgICBwYWRkaW5nOiAwOyB9XFxuICAubWZwLWltZy1tb2JpbGUgLm1mcC1maWd1cmU6YWZ0ZXIge1xcbiAgICB0b3A6IDA7XFxuICAgIGJvdHRvbTogMDsgfVxcbiAgLm1mcC1pbWctbW9iaWxlIC5tZnAtZmlndXJlIHNtYWxsIHtcXG4gICAgZGlzcGxheTogaW5saW5lO1xcbiAgICBtYXJnaW4tbGVmdDogNXB4OyB9XFxuICAubWZwLWltZy1tb2JpbGUgLm1mcC1ib3R0b20tYmFyIHtcXG4gICAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjYpO1xcbiAgICBib3R0b206IDA7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgdG9wOiBhdXRvO1xcbiAgICBwYWRkaW5nOiAzcHggNXB4O1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7IH1cXG4gIC5tZnAtaW1nLW1vYmlsZSAubWZwLWJvdHRvbS1iYXI6ZW1wdHkge1xcbiAgICBwYWRkaW5nOiAwOyB9XFxuICAubWZwLWltZy1tb2JpbGUgLm1mcC1jb3VudGVyIHtcXG4gICAgcmlnaHQ6IDVweDtcXG4gICAgdG9wOiAzcHg7IH1cXG4gIC5tZnAtaW1nLW1vYmlsZSAubWZwLWNsb3NlIHtcXG4gICAgdG9wOiAwO1xcbiAgICByaWdodDogMDtcXG4gICAgd2lkdGg6IDM1cHg7XFxuICAgIGhlaWdodDogMzVweDtcXG4gICAgbGluZS1oZWlnaHQ6IDM1cHg7XFxuICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC42KTtcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgIHBhZGRpbmc6IDA7IH0gfVxcblxcbkBtZWRpYSBhbGwgYW5kIChtYXgtd2lkdGg6IDkwMHB4KSB7XFxuICAubWZwLWFycm93IHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDAuNzUpO1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDAuNzUpOyB9XFxuICAubWZwLWFycm93LWxlZnQge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IDA7XFxuICAgIHRyYW5zZm9ybS1vcmlnaW46IDA7IH1cXG4gIC5tZnAtYXJyb3ctcmlnaHQge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IDEwMCU7XFxuICAgIHRyYW5zZm9ybS1vcmlnaW46IDEwMCU7IH1cXG4gIC5tZnAtY29udGFpbmVyIHtcXG4gICAgcGFkZGluZy1sZWZ0OiA2cHg7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDZweDsgfSB9XFxuXFxuLmJzMy1yb3cge1xcbiAgbWFyZ2luLWxlZnQ6IC0xNXB4O1xcbiAgbWFyZ2luLXJpZ2h0OiAtMTVweDsgfVxcbiAgLmJzMy1yb3c6OmFmdGVyIHtcXG4gICAgY29udGVudDogXFxcIlxcXCI7XFxuICAgIGRpc3BsYXk6IHRhYmxlO1xcbiAgICBjbGVhcjogYm90aDsgfVxcblxcbi5iczMtY29sLXhzLTEsIC5iczMtY29sLXhzLTIsIC5iczMtY29sLXhzLTMsIC5iczMtY29sLXhzLTQsIC5iczMtY29sLXhzLTUsIC5iczMtY29sLXhzLTYsIC5iczMtY29sLXhzLTcsIC5iczMtY29sLXhzLTgsIC5iczMtY29sLXhzLTksIC5iczMtY29sLXhzLTEwLCAuYnMzLWNvbC14cy0xMSwgLmJzMy1jb2wteHMtMTIsIC5iczMtY29sLXNtLTEsIC5iczMtY29sLXNtLTIsIC5iczMtY29sLXNtLTMsIC5iczMtY29sLXNtLTQsIC5iczMtY29sLXNtLTUsIC5iczMtY29sLXNtLTYsIC5iczMtY29sLXNtLTcsIC5iczMtY29sLXNtLTgsIC5iczMtY29sLXNtLTksIC5iczMtY29sLXNtLTEwLCAuYnMzLWNvbC1zbS0xMSwgLmJzMy1jb2wtc20tMTIsIC5iczMtY29sLW1kLTEsIC5iczMtY29sLW1kLTIsIC5iczMtY29sLW1kLTMsIC5iczMtY29sLW1kLTQsIC5iczMtY29sLW1kLTUsIC5iczMtY29sLW1kLTYsIC5iczMtY29sLW1kLTcsIC5iczMtY29sLW1kLTgsIC5iczMtY29sLW1kLTksIC5iczMtY29sLW1kLTEwLCAuYnMzLWNvbC1tZC0xMSwgLmJzMy1jb2wtbWQtMTIsIC5iczMtY29sLWxnLTEsIC5iczMtY29sLWxnLTIsIC5iczMtY29sLWxnLTMsIC5iczMtY29sLWxnLTQsIC5iczMtY29sLWxnLTUsIC5iczMtY29sLWxnLTYsIC5iczMtY29sLWxnLTcsIC5iczMtY29sLWxnLTgsIC5iczMtY29sLWxnLTksIC5iczMtY29sLWxnLTEwLCAuYnMzLWNvbC1sZy0xMSwgLmJzMy1jb2wtbGctMTIsIC5iczMtY29sLXhsLTEsIC5iczMtY29sLXhsLTIsIC5iczMtY29sLXhsLTMsIC5iczMtY29sLXhsLTQsIC5iczMtY29sLXhsLTUsIC5iczMtY29sLXhsLTYsIC5iczMtY29sLXhsLTcsIC5iczMtY29sLXhsLTgsIC5iczMtY29sLXhsLTksIC5iczMtY29sLXhsLTEwLCAuYnMzLWNvbC14bC0xMSwgLmJzMy1jb2wteGwtMTIge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgbWluLWhlaWdodDogMXB4O1xcbiAgcGFkZGluZy1sZWZ0OiAxNXB4O1xcbiAgcGFkZGluZy1yaWdodDogMTVweDsgfVxcblxcbi5iczMtY29sLXhzLTEsIC5iczMtY29sLXhzLTIsIC5iczMtY29sLXhzLTMsIC5iczMtY29sLXhzLTQsIC5iczMtY29sLXhzLTUsIC5iczMtY29sLXhzLTYsIC5iczMtY29sLXhzLTcsIC5iczMtY29sLXhzLTgsIC5iczMtY29sLXhzLTksIC5iczMtY29sLXhzLTEwLCAuYnMzLWNvbC14cy0xMSwgLmJzMy1jb2wteHMtMTIge1xcbiAgZmxvYXQ6IGxlZnQ7IH1cXG5cXG4uYnMzLWNvbC14cy0xIHtcXG4gIHdpZHRoOiA4LjMzMzMzJTsgfVxcblxcbi5iczMtY29sLXhzLTIge1xcbiAgd2lkdGg6IDE2LjY2NjY3JTsgfVxcblxcbi5iczMtY29sLXhzLTMge1xcbiAgd2lkdGg6IDI1JTsgfVxcblxcbi5iczMtY29sLXhzLTQge1xcbiAgd2lkdGg6IDMzLjMzMzMzJTsgfVxcblxcbi5iczMtY29sLXhzLTUge1xcbiAgd2lkdGg6IDQxLjY2NjY3JTsgfVxcblxcbi5iczMtY29sLXhzLTYge1xcbiAgd2lkdGg6IDUwJTsgfVxcblxcbi5iczMtY29sLXhzLTcge1xcbiAgd2lkdGg6IDU4LjMzMzMzJTsgfVxcblxcbi5iczMtY29sLXhzLTgge1xcbiAgd2lkdGg6IDY2LjY2NjY3JTsgfVxcblxcbi5iczMtY29sLXhzLTkge1xcbiAgd2lkdGg6IDc1JTsgfVxcblxcbi5iczMtY29sLXhzLTEwIHtcXG4gIHdpZHRoOiA4My4zMzMzMyU7IH1cXG5cXG4uYnMzLWNvbC14cy0xMSB7XFxuICB3aWR0aDogOTEuNjY2NjclOyB9XFxuXFxuLmJzMy1jb2wteHMtMTIge1xcbiAgd2lkdGg6IDEwMCU7IH1cXG5cXG4uYnMzLWNvbC14cy1wdWxsLTAge1xcbiAgcmlnaHQ6IGF1dG87IH1cXG5cXG4uYnMzLWNvbC14cy1wdWxsLTEge1xcbiAgcmlnaHQ6IDguMzMzMzMlOyB9XFxuXFxuLmJzMy1jb2wteHMtcHVsbC0yIHtcXG4gIHJpZ2h0OiAxNi42NjY2NyU7IH1cXG5cXG4uYnMzLWNvbC14cy1wdWxsLTMge1xcbiAgcmlnaHQ6IDI1JTsgfVxcblxcbi5iczMtY29sLXhzLXB1bGwtNCB7XFxuICByaWdodDogMzMuMzMzMzMlOyB9XFxuXFxuLmJzMy1jb2wteHMtcHVsbC01IHtcXG4gIHJpZ2h0OiA0MS42NjY2NyU7IH1cXG5cXG4uYnMzLWNvbC14cy1wdWxsLTYge1xcbiAgcmlnaHQ6IDUwJTsgfVxcblxcbi5iczMtY29sLXhzLXB1bGwtNyB7XFxuICByaWdodDogNTguMzMzMzMlOyB9XFxuXFxuLmJzMy1jb2wteHMtcHVsbC04IHtcXG4gIHJpZ2h0OiA2Ni42NjY2NyU7IH1cXG5cXG4uYnMzLWNvbC14cy1wdWxsLTkge1xcbiAgcmlnaHQ6IDc1JTsgfVxcblxcbi5iczMtY29sLXhzLXB1bGwtMTAge1xcbiAgcmlnaHQ6IDgzLjMzMzMzJTsgfVxcblxcbi5iczMtY29sLXhzLXB1bGwtMTEge1xcbiAgcmlnaHQ6IDkxLjY2NjY3JTsgfVxcblxcbi5iczMtY29sLXhzLXB1bGwtMTIge1xcbiAgcmlnaHQ6IDEwMCU7IH1cXG5cXG4uYnMzLWNvbC14cy1wdXNoLTAge1xcbiAgbGVmdDogYXV0bzsgfVxcblxcbi5iczMtY29sLXhzLXB1c2gtMSB7XFxuICBsZWZ0OiA4LjMzMzMzJTsgfVxcblxcbi5iczMtY29sLXhzLXB1c2gtMiB7XFxuICBsZWZ0OiAxNi42NjY2NyU7IH1cXG5cXG4uYnMzLWNvbC14cy1wdXNoLTMge1xcbiAgbGVmdDogMjUlOyB9XFxuXFxuLmJzMy1jb2wteHMtcHVzaC00IHtcXG4gIGxlZnQ6IDMzLjMzMzMzJTsgfVxcblxcbi5iczMtY29sLXhzLXB1c2gtNSB7XFxuICBsZWZ0OiA0MS42NjY2NyU7IH1cXG5cXG4uYnMzLWNvbC14cy1wdXNoLTYge1xcbiAgbGVmdDogNTAlOyB9XFxuXFxuLmJzMy1jb2wteHMtcHVzaC03IHtcXG4gIGxlZnQ6IDU4LjMzMzMzJTsgfVxcblxcbi5iczMtY29sLXhzLXB1c2gtOCB7XFxuICBsZWZ0OiA2Ni42NjY2NyU7IH1cXG5cXG4uYnMzLWNvbC14cy1wdXNoLTkge1xcbiAgbGVmdDogNzUlOyB9XFxuXFxuLmJzMy1jb2wteHMtcHVzaC0xMCB7XFxuICBsZWZ0OiA4My4zMzMzMyU7IH1cXG5cXG4uYnMzLWNvbC14cy1wdXNoLTExIHtcXG4gIGxlZnQ6IDkxLjY2NjY3JTsgfVxcblxcbi5iczMtY29sLXhzLXB1c2gtMTIge1xcbiAgbGVmdDogMTAwJTsgfVxcblxcbi5iczMtY29sLXhzLW9mZnNldC0wIHtcXG4gIG1hcmdpbi1sZWZ0OiAwJTsgfVxcblxcbi5iczMtY29sLXhzLW9mZnNldC0xIHtcXG4gIG1hcmdpbi1sZWZ0OiA4LjMzMzMzJTsgfVxcblxcbi5iczMtY29sLXhzLW9mZnNldC0yIHtcXG4gIG1hcmdpbi1sZWZ0OiAxNi42NjY2NyU7IH1cXG5cXG4uYnMzLWNvbC14cy1vZmZzZXQtMyB7XFxuICBtYXJnaW4tbGVmdDogMjUlOyB9XFxuXFxuLmJzMy1jb2wteHMtb2Zmc2V0LTQge1xcbiAgbWFyZ2luLWxlZnQ6IDMzLjMzMzMzJTsgfVxcblxcbi5iczMtY29sLXhzLW9mZnNldC01IHtcXG4gIG1hcmdpbi1sZWZ0OiA0MS42NjY2NyU7IH1cXG5cXG4uYnMzLWNvbC14cy1vZmZzZXQtNiB7XFxuICBtYXJnaW4tbGVmdDogNTAlOyB9XFxuXFxuLmJzMy1jb2wteHMtb2Zmc2V0LTcge1xcbiAgbWFyZ2luLWxlZnQ6IDU4LjMzMzMzJTsgfVxcblxcbi5iczMtY29sLXhzLW9mZnNldC04IHtcXG4gIG1hcmdpbi1sZWZ0OiA2Ni42NjY2NyU7IH1cXG5cXG4uYnMzLWNvbC14cy1vZmZzZXQtOSB7XFxuICBtYXJnaW4tbGVmdDogNzUlOyB9XFxuXFxuLmJzMy1jb2wteHMtb2Zmc2V0LTEwIHtcXG4gIG1hcmdpbi1sZWZ0OiA4My4zMzMzMyU7IH1cXG5cXG4uYnMzLWNvbC14cy1vZmZzZXQtMTEge1xcbiAgbWFyZ2luLWxlZnQ6IDkxLjY2NjY3JTsgfVxcblxcbi5iczMtY29sLXhzLW9mZnNldC0xMiB7XFxuICBtYXJnaW4tbGVmdDogMTAwJTsgfVxcblxcbkBtZWRpYSAobWluLXdpZHRoOiA1NzZweCkge1xcbiAgLmJzMy1jb2wtc20tMSwgLmJzMy1jb2wtc20tMiwgLmJzMy1jb2wtc20tMywgLmJzMy1jb2wtc20tNCwgLmJzMy1jb2wtc20tNSwgLmJzMy1jb2wtc20tNiwgLmJzMy1jb2wtc20tNywgLmJzMy1jb2wtc20tOCwgLmJzMy1jb2wtc20tOSwgLmJzMy1jb2wtc20tMTAsIC5iczMtY29sLXNtLTExLCAuYnMzLWNvbC1zbS0xMiB7XFxuICAgIGZsb2F0OiBsZWZ0OyB9XFxuICAuYnMzLWNvbC1zbS0xIHtcXG4gICAgd2lkdGg6IDguMzMzMzMlOyB9XFxuICAuYnMzLWNvbC1zbS0yIHtcXG4gICAgd2lkdGg6IDE2LjY2NjY3JTsgfVxcbiAgLmJzMy1jb2wtc20tMyB7XFxuICAgIHdpZHRoOiAyNSU7IH1cXG4gIC5iczMtY29sLXNtLTQge1xcbiAgICB3aWR0aDogMzMuMzMzMzMlOyB9XFxuICAuYnMzLWNvbC1zbS01IHtcXG4gICAgd2lkdGg6IDQxLjY2NjY3JTsgfVxcbiAgLmJzMy1jb2wtc20tNiB7XFxuICAgIHdpZHRoOiA1MCU7IH1cXG4gIC5iczMtY29sLXNtLTcge1xcbiAgICB3aWR0aDogNTguMzMzMzMlOyB9XFxuICAuYnMzLWNvbC1zbS04IHtcXG4gICAgd2lkdGg6IDY2LjY2NjY3JTsgfVxcbiAgLmJzMy1jb2wtc20tOSB7XFxuICAgIHdpZHRoOiA3NSU7IH1cXG4gIC5iczMtY29sLXNtLTEwIHtcXG4gICAgd2lkdGg6IDgzLjMzMzMzJTsgfVxcbiAgLmJzMy1jb2wtc20tMTEge1xcbiAgICB3aWR0aDogOTEuNjY2NjclOyB9XFxuICAuYnMzLWNvbC1zbS0xMiB7XFxuICAgIHdpZHRoOiAxMDAlOyB9XFxuICAuYnMzLWNvbC1zbS1wdWxsLTAge1xcbiAgICByaWdodDogYXV0bzsgfVxcbiAgLmJzMy1jb2wtc20tcHVsbC0xIHtcXG4gICAgcmlnaHQ6IDguMzMzMzMlOyB9XFxuICAuYnMzLWNvbC1zbS1wdWxsLTIge1xcbiAgICByaWdodDogMTYuNjY2NjclOyB9XFxuICAuYnMzLWNvbC1zbS1wdWxsLTMge1xcbiAgICByaWdodDogMjUlOyB9XFxuICAuYnMzLWNvbC1zbS1wdWxsLTQge1xcbiAgICByaWdodDogMzMuMzMzMzMlOyB9XFxuICAuYnMzLWNvbC1zbS1wdWxsLTUge1xcbiAgICByaWdodDogNDEuNjY2NjclOyB9XFxuICAuYnMzLWNvbC1zbS1wdWxsLTYge1xcbiAgICByaWdodDogNTAlOyB9XFxuICAuYnMzLWNvbC1zbS1wdWxsLTcge1xcbiAgICByaWdodDogNTguMzMzMzMlOyB9XFxuICAuYnMzLWNvbC1zbS1wdWxsLTgge1xcbiAgICByaWdodDogNjYuNjY2NjclOyB9XFxuICAuYnMzLWNvbC1zbS1wdWxsLTkge1xcbiAgICByaWdodDogNzUlOyB9XFxuICAuYnMzLWNvbC1zbS1wdWxsLTEwIHtcXG4gICAgcmlnaHQ6IDgzLjMzMzMzJTsgfVxcbiAgLmJzMy1jb2wtc20tcHVsbC0xMSB7XFxuICAgIHJpZ2h0OiA5MS42NjY2NyU7IH1cXG4gIC5iczMtY29sLXNtLXB1bGwtMTIge1xcbiAgICByaWdodDogMTAwJTsgfVxcbiAgLmJzMy1jb2wtc20tcHVzaC0wIHtcXG4gICAgbGVmdDogYXV0bzsgfVxcbiAgLmJzMy1jb2wtc20tcHVzaC0xIHtcXG4gICAgbGVmdDogOC4zMzMzMyU7IH1cXG4gIC5iczMtY29sLXNtLXB1c2gtMiB7XFxuICAgIGxlZnQ6IDE2LjY2NjY3JTsgfVxcbiAgLmJzMy1jb2wtc20tcHVzaC0zIHtcXG4gICAgbGVmdDogMjUlOyB9XFxuICAuYnMzLWNvbC1zbS1wdXNoLTQge1xcbiAgICBsZWZ0OiAzMy4zMzMzMyU7IH1cXG4gIC5iczMtY29sLXNtLXB1c2gtNSB7XFxuICAgIGxlZnQ6IDQxLjY2NjY3JTsgfVxcbiAgLmJzMy1jb2wtc20tcHVzaC02IHtcXG4gICAgbGVmdDogNTAlOyB9XFxuICAuYnMzLWNvbC1zbS1wdXNoLTcge1xcbiAgICBsZWZ0OiA1OC4zMzMzMyU7IH1cXG4gIC5iczMtY29sLXNtLXB1c2gtOCB7XFxuICAgIGxlZnQ6IDY2LjY2NjY3JTsgfVxcbiAgLmJzMy1jb2wtc20tcHVzaC05IHtcXG4gICAgbGVmdDogNzUlOyB9XFxuICAuYnMzLWNvbC1zbS1wdXNoLTEwIHtcXG4gICAgbGVmdDogODMuMzMzMzMlOyB9XFxuICAuYnMzLWNvbC1zbS1wdXNoLTExIHtcXG4gICAgbGVmdDogOTEuNjY2NjclOyB9XFxuICAuYnMzLWNvbC1zbS1wdXNoLTEyIHtcXG4gICAgbGVmdDogMTAwJTsgfVxcbiAgLmJzMy1jb2wtc20tb2Zmc2V0LTAge1xcbiAgICBtYXJnaW4tbGVmdDogMCU7IH1cXG4gIC5iczMtY29sLXNtLW9mZnNldC0xIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDguMzMzMzMlOyB9XFxuICAuYnMzLWNvbC1zbS1vZmZzZXQtMiB7XFxuICAgIG1hcmdpbi1sZWZ0OiAxNi42NjY2NyU7IH1cXG4gIC5iczMtY29sLXNtLW9mZnNldC0zIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDI1JTsgfVxcbiAgLmJzMy1jb2wtc20tb2Zmc2V0LTQge1xcbiAgICBtYXJnaW4tbGVmdDogMzMuMzMzMzMlOyB9XFxuICAuYnMzLWNvbC1zbS1vZmZzZXQtNSB7XFxuICAgIG1hcmdpbi1sZWZ0OiA0MS42NjY2NyU7IH1cXG4gIC5iczMtY29sLXNtLW9mZnNldC02IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDUwJTsgfVxcbiAgLmJzMy1jb2wtc20tb2Zmc2V0LTcge1xcbiAgICBtYXJnaW4tbGVmdDogNTguMzMzMzMlOyB9XFxuICAuYnMzLWNvbC1zbS1vZmZzZXQtOCB7XFxuICAgIG1hcmdpbi1sZWZ0OiA2Ni42NjY2NyU7IH1cXG4gIC5iczMtY29sLXNtLW9mZnNldC05IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDc1JTsgfVxcbiAgLmJzMy1jb2wtc20tb2Zmc2V0LTEwIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDgzLjMzMzMzJTsgfVxcbiAgLmJzMy1jb2wtc20tb2Zmc2V0LTExIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDkxLjY2NjY3JTsgfVxcbiAgLmJzMy1jb2wtc20tb2Zmc2V0LTEyIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDEwMCU7IH0gfVxcblxcbkBtZWRpYSAobWluLXdpZHRoOiA3NjhweCkge1xcbiAgLmJzMy1jb2wtbWQtMSwgLmJzMy1jb2wtbWQtMiwgLmJzMy1jb2wtbWQtMywgLmJzMy1jb2wtbWQtNCwgLmJzMy1jb2wtbWQtNSwgLmJzMy1jb2wtbWQtNiwgLmJzMy1jb2wtbWQtNywgLmJzMy1jb2wtbWQtOCwgLmJzMy1jb2wtbWQtOSwgLmJzMy1jb2wtbWQtMTAsIC5iczMtY29sLW1kLTExLCAuYnMzLWNvbC1tZC0xMiB7XFxuICAgIGZsb2F0OiBsZWZ0OyB9XFxuICAuYnMzLWNvbC1tZC0xIHtcXG4gICAgd2lkdGg6IDguMzMzMzMlOyB9XFxuICAuYnMzLWNvbC1tZC0yIHtcXG4gICAgd2lkdGg6IDE2LjY2NjY3JTsgfVxcbiAgLmJzMy1jb2wtbWQtMyB7XFxuICAgIHdpZHRoOiAyNSU7IH1cXG4gIC5iczMtY29sLW1kLTQge1xcbiAgICB3aWR0aDogMzMuMzMzMzMlOyB9XFxuICAuYnMzLWNvbC1tZC01IHtcXG4gICAgd2lkdGg6IDQxLjY2NjY3JTsgfVxcbiAgLmJzMy1jb2wtbWQtNiB7XFxuICAgIHdpZHRoOiA1MCU7IH1cXG4gIC5iczMtY29sLW1kLTcge1xcbiAgICB3aWR0aDogNTguMzMzMzMlOyB9XFxuICAuYnMzLWNvbC1tZC04IHtcXG4gICAgd2lkdGg6IDY2LjY2NjY3JTsgfVxcbiAgLmJzMy1jb2wtbWQtOSB7XFxuICAgIHdpZHRoOiA3NSU7IH1cXG4gIC5iczMtY29sLW1kLTEwIHtcXG4gICAgd2lkdGg6IDgzLjMzMzMzJTsgfVxcbiAgLmJzMy1jb2wtbWQtMTEge1xcbiAgICB3aWR0aDogOTEuNjY2NjclOyB9XFxuICAuYnMzLWNvbC1tZC0xMiB7XFxuICAgIHdpZHRoOiAxMDAlOyB9XFxuICAuYnMzLWNvbC1tZC1wdWxsLTAge1xcbiAgICByaWdodDogYXV0bzsgfVxcbiAgLmJzMy1jb2wtbWQtcHVsbC0xIHtcXG4gICAgcmlnaHQ6IDguMzMzMzMlOyB9XFxuICAuYnMzLWNvbC1tZC1wdWxsLTIge1xcbiAgICByaWdodDogMTYuNjY2NjclOyB9XFxuICAuYnMzLWNvbC1tZC1wdWxsLTMge1xcbiAgICByaWdodDogMjUlOyB9XFxuICAuYnMzLWNvbC1tZC1wdWxsLTQge1xcbiAgICByaWdodDogMzMuMzMzMzMlOyB9XFxuICAuYnMzLWNvbC1tZC1wdWxsLTUge1xcbiAgICByaWdodDogNDEuNjY2NjclOyB9XFxuICAuYnMzLWNvbC1tZC1wdWxsLTYge1xcbiAgICByaWdodDogNTAlOyB9XFxuICAuYnMzLWNvbC1tZC1wdWxsLTcge1xcbiAgICByaWdodDogNTguMzMzMzMlOyB9XFxuICAuYnMzLWNvbC1tZC1wdWxsLTgge1xcbiAgICByaWdodDogNjYuNjY2NjclOyB9XFxuICAuYnMzLWNvbC1tZC1wdWxsLTkge1xcbiAgICByaWdodDogNzUlOyB9XFxuICAuYnMzLWNvbC1tZC1wdWxsLTEwIHtcXG4gICAgcmlnaHQ6IDgzLjMzMzMzJTsgfVxcbiAgLmJzMy1jb2wtbWQtcHVsbC0xMSB7XFxuICAgIHJpZ2h0OiA5MS42NjY2NyU7IH1cXG4gIC5iczMtY29sLW1kLXB1bGwtMTIge1xcbiAgICByaWdodDogMTAwJTsgfVxcbiAgLmJzMy1jb2wtbWQtcHVzaC0wIHtcXG4gICAgbGVmdDogYXV0bzsgfVxcbiAgLmJzMy1jb2wtbWQtcHVzaC0xIHtcXG4gICAgbGVmdDogOC4zMzMzMyU7IH1cXG4gIC5iczMtY29sLW1kLXB1c2gtMiB7XFxuICAgIGxlZnQ6IDE2LjY2NjY3JTsgfVxcbiAgLmJzMy1jb2wtbWQtcHVzaC0zIHtcXG4gICAgbGVmdDogMjUlOyB9XFxuICAuYnMzLWNvbC1tZC1wdXNoLTQge1xcbiAgICBsZWZ0OiAzMy4zMzMzMyU7IH1cXG4gIC5iczMtY29sLW1kLXB1c2gtNSB7XFxuICAgIGxlZnQ6IDQxLjY2NjY3JTsgfVxcbiAgLmJzMy1jb2wtbWQtcHVzaC02IHtcXG4gICAgbGVmdDogNTAlOyB9XFxuICAuYnMzLWNvbC1tZC1wdXNoLTcge1xcbiAgICBsZWZ0OiA1OC4zMzMzMyU7IH1cXG4gIC5iczMtY29sLW1kLXB1c2gtOCB7XFxuICAgIGxlZnQ6IDY2LjY2NjY3JTsgfVxcbiAgLmJzMy1jb2wtbWQtcHVzaC05IHtcXG4gICAgbGVmdDogNzUlOyB9XFxuICAuYnMzLWNvbC1tZC1wdXNoLTEwIHtcXG4gICAgbGVmdDogODMuMzMzMzMlOyB9XFxuICAuYnMzLWNvbC1tZC1wdXNoLTExIHtcXG4gICAgbGVmdDogOTEuNjY2NjclOyB9XFxuICAuYnMzLWNvbC1tZC1wdXNoLTEyIHtcXG4gICAgbGVmdDogMTAwJTsgfVxcbiAgLmJzMy1jb2wtbWQtb2Zmc2V0LTAge1xcbiAgICBtYXJnaW4tbGVmdDogMCU7IH1cXG4gIC5iczMtY29sLW1kLW9mZnNldC0xIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDguMzMzMzMlOyB9XFxuICAuYnMzLWNvbC1tZC1vZmZzZXQtMiB7XFxuICAgIG1hcmdpbi1sZWZ0OiAxNi42NjY2NyU7IH1cXG4gIC5iczMtY29sLW1kLW9mZnNldC0zIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDI1JTsgfVxcbiAgLmJzMy1jb2wtbWQtb2Zmc2V0LTQge1xcbiAgICBtYXJnaW4tbGVmdDogMzMuMzMzMzMlOyB9XFxuICAuYnMzLWNvbC1tZC1vZmZzZXQtNSB7XFxuICAgIG1hcmdpbi1sZWZ0OiA0MS42NjY2NyU7IH1cXG4gIC5iczMtY29sLW1kLW9mZnNldC02IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDUwJTsgfVxcbiAgLmJzMy1jb2wtbWQtb2Zmc2V0LTcge1xcbiAgICBtYXJnaW4tbGVmdDogNTguMzMzMzMlOyB9XFxuICAuYnMzLWNvbC1tZC1vZmZzZXQtOCB7XFxuICAgIG1hcmdpbi1sZWZ0OiA2Ni42NjY2NyU7IH1cXG4gIC5iczMtY29sLW1kLW9mZnNldC05IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDc1JTsgfVxcbiAgLmJzMy1jb2wtbWQtb2Zmc2V0LTEwIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDgzLjMzMzMzJTsgfVxcbiAgLmJzMy1jb2wtbWQtb2Zmc2V0LTExIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDkxLjY2NjY3JTsgfVxcbiAgLmJzMy1jb2wtbWQtb2Zmc2V0LTEyIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDEwMCU7IH0gfVxcblxcbkBtZWRpYSAobWluLXdpZHRoOiA5OTJweCkge1xcbiAgLmJzMy1jb2wtbGctMSwgLmJzMy1jb2wtbGctMiwgLmJzMy1jb2wtbGctMywgLmJzMy1jb2wtbGctNCwgLmJzMy1jb2wtbGctNSwgLmJzMy1jb2wtbGctNiwgLmJzMy1jb2wtbGctNywgLmJzMy1jb2wtbGctOCwgLmJzMy1jb2wtbGctOSwgLmJzMy1jb2wtbGctMTAsIC5iczMtY29sLWxnLTExLCAuYnMzLWNvbC1sZy0xMiB7XFxuICAgIGZsb2F0OiBsZWZ0OyB9XFxuICAuYnMzLWNvbC1sZy0xIHtcXG4gICAgd2lkdGg6IDguMzMzMzMlOyB9XFxuICAuYnMzLWNvbC1sZy0yIHtcXG4gICAgd2lkdGg6IDE2LjY2NjY3JTsgfVxcbiAgLmJzMy1jb2wtbGctMyB7XFxuICAgIHdpZHRoOiAyNSU7IH1cXG4gIC5iczMtY29sLWxnLTQge1xcbiAgICB3aWR0aDogMzMuMzMzMzMlOyB9XFxuICAuYnMzLWNvbC1sZy01IHtcXG4gICAgd2lkdGg6IDQxLjY2NjY3JTsgfVxcbiAgLmJzMy1jb2wtbGctNiB7XFxuICAgIHdpZHRoOiA1MCU7IH1cXG4gIC5iczMtY29sLWxnLTcge1xcbiAgICB3aWR0aDogNTguMzMzMzMlOyB9XFxuICAuYnMzLWNvbC1sZy04IHtcXG4gICAgd2lkdGg6IDY2LjY2NjY3JTsgfVxcbiAgLmJzMy1jb2wtbGctOSB7XFxuICAgIHdpZHRoOiA3NSU7IH1cXG4gIC5iczMtY29sLWxnLTEwIHtcXG4gICAgd2lkdGg6IDgzLjMzMzMzJTsgfVxcbiAgLmJzMy1jb2wtbGctMTEge1xcbiAgICB3aWR0aDogOTEuNjY2NjclOyB9XFxuICAuYnMzLWNvbC1sZy0xMiB7XFxuICAgIHdpZHRoOiAxMDAlOyB9XFxuICAuYnMzLWNvbC1sZy1wdWxsLTAge1xcbiAgICByaWdodDogYXV0bzsgfVxcbiAgLmJzMy1jb2wtbGctcHVsbC0xIHtcXG4gICAgcmlnaHQ6IDguMzMzMzMlOyB9XFxuICAuYnMzLWNvbC1sZy1wdWxsLTIge1xcbiAgICByaWdodDogMTYuNjY2NjclOyB9XFxuICAuYnMzLWNvbC1sZy1wdWxsLTMge1xcbiAgICByaWdodDogMjUlOyB9XFxuICAuYnMzLWNvbC1sZy1wdWxsLTQge1xcbiAgICByaWdodDogMzMuMzMzMzMlOyB9XFxuICAuYnMzLWNvbC1sZy1wdWxsLTUge1xcbiAgICByaWdodDogNDEuNjY2NjclOyB9XFxuICAuYnMzLWNvbC1sZy1wdWxsLTYge1xcbiAgICByaWdodDogNTAlOyB9XFxuICAuYnMzLWNvbC1sZy1wdWxsLTcge1xcbiAgICByaWdodDogNTguMzMzMzMlOyB9XFxuICAuYnMzLWNvbC1sZy1wdWxsLTgge1xcbiAgICByaWdodDogNjYuNjY2NjclOyB9XFxuICAuYnMzLWNvbC1sZy1wdWxsLTkge1xcbiAgICByaWdodDogNzUlOyB9XFxuICAuYnMzLWNvbC1sZy1wdWxsLTEwIHtcXG4gICAgcmlnaHQ6IDgzLjMzMzMzJTsgfVxcbiAgLmJzMy1jb2wtbGctcHVsbC0xMSB7XFxuICAgIHJpZ2h0OiA5MS42NjY2NyU7IH1cXG4gIC5iczMtY29sLWxnLXB1bGwtMTIge1xcbiAgICByaWdodDogMTAwJTsgfVxcbiAgLmJzMy1jb2wtbGctcHVzaC0wIHtcXG4gICAgbGVmdDogYXV0bzsgfVxcbiAgLmJzMy1jb2wtbGctcHVzaC0xIHtcXG4gICAgbGVmdDogOC4zMzMzMyU7IH1cXG4gIC5iczMtY29sLWxnLXB1c2gtMiB7XFxuICAgIGxlZnQ6IDE2LjY2NjY3JTsgfVxcbiAgLmJzMy1jb2wtbGctcHVzaC0zIHtcXG4gICAgbGVmdDogMjUlOyB9XFxuICAuYnMzLWNvbC1sZy1wdXNoLTQge1xcbiAgICBsZWZ0OiAzMy4zMzMzMyU7IH1cXG4gIC5iczMtY29sLWxnLXB1c2gtNSB7XFxuICAgIGxlZnQ6IDQxLjY2NjY3JTsgfVxcbiAgLmJzMy1jb2wtbGctcHVzaC02IHtcXG4gICAgbGVmdDogNTAlOyB9XFxuICAuYnMzLWNvbC1sZy1wdXNoLTcge1xcbiAgICBsZWZ0OiA1OC4zMzMzMyU7IH1cXG4gIC5iczMtY29sLWxnLXB1c2gtOCB7XFxuICAgIGxlZnQ6IDY2LjY2NjY3JTsgfVxcbiAgLmJzMy1jb2wtbGctcHVzaC05IHtcXG4gICAgbGVmdDogNzUlOyB9XFxuICAuYnMzLWNvbC1sZy1wdXNoLTEwIHtcXG4gICAgbGVmdDogODMuMzMzMzMlOyB9XFxuICAuYnMzLWNvbC1sZy1wdXNoLTExIHtcXG4gICAgbGVmdDogOTEuNjY2NjclOyB9XFxuICAuYnMzLWNvbC1sZy1wdXNoLTEyIHtcXG4gICAgbGVmdDogMTAwJTsgfVxcbiAgLmJzMy1jb2wtbGctb2Zmc2V0LTAge1xcbiAgICBtYXJnaW4tbGVmdDogMCU7IH1cXG4gIC5iczMtY29sLWxnLW9mZnNldC0xIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDguMzMzMzMlOyB9XFxuICAuYnMzLWNvbC1sZy1vZmZzZXQtMiB7XFxuICAgIG1hcmdpbi1sZWZ0OiAxNi42NjY2NyU7IH1cXG4gIC5iczMtY29sLWxnLW9mZnNldC0zIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDI1JTsgfVxcbiAgLmJzMy1jb2wtbGctb2Zmc2V0LTQge1xcbiAgICBtYXJnaW4tbGVmdDogMzMuMzMzMzMlOyB9XFxuICAuYnMzLWNvbC1sZy1vZmZzZXQtNSB7XFxuICAgIG1hcmdpbi1sZWZ0OiA0MS42NjY2NyU7IH1cXG4gIC5iczMtY29sLWxnLW9mZnNldC02IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDUwJTsgfVxcbiAgLmJzMy1jb2wtbGctb2Zmc2V0LTcge1xcbiAgICBtYXJnaW4tbGVmdDogNTguMzMzMzMlOyB9XFxuICAuYnMzLWNvbC1sZy1vZmZzZXQtOCB7XFxuICAgIG1hcmdpbi1sZWZ0OiA2Ni42NjY2NyU7IH1cXG4gIC5iczMtY29sLWxnLW9mZnNldC05IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDc1JTsgfVxcbiAgLmJzMy1jb2wtbGctb2Zmc2V0LTEwIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDgzLjMzMzMzJTsgfVxcbiAgLmJzMy1jb2wtbGctb2Zmc2V0LTExIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDkxLjY2NjY3JTsgfVxcbiAgLmJzMy1jb2wtbGctb2Zmc2V0LTEyIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDEwMCU7IH0gfVxcblxcbkBtZWRpYSAobWluLXdpZHRoOiAxMjAwcHgpIHtcXG4gIC5iczMtY29sLXhsLTEsIC5iczMtY29sLXhsLTIsIC5iczMtY29sLXhsLTMsIC5iczMtY29sLXhsLTQsIC5iczMtY29sLXhsLTUsIC5iczMtY29sLXhsLTYsIC5iczMtY29sLXhsLTcsIC5iczMtY29sLXhsLTgsIC5iczMtY29sLXhsLTksIC5iczMtY29sLXhsLTEwLCAuYnMzLWNvbC14bC0xMSwgLmJzMy1jb2wteGwtMTIge1xcbiAgICBmbG9hdDogbGVmdDsgfVxcbiAgLmJzMy1jb2wteGwtMSB7XFxuICAgIHdpZHRoOiA4LjMzMzMzJTsgfVxcbiAgLmJzMy1jb2wteGwtMiB7XFxuICAgIHdpZHRoOiAxNi42NjY2NyU7IH1cXG4gIC5iczMtY29sLXhsLTMge1xcbiAgICB3aWR0aDogMjUlOyB9XFxuICAuYnMzLWNvbC14bC00IHtcXG4gICAgd2lkdGg6IDMzLjMzMzMzJTsgfVxcbiAgLmJzMy1jb2wteGwtNSB7XFxuICAgIHdpZHRoOiA0MS42NjY2NyU7IH1cXG4gIC5iczMtY29sLXhsLTYge1xcbiAgICB3aWR0aDogNTAlOyB9XFxuICAuYnMzLWNvbC14bC03IHtcXG4gICAgd2lkdGg6IDU4LjMzMzMzJTsgfVxcbiAgLmJzMy1jb2wteGwtOCB7XFxuICAgIHdpZHRoOiA2Ni42NjY2NyU7IH1cXG4gIC5iczMtY29sLXhsLTkge1xcbiAgICB3aWR0aDogNzUlOyB9XFxuICAuYnMzLWNvbC14bC0xMCB7XFxuICAgIHdpZHRoOiA4My4zMzMzMyU7IH1cXG4gIC5iczMtY29sLXhsLTExIHtcXG4gICAgd2lkdGg6IDkxLjY2NjY3JTsgfVxcbiAgLmJzMy1jb2wteGwtMTIge1xcbiAgICB3aWR0aDogMTAwJTsgfVxcbiAgLmJzMy1jb2wteGwtcHVsbC0wIHtcXG4gICAgcmlnaHQ6IGF1dG87IH1cXG4gIC5iczMtY29sLXhsLXB1bGwtMSB7XFxuICAgIHJpZ2h0OiA4LjMzMzMzJTsgfVxcbiAgLmJzMy1jb2wteGwtcHVsbC0yIHtcXG4gICAgcmlnaHQ6IDE2LjY2NjY3JTsgfVxcbiAgLmJzMy1jb2wteGwtcHVsbC0zIHtcXG4gICAgcmlnaHQ6IDI1JTsgfVxcbiAgLmJzMy1jb2wteGwtcHVsbC00IHtcXG4gICAgcmlnaHQ6IDMzLjMzMzMzJTsgfVxcbiAgLmJzMy1jb2wteGwtcHVsbC01IHtcXG4gICAgcmlnaHQ6IDQxLjY2NjY3JTsgfVxcbiAgLmJzMy1jb2wteGwtcHVsbC02IHtcXG4gICAgcmlnaHQ6IDUwJTsgfVxcbiAgLmJzMy1jb2wteGwtcHVsbC03IHtcXG4gICAgcmlnaHQ6IDU4LjMzMzMzJTsgfVxcbiAgLmJzMy1jb2wteGwtcHVsbC04IHtcXG4gICAgcmlnaHQ6IDY2LjY2NjY3JTsgfVxcbiAgLmJzMy1jb2wteGwtcHVsbC05IHtcXG4gICAgcmlnaHQ6IDc1JTsgfVxcbiAgLmJzMy1jb2wteGwtcHVsbC0xMCB7XFxuICAgIHJpZ2h0OiA4My4zMzMzMyU7IH1cXG4gIC5iczMtY29sLXhsLXB1bGwtMTEge1xcbiAgICByaWdodDogOTEuNjY2NjclOyB9XFxuICAuYnMzLWNvbC14bC1wdWxsLTEyIHtcXG4gICAgcmlnaHQ6IDEwMCU7IH1cXG4gIC5iczMtY29sLXhsLXB1c2gtMCB7XFxuICAgIGxlZnQ6IGF1dG87IH1cXG4gIC5iczMtY29sLXhsLXB1c2gtMSB7XFxuICAgIGxlZnQ6IDguMzMzMzMlOyB9XFxuICAuYnMzLWNvbC14bC1wdXNoLTIge1xcbiAgICBsZWZ0OiAxNi42NjY2NyU7IH1cXG4gIC5iczMtY29sLXhsLXB1c2gtMyB7XFxuICAgIGxlZnQ6IDI1JTsgfVxcbiAgLmJzMy1jb2wteGwtcHVzaC00IHtcXG4gICAgbGVmdDogMzMuMzMzMzMlOyB9XFxuICAuYnMzLWNvbC14bC1wdXNoLTUge1xcbiAgICBsZWZ0OiA0MS42NjY2NyU7IH1cXG4gIC5iczMtY29sLXhsLXB1c2gtNiB7XFxuICAgIGxlZnQ6IDUwJTsgfVxcbiAgLmJzMy1jb2wteGwtcHVzaC03IHtcXG4gICAgbGVmdDogNTguMzMzMzMlOyB9XFxuICAuYnMzLWNvbC14bC1wdXNoLTgge1xcbiAgICBsZWZ0OiA2Ni42NjY2NyU7IH1cXG4gIC5iczMtY29sLXhsLXB1c2gtOSB7XFxuICAgIGxlZnQ6IDc1JTsgfVxcbiAgLmJzMy1jb2wteGwtcHVzaC0xMCB7XFxuICAgIGxlZnQ6IDgzLjMzMzMzJTsgfVxcbiAgLmJzMy1jb2wteGwtcHVzaC0xMSB7XFxuICAgIGxlZnQ6IDkxLjY2NjY3JTsgfVxcbiAgLmJzMy1jb2wteGwtcHVzaC0xMiB7XFxuICAgIGxlZnQ6IDEwMCU7IH1cXG4gIC5iczMtY29sLXhsLW9mZnNldC0wIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDAlOyB9XFxuICAuYnMzLWNvbC14bC1vZmZzZXQtMSB7XFxuICAgIG1hcmdpbi1sZWZ0OiA4LjMzMzMzJTsgfVxcbiAgLmJzMy1jb2wteGwtb2Zmc2V0LTIge1xcbiAgICBtYXJnaW4tbGVmdDogMTYuNjY2NjclOyB9XFxuICAuYnMzLWNvbC14bC1vZmZzZXQtMyB7XFxuICAgIG1hcmdpbi1sZWZ0OiAyNSU7IH1cXG4gIC5iczMtY29sLXhsLW9mZnNldC00IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDMzLjMzMzMzJTsgfVxcbiAgLmJzMy1jb2wteGwtb2Zmc2V0LTUge1xcbiAgICBtYXJnaW4tbGVmdDogNDEuNjY2NjclOyB9XFxuICAuYnMzLWNvbC14bC1vZmZzZXQtNiB7XFxuICAgIG1hcmdpbi1sZWZ0OiA1MCU7IH1cXG4gIC5iczMtY29sLXhsLW9mZnNldC03IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDU4LjMzMzMzJTsgfVxcbiAgLmJzMy1jb2wteGwtb2Zmc2V0LTgge1xcbiAgICBtYXJnaW4tbGVmdDogNjYuNjY2NjclOyB9XFxuICAuYnMzLWNvbC14bC1vZmZzZXQtOSB7XFxuICAgIG1hcmdpbi1sZWZ0OiA3NSU7IH1cXG4gIC5iczMtY29sLXhsLW9mZnNldC0xMCB7XFxuICAgIG1hcmdpbi1sZWZ0OiA4My4zMzMzMyU7IH1cXG4gIC5iczMtY29sLXhsLW9mZnNldC0xMSB7XFxuICAgIG1hcmdpbi1sZWZ0OiA5MS42NjY2NyU7IH1cXG4gIC5iczMtY29sLXhsLW9mZnNldC0xMiB7XFxuICAgIG1hcmdpbi1sZWZ0OiAxMDAlOyB9IH1cXG5cXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyoqICAgICAgICAgIFBvc3QgTGlua3MgICAgICAgICAgICoqL1xcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4ucG9zdC1saW5rcyB7XFxuICBtYXJnaW4tYm90dG9tOiAwO1xcbiAgZm9udC1zaXplOiAwLjg3NXJlbTtcXG4gIHBhZGRpbmctbGVmdDogMDsgfVxcbiAgLnBvc3QtbGlua3M6OmFmdGVyIHtcXG4gICAgY29udGVudDogXFxcIlxcXCI7XFxuICAgIGRpc3BsYXk6IHRhYmxlO1xcbiAgICBjbGVhcjogYm90aDsgfVxcbiAgLnBvc3QtbGlua3MgPiBsaSB7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbiAgICBsaXN0LXN0eWxlOiBub25lOyB9XFxuICAgIC5wb3N0LWxpbmtzID4gbGkgKyBsaTpiZWZvcmUge1xcbiAgICAgIGNvbG9yOiAjOTk5O1xcbiAgICAgIGNvbnRlbnQ6IFxcXCJcXFxcMjVjZlxcXCI7XFxuICAgICAgcGFkZGluZzogMCA4cHg7IH1cXG4gICAgLnBvc3QtbGlua3MgPiBsaSA+IGEge1xcbiAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gICAgICBjb2xvcjogIzk5OTk5OTsgfVxcbiAgICAgIC5wb3N0LWxpbmtzID4gbGkgPiBhOmhvdmVyIHtcXG4gICAgICAgIGNvbG9yOiAjOTk5OTk5OyB9XFxuICAucG9zdC1saW5rcy5uby1zZXBhcmF0b3IgPiBsaSArIGxpIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDEycHg7IH1cXG4gICAgLnBvc3QtbGlua3Mubm8tc2VwYXJhdG9yID4gbGkgKyBsaTpiZWZvcmUge1xcbiAgICAgIGNvbnRlbnQ6IG5vcm1hbDsgfVxcblxcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiogICAgICAgICAgICBHYWxsZXJ5ICAgICAgICAgICAgKiovXFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi5nYWxsZXJ5IC5pbWctdGh1bWJuYWlsIGZpZ2NhcHRpb24ge1xcbiAgbWFyZ2luOiAwLjg1NzFyZW0gMC41NzE0cmVtIDAuODU3MXJlbSAwLjU3MTRyZW07IH1cXG5cXG4uZ2FsbGVyeSAuaW1nLXRodW1ibmFpbCBhIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICBtYXgtd2lkdGg6IDEwMCU7IH1cXG4gIC5nYWxsZXJ5IC5pbWctdGh1bWJuYWlsIGEgPiBpbWcge1xcbiAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gLjE1cyBlYXNlO1xcbiAgICBtYXgtd2lkdGg6IDEwMCU7IH1cXG5cXG4uZ2FsbGVyeSAuaW1nLXRodW1ibmFpbDpob3ZlciBhID4gaW1nIHtcXG4gIHRyYW5zZm9ybTogc2NhbGUoMS4xLCAxLjEpOyB9XFxuXFxuLmdhbGxlcnkgLnBvc3QtbGlua3MgPiBsaSA+IGEge1xcbiAgZGlzcGxheTogaW5saW5lOyB9XFxuXFxuLmdhbGxlcnkgPiBkaXYge1xcbiAgbWF4LXdpZHRoOiAxMDAlOyB9XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvZXh0cmEvZ2FsbGVyeS9nYWxsZXJ5LnN0eWxlLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDExMjNcbi8vIG1vZHVsZSBjaHVua3MgPSA1Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 1124:
/* unknown exports provided */
/* all exports used */
/*!**************************************************!*\
  !*** ./src/app/extra/invoice/invoice.style.scss ***!
  \**************************************************/
/***/ (function(module, exports) {

eval("module.exports = \"/***********************************/\\n/**            INVOICE            **/\\n/***********************************/\\n.widget-invoice {\\n  padding: 40px; }\\n  @media (max-width: 575px) {\\n    .widget-invoice .print-buttons .btn {\\n      padding-left: 0.8rem;\\n      padding-right: 0.8rem; } }\\n  .widget-invoice > header .invoice-logo {\\n    max-height: 50px; }\\n  .widget-invoice > header + .widget-body {\\n    margin-top: 70px; }\\n\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEyNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvZXh0cmEvaW52b2ljZS9pbnZvaWNlLnN0eWxlLnNjc3M/OGI3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qKiAgICAgICAgICAgIElOVk9JQ0UgICAgICAgICAgICAqKi9cXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLndpZGdldC1pbnZvaWNlIHtcXG4gIHBhZGRpbmc6IDQwcHg7IH1cXG4gIEBtZWRpYSAobWF4LXdpZHRoOiA1NzVweCkge1xcbiAgICAud2lkZ2V0LWludm9pY2UgLnByaW50LWJ1dHRvbnMgLmJ0biB7XFxuICAgICAgcGFkZGluZy1sZWZ0OiAwLjhyZW07XFxuICAgICAgcGFkZGluZy1yaWdodDogMC44cmVtOyB9IH1cXG4gIC53aWRnZXQtaW52b2ljZSA+IGhlYWRlciAuaW52b2ljZS1sb2dvIHtcXG4gICAgbWF4LWhlaWdodDogNTBweDsgfVxcbiAgLndpZGdldC1pbnZvaWNlID4gaGVhZGVyICsgLndpZGdldC1ib2R5IHtcXG4gICAgbWFyZ2luLXRvcDogNzBweDsgfVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL2V4dHJhL2ludm9pY2UvaW52b2ljZS5zdHlsZS5zY3NzXG4vLyBtb2R1bGUgaWQgPSAxMTI0XG4vLyBtb2R1bGUgY2h1bmtzID0gNSJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 1125:
/* unknown exports provided */
/* all exports used */
/*!****************************************************************!*\
  !*** ./src/app/extra/search-results/search-results.style.scss ***!
  \****************************************************************/
/***/ (function(module, exports) {

eval("module.exports = \"/***********************************/\\n/**         Search Result         **/\\n/***********************************/\\n.search-result-categories > li > a {\\n  color: #777;\\n  font-weight: 400; }\\n  .search-result-categories > li > a:hover {\\n    background-color: #ddd;\\n    color: #555555; }\\n\\n.search-results-count {\\n  margin-top: 10px; }\\n\\n.search-result-item {\\n  padding: 20px;\\n  background-color: #fff;\\n  border-radius: 0.25rem; }\\n  .search-result-item::after {\\n    content: \\\"\\\";\\n    display: table;\\n    clear: both; }\\n  .search-result-item .image-link {\\n    display: block;\\n    overflow: hidden;\\n    border-top-left-radius: 0.25rem;\\n    border-bottom-left-radius: 0.25rem; }\\n    @media (min-width: 768px) {\\n      .search-result-item .image-link {\\n        display: inline-block;\\n        margin: -20px 0 -20px -20px;\\n        float: left;\\n        width: 200px; } }\\n    @media (max-width: 767px) {\\n      .search-result-item .image-link {\\n        max-height: 200px; } }\\n  .search-result-item .image {\\n    max-width: 100%; }\\n  .search-result-item .info {\\n    margin-top: 2px;\\n    font-size: 0.875rem;\\n    color: #999999; }\\n  .search-result-item .description {\\n    font-size: 13px; }\\n  .search-result-item + .search-result-item {\\n    margin-top: 20px; }\\n\\n.search-result-item-body {\\n  height: auto; }\\n  @media (max-width: 767px) {\\n    .search-result-item-body {\\n      margin-top: 10px; } }\\n  @media (min-width: 768px) {\\n    .search-result-item-body {\\n      margin-left: 200px; } }\\n\\n.search-result-item-heading {\\n  font-weight: 400; }\\n  .search-result-item-heading > a {\\n    color: #555555; }\\n  @media (min-width: 768px) {\\n    .search-result-item-heading {\\n      margin: 0; } }\\n\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEyNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvZXh0cmEvc2VhcmNoLXJlc3VsdHMvc2VhcmNoLXJlc3VsdHMuc3R5bGUuc2Nzcz85N2I4Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLyoqICAgICAgICAgU2VhcmNoIFJlc3VsdCAgICAgICAgICoqL1xcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4uc2VhcmNoLXJlc3VsdC1jYXRlZ29yaWVzID4gbGkgPiBhIHtcXG4gIGNvbG9yOiAjNzc3O1xcbiAgZm9udC13ZWlnaHQ6IDQwMDsgfVxcbiAgLnNlYXJjaC1yZXN1bHQtY2F0ZWdvcmllcyA+IGxpID4gYTpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNkZGQ7XFxuICAgIGNvbG9yOiAjNTU1NTU1OyB9XFxuXFxuLnNlYXJjaC1yZXN1bHRzLWNvdW50IHtcXG4gIG1hcmdpbi10b3A6IDEwcHg7IH1cXG5cXG4uc2VhcmNoLXJlc3VsdC1pdGVtIHtcXG4gIHBhZGRpbmc6IDIwcHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbiAgYm9yZGVyLXJhZGl1czogMC4yNXJlbTsgfVxcbiAgLnNlYXJjaC1yZXN1bHQtaXRlbTo6YWZ0ZXIge1xcbiAgICBjb250ZW50OiBcXFwiXFxcIjtcXG4gICAgZGlzcGxheTogdGFibGU7XFxuICAgIGNsZWFyOiBib3RoOyB9XFxuICAuc2VhcmNoLXJlc3VsdC1pdGVtIC5pbWFnZS1saW5rIHtcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDAuMjVyZW07XFxuICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDAuMjVyZW07IH1cXG4gICAgQG1lZGlhIChtaW4td2lkdGg6IDc2OHB4KSB7XFxuICAgICAgLnNlYXJjaC1yZXN1bHQtaXRlbSAuaW1hZ2UtbGluayB7XFxuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgICAgICBtYXJnaW46IC0yMHB4IDAgLTIwcHggLTIwcHg7XFxuICAgICAgICBmbG9hdDogbGVmdDtcXG4gICAgICAgIHdpZHRoOiAyMDBweDsgfSB9XFxuICAgIEBtZWRpYSAobWF4LXdpZHRoOiA3NjdweCkge1xcbiAgICAgIC5zZWFyY2gtcmVzdWx0LWl0ZW0gLmltYWdlLWxpbmsge1xcbiAgICAgICAgbWF4LWhlaWdodDogMjAwcHg7IH0gfVxcbiAgLnNlYXJjaC1yZXN1bHQtaXRlbSAuaW1hZ2Uge1xcbiAgICBtYXgtd2lkdGg6IDEwMCU7IH1cXG4gIC5zZWFyY2gtcmVzdWx0LWl0ZW0gLmluZm8ge1xcbiAgICBtYXJnaW4tdG9wOiAycHg7XFxuICAgIGZvbnQtc2l6ZTogMC44NzVyZW07XFxuICAgIGNvbG9yOiAjOTk5OTk5OyB9XFxuICAuc2VhcmNoLXJlc3VsdC1pdGVtIC5kZXNjcmlwdGlvbiB7XFxuICAgIGZvbnQtc2l6ZTogMTNweDsgfVxcbiAgLnNlYXJjaC1yZXN1bHQtaXRlbSArIC5zZWFyY2gtcmVzdWx0LWl0ZW0ge1xcbiAgICBtYXJnaW4tdG9wOiAyMHB4OyB9XFxuXFxuLnNlYXJjaC1yZXN1bHQtaXRlbS1ib2R5IHtcXG4gIGhlaWdodDogYXV0bzsgfVxcbiAgQG1lZGlhIChtYXgtd2lkdGg6IDc2N3B4KSB7XFxuICAgIC5zZWFyY2gtcmVzdWx0LWl0ZW0tYm9keSB7XFxuICAgICAgbWFyZ2luLXRvcDogMTBweDsgfSB9XFxuICBAbWVkaWEgKG1pbi13aWR0aDogNzY4cHgpIHtcXG4gICAgLnNlYXJjaC1yZXN1bHQtaXRlbS1ib2R5IHtcXG4gICAgICBtYXJnaW4tbGVmdDogMjAwcHg7IH0gfVxcblxcbi5zZWFyY2gtcmVzdWx0LWl0ZW0taGVhZGluZyB7XFxuICBmb250LXdlaWdodDogNDAwOyB9XFxuICAuc2VhcmNoLXJlc3VsdC1pdGVtLWhlYWRpbmcgPiBhIHtcXG4gICAgY29sb3I6ICM1NTU1NTU7IH1cXG4gIEBtZWRpYSAobWluLXdpZHRoOiA3NjhweCkge1xcbiAgICAuc2VhcmNoLXJlc3VsdC1pdGVtLWhlYWRpbmcge1xcbiAgICAgIG1hcmdpbjogMDsgfSB9XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvZXh0cmEvc2VhcmNoLXJlc3VsdHMvc2VhcmNoLXJlc3VsdHMuc3R5bGUuc2Nzc1xuLy8gbW9kdWxlIGlkID0gMTEyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDUiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 1126:
/* unknown exports provided */
/* all exports used */
/*!******************************************************!*\
  !*** ./src/app/extra/time-line/time-line.style.scss ***!
  \******************************************************/
/***/ (function(module, exports) {

eval("module.exports = \"/***********************************/\\n/**          Post Links           **/\\n/***********************************/\\n.post-links {\\n  margin-bottom: 0;\\n  font-size: 0.875rem;\\n  padding-left: 0; }\\n  .post-links::after {\\n    content: \\\"\\\";\\n    display: table;\\n    clear: both; }\\n  .post-links > li {\\n    float: left;\\n    list-style: none; }\\n    .post-links > li + li:before {\\n      color: #999;\\n      content: \\\"\\\\25cf\\\";\\n      padding: 0 8px; }\\n    .post-links > li > a {\\n      text-decoration: none;\\n      color: #999999; }\\n      .post-links > li > a:hover {\\n        color: #999999; }\\n  .post-links.no-separator > li + li {\\n    margin-left: 12px; }\\n    .post-links.no-separator > li + li:before {\\n      content: normal; }\\n\\n/***********************************/\\n/**          Post Comments           **/\\n/***********************************/\\n.post-comments {\\n  font-size: 0.875rem;\\n  padding-left: 0; }\\n  .post-comments::after {\\n    content: \\\"\\\";\\n    display: table;\\n    clear: both; }\\n  .post-links + .post-comments {\\n    margin-top: 0.5rem; }\\n  .post-comments > li {\\n    padding: 10px;\\n    border-top: 1px solid #e7e7e7;\\n    list-style: none; }\\n    .post-comments > li::after {\\n      content: \\\"\\\";\\n      display: table;\\n      clear: both; }\\n    .post-comments > li:last-child {\\n      padding-bottom: 0; }\\n  .post-comments p:last-child {\\n    margin-bottom: 0; }\\n  .post-comments .avatar {\\n    margin-top: 1px; }\\n  .post-comments .author {\\n    margin-top: 0;\\n    margin-bottom: 2px;\\n    color: #7ca9dd; }\\n  .post-comments .comment-body {\\n    overflow: auto; }\\n  .post-comments h6.author > small {\\n    font-size: 11px; }\\n  .widget > footer .post-comments {\\n    margin-left: -20px;\\n    margin-right: -20px; }\\n\\n/***********************************/\\n/**           Time Line           **/\\n/***********************************/\\n.timeline {\\n  position: relative;\\n  min-height: 100%;\\n  list-style: none;\\n  padding-left: 0;\\n  margin-bottom: -40px;\\n  /* content padding bottom */\\n  padding-bottom: 80px;\\n  /* the time line :) */ }\\n  .timeline > li::after {\\n    content: \\\"\\\";\\n    display: table;\\n    clear: both; }\\n  .timeline > li + li {\\n    margin-top: 30px; }\\n  .timeline:before {\\n    position: absolute;\\n    top: 0;\\n    bottom: 0;\\n    left: 24%;\\n    width: 8px;\\n    content: \\\" \\\";\\n    margin-left: -4px;\\n    background-color: #fff; }\\n    @media (min-width: 992px) {\\n      .timeline:before {\\n        left: 50%;\\n        margin-left: -4px; } }\\n\\n.event {\\n  background: #fff;\\n  border-radius: 0.25rem;\\n  padding: 20px 20px 0;\\n  position: relative; }\\n  .timeline .event {\\n    float: right;\\n    width: 68%; }\\n    .timeline .event:before {\\n      right: 100%;\\n      content: \\\" \\\";\\n      height: 0;\\n      width: 0;\\n      position: absolute;\\n      border: 10px solid transparent;\\n      border-right-color: #fff;\\n      top: 15px; }\\n  .event .post-comments {\\n    margin-left: -20px;\\n    margin-right: -20px; }\\n  .event > footer {\\n    margin: 20px -20px 0;\\n    padding: 10px 20px;\\n    border-bottom-left-radius: 0.25rem;\\n    border-bottom-right-radius: 0.25rem;\\n    background-color: #f3f3f3; }\\n    .event > footer::after {\\n      content: \\\"\\\";\\n      display: table;\\n      clear: both; }\\n    .event > footer .thumb {\\n      margin-left: 10px; }\\n  @media (min-width: 992px) {\\n    .timeline .event {\\n      width: 45%; }\\n    .timeline > li.on-left .event {\\n      float: left; }\\n      .timeline > li.on-left .event:before {\\n        right: auto;\\n        left: 100%;\\n        border-right-color: transparent;\\n        border-left-color: #fff; } }\\n\\n.timeline .event-time {\\n  float: left;\\n  width: 18%;\\n  margin-top: 5px;\\n  text-align: right; }\\n  .timeline .event-time > .date {\\n    display: block;\\n    font-size: 15px; }\\n  .timeline .event-time > .time {\\n    display: block;\\n    font-size: 1.25rem;\\n    font-weight: 400; }\\n\\n@media (min-width: 992px) {\\n  .timeline .event-time {\\n    width: 46%; }\\n  .timeline > li.on-left .event-time {\\n    float: right;\\n    text-align: left; } }\\n\\n.timeline .event-icon {\\n  position: absolute;\\n  left: 24%;\\n  width: 50px;\\n  height: 50px;\\n  line-height: 37px;\\n  margin-left: -25px;\\n  background-color: #fff;\\n  border: 7px solid #fff;\\n  border-radius: 50%;\\n  text-align: center; }\\n  .timeline .event-icon .glyphicon {\\n    top: 11px; }\\n  .timeline .event-icon.event-icon-danger {\\n    background-color: #dd5826;\\n    border-color: #e27045; }\\n  .timeline .event-icon.event-icon-warning {\\n    background-color: #f0b518;\\n    border-color: #f2c03a; }\\n  .timeline .event-icon.event-icon-success {\\n    background-color: #64bd63;\\n    border-color: #7dc87c; }\\n  .timeline .event-icon.event-icon-info {\\n    background-color: #5dc4bf;\\n    border-color: #77cec9; }\\n  .timeline .event-icon.event-icon-primary {\\n    background-color: #5d8fc2;\\n    border-color: #77a1cc; }\\n  .timeline .event-icon.event-icon-danger, .timeline .event-icon.event-icon-warning, .timeline .event-icon.event-icon-success, .timeline .event-icon.event-icon-info, .timeline .event-icon.event-icon-primary {\\n    color: #fff; }\\n  @media (min-width: 992px) {\\n    .timeline .event-icon {\\n      left: 50%; } }\\n  .timeline .event-icon > img {\\n    width: 36px;\\n    height: 36px;\\n    margin-top: -4px; }\\n\\n.event-heading {\\n  margin: 0 0 2px;\\n  font-weight: 600; }\\n  .event-heading > a {\\n    text-decoration: none;\\n    color: #7ca9dd; }\\n  .event-heading > small {\\n    font-weight: 600; }\\n    .event-heading > small > a {\\n      text-decoration: none;\\n      color: #999999; }\\n\\n.event-map {\\n  display: block;\\n  height: 200px;\\n  margin: 0 -20px -20px;\\n  overflow: visible !important; }\\n\\n.event-image {\\n  margin: 0 -20px -20px;\\n  max-height: 260px;\\n  overflow: hidden; }\\n  .event-image > img {\\n    max-width: 100%; }\\n\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEyNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvZXh0cmEvdGltZS1saW5lL3RpbWUtbGluZS5zdHlsZS5zY3NzP2ViMjkiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiogICAgICAgICAgUG9zdCBMaW5rcyAgICAgICAgICAgKiovXFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi5wb3N0LWxpbmtzIHtcXG4gIG1hcmdpbi1ib3R0b206IDA7XFxuICBmb250LXNpemU6IDAuODc1cmVtO1xcbiAgcGFkZGluZy1sZWZ0OiAwOyB9XFxuICAucG9zdC1saW5rczo6YWZ0ZXIge1xcbiAgICBjb250ZW50OiBcXFwiXFxcIjtcXG4gICAgZGlzcGxheTogdGFibGU7XFxuICAgIGNsZWFyOiBib3RoOyB9XFxuICAucG9zdC1saW5rcyA+IGxpIHtcXG4gICAgZmxvYXQ6IGxlZnQ7XFxuICAgIGxpc3Qtc3R5bGU6IG5vbmU7IH1cXG4gICAgLnBvc3QtbGlua3MgPiBsaSArIGxpOmJlZm9yZSB7XFxuICAgICAgY29sb3I6ICM5OTk7XFxuICAgICAgY29udGVudDogXFxcIlxcXFwyNWNmXFxcIjtcXG4gICAgICBwYWRkaW5nOiAwIDhweDsgfVxcbiAgICAucG9zdC1saW5rcyA+IGxpID4gYSB7XFxuICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgICAgIGNvbG9yOiAjOTk5OTk5OyB9XFxuICAgICAgLnBvc3QtbGlua3MgPiBsaSA+IGE6aG92ZXIge1xcbiAgICAgICAgY29sb3I6ICM5OTk5OTk7IH1cXG4gIC5wb3N0LWxpbmtzLm5vLXNlcGFyYXRvciA+IGxpICsgbGkge1xcbiAgICBtYXJnaW4tbGVmdDogMTJweDsgfVxcbiAgICAucG9zdC1saW5rcy5uby1zZXBhcmF0b3IgPiBsaSArIGxpOmJlZm9yZSB7XFxuICAgICAgY29udGVudDogbm9ybWFsOyB9XFxuXFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qKiAgICAgICAgICBQb3N0IENvbW1lbnRzICAgICAgICAgICAqKi9cXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuLnBvc3QtY29tbWVudHMge1xcbiAgZm9udC1zaXplOiAwLjg3NXJlbTtcXG4gIHBhZGRpbmctbGVmdDogMDsgfVxcbiAgLnBvc3QtY29tbWVudHM6OmFmdGVyIHtcXG4gICAgY29udGVudDogXFxcIlxcXCI7XFxuICAgIGRpc3BsYXk6IHRhYmxlO1xcbiAgICBjbGVhcjogYm90aDsgfVxcbiAgLnBvc3QtbGlua3MgKyAucG9zdC1jb21tZW50cyB7XFxuICAgIG1hcmdpbi10b3A6IDAuNXJlbTsgfVxcbiAgLnBvc3QtY29tbWVudHMgPiBsaSB7XFxuICAgIHBhZGRpbmc6IDEwcHg7XFxuICAgIGJvcmRlci10b3A6IDFweCBzb2xpZCAjZTdlN2U3O1xcbiAgICBsaXN0LXN0eWxlOiBub25lOyB9XFxuICAgIC5wb3N0LWNvbW1lbnRzID4gbGk6OmFmdGVyIHtcXG4gICAgICBjb250ZW50OiBcXFwiXFxcIjtcXG4gICAgICBkaXNwbGF5OiB0YWJsZTtcXG4gICAgICBjbGVhcjogYm90aDsgfVxcbiAgICAucG9zdC1jb21tZW50cyA+IGxpOmxhc3QtY2hpbGQge1xcbiAgICAgIHBhZGRpbmctYm90dG9tOiAwOyB9XFxuICAucG9zdC1jb21tZW50cyBwOmxhc3QtY2hpbGQge1xcbiAgICBtYXJnaW4tYm90dG9tOiAwOyB9XFxuICAucG9zdC1jb21tZW50cyAuYXZhdGFyIHtcXG4gICAgbWFyZ2luLXRvcDogMXB4OyB9XFxuICAucG9zdC1jb21tZW50cyAuYXV0aG9yIHtcXG4gICAgbWFyZ2luLXRvcDogMDtcXG4gICAgbWFyZ2luLWJvdHRvbTogMnB4O1xcbiAgICBjb2xvcjogIzdjYTlkZDsgfVxcbiAgLnBvc3QtY29tbWVudHMgLmNvbW1lbnQtYm9keSB7XFxuICAgIG92ZXJmbG93OiBhdXRvOyB9XFxuICAucG9zdC1jb21tZW50cyBoNi5hdXRob3IgPiBzbWFsbCB7XFxuICAgIGZvbnQtc2l6ZTogMTFweDsgfVxcbiAgLndpZGdldCA+IGZvb3RlciAucG9zdC1jb21tZW50cyB7XFxuICAgIG1hcmdpbi1sZWZ0OiAtMjBweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtMjBweDsgfVxcblxcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4vKiogICAgICAgICAgIFRpbWUgTGluZSAgICAgICAgICAgKiovXFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi50aW1lbGluZSB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBtaW4taGVpZ2h0OiAxMDAlO1xcbiAgbGlzdC1zdHlsZTogbm9uZTtcXG4gIHBhZGRpbmctbGVmdDogMDtcXG4gIG1hcmdpbi1ib3R0b206IC00MHB4O1xcbiAgLyogY29udGVudCBwYWRkaW5nIGJvdHRvbSAqL1xcbiAgcGFkZGluZy1ib3R0b206IDgwcHg7XFxuICAvKiB0aGUgdGltZSBsaW5lIDopICovIH1cXG4gIC50aW1lbGluZSA+IGxpOjphZnRlciB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFwiO1xcbiAgICBkaXNwbGF5OiB0YWJsZTtcXG4gICAgY2xlYXI6IGJvdGg7IH1cXG4gIC50aW1lbGluZSA+IGxpICsgbGkge1xcbiAgICBtYXJnaW4tdG9wOiAzMHB4OyB9XFxuICAudGltZWxpbmU6YmVmb3JlIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IDA7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgbGVmdDogMjQlO1xcbiAgICB3aWR0aDogOHB4O1xcbiAgICBjb250ZW50OiBcXFwiIFxcXCI7XFxuICAgIG1hcmdpbi1sZWZ0OiAtNHB4O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmOyB9XFxuICAgIEBtZWRpYSAobWluLXdpZHRoOiA5OTJweCkge1xcbiAgICAgIC50aW1lbGluZTpiZWZvcmUge1xcbiAgICAgICAgbGVmdDogNTAlO1xcbiAgICAgICAgbWFyZ2luLWxlZnQ6IC00cHg7IH0gfVxcblxcbi5ldmVudCB7XFxuICBiYWNrZ3JvdW5kOiAjZmZmO1xcbiAgYm9yZGVyLXJhZGl1czogMC4yNXJlbTtcXG4gIHBhZGRpbmc6IDIwcHggMjBweCAwO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlOyB9XFxuICAudGltZWxpbmUgLmV2ZW50IHtcXG4gICAgZmxvYXQ6IHJpZ2h0O1xcbiAgICB3aWR0aDogNjglOyB9XFxuICAgIC50aW1lbGluZSAuZXZlbnQ6YmVmb3JlIHtcXG4gICAgICByaWdodDogMTAwJTtcXG4gICAgICBjb250ZW50OiBcXFwiIFxcXCI7XFxuICAgICAgaGVpZ2h0OiAwO1xcbiAgICAgIHdpZHRoOiAwO1xcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICBib3JkZXI6IDEwcHggc29saWQgdHJhbnNwYXJlbnQ7XFxuICAgICAgYm9yZGVyLXJpZ2h0LWNvbG9yOiAjZmZmO1xcbiAgICAgIHRvcDogMTVweDsgfVxcbiAgLmV2ZW50IC5wb3N0LWNvbW1lbnRzIHtcXG4gICAgbWFyZ2luLWxlZnQ6IC0yMHB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IC0yMHB4OyB9XFxuICAuZXZlbnQgPiBmb290ZXIge1xcbiAgICBtYXJnaW46IDIwcHggLTIwcHggMDtcXG4gICAgcGFkZGluZzogMTBweCAyMHB4O1xcbiAgICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAwLjI1cmVtO1xcbiAgICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogMC4yNXJlbTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2YzZjNmMzsgfVxcbiAgICAuZXZlbnQgPiBmb290ZXI6OmFmdGVyIHtcXG4gICAgICBjb250ZW50OiBcXFwiXFxcIjtcXG4gICAgICBkaXNwbGF5OiB0YWJsZTtcXG4gICAgICBjbGVhcjogYm90aDsgfVxcbiAgICAuZXZlbnQgPiBmb290ZXIgLnRodW1iIHtcXG4gICAgICBtYXJnaW4tbGVmdDogMTBweDsgfVxcbiAgQG1lZGlhIChtaW4td2lkdGg6IDk5MnB4KSB7XFxuICAgIC50aW1lbGluZSAuZXZlbnQge1xcbiAgICAgIHdpZHRoOiA0NSU7IH1cXG4gICAgLnRpbWVsaW5lID4gbGkub24tbGVmdCAuZXZlbnQge1xcbiAgICAgIGZsb2F0OiBsZWZ0OyB9XFxuICAgICAgLnRpbWVsaW5lID4gbGkub24tbGVmdCAuZXZlbnQ6YmVmb3JlIHtcXG4gICAgICAgIHJpZ2h0OiBhdXRvO1xcbiAgICAgICAgbGVmdDogMTAwJTtcXG4gICAgICAgIGJvcmRlci1yaWdodC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgICAgICBib3JkZXItbGVmdC1jb2xvcjogI2ZmZjsgfSB9XFxuXFxuLnRpbWVsaW5lIC5ldmVudC10aW1lIHtcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgd2lkdGg6IDE4JTtcXG4gIG1hcmdpbi10b3A6IDVweDtcXG4gIHRleHQtYWxpZ246IHJpZ2h0OyB9XFxuICAudGltZWxpbmUgLmV2ZW50LXRpbWUgPiAuZGF0ZSB7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICBmb250LXNpemU6IDE1cHg7IH1cXG4gIC50aW1lbGluZSAuZXZlbnQtdGltZSA+IC50aW1lIHtcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICAgIGZvbnQtc2l6ZTogMS4yNXJlbTtcXG4gICAgZm9udC13ZWlnaHQ6IDQwMDsgfVxcblxcbkBtZWRpYSAobWluLXdpZHRoOiA5OTJweCkge1xcbiAgLnRpbWVsaW5lIC5ldmVudC10aW1lIHtcXG4gICAgd2lkdGg6IDQ2JTsgfVxcbiAgLnRpbWVsaW5lID4gbGkub24tbGVmdCAuZXZlbnQtdGltZSB7XFxuICAgIGZsb2F0OiByaWdodDtcXG4gICAgdGV4dC1hbGlnbjogbGVmdDsgfSB9XFxuXFxuLnRpbWVsaW5lIC5ldmVudC1pY29uIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGxlZnQ6IDI0JTtcXG4gIHdpZHRoOiA1MHB4O1xcbiAgaGVpZ2h0OiA1MHB4O1xcbiAgbGluZS1oZWlnaHQ6IDM3cHg7XFxuICBtYXJnaW4tbGVmdDogLTI1cHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbiAgYm9yZGVyOiA3cHggc29saWQgI2ZmZjtcXG4gIGJvcmRlci1yYWRpdXM6IDUwJTtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjsgfVxcbiAgLnRpbWVsaW5lIC5ldmVudC1pY29uIC5nbHlwaGljb24ge1xcbiAgICB0b3A6IDExcHg7IH1cXG4gIC50aW1lbGluZSAuZXZlbnQtaWNvbi5ldmVudC1pY29uLWRhbmdlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNkZDU4MjY7XFxuICAgIGJvcmRlci1jb2xvcjogI2UyNzA0NTsgfVxcbiAgLnRpbWVsaW5lIC5ldmVudC1pY29uLmV2ZW50LWljb24td2FybmluZyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmMGI1MTg7XFxuICAgIGJvcmRlci1jb2xvcjogI2YyYzAzYTsgfVxcbiAgLnRpbWVsaW5lIC5ldmVudC1pY29uLmV2ZW50LWljb24tc3VjY2VzcyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICM2NGJkNjM7XFxuICAgIGJvcmRlci1jb2xvcjogIzdkYzg3YzsgfVxcbiAgLnRpbWVsaW5lIC5ldmVudC1pY29uLmV2ZW50LWljb24taW5mbyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICM1ZGM0YmY7XFxuICAgIGJvcmRlci1jb2xvcjogIzc3Y2VjOTsgfVxcbiAgLnRpbWVsaW5lIC5ldmVudC1pY29uLmV2ZW50LWljb24tcHJpbWFyeSB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICM1ZDhmYzI7XFxuICAgIGJvcmRlci1jb2xvcjogIzc3YTFjYzsgfVxcbiAgLnRpbWVsaW5lIC5ldmVudC1pY29uLmV2ZW50LWljb24tZGFuZ2VyLCAudGltZWxpbmUgLmV2ZW50LWljb24uZXZlbnQtaWNvbi13YXJuaW5nLCAudGltZWxpbmUgLmV2ZW50LWljb24uZXZlbnQtaWNvbi1zdWNjZXNzLCAudGltZWxpbmUgLmV2ZW50LWljb24uZXZlbnQtaWNvbi1pbmZvLCAudGltZWxpbmUgLmV2ZW50LWljb24uZXZlbnQtaWNvbi1wcmltYXJ5IHtcXG4gICAgY29sb3I6ICNmZmY7IH1cXG4gIEBtZWRpYSAobWluLXdpZHRoOiA5OTJweCkge1xcbiAgICAudGltZWxpbmUgLmV2ZW50LWljb24ge1xcbiAgICAgIGxlZnQ6IDUwJTsgfSB9XFxuICAudGltZWxpbmUgLmV2ZW50LWljb24gPiBpbWcge1xcbiAgICB3aWR0aDogMzZweDtcXG4gICAgaGVpZ2h0OiAzNnB4O1xcbiAgICBtYXJnaW4tdG9wOiAtNHB4OyB9XFxuXFxuLmV2ZW50LWhlYWRpbmcge1xcbiAgbWFyZ2luOiAwIDAgMnB4O1xcbiAgZm9udC13ZWlnaHQ6IDYwMDsgfVxcbiAgLmV2ZW50LWhlYWRpbmcgPiBhIHtcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgICBjb2xvcjogIzdjYTlkZDsgfVxcbiAgLmV2ZW50LWhlYWRpbmcgPiBzbWFsbCB7XFxuICAgIGZvbnQtd2VpZ2h0OiA2MDA7IH1cXG4gICAgLmV2ZW50LWhlYWRpbmcgPiBzbWFsbCA+IGEge1xcbiAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gICAgICBjb2xvcjogIzk5OTk5OTsgfVxcblxcbi5ldmVudC1tYXAge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBoZWlnaHQ6IDIwMHB4O1xcbiAgbWFyZ2luOiAwIC0yMHB4IC0yMHB4O1xcbiAgb3ZlcmZsb3c6IHZpc2libGUgIWltcG9ydGFudDsgfVxcblxcbi5ldmVudC1pbWFnZSB7XFxuICBtYXJnaW46IDAgLTIwcHggLTIwcHg7XFxuICBtYXgtaGVpZ2h0OiAyNjBweDtcXG4gIG92ZXJmbG93OiBoaWRkZW47IH1cXG4gIC5ldmVudC1pbWFnZSA+IGltZyB7XFxuICAgIG1heC13aWR0aDogMTAwJTsgfVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL2V4dHJhL3RpbWUtbGluZS90aW1lLWxpbmUuc3R5bGUuc2Nzc1xuLy8gbW9kdWxlIGlkID0gMTEyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDUiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 1145:
/* unknown exports provided */
/* all exports used */
/*!*******************************************************!*\
  !*** ./src/app/extra/calendar/calendar.template.html ***!
  \*******************************************************/
/***/ (function(module, exports) {

eval("module.exports = \"<ol class=\\\"breadcrumb\\\">\\r\\n  <li class=\\\"breadcrumb-item\\\">YOU ARE HERE</li>\\r\\n  <li class=\\\"breadcrumb-item active\\\">Calendar</li>\\r\\n</ol>\\r\\n<div>\\r\\n  <div class=\\\"row\\\">\\r\\n    <div class=\\\"col-xl-4 col-xs-12\\\">\\r\\n      <h1 class=\\\"page-title\\\">{{currentMonth()}} - <span class=\\\"fw-semi-bold\\\">{{currentDay()}}</span></h1>\\r\\n    </div>\\r\\n  </div>\\r\\n  <div class=\\\"row\\\">\\r\\n    <div class=\\\"col-lg-3 col-xl-4 col-xs-12\\\">\\r\\n      <h4>Draggable <span class=\\\"fw-semi-bold\\\">Events</span></h4>\\r\\n      <p>Just drap and drop events from there directly into the calendar.</p>\\r\\n      <div class=\\\"calendar-external-events mb-lg\\\">\\r\\n        <div class='external-event draggable' data-event-class=\\\"bg-success text-white\\\">\\r\\n          <i class=\\\"fa fa-circle fa-fw text-success ml-xs\\\"></i>\\r\\n          Make a tea\\r\\n        </div>\\r\\n        <div class='external-event draggable' data-event-class=\\\"bg-warning text-white\\\">\\r\\n          <i class=\\\"fa fa-circle fa-fw text-warning ml-xs\\\"></i>\\r\\n          Open windows\\r\\n        </div>\\r\\n        <div class='external-event draggable' data-event-class=\\\"bg-gray text-white\\\">\\r\\n          <i class=\\\"fa fa-circle-o fa-fw text-gray-light ml-xs\\\"></i>\\r\\n          Some stuff\\r\\n        </div>\\r\\n        <div class='external-event draggable' data-event-class=\\\"bg-danger text-white\\\">\\r\\n          <i class=\\\"fa fa-square fa-fw text-danger ml-xs\\\"></i>\\r\\n          Study UX engineering\\r\\n        </div>\\r\\n        <div class='external-event draggable' data-event-class=\\\"bg-gray text-white\\\">\\r\\n          <i class=\\\"fa fa-circle-o fa-fw text-gray-light ml-xs\\\"></i>\\r\\n          Another stuff\\r\\n        </div>\\r\\n      </div>\\r\\n    </div>\\r\\n    <div class=\\\"col-lg-9 col-xl-8 col-xs-12\\\">\\r\\n      <section class=\\\"widget widget-calendar\\\">\\r\\n        <div class=\\\"widget-body\\\">\\r\\n          <div class=\\\"calendar-controls\\\">\\r\\n            <div class=\\\"btn-group \\\">\\r\\n              <button class=\\\"btn btn-default\\\" (click)=\\\"prev()\\\"><i class=\\\"fa fa-angle-left\\\"></i></button>\\r\\n              <button class=\\\"btn btn-default\\\" (click)=\\\"next()\\\"><i class=\\\"fa fa-angle-right\\\"></i></button>\\r\\n            </div>\\r\\n            <div class=\\\"btn-group pull-right\\\" data-toggle=\\\"buttons\\\">\\r\\n              <label class=\\\"btn btn-default active\\\" (click)=\\\"changeView('month')\\\">\\r\\n                <input type=\\\"radio\\\" name=\\\"view\\\" value=\\\"month\\\"> Month\\r\\n              </label>\\r\\n              <label class=\\\"btn btn-default\\\" (click)=\\\"changeView('agendaWeek')\\\">\\r\\n                <input type=\\\"radio\\\" name=\\\"view\\\" value=\\\"agendaWeek\\\"> Week\\r\\n              </label>\\r\\n              <label class=\\\"btn btn-default\\\" (click)=\\\"changeView('agendaDay')\\\">\\r\\n                <input type=\\\"radio\\\" name=\\\"view\\\" value=\\\"agendaDay\\\"> Day\\r\\n              </label>\\r\\n            </div>\\r\\n          </div>\\r\\n          <div id=\\\"calendar\\\"></div>\\r\\n        </div>\\r\\n      </section>\\r\\n      <div bsModal #modalWindow=\\\"bs-modal\\\" class=\\\"modal fade\\\" tabindex=\\\"-1\\\" role=\\\"dialog\\\" aria-labelledby=\\\"mySmallModalLabel\\\" aria-hidden=\\\"true\\\">\\r\\n        <div class=\\\"modal-dialog modal-sm\\\" role=\\\"document\\\">\\r\\n          <div *ngIf=\\\"calendarEvent === 'create'\\\" class=\\\"modal-content\\\">\\r\\n            <div class=\\\"modal-header\\\">\\r\\n              <button type=\\\"button\\\" class=\\\"close\\\" (click)=\\\"modalWindow.hide()\\\" aria-hidden=\\\"true\\\"></button>\\r\\n              <h5 class=\\\"modal-title\\\">New Event</h5>\\r\\n              <p class=\\\"fs-mini text-muted mt-sm\\\">\\r\\n                Just enter event name to create a new one\\r\\n              </p>\\r\\n            </div>\\r\\n            <div class=\\\"modal-body bg-gray-lighter\\\">\\r\\n              <div class=\\\"form-group\\\">\\r\\n                <input type=\\\"text\\\" [(ngModel)]=\\\"event.title\\\" class=\\\"form-control input-no-border\\\"\\r\\n                       placeholder=\\\"Name\\\">\\r\\n              </div>\\r\\n            </div>\\r\\n            <div class=\\\"modal-footer no-border\\\">\\r\\n              <button (click)=\\\"modalWindow.hide()\\\" class=\\\"btn btn-default\\\">Cancel</button>\\r\\n              <button (click)=\\\"createEvent()\\\" class=\\\"btn btn-success\\\">OK</button>\\r\\n            </div>\\r\\n          </div>\\r\\n          <div *ngIf=\\\"calendarEvent === 'show'\\\" class=\\\"modal-content\\\">\\r\\n            <div class=\\\"modal-header\\\">\\r\\n              <button type=\\\"button\\\" class=\\\"close\\\" (click)=\\\"modalWindow.hide()\\\" aria-hidden=\\\"true\\\"></button>\\r\\n              <h5 *ngIf=\\\"event.title\\\" class=\\\"modal-title\\\">{{ event.title }}</h5>\\r\\n            </div>\\r\\n            <div class=\\\"modal-body fs-mini\\\">\\r\\n              <p><i class=\\\"fa fa-calendar text-muted fs-sm\\\"></i> &nbsp; {{ event.start }}\\r\\n              <p *ngIf=\\\"event.end\\\">\\r\\n                <i class=\\\"fa fa-clock-o text-muted fs-sm\\\"></i> &nbsp; {{ event.end }}\\r\\n              </p>\\r\\n              <p *ngIf=\\\"event.description\\\">{{ event.description }}</p>\\r\\n            </div>\\r\\n            <div class=\\\"modal-footer no-border\\\">\\r\\n              <button type=\\\"button\\\" class=\\\"btn btn-default btn-sm\\\" (click)=\\\"modalWindow.hide()\\\">OK</button>\\r\\n            </div>\\r\\n          </div>\\r\\n        </div>\\r\\n      </div>\\r\\n    </div>\\r\\n  </div>\\r\\n</div>\\r\\n\\r\\n\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE0NS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvZXh0cmEvY2FsZW5kYXIvY2FsZW5kYXIudGVtcGxhdGUuaHRtbD8xYmViIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCI8b2wgY2xhc3M9XFxcImJyZWFkY3J1bWJcXFwiPlxcclxcbiAgPGxpIGNsYXNzPVxcXCJicmVhZGNydW1iLWl0ZW1cXFwiPllPVSBBUkUgSEVSRTwvbGk+XFxyXFxuICA8bGkgY2xhc3M9XFxcImJyZWFkY3J1bWItaXRlbSBhY3RpdmVcXFwiPkNhbGVuZGFyPC9saT5cXHJcXG48L29sPlxcclxcbjxkaXY+XFxyXFxuICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjb2wteGwtNCBjb2wteHMtMTJcXFwiPlxcclxcbiAgICAgIDxoMSBjbGFzcz1cXFwicGFnZS10aXRsZVxcXCI+e3tjdXJyZW50TW9udGgoKX19IC0gPHNwYW4gY2xhc3M9XFxcImZ3LXNlbWktYm9sZFxcXCI+e3tjdXJyZW50RGF5KCl9fTwvc3Bhbj48L2gxPlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gIDwvZGl2PlxcclxcbiAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwiY29sLWxnLTMgY29sLXhsLTQgY29sLXhzLTEyXFxcIj5cXHJcXG4gICAgICA8aDQ+RHJhZ2dhYmxlIDxzcGFuIGNsYXNzPVxcXCJmdy1zZW1pLWJvbGRcXFwiPkV2ZW50czwvc3Bhbj48L2g0PlxcclxcbiAgICAgIDxwPkp1c3QgZHJhcCBhbmQgZHJvcCBldmVudHMgZnJvbSB0aGVyZSBkaXJlY3RseSBpbnRvIHRoZSBjYWxlbmRhci48L3A+XFxyXFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY2FsZW5kYXItZXh0ZXJuYWwtZXZlbnRzIG1iLWxnXFxcIj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9J2V4dGVybmFsLWV2ZW50IGRyYWdnYWJsZScgZGF0YS1ldmVudC1jbGFzcz1cXFwiYmctc3VjY2VzcyB0ZXh0LXdoaXRlXFxcIj5cXHJcXG4gICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWNpcmNsZSBmYS1mdyB0ZXh0LXN1Y2Nlc3MgbWwteHNcXFwiPjwvaT5cXHJcXG4gICAgICAgICAgTWFrZSBhIHRlYVxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPSdleHRlcm5hbC1ldmVudCBkcmFnZ2FibGUnIGRhdGEtZXZlbnQtY2xhc3M9XFxcImJnLXdhcm5pbmcgdGV4dC13aGl0ZVxcXCI+XFxyXFxuICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1jaXJjbGUgZmEtZncgdGV4dC13YXJuaW5nIG1sLXhzXFxcIj48L2k+XFxyXFxuICAgICAgICAgIE9wZW4gd2luZG93c1xcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPSdleHRlcm5hbC1ldmVudCBkcmFnZ2FibGUnIGRhdGEtZXZlbnQtY2xhc3M9XFxcImJnLWdyYXkgdGV4dC13aGl0ZVxcXCI+XFxyXFxuICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1jaXJjbGUtbyBmYS1mdyB0ZXh0LWdyYXktbGlnaHQgbWwteHNcXFwiPjwvaT5cXHJcXG4gICAgICAgICAgU29tZSBzdHVmZlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPSdleHRlcm5hbC1ldmVudCBkcmFnZ2FibGUnIGRhdGEtZXZlbnQtY2xhc3M9XFxcImJnLWRhbmdlciB0ZXh0LXdoaXRlXFxcIj5cXHJcXG4gICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLXNxdWFyZSBmYS1mdyB0ZXh0LWRhbmdlciBtbC14c1xcXCI+PC9pPlxcclxcbiAgICAgICAgICBTdHVkeSBVWCBlbmdpbmVlcmluZ1xcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPSdleHRlcm5hbC1ldmVudCBkcmFnZ2FibGUnIGRhdGEtZXZlbnQtY2xhc3M9XFxcImJnLWdyYXkgdGV4dC13aGl0ZVxcXCI+XFxyXFxuICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1jaXJjbGUtbyBmYS1mdyB0ZXh0LWdyYXktbGlnaHQgbWwteHNcXFwiPjwvaT5cXHJcXG4gICAgICAgICAgQW5vdGhlciBzdHVmZlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgPC9kaXY+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbGctOSBjb2wteGwtOCBjb2wteHMtMTJcXFwiPlxcclxcbiAgICAgIDxzZWN0aW9uIGNsYXNzPVxcXCJ3aWRnZXQgd2lkZ2V0LWNhbGVuZGFyXFxcIj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcIndpZGdldC1ib2R5XFxcIj5cXHJcXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY2FsZW5kYXItY29udHJvbHNcXFwiPlxcclxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImJ0bi1ncm91cCBcXFwiPlxcclxcbiAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0XFxcIiAoY2xpY2spPVxcXCJwcmV2KClcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1hbmdsZS1sZWZ0XFxcIj48L2k+PC9idXR0b24+XFxyXFxuICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHRcXFwiIChjbGljayk9XFxcIm5leHQoKVxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLWFuZ2xlLXJpZ2h0XFxcIj48L2k+PC9idXR0b24+XFxyXFxuICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiYnRuLWdyb3VwIHB1bGwtcmlnaHRcXFwiIGRhdGEtdG9nZ2xlPVxcXCJidXR0b25zXFxcIj5cXHJcXG4gICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IGFjdGl2ZVxcXCIgKGNsaWNrKT1cXFwiY2hhbmdlVmlldygnbW9udGgnKVxcXCI+XFxyXFxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJyYWRpb1xcXCIgbmFtZT1cXFwidmlld1xcXCIgdmFsdWU9XFxcIm1vbnRoXFxcIj4gTW9udGhcXHJcXG4gICAgICAgICAgICAgIDwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdFxcXCIgKGNsaWNrKT1cXFwiY2hhbmdlVmlldygnYWdlbmRhV2VlaycpXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcInJhZGlvXFxcIiBuYW1lPVxcXCJ2aWV3XFxcIiB2YWx1ZT1cXFwiYWdlbmRhV2Vla1xcXCI+IFdlZWtcXHJcXG4gICAgICAgICAgICAgIDwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdFxcXCIgKGNsaWNrKT1cXFwiY2hhbmdlVmlldygnYWdlbmRhRGF5JylcXFwiPlxcclxcbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwicmFkaW9cXFwiIG5hbWU9XFxcInZpZXdcXFwiIHZhbHVlPVxcXCJhZ2VuZGFEYXlcXFwiPiBEYXlcXHJcXG4gICAgICAgICAgICAgIDwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICA8ZGl2IGlkPVxcXCJjYWxlbmRhclxcXCI+PC9kaXY+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICA8L3NlY3Rpb24+XFxyXFxuICAgICAgPGRpdiBic01vZGFsICNtb2RhbFdpbmRvdz1cXFwiYnMtbW9kYWxcXFwiIGNsYXNzPVxcXCJtb2RhbCBmYWRlXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiIHJvbGU9XFxcImRpYWxvZ1xcXCIgYXJpYS1sYWJlbGxlZGJ5PVxcXCJteVNtYWxsTW9kYWxMYWJlbFxcXCIgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiPlxcclxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwibW9kYWwtZGlhbG9nIG1vZGFsLXNtXFxcIiByb2xlPVxcXCJkb2N1bWVudFxcXCI+XFxyXFxuICAgICAgICAgIDxkaXYgKm5nSWY9XFxcImNhbGVuZGFyRXZlbnQgPT09ICdjcmVhdGUnXFxcIiBjbGFzcz1cXFwibW9kYWwtY29udGVudFxcXCI+XFxyXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwibW9kYWwtaGVhZGVyXFxcIj5cXHJcXG4gICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiY2xvc2VcXFwiIChjbGljayk9XFxcIm1vZGFsV2luZG93LmhpZGUoKVxcXCIgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiPsOXPC9idXR0b24+XFxyXFxuICAgICAgICAgICAgICA8aDUgY2xhc3M9XFxcIm1vZGFsLXRpdGxlXFxcIj5OZXcgRXZlbnQ8L2g1PlxcclxcbiAgICAgICAgICAgICAgPHAgY2xhc3M9XFxcImZzLW1pbmkgdGV4dC1tdXRlZCBtdC1zbVxcXCI+XFxyXFxuICAgICAgICAgICAgICAgIEp1c3QgZW50ZXIgZXZlbnQgbmFtZSB0byBjcmVhdGUgYSBuZXcgb25lXFxyXFxuICAgICAgICAgICAgICA8L3A+XFxyXFxuICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwibW9kYWwtYm9keSBiZy1ncmF5LWxpZ2h0ZXJcXFwiPlxcclxcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBbKG5nTW9kZWwpXT1cXFwiZXZlbnQudGl0bGVcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2wgaW5wdXQtbm8tYm9yZGVyXFxcIlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XFxcIk5hbWVcXFwiPlxcclxcbiAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwibW9kYWwtZm9vdGVyIG5vLWJvcmRlclxcXCI+XFxyXFxuICAgICAgICAgICAgICA8YnV0dG9uIChjbGljayk9XFxcIm1vZGFsV2luZG93LmhpZGUoKVxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdFxcXCI+Q2FuY2VsPC9idXR0b24+XFxyXFxuICAgICAgICAgICAgICA8YnV0dG9uIChjbGljayk9XFxcImNyZWF0ZUV2ZW50KClcXFwiIGNsYXNzPVxcXCJidG4gYnRuLXN1Y2Nlc3NcXFwiPk9LPC9idXR0b24+XFxyXFxuICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICA8ZGl2ICpuZ0lmPVxcXCJjYWxlbmRhckV2ZW50ID09PSAnc2hvdydcXFwiIGNsYXNzPVxcXCJtb2RhbC1jb250ZW50XFxcIj5cXHJcXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1oZWFkZXJcXFwiPlxcclxcbiAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJjbG9zZVxcXCIgKGNsaWNrKT1cXFwibW9kYWxXaW5kb3cuaGlkZSgpXFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+w5c8L2J1dHRvbj5cXHJcXG4gICAgICAgICAgICAgIDxoNSAqbmdJZj1cXFwiZXZlbnQudGl0bGVcXFwiIGNsYXNzPVxcXCJtb2RhbC10aXRsZVxcXCI+e3sgZXZlbnQudGl0bGUgfX08L2g1PlxcclxcbiAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWJvZHkgZnMtbWluaVxcXCI+XFxyXFxuICAgICAgICAgICAgICA8cD48aSBjbGFzcz1cXFwiZmEgZmEtY2FsZW5kYXIgdGV4dC1tdXRlZCBmcy1zbVxcXCI+PC9pPiAmbmJzcDsge3sgZXZlbnQuc3RhcnQgfX1cXHJcXG4gICAgICAgICAgICAgIDxwICpuZ0lmPVxcXCJldmVudC5lbmRcXFwiPlxcclxcbiAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtY2xvY2stbyB0ZXh0LW11dGVkIGZzLXNtXFxcIj48L2k+ICZuYnNwOyB7eyBldmVudC5lbmQgfX1cXHJcXG4gICAgICAgICAgICAgIDwvcD5cXHJcXG4gICAgICAgICAgICAgIDxwICpuZ0lmPVxcXCJldmVudC5kZXNjcmlwdGlvblxcXCI+e3sgZXZlbnQuZGVzY3JpcHRpb24gfX08L3A+XFxyXFxuICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwibW9kYWwtZm9vdGVyIG5vLWJvcmRlclxcXCI+XFxyXFxuICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCBidG4tc21cXFwiIChjbGljayk9XFxcIm1vZGFsV2luZG93LmhpZGUoKVxcXCI+T0s8L2J1dHRvbj5cXHJcXG4gICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICA8L2Rpdj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICA8L2Rpdj5cXHJcXG48L2Rpdj5cXHJcXG5cXHJcXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2FwcC9leHRyYS9jYWxlbmRhci9jYWxlbmRhci50ZW1wbGF0ZS5odG1sXG4vLyBtb2R1bGUgaWQgPSAxMTQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gNSJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 1146:
/* unknown exports provided */
/* all exports used */
/*!*****************************************************!*\
  !*** ./src/app/extra/gallery/gallery.template.html ***!
  \*****************************************************/
/***/ (function(module, exports) {

eval("module.exports = \"<ol class=\\\"breadcrumb\\\">\\r\\n  <li class=\\\"breadcrumb-item\\\">YOU ARE HERE</li>\\r\\n  <li class=\\\"breadcrumb-item active\\\">Gallery</li>\\r\\n</ol>\\r\\n<h1 class=\\\"page-title\\\">Media - <span class=\\\"fw-semi-bold\\\">Images</span></h1>\\r\\n\\r\\n<div>\\r\\n  <div class=\\\"clearfix mb-lg {{abc}}\\\">\\r\\n    <div class=\\\"btn-group m-b-20\\\">\\r\\n        <span class=\\\"btn btn-default\\\" [ngClass]=\\\"{'active': activeGroup == 'all'}\\\"\\r\\n              (click)=\\\"activeGroupSelected('all')\\\">All</span>\\r\\n        <span class=\\\"btn btn-default\\\" [ngClass]=\\\"{'active': activeGroup == 'nature'}\\\"\\r\\n              (click)=\\\"activeGroupSelected('nature')\\\">Nature</span>\\r\\n        <span class=\\\"btn btn-default\\\" [ngClass]=\\\"{'active': activeGroup == 'people'}\\\"\\r\\n              (click)=\\\"activeGroupSelected('people')\\\">People</span>\\r\\n        <span class=\\\"btn btn-default\\\" [ngClass]=\\\"{'active': activeGroup == 'space'}\\\"\\r\\n              (click)= \\\"activeGroupSelected('space')\\\">Space</span>\\r\\n    </div>\\r\\n    <div class=\\\"float-xs-right m-b-20\\\">\\r\\n      <div class=\\\"btn-group\\\">\\r\\n                <span class=\\\"btn btn-default\\\" [ngClass]=\\\"{'active': order == false}\\\"\\r\\n                      (click)=\\\"orderSelected(false)\\\"><i class=\\\"fa fa-sort-numeric-asc\\\"></i></span>\\r\\n                <span class=\\\"btn btn-default\\\"  [ngClass]=\\\"{'active': order == true}\\\"\\r\\n                      (click)=\\\"orderSelected(true)\\\"><i class=\\\"fa fa-sort-numeric-desc\\\"></i></span>\\r\\n      </div>\\r\\n    </div>\\r\\n  </div>\\r\\n  <div class=\\\"bs3-row gallery\\\" id=\\\"magnific\\\">\\r\\n    <div *ngFor=\\\"let item of items\\\"\\r\\n         class=\\\"bs3-col-md-6 bs3-col-lg-3 bs3-col-xs-12 gallery-item\\\" attr.data-title=\\\"{{ item.name }}\\\" attr.data-groups=\\\"{{ item.groups[0] }}\\\">\\r\\n      <figure class=\\\"figure img-thumbnail\\\">\\r\\n        <a href=\\\"{{item.src}}\\\"><img class=\\\"figure-img\\\" src=\\\"{{item.src}}\\\" alt=\\\"...\\\"></a>\\r\\n        <figcaption class=\\\"figure-caption\\\">\\r\\n          <h6 class=\\\"mt-0 mb-xs\\\">{{item.name}}</h6>\\r\\n          <ul class=\\\"post-links\\\">\\r\\n            <li><a href=\\\"#\\\">{{item.date}}</a></li>\\r\\n            <li><a href=\\\"#\\\"><span class=\\\"text-danger\\\"><i class=\\\"fa {{item.like ? 'fa-heart' : 'fa-heart-o'}}\\\"></i> Like</span></a></li>\\r\\n            <li><a href=\\\"#\\\">Details</a></li>\\r\\n          </ul>\\r\\n        </figcaption>\\r\\n      </figure>\\r\\n    </div>\\r\\n    <div class=\\\"bs3-col-md-6 bs3-col-lg-3 bs3-col-xs-12 js-shuffle-sizer\\\"></div>\\r\\n  </div>\\r\\n</div>\\r\\n\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE0Ni5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvZXh0cmEvZ2FsbGVyeS9nYWxsZXJ5LnRlbXBsYXRlLmh0bWw/NjI1MSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiPG9sIGNsYXNzPVxcXCJicmVhZGNydW1iXFxcIj5cXHJcXG4gIDxsaSBjbGFzcz1cXFwiYnJlYWRjcnVtYi1pdGVtXFxcIj5ZT1UgQVJFIEhFUkU8L2xpPlxcclxcbiAgPGxpIGNsYXNzPVxcXCJicmVhZGNydW1iLWl0ZW0gYWN0aXZlXFxcIj5HYWxsZXJ5PC9saT5cXHJcXG48L29sPlxcclxcbjxoMSBjbGFzcz1cXFwicGFnZS10aXRsZVxcXCI+TWVkaWEgLSA8c3BhbiBjbGFzcz1cXFwiZnctc2VtaS1ib2xkXFxcIj5JbWFnZXM8L3NwYW4+PC9oMT5cXHJcXG5cXHJcXG48ZGl2PlxcclxcbiAgPGRpdiBjbGFzcz1cXFwiY2xlYXJmaXggbWItbGcge3thYmN9fVxcXCI+XFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcImJ0bi1ncm91cCBtLWItMjBcXFwiPlxcclxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdFxcXCIgW25nQ2xhc3NdPVxcXCJ7J2FjdGl2ZSc6IGFjdGl2ZUdyb3VwID09ICdhbGwnfVxcXCJcXHJcXG4gICAgICAgICAgICAgIChjbGljayk9XFxcImFjdGl2ZUdyb3VwU2VsZWN0ZWQoJ2FsbCcpXFxcIj5BbGw8L3NwYW4+XFxyXFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0XFxcIiBbbmdDbGFzc109XFxcInsnYWN0aXZlJzogYWN0aXZlR3JvdXAgPT0gJ25hdHVyZSd9XFxcIlxcclxcbiAgICAgICAgICAgICAgKGNsaWNrKT1cXFwiYWN0aXZlR3JvdXBTZWxlY3RlZCgnbmF0dXJlJylcXFwiPk5hdHVyZTwvc3Bhbj5cXHJcXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHRcXFwiIFtuZ0NsYXNzXT1cXFwieydhY3RpdmUnOiBhY3RpdmVHcm91cCA9PSAncGVvcGxlJ31cXFwiXFxyXFxuICAgICAgICAgICAgICAoY2xpY2spPVxcXCJhY3RpdmVHcm91cFNlbGVjdGVkKCdwZW9wbGUnKVxcXCI+UGVvcGxlPC9zcGFuPlxcclxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdFxcXCIgW25nQ2xhc3NdPVxcXCJ7J2FjdGl2ZSc6IGFjdGl2ZUdyb3VwID09ICdzcGFjZSd9XFxcIlxcclxcbiAgICAgICAgICAgICAgKGNsaWNrKT0gXFxcImFjdGl2ZUdyb3VwU2VsZWN0ZWQoJ3NwYWNlJylcXFwiPlNwYWNlPC9zcGFuPlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwiZmxvYXQteHMtcmlnaHQgbS1iLTIwXFxcIj5cXHJcXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJidG4tZ3JvdXBcXFwiPlxcclxcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0XFxcIiBbbmdDbGFzc109XFxcInsnYWN0aXZlJzogb3JkZXIgPT0gZmFsc2V9XFxcIlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVxcXCJvcmRlclNlbGVjdGVkKGZhbHNlKVxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLXNvcnQtbnVtZXJpYy1hc2NcXFwiPjwvaT48L3NwYW4+XFxyXFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHRcXFwiICBbbmdDbGFzc109XFxcInsnYWN0aXZlJzogb3JkZXIgPT0gdHJ1ZX1cXFwiXFxyXFxuICAgICAgICAgICAgICAgICAgICAgIChjbGljayk9XFxcIm9yZGVyU2VsZWN0ZWQodHJ1ZSlcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1zb3J0LW51bWVyaWMtZGVzY1xcXCI+PC9pPjwvc3Bhbj5cXHJcXG4gICAgICA8L2Rpdj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICA8L2Rpdj5cXHJcXG4gIDxkaXYgY2xhc3M9XFxcImJzMy1yb3cgZ2FsbGVyeVxcXCIgaWQ9XFxcIm1hZ25pZmljXFxcIj5cXHJcXG4gICAgPGRpdiAqbmdGb3I9XFxcImxldCBpdGVtIG9mIGl0ZW1zXFxcIlxcclxcbiAgICAgICAgIGNsYXNzPVxcXCJiczMtY29sLW1kLTYgYnMzLWNvbC1sZy0zIGJzMy1jb2wteHMtMTIgZ2FsbGVyeS1pdGVtXFxcIiBhdHRyLmRhdGEtdGl0bGU9XFxcInt7IGl0ZW0ubmFtZSB9fVxcXCIgYXR0ci5kYXRhLWdyb3Vwcz1cXFwie3sgaXRlbS5ncm91cHNbMF0gfX1cXFwiPlxcclxcbiAgICAgIDxmaWd1cmUgY2xhc3M9XFxcImZpZ3VyZSBpbWctdGh1bWJuYWlsXFxcIj5cXHJcXG4gICAgICAgIDxhIGhyZWY9XFxcInt7aXRlbS5zcmN9fVxcXCI+PGltZyBjbGFzcz1cXFwiZmlndXJlLWltZ1xcXCIgc3JjPVxcXCJ7e2l0ZW0uc3JjfX1cXFwiIGFsdD1cXFwiLi4uXFxcIj48L2E+XFxyXFxuICAgICAgICA8ZmlnY2FwdGlvbiBjbGFzcz1cXFwiZmlndXJlLWNhcHRpb25cXFwiPlxcclxcbiAgICAgICAgICA8aDYgY2xhc3M9XFxcIm10LTAgbWIteHNcXFwiPnt7aXRlbS5uYW1lfX08L2g2PlxcclxcbiAgICAgICAgICA8dWwgY2xhc3M9XFxcInBvc3QtbGlua3NcXFwiPlxcclxcbiAgICAgICAgICAgIDxsaT48YSBocmVmPVxcXCIjXFxcIj57e2l0ZW0uZGF0ZX19PC9hPjwvbGk+XFxyXFxuICAgICAgICAgICAgPGxpPjxhIGhyZWY9XFxcIiNcXFwiPjxzcGFuIGNsYXNzPVxcXCJ0ZXh0LWRhbmdlclxcXCI+PGkgY2xhc3M9XFxcImZhIHt7aXRlbS5saWtlID8gJ2ZhLWhlYXJ0JyA6ICdmYS1oZWFydC1vJ319XFxcIj48L2k+IExpa2U8L3NwYW4+PC9hPjwvbGk+XFxyXFxuICAgICAgICAgICAgPGxpPjxhIGhyZWY9XFxcIiNcXFwiPkRldGFpbHM8L2E+PC9saT5cXHJcXG4gICAgICAgICAgPC91bD5cXHJcXG4gICAgICAgIDwvZmlnY2FwdGlvbj5cXHJcXG4gICAgICA8L2ZpZ3VyZT5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcImJzMy1jb2wtbWQtNiBiczMtY29sLWxnLTMgYnMzLWNvbC14cy0xMiBqcy1zaHVmZmxlLXNpemVyXFxcIj48L2Rpdj5cXHJcXG4gIDwvZGl2PlxcclxcbjwvZGl2PlxcclxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwL2V4dHJhL2dhbGxlcnkvZ2FsbGVyeS50ZW1wbGF0ZS5odG1sXG4vLyBtb2R1bGUgaWQgPSAxMTQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gNSJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 1147:
/* unknown exports provided */
/* all exports used */
/*!*****************************************************!*\
  !*** ./src/app/extra/invoice/invoice.template.html ***!
  \*****************************************************/
/***/ (function(module, exports) {

eval("module.exports = \"<div class=\\\"row\\\">\\r\\n  <div class=\\\"col-lg-11\\\">\\r\\n    <section class=\\\"widget widget-invoice\\\">\\r\\n      <header>\\r\\n        <div class=\\\"row\\\">\\r\\n          <div class=\\\"col-md-6 col-print-6 col-xs-12\\\">\\r\\n            <img src=\\\"assets/img/invoice-logo.png\\\" alt=\\\"Logo\\\" class=\\\"invoice-logo\\\"/>\\r\\n          </div>\\r\\n          <div class=\\\"col-md-6 col-print-6 col-xs-12\\\">\\r\\n            <h4 class=\\\"text-xs-right\\\">\\r\\n              #<span class=\\\"fw-semi-bold\\\">9.45613</span> / <small>17 May 2014</small>\\r\\n            </h4>\\r\\n            <div class=\\\"text-muted fs-larger text-xs-right\\\">\\r\\n              Some Invoice number description or whatever\\r\\n            </div>\\r\\n          </div>\\r\\n        </div>\\r\\n      </header>\\r\\n      <div class=\\\"widget-body\\\">\\r\\n        <div class=\\\"row mb-lg\\\">\\r\\n          <section class=\\\"col-xs-6 col-print-6\\\">\\r\\n            <h5 class=\\\"text-muted no-margin\\\">Company Information</h5>\\r\\n            <h3 class=\\\"company-name m-t-1\\\">\\r\\n              Wrapbootstrap LLC\\r\\n            </h3>\\r\\n            <address>\\r\\n              <strong>2 Infinite Loop</strong><br>\\r\\n              Minsk, Belarus 220004<br>\\r\\n              088.253.5345<br>\\r\\n              <abbr title=\\\"Work email\\\">e-mail:</abbr> <a href=\\\"mailto:#\\\">email@example.com</a><br>\\r\\n              <abbr title=\\\"Work Phone\\\">phone:</abbr> (012) 345-678-901<br>\\r\\n              <abbr title=\\\"Work Fax\\\">fax:</abbr> (012) 678-132-901\\r\\n            </address>\\r\\n          </section>\\r\\n          <section class=\\\"col-xs-6 col-print-6 text-xs-right\\\">\\r\\n            <h5 class=\\\"text-muted no-margin\\\">Client Information</h5>\\r\\n            <h3 class=\\\"client-name m-t-1\\\">\\r\\n              Veronica Niasvizhskaja\\r\\n            </h3>\\r\\n            <address>\\r\\n              <strong>Consultant</strong> at\\r\\n              <a href=\\\"#\\\">Allspana</a><br>\\r\\n              <abbr title=\\\"Work email\\\">e-mail:</abbr> <a href=\\\"mailto:#\\\">maryna@allspana.by</a><br>\\r\\n              <abbr title=\\\"Work Phone\\\">phone:</abbr> (012) 345-678-901<br>\\r\\n              <abbr title=\\\"Work Fax\\\">fax:</abbr> (012) 678-132-901\\r\\n              <p class=\\\"no-margin\\\"><strong>Note:</strong></p>\\r\\n              <p class=\\\"text-muted\\\">Some nights I stay up cashing in my bad luck.\\r\\n                Some nights I call it a draw</p>\\r\\n            </address>\\r\\n          </section>\\r\\n        </div>\\r\\n        <table class=\\\"table table-striped\\\">\\r\\n          <thead>\\r\\n          <tr>\\r\\n            <th>#</th>\\r\\n            <th>Item</th>\\r\\n            <th class=\\\"hidden-xs-down hidden-print\\\">Description</th>\\r\\n            <th>Quantity</th>\\r\\n            <th class=\\\"hidden-xs-down hidden-print\\\">Price per Unit</th>\\r\\n            <th>Total</th>\\r\\n          </tr>\\r\\n          </thead>\\r\\n          <tbody>\\r\\n          <tr>\\r\\n            <td>1</td>\\r\\n            <td>Brand-new 27' monitor</td>\\r\\n            <td class=\\\"hidden-xs-down hidden-print\\\">2,560x1,440-pixel (WQHD) resolution supported!</td>\\r\\n            <td>2</td>\\r\\n            <td class=\\\"hidden-xs-down hidden-print\\\">700</td>\\r\\n            <td>1,400.00</td>\\r\\n          </tr>\\r\\n          <tr>\\r\\n            <td>2</td>\\r\\n            <td>Domain: okendoken.com</td>\\r\\n            <td class=\\\"hidden-xs-down hidden-print\\\">6-month registration</td>\\r\\n            <td>1</td>\\r\\n            <td class=\\\"hidden-xs-down hidden-print\\\">10.99</td>\\r\\n            <td>21.88</td>\\r\\n          </tr>\\r\\n          <tr>\\r\\n            <td>3</td>\\r\\n            <td>Atlas Shrugged</td>\\r\\n            <td class=\\\"hidden-xs-down hidden-print\\\">Novel by Ayn Rand, first published in 1957 in the US</td>\\r\\n            <td>5</td>\\r\\n            <td class=\\\"hidden-xs-down hidden-print\\\">35</td>\\r\\n            <td>175.00</td>\\r\\n          </tr>\\r\\n          <tr>\\r\\n            <td>4</td>\\r\\n            <td>New Song by Dr. Pre</td>\\r\\n            <td class=\\\"hidden-xs-down hidden-print\\\">Lyrics: praesent blandit augue non sapien ornare imperdiet</td>\\r\\n            <td>1</td>\\r\\n            <td class=\\\"hidden-xs-down hidden-print\\\">2</td>\\r\\n            <td>2.00</td>\\r\\n          </tr>\\r\\n          </tbody>\\r\\n        </table>\\r\\n        <div class=\\\"row\\\">\\r\\n          <div class=\\\"col-md-8 col-print-6 col-xs-12\\\">\\r\\n            <p>\\r\\n              <strong>Note:</strong>\\r\\n              Thank you for your business. Keep in mind, sometimes bad things happen. But it's just sometimes.\\r\\n            </p>\\r\\n          </div>\\r\\n          <div class=\\\"col-md-4 col-print-6 col-xs-12\\\">\\r\\n            <div class=\\\"row text-xs-right\\\">\\r\\n              <div class=\\\"col-xs-6\\\"></div> <!-- instead of offset -->\\r\\n              <div class=\\\"col-xs-3\\\">\\r\\n                <p>Subtotal</p>\\r\\n                <p>Tax(10%)</p>\\r\\n                <p class=\\\"no-margin\\\"><strong>Total</strong></p>\\r\\n              </div>\\r\\n              <div class=\\\"col-xs-3\\\">\\r\\n                <p>1,598.88</p>\\r\\n                <p>159.89</p>\\r\\n                <p class=\\\"no-margin\\\"><strong>1,758.77</strong></p>\\r\\n              </div>\\r\\n            </div>\\r\\n          </div>\\r\\n        </div>\\r\\n        <p class=\\\"text-xs-right mt-lg mb-xs\\\">\\r\\n          Marketing Consultant\\r\\n        </p>\\r\\n        <p class=\\\"text-xs-right\\\">\\r\\n          <span class=\\\"fw-semi-bold\\\">Bob Smith</span>\\r\\n        </p>\\r\\n        <div class=\\\"btn-toolbar mt-lg text-xs-right hidden-print\\\">\\r\\n          <button (click)=\\\"print()\\\" class=\\\"btn btn-inverse\\\">\\r\\n            <i class=\\\"fa fa-print\\\"></i>\\r\\n            &nbsp;&nbsp;\\r\\n            Print\\r\\n          </button>\\r\\n          <button class=\\\"btn btn-danger\\\">\\r\\n            Proceed with Payment\\r\\n            &nbsp;\\r\\n                                <span class=\\\"circle bg-white\\\">\\r\\n                                    <i class=\\\"fa fa-arrow-right text-danger\\\"></i>\\r\\n                                </span>\\r\\n          </button>\\r\\n        </div>\\r\\n      </div>\\r\\n    </section>\\r\\n  </div>\\r\\n</div>\\r\\n\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE0Ny5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvZXh0cmEvaW52b2ljZS9pbnZvaWNlLnRlbXBsYXRlLmh0bWw/YzMzNyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXHJcXG4gIDxkaXYgY2xhc3M9XFxcImNvbC1sZy0xMVxcXCI+XFxyXFxuICAgIDxzZWN0aW9uIGNsYXNzPVxcXCJ3aWRnZXQgd2lkZ2V0LWludm9pY2VcXFwiPlxcclxcbiAgICAgIDxoZWFkZXI+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcclxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtNiBjb2wtcHJpbnQtNiBjb2wteHMtMTJcXFwiPlxcclxcbiAgICAgICAgICAgIDxpbWcgc3JjPVxcXCJhc3NldHMvaW1nL2ludm9pY2UtbG9nby5wbmdcXFwiIGFsdD1cXFwiTG9nb1xcXCIgY2xhc3M9XFxcImludm9pY2UtbG9nb1xcXCIvPlxcclxcbiAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTYgY29sLXByaW50LTYgY29sLXhzLTEyXFxcIj5cXHJcXG4gICAgICAgICAgICA8aDQgY2xhc3M9XFxcInRleHQteHMtcmlnaHRcXFwiPlxcclxcbiAgICAgICAgICAgICAgIzxzcGFuIGNsYXNzPVxcXCJmdy1zZW1pLWJvbGRcXFwiPjkuNDU2MTM8L3NwYW4+IC8gPHNtYWxsPjE3IE1heSAyMDE0PC9zbWFsbD5cXHJcXG4gICAgICAgICAgICA8L2g0PlxcclxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInRleHQtbXV0ZWQgZnMtbGFyZ2VyIHRleHQteHMtcmlnaHRcXFwiPlxcclxcbiAgICAgICAgICAgICAgU29tZSBJbnZvaWNlIG51bWJlciBkZXNjcmlwdGlvbiBvciB3aGF0ZXZlclxcclxcbiAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICAgIDwvaGVhZGVyPlxcclxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIndpZGdldC1ib2R5XFxcIj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInJvdyBtYi1sZ1xcXCI+XFxyXFxuICAgICAgICAgIDxzZWN0aW9uIGNsYXNzPVxcXCJjb2wteHMtNiBjb2wtcHJpbnQtNlxcXCI+XFxyXFxuICAgICAgICAgICAgPGg1IGNsYXNzPVxcXCJ0ZXh0LW11dGVkIG5vLW1hcmdpblxcXCI+Q29tcGFueSBJbmZvcm1hdGlvbjwvaDU+XFxyXFxuICAgICAgICAgICAgPGgzIGNsYXNzPVxcXCJjb21wYW55LW5hbWUgbS10LTFcXFwiPlxcclxcbiAgICAgICAgICAgICAgV3JhcGJvb3RzdHJhcCBMTENcXHJcXG4gICAgICAgICAgICA8L2gzPlxcclxcbiAgICAgICAgICAgIDxhZGRyZXNzPlxcclxcbiAgICAgICAgICAgICAgPHN0cm9uZz4yIEluZmluaXRlIExvb3A8L3N0cm9uZz48YnI+XFxyXFxuICAgICAgICAgICAgICBNaW5zaywgQmVsYXJ1cyAyMjAwMDQ8YnI+XFxyXFxuICAgICAgICAgICAgICAwODguMjUzLjUzNDU8YnI+XFxyXFxuICAgICAgICAgICAgICA8YWJiciB0aXRsZT1cXFwiV29yayBlbWFpbFxcXCI+ZS1tYWlsOjwvYWJicj4gPGEgaHJlZj1cXFwibWFpbHRvOiNcXFwiPmVtYWlsQGV4YW1wbGUuY29tPC9hPjxicj5cXHJcXG4gICAgICAgICAgICAgIDxhYmJyIHRpdGxlPVxcXCJXb3JrIFBob25lXFxcIj5waG9uZTo8L2FiYnI+ICgwMTIpIDM0NS02NzgtOTAxPGJyPlxcclxcbiAgICAgICAgICAgICAgPGFiYnIgdGl0bGU9XFxcIldvcmsgRmF4XFxcIj5mYXg6PC9hYmJyPiAoMDEyKSA2NzgtMTMyLTkwMVxcclxcbiAgICAgICAgICAgIDwvYWRkcmVzcz5cXHJcXG4gICAgICAgICAgPC9zZWN0aW9uPlxcclxcbiAgICAgICAgICA8c2VjdGlvbiBjbGFzcz1cXFwiY29sLXhzLTYgY29sLXByaW50LTYgdGV4dC14cy1yaWdodFxcXCI+XFxyXFxuICAgICAgICAgICAgPGg1IGNsYXNzPVxcXCJ0ZXh0LW11dGVkIG5vLW1hcmdpblxcXCI+Q2xpZW50IEluZm9ybWF0aW9uPC9oNT5cXHJcXG4gICAgICAgICAgICA8aDMgY2xhc3M9XFxcImNsaWVudC1uYW1lIG0tdC0xXFxcIj5cXHJcXG4gICAgICAgICAgICAgIFZlcm9uaWNhIE5pYXN2aXpoc2thamFcXHJcXG4gICAgICAgICAgICA8L2gzPlxcclxcbiAgICAgICAgICAgIDxhZGRyZXNzPlxcclxcbiAgICAgICAgICAgICAgPHN0cm9uZz5Db25zdWx0YW50PC9zdHJvbmc+IGF0XFxyXFxuICAgICAgICAgICAgICA8YSBocmVmPVxcXCIjXFxcIj5BbGxzcGFuYTwvYT48YnI+XFxyXFxuICAgICAgICAgICAgICA8YWJiciB0aXRsZT1cXFwiV29yayBlbWFpbFxcXCI+ZS1tYWlsOjwvYWJicj4gPGEgaHJlZj1cXFwibWFpbHRvOiNcXFwiPm1hcnluYUBhbGxzcGFuYS5ieTwvYT48YnI+XFxyXFxuICAgICAgICAgICAgICA8YWJiciB0aXRsZT1cXFwiV29yayBQaG9uZVxcXCI+cGhvbmU6PC9hYmJyPiAoMDEyKSAzNDUtNjc4LTkwMTxicj5cXHJcXG4gICAgICAgICAgICAgIDxhYmJyIHRpdGxlPVxcXCJXb3JrIEZheFxcXCI+ZmF4OjwvYWJicj4gKDAxMikgNjc4LTEzMi05MDFcXHJcXG4gICAgICAgICAgICAgIDxwIGNsYXNzPVxcXCJuby1tYXJnaW5cXFwiPjxzdHJvbmc+Tm90ZTo8L3N0cm9uZz48L3A+XFxyXFxuICAgICAgICAgICAgICA8cCBjbGFzcz1cXFwidGV4dC1tdXRlZFxcXCI+U29tZSBuaWdodHMgSSBzdGF5IHVwIGNhc2hpbmcgaW4gbXkgYmFkIGx1Y2suXFxyXFxuICAgICAgICAgICAgICAgIFNvbWUgbmlnaHRzIEkgY2FsbCBpdCBhIGRyYXc8L3A+XFxyXFxuICAgICAgICAgICAgPC9hZGRyZXNzPlxcclxcbiAgICAgICAgICA8L3NlY3Rpb24+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDx0YWJsZSBjbGFzcz1cXFwidGFibGUgdGFibGUtc3RyaXBlZFxcXCI+XFxyXFxuICAgICAgICAgIDx0aGVhZD5cXHJcXG4gICAgICAgICAgPHRyPlxcclxcbiAgICAgICAgICAgIDx0aD4jPC90aD5cXHJcXG4gICAgICAgICAgICA8dGg+SXRlbTwvdGg+XFxyXFxuICAgICAgICAgICAgPHRoIGNsYXNzPVxcXCJoaWRkZW4teHMtZG93biBoaWRkZW4tcHJpbnRcXFwiPkRlc2NyaXB0aW9uPC90aD5cXHJcXG4gICAgICAgICAgICA8dGg+UXVhbnRpdHk8L3RoPlxcclxcbiAgICAgICAgICAgIDx0aCBjbGFzcz1cXFwiaGlkZGVuLXhzLWRvd24gaGlkZGVuLXByaW50XFxcIj5QcmljZSBwZXIgVW5pdDwvdGg+XFxyXFxuICAgICAgICAgICAgPHRoPlRvdGFsPC90aD5cXHJcXG4gICAgICAgICAgPC90cj5cXHJcXG4gICAgICAgICAgPC90aGVhZD5cXHJcXG4gICAgICAgICAgPHRib2R5PlxcclxcbiAgICAgICAgICA8dHI+XFxyXFxuICAgICAgICAgICAgPHRkPjE8L3RkPlxcclxcbiAgICAgICAgICAgIDx0ZD5CcmFuZC1uZXcgMjcnIG1vbml0b3I8L3RkPlxcclxcbiAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwiaGlkZGVuLXhzLWRvd24gaGlkZGVuLXByaW50XFxcIj4yLDU2MHgxLDQ0MC1waXhlbCAoV1FIRCkgcmVzb2x1dGlvbiBzdXBwb3J0ZWQhPC90ZD5cXHJcXG4gICAgICAgICAgICA8dGQ+MjwvdGQ+XFxyXFxuICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJoaWRkZW4teHMtZG93biBoaWRkZW4tcHJpbnRcXFwiPjcwMDwvdGQ+XFxyXFxuICAgICAgICAgICAgPHRkPjEsNDAwLjAwPC90ZD5cXHJcXG4gICAgICAgICAgPC90cj5cXHJcXG4gICAgICAgICAgPHRyPlxcclxcbiAgICAgICAgICAgIDx0ZD4yPC90ZD5cXHJcXG4gICAgICAgICAgICA8dGQ+RG9tYWluOiBva2VuZG9rZW4uY29tPC90ZD5cXHJcXG4gICAgICAgICAgICA8dGQgY2xhc3M9XFxcImhpZGRlbi14cy1kb3duIGhpZGRlbi1wcmludFxcXCI+Ni1tb250aCByZWdpc3RyYXRpb248L3RkPlxcclxcbiAgICAgICAgICAgIDx0ZD4xPC90ZD5cXHJcXG4gICAgICAgICAgICA8dGQgY2xhc3M9XFxcImhpZGRlbi14cy1kb3duIGhpZGRlbi1wcmludFxcXCI+MTAuOTk8L3RkPlxcclxcbiAgICAgICAgICAgIDx0ZD4yMS44ODwvdGQ+XFxyXFxuICAgICAgICAgIDwvdHI+XFxyXFxuICAgICAgICAgIDx0cj5cXHJcXG4gICAgICAgICAgICA8dGQ+MzwvdGQ+XFxyXFxuICAgICAgICAgICAgPHRkPkF0bGFzIFNocnVnZ2VkPC90ZD5cXHJcXG4gICAgICAgICAgICA8dGQgY2xhc3M9XFxcImhpZGRlbi14cy1kb3duIGhpZGRlbi1wcmludFxcXCI+Tm92ZWwgYnkgQXluIFJhbmQsIGZpcnN0IHB1Ymxpc2hlZCBpbiAxOTU3IGluIHRoZSBVUzwvdGQ+XFxyXFxuICAgICAgICAgICAgPHRkPjU8L3RkPlxcclxcbiAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwiaGlkZGVuLXhzLWRvd24gaGlkZGVuLXByaW50XFxcIj4zNTwvdGQ+XFxyXFxuICAgICAgICAgICAgPHRkPjE3NS4wMDwvdGQ+XFxyXFxuICAgICAgICAgIDwvdHI+XFxyXFxuICAgICAgICAgIDx0cj5cXHJcXG4gICAgICAgICAgICA8dGQ+NDwvdGQ+XFxyXFxuICAgICAgICAgICAgPHRkPk5ldyBTb25nIGJ5IERyLiBQcmU8L3RkPlxcclxcbiAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFwiaGlkZGVuLXhzLWRvd24gaGlkZGVuLXByaW50XFxcIj5MeXJpY3M6IHByYWVzZW50IGJsYW5kaXQgYXVndWUgbm9uIHNhcGllbiBvcm5hcmUgaW1wZXJkaWV0PC90ZD5cXHJcXG4gICAgICAgICAgICA8dGQ+MTwvdGQ+XFxyXFxuICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJoaWRkZW4teHMtZG93biBoaWRkZW4tcHJpbnRcXFwiPjI8L3RkPlxcclxcbiAgICAgICAgICAgIDx0ZD4yLjAwPC90ZD5cXHJcXG4gICAgICAgICAgPC90cj5cXHJcXG4gICAgICAgICAgPC90Ym9keT5cXHJcXG4gICAgICAgIDwvdGFibGU+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcclxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtOCBjb2wtcHJpbnQtNiBjb2wteHMtMTJcXFwiPlxcclxcbiAgICAgICAgICAgIDxwPlxcclxcbiAgICAgICAgICAgICAgPHN0cm9uZz5Ob3RlOjwvc3Ryb25nPlxcclxcbiAgICAgICAgICAgICAgVGhhbmsgeW91IGZvciB5b3VyIGJ1c2luZXNzLiBLZWVwIGluIG1pbmQsIHNvbWV0aW1lcyBiYWQgdGhpbmdzIGhhcHBlbi4gQnV0IGl0J3MganVzdCBzb21ldGltZXMuXFxyXFxuICAgICAgICAgICAgPC9wPlxcclxcbiAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTQgY29sLXByaW50LTYgY29sLXhzLTEyXFxcIj5cXHJcXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb3cgdGV4dC14cy1yaWdodFxcXCI+XFxyXFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wteHMtNlxcXCI+PC9kaXY+IDwhLS0gaW5zdGVhZCBvZiBvZmZzZXQgLS0+XFxyXFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wteHMtM1xcXCI+XFxyXFxuICAgICAgICAgICAgICAgIDxwPlN1YnRvdGFsPC9wPlxcclxcbiAgICAgICAgICAgICAgICA8cD5UYXgoMTAlKTwvcD5cXHJcXG4gICAgICAgICAgICAgICAgPHAgY2xhc3M9XFxcIm5vLW1hcmdpblxcXCI+PHN0cm9uZz5Ub3RhbDwvc3Ryb25nPjwvcD5cXHJcXG4gICAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLXhzLTNcXFwiPlxcclxcbiAgICAgICAgICAgICAgICA8cD4xLDU5OC44ODwvcD5cXHJcXG4gICAgICAgICAgICAgICAgPHA+MTU5Ljg5PC9wPlxcclxcbiAgICAgICAgICAgICAgICA8cCBjbGFzcz1cXFwibm8tbWFyZ2luXFxcIj48c3Ryb25nPjEsNzU4Ljc3PC9zdHJvbmc+PC9wPlxcclxcbiAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8cCBjbGFzcz1cXFwidGV4dC14cy1yaWdodCBtdC1sZyBtYi14c1xcXCI+XFxyXFxuICAgICAgICAgIE1hcmtldGluZyBDb25zdWx0YW50XFxyXFxuICAgICAgICA8L3A+XFxyXFxuICAgICAgICA8cCBjbGFzcz1cXFwidGV4dC14cy1yaWdodFxcXCI+XFxyXFxuICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJmdy1zZW1pLWJvbGRcXFwiPkJvYiBTbWl0aDwvc3Bhbj5cXHJcXG4gICAgICAgIDwvcD5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImJ0bi10b29sYmFyIG10LWxnIHRleHQteHMtcmlnaHQgaGlkZGVuLXByaW50XFxcIj5cXHJcXG4gICAgICAgICAgPGJ1dHRvbiAoY2xpY2spPVxcXCJwcmludCgpXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1pbnZlcnNlXFxcIj5cXHJcXG4gICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtcHJpbnRcXFwiPjwvaT5cXHJcXG4gICAgICAgICAgICAmbmJzcDsmbmJzcDtcXHJcXG4gICAgICAgICAgICBQcmludFxcclxcbiAgICAgICAgICA8L2J1dHRvbj5cXHJcXG4gICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnRuIGJ0bi1kYW5nZXJcXFwiPlxcclxcbiAgICAgICAgICAgIFByb2NlZWQgd2l0aCBQYXltZW50XFxyXFxuICAgICAgICAgICAgJm5ic3A7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiY2lyY2xlIGJnLXdoaXRlXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtYXJyb3ctcmlnaHQgdGV4dC1kYW5nZXJcXFwiPjwvaT5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cXHJcXG4gICAgICAgICAgPC9idXR0b24+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICA8L2Rpdj5cXHJcXG4gICAgPC9zZWN0aW9uPlxcclxcbiAgPC9kaXY+XFxyXFxuPC9kaXY+XFxyXFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvZXh0cmEvaW52b2ljZS9pbnZvaWNlLnRlbXBsYXRlLmh0bWxcbi8vIG1vZHVsZSBpZCA9IDExNDdcbi8vIG1vZHVsZSBjaHVua3MgPSA1Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 1148:
/* unknown exports provided */
/* all exports used */
/*!*******************************************************************!*\
  !*** ./src/app/extra/search-results/search-results.template.html ***!
  \*******************************************************************/
/***/ (function(module, exports) {

eval("module.exports = \"<ol class=\\\"breadcrumb\\\">\\r\\n  <li class=\\\"breadcrumb-item\\\">YOU ARE HERE</li>\\r\\n  <li class=\\\"breadcrumb-item active\\\">Search Results</li>\\r\\n</ol>\\r\\n<h1 class=\\\"page-title\\\">Matching - <span class=\\\"fw-semi-bold\\\">Results</span></h1>\\r\\n<div class=\\\"clearfix\\\">\\r\\n  <div class=\\\"btn-toolbar\\\">\\r\\n    <div class=\\\"btn-group\\\">\\r\\n      <a data-toggle=\\\"dropdown\\\" class=\\\"btn dropdown-toggle btn-default\\\">\\r\\n        Popular <span class=\\\"caret\\\"></span>\\r\\n      </a>\\r\\n      <ul class=\\\"dropdown-menu\\\">\\r\\n        <li><a class=\\\"dropdown-item\\\" href=\\\"#\\\">All</a></li>\\r\\n        <li><a class=\\\"dropdown-item\\\" href=\\\"#\\\">Popular</a></li>\\r\\n        <li><a class=\\\"dropdown-item\\\" href=\\\"#\\\">Interesting</a></li>\\r\\n        <li><a class=\\\"dropdown-item\\\" href=\\\"#\\\">Latest</a></li>\\r\\n      </ul>\\r\\n    </div>\\r\\n    <div class=\\\"btn-group\\\">\\r\\n      <a data-toggle=\\\"dropdown\\\" class=\\\"btn dropdown-toggle btn-default\\\">\\r\\n        All Time <span class=\\\"caret\\\"></span>\\r\\n      </a>\\r\\n      <ul class=\\\"dropdown-menu\\\">\\r\\n        <li><a class=\\\"dropdown-item\\\" href=\\\"#\\\">Last 24h</a></li>\\r\\n        <li><a class=\\\"dropdown-item\\\" href=\\\"#\\\">Last Month</a></li>\\r\\n        <li><a class=\\\"dropdown-item\\\" href=\\\"#\\\">Last Year</a></li>\\r\\n      </ul>\\r\\n    </div>\\r\\n    <div class=\\\"btn-group float-xs-right\\\">\\r\\n      <button class=\\\"btn btn-gray active\\\" type=\\\"button\\\"><i class=\\\"fa fa-th-list\\\"></i></button>\\r\\n      <button class=\\\"btn btn-gray\\\" type=\\\"button\\\"><i class=\\\"fa fa-th-large\\\"></i></button>\\r\\n    </div>\\r\\n  </div>\\r\\n</div>\\r\\n<div class=\\\"row\\\">\\r\\n  <div class=\\\"col-xl-3 push-xl-9 col-xs-12\\\">\\r\\n    <h5>Results <span class=\\\"fw-semi-bold\\\">Filtering</span></h5>\\r\\n    <p class=\\\"text-muted fs-mini\\\">Listed content is categorized by the following groups:</p>\\r\\n    <ul class=\\\"nav nav-pills nav-stacked search-result-categories mt\\\">\\r\\n      <li class=\\\"nav-item\\\">\\r\\n        <a class=\\\"nav-link\\\" href=\\\"#\\\">\\r\\n          Hot Ideas\\r\\n          <span class=\\\"tag tag-pill tag-default float-xs-right\\\">34</span>\\r\\n        </a>\\r\\n      </li>\\r\\n      <li class=\\\"nav-item\\\"><a class=\\\"nav-link\\\" href=\\\"#\\\">\\r\\n        Latest Pictures\\r\\n        <span class=\\\"tag tag-pill tag-default float-xs-right\\\">9</span>\\r\\n      </a></li>\\r\\n      <li class=\\\"nav-item\\\"><a class=\\\"nav-link\\\" href=\\\"#\\\">tags of Day</a></li>\\r\\n      <li class=\\\"nav-item\\\">\\r\\n        <a class=\\\"nav-link\\\" href=\\\"#\\\">\\r\\n          Recent Movies\\r\\n        </a>\\r\\n      </li>\\r\\n      <li class=\\\"nav-item\\\">\\r\\n        <a class=\\\"nav-link\\\" href=\\\"#\\\">Globals <span class=\\\"tag tag-pill tag-default float-xs-right\\\">18</span></a>\\r\\n      </li>\\r\\n    </ul>\\r\\n  </div>\\r\\n  <div class=\\\"col-xl-9 pull-xl-3 col-xs-12\\\">\\r\\n    <p class=\\\"search-results-count\\\">About 94 700 000 (0.39 sec.) results</p>\\r\\n    <section class=\\\"search-result-item\\\">\\r\\n      <a class=\\\"image-link\\\" href=\\\"#\\\">\\r\\n        <img class=\\\"image\\\" src=\\\"assets/img/pictures/1.jpg\\\">\\r\\n      </a>\\r\\n      <div class=\\\"search-result-item-body\\\">\\r\\n        <div class=\\\"row\\\">\\r\\n          <div class=\\\"col-md-9 col-xs-12\\\">\\r\\n            <h5 class=\\\"search-result-item-heading\\\">\\r\\n              <a href=\\\"#\\\">Next generation admin template</a>\\r\\n            </h5>\\r\\n            <p class=\\\"info\\\">\\r\\n              New York, NY 20188\\r\\n            </p>\\r\\n            <p class=\\\"description\\\">\\r\\n              Not just usual Metro. But something bigger. Not just usual widgets, but real\\r\\n              widgets. Not just yet another admin template, but next generation admin template.\\r\\n            </p>\\r\\n          </div>\\r\\n          <div class=\\\"col-md-3 col-xs-12 text-xs-center\\\">\\r\\n            <p class=\\\"value3 mt-sm\\\">\\r\\n              $9, 700\\r\\n            </p>\\r\\n            <p class=\\\"fs-mini text-muted\\\">\\r\\n              PER WEEK\\r\\n            </p>\\r\\n            <a class=\\\"btn btn-primary btn-info btn-sm\\\" href=\\\"#\\\">Learn More</a>\\r\\n          </div>\\r\\n        </div>\\r\\n      </div>\\r\\n    </section>\\r\\n    <section class=\\\"search-result-item\\\">\\r\\n      <a class=\\\"image-link\\\" href=\\\"#\\\">\\r\\n        <img class=\\\"image\\\" src=\\\"assets/img/pictures/5.jpg\\\">\\r\\n      </a>\\r\\n      <div class=\\\"search-result-item-body\\\">\\r\\n        <div class=\\\"row\\\">\\r\\n          <div class=\\\"col-md-9 col-xs-12\\\">\\r\\n            <h5 class=\\\"search-result-item-heading\\\">\\r\\n              <a href=\\\"#\\\">Try. Posted by Okendoken</a>\\r\\n              <span class=\\\"tag tag-pill tag-danger fw-normal float-xs-right\\\">Best Deal!</span>\\r\\n            </h5>\\r\\n            <p class=\\\"info\\\">\\r\\n              Los Angeles, NY 20188\\r\\n            </p>\\r\\n            <p class=\\\"description\\\">\\r\\n              You will never know exactly how something will go until you try it. You can\\r\\n              think three hundred times and still have no precise result.\\r\\n            </p>\\r\\n          </div>\\r\\n          <div class=\\\"col-md-3 col-xs-12 text-xs-center\\\">\\r\\n            <p class=\\\"value3 mt-sm\\\">\\r\\n              $10, 300\\r\\n            </p>\\r\\n            <p class=\\\"fs-mini text-muted\\\">\\r\\n              PER WEEK\\r\\n            </p>\\r\\n            <a class=\\\"btn btn-primary btn-info btn-sm\\\" href=\\\"#\\\">Learn More</a>\\r\\n          </div>\\r\\n        </div>\\r\\n      </div>\\r\\n    </section>\\r\\n    <section class=\\\"search-result-item\\\">\\r\\n      <a class=\\\"image-link\\\" href=\\\"#\\\">\\r\\n        <img class=\\\"image\\\" src=\\\"assets/img/pictures/13.jpg\\\">\\r\\n      </a>\\r\\n      <div class=\\\"search-result-item-body\\\">\\r\\n        <div class=\\\"row\\\">\\r\\n          <div class=\\\"col-md-9 col-xs-12\\\">\\r\\n            <h5 class=\\\"search-result-item-heading\\\">\\r\\n              <a href=\\\"#\\\">Vitaut the Great</a>\\r\\n            </h5>\\r\\n            <p class=\\\"info\\\">\\r\\n              New York, NY 20188\\r\\n            </p>\\r\\n            <p class=\\\"description\\\">\\r\\n              The Great Prince of the Grand Duchy of Lithuania he had stopped the invasion to\\r\\n              Europe of Timur (Tamerlan) from Asia heading a big Army of Belarusians, Lithuanians.\\r\\n            </p>\\r\\n          </div>\\r\\n          <div class=\\\"col-md-3 col-xs-12 text-xs-center\\\">\\r\\n            <p class=\\\"value3 mt-sm\\\">\\r\\n              $3, 200\\r\\n            </p>\\r\\n            <p class=\\\"fs-mini text-muted\\\">\\r\\n              PER WEEK\\r\\n            </p>\\r\\n            <a class=\\\"btn btn-info btn-sm\\\" href=\\\"#\\\">Learn More</a>\\r\\n          </div>\\r\\n        </div>\\r\\n      </div>\\r\\n    </section>\\r\\n    <section class=\\\"search-result-item\\\">\\r\\n      <a class=\\\"image-link\\\" href=\\\"#\\\">\\r\\n        <img class=\\\"image\\\" src=\\\"assets/img/pictures/3.jpg\\\">\\r\\n      </a>\\r\\n      <div class=\\\"search-result-item-body\\\">\\r\\n        <div class=\\\"row\\\">\\r\\n          <div class=\\\"col-md-9 col-xs-12\\\">\\r\\n            <h5 class=\\\"search-result-item-heading\\\">\\r\\n              <a href=\\\"#\\\">Can I use CSS3 Radial-Gradient?</a>\\r\\n            </h5>\\r\\n            <p class=\\\"info\\\">\\r\\n              Minsk, NY 20188\\r\\n            </p>\\r\\n            <p class=\\\"description\\\">\\r\\n              Yes you can! Further more, you should! It let's you create really beautiful images\\r\\n              either for elements or for the entire background.\\r\\n            </p>\\r\\n          </div>\\r\\n          <div class=\\\"col-md-3 col-xs-12 text-xs-center\\\">\\r\\n            <p class=\\\"value3 mt-sm\\\">\\r\\n              $2, 400\\r\\n            </p>\\r\\n            <p class=\\\"fs-mini text-muted\\\">\\r\\n              PER MONTH\\r\\n            </p>\\r\\n            <a class=\\\"btn btn-info btn-sm\\\" href=\\\"#\\\">Learn More</a>\\r\\n          </div>\\r\\n        </div>\\r\\n      </div>\\r\\n    </section>\\r\\n    <div class=\\\"text-xs-center\\\">\\r\\n      <ul class=\\\"pagination pagination-sm\\\">\\r\\n        <li class=\\\"disabled page-item\\\"><a class=\\\"page-link\\\" href=\\\"#\\\">Prev</a></li>\\r\\n        <li class=\\\"active page-item\\\"><a class=\\\"page-link\\\" href=\\\"#\\\">1</a></li>\\r\\n        <li class=\\\"page-item\\\"><a class=\\\"page-link\\\" href=\\\"#\\\">2</a></li>\\r\\n        <li class=\\\"page-item\\\"><a class=\\\"page-link\\\" href=\\\"#\\\">3</a></li>\\r\\n        <li class=\\\"page-item\\\"><a class=\\\"page-link\\\" href=\\\"#\\\">4</a></li>\\r\\n        <li class=\\\"page-item\\\"><a class=\\\"page-link\\\" href=\\\"#\\\">5</a></li>\\r\\n        <li class=\\\"page-item\\\"><a class=\\\"page-link\\\" href=\\\"#\\\">Next</a></li>\\r\\n      </ul>\\r\\n    </div>\\r\\n  </div>\\r\\n</div>\\r\\n\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE0OC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvZXh0cmEvc2VhcmNoLXJlc3VsdHMvc2VhcmNoLXJlc3VsdHMudGVtcGxhdGUuaHRtbD85N2Q1Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCI8b2wgY2xhc3M9XFxcImJyZWFkY3J1bWJcXFwiPlxcclxcbiAgPGxpIGNsYXNzPVxcXCJicmVhZGNydW1iLWl0ZW1cXFwiPllPVSBBUkUgSEVSRTwvbGk+XFxyXFxuICA8bGkgY2xhc3M9XFxcImJyZWFkY3J1bWItaXRlbSBhY3RpdmVcXFwiPlNlYXJjaCBSZXN1bHRzPC9saT5cXHJcXG48L29sPlxcclxcbjxoMSBjbGFzcz1cXFwicGFnZS10aXRsZVxcXCI+TWF0Y2hpbmcgLSA8c3BhbiBjbGFzcz1cXFwiZnctc2VtaS1ib2xkXFxcIj5SZXN1bHRzPC9zcGFuPjwvaDE+XFxyXFxuPGRpdiBjbGFzcz1cXFwiY2xlYXJmaXhcXFwiPlxcclxcbiAgPGRpdiBjbGFzcz1cXFwiYnRuLXRvb2xiYXJcXFwiPlxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJidG4tZ3JvdXBcXFwiPlxcclxcbiAgICAgIDxhIGRhdGEtdG9nZ2xlPVxcXCJkcm9wZG93blxcXCIgY2xhc3M9XFxcImJ0biBkcm9wZG93bi10b2dnbGUgYnRuLWRlZmF1bHRcXFwiPlxcclxcbiAgICAgICAgUG9wdWxhciA8c3BhbiBjbGFzcz1cXFwiY2FyZXRcXFwiPjwvc3Bhbj5cXHJcXG4gICAgICA8L2E+XFxyXFxuICAgICAgPHVsIGNsYXNzPVxcXCJkcm9wZG93bi1tZW51XFxcIj5cXHJcXG4gICAgICAgIDxsaT48YSBjbGFzcz1cXFwiZHJvcGRvd24taXRlbVxcXCIgaHJlZj1cXFwiI1xcXCI+QWxsPC9hPjwvbGk+XFxyXFxuICAgICAgICA8bGk+PGEgY2xhc3M9XFxcImRyb3Bkb3duLWl0ZW1cXFwiIGhyZWY9XFxcIiNcXFwiPlBvcHVsYXI8L2E+PC9saT5cXHJcXG4gICAgICAgIDxsaT48YSBjbGFzcz1cXFwiZHJvcGRvd24taXRlbVxcXCIgaHJlZj1cXFwiI1xcXCI+SW50ZXJlc3Rpbmc8L2E+PC9saT5cXHJcXG4gICAgICAgIDxsaT48YSBjbGFzcz1cXFwiZHJvcGRvd24taXRlbVxcXCIgaHJlZj1cXFwiI1xcXCI+TGF0ZXN0PC9hPjwvbGk+XFxyXFxuICAgICAgPC91bD5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcImJ0bi1ncm91cFxcXCI+XFxyXFxuICAgICAgPGEgZGF0YS10b2dnbGU9XFxcImRyb3Bkb3duXFxcIiBjbGFzcz1cXFwiYnRuIGRyb3Bkb3duLXRvZ2dsZSBidG4tZGVmYXVsdFxcXCI+XFxyXFxuICAgICAgICBBbGwgVGltZSA8c3BhbiBjbGFzcz1cXFwiY2FyZXRcXFwiPjwvc3Bhbj5cXHJcXG4gICAgICA8L2E+XFxyXFxuICAgICAgPHVsIGNsYXNzPVxcXCJkcm9wZG93bi1tZW51XFxcIj5cXHJcXG4gICAgICAgIDxsaT48YSBjbGFzcz1cXFwiZHJvcGRvd24taXRlbVxcXCIgaHJlZj1cXFwiI1xcXCI+TGFzdCAyNGg8L2E+PC9saT5cXHJcXG4gICAgICAgIDxsaT48YSBjbGFzcz1cXFwiZHJvcGRvd24taXRlbVxcXCIgaHJlZj1cXFwiI1xcXCI+TGFzdCBNb250aDwvYT48L2xpPlxcclxcbiAgICAgICAgPGxpPjxhIGNsYXNzPVxcXCJkcm9wZG93bi1pdGVtXFxcIiBocmVmPVxcXCIjXFxcIj5MYXN0IFllYXI8L2E+PC9saT5cXHJcXG4gICAgICA8L3VsPlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwiYnRuLWdyb3VwIGZsb2F0LXhzLXJpZ2h0XFxcIj5cXHJcXG4gICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidG4gYnRuLWdyYXkgYWN0aXZlXFxcIiB0eXBlPVxcXCJidXR0b25cXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS10aC1saXN0XFxcIj48L2k+PC9idXR0b24+XFxyXFxuICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnRuIGJ0bi1ncmF5XFxcIiB0eXBlPVxcXCJidXR0b25cXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS10aC1sYXJnZVxcXCI+PC9pPjwvYnV0dG9uPlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gIDwvZGl2PlxcclxcbjwvZGl2PlxcclxcbjxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxyXFxuICA8ZGl2IGNsYXNzPVxcXCJjb2wteGwtMyBwdXNoLXhsLTkgY29sLXhzLTEyXFxcIj5cXHJcXG4gICAgPGg1PlJlc3VsdHMgPHNwYW4gY2xhc3M9XFxcImZ3LXNlbWktYm9sZFxcXCI+RmlsdGVyaW5nPC9zcGFuPjwvaDU+XFxyXFxuICAgIDxwIGNsYXNzPVxcXCJ0ZXh0LW11dGVkIGZzLW1pbmlcXFwiPkxpc3RlZCBjb250ZW50IGlzIGNhdGVnb3JpemVkIGJ5IHRoZSBmb2xsb3dpbmcgZ3JvdXBzOjwvcD5cXHJcXG4gICAgPHVsIGNsYXNzPVxcXCJuYXYgbmF2LXBpbGxzIG5hdi1zdGFja2VkIHNlYXJjaC1yZXN1bHQtY2F0ZWdvcmllcyBtdFxcXCI+XFxyXFxuICAgICAgPGxpIGNsYXNzPVxcXCJuYXYtaXRlbVxcXCI+XFxyXFxuICAgICAgICA8YSBjbGFzcz1cXFwibmF2LWxpbmtcXFwiIGhyZWY9XFxcIiNcXFwiPlxcclxcbiAgICAgICAgICBIb3QgSWRlYXNcXHJcXG4gICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInRhZyB0YWctcGlsbCB0YWctZGVmYXVsdCBmbG9hdC14cy1yaWdodFxcXCI+MzQ8L3NwYW4+XFxyXFxuICAgICAgICA8L2E+XFxyXFxuICAgICAgPC9saT5cXHJcXG4gICAgICA8bGkgY2xhc3M9XFxcIm5hdi1pdGVtXFxcIj48YSBjbGFzcz1cXFwibmF2LWxpbmtcXFwiIGhyZWY9XFxcIiNcXFwiPlxcclxcbiAgICAgICAgTGF0ZXN0IFBpY3R1cmVzXFxyXFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwidGFnIHRhZy1waWxsIHRhZy1kZWZhdWx0IGZsb2F0LXhzLXJpZ2h0XFxcIj45PC9zcGFuPlxcclxcbiAgICAgIDwvYT48L2xpPlxcclxcbiAgICAgIDxsaSBjbGFzcz1cXFwibmF2LWl0ZW1cXFwiPjxhIGNsYXNzPVxcXCJuYXYtbGlua1xcXCIgaHJlZj1cXFwiI1xcXCI+dGFncyBvZiBEYXk8L2E+PC9saT5cXHJcXG4gICAgICA8bGkgY2xhc3M9XFxcIm5hdi1pdGVtXFxcIj5cXHJcXG4gICAgICAgIDxhIGNsYXNzPVxcXCJuYXYtbGlua1xcXCIgaHJlZj1cXFwiI1xcXCI+XFxyXFxuICAgICAgICAgIFJlY2VudCBNb3ZpZXNcXHJcXG4gICAgICAgIDwvYT5cXHJcXG4gICAgICA8L2xpPlxcclxcbiAgICAgIDxsaSBjbGFzcz1cXFwibmF2LWl0ZW1cXFwiPlxcclxcbiAgICAgICAgPGEgY2xhc3M9XFxcIm5hdi1saW5rXFxcIiBocmVmPVxcXCIjXFxcIj5HbG9iYWxzIDxzcGFuIGNsYXNzPVxcXCJ0YWcgdGFnLXBpbGwgdGFnLWRlZmF1bHQgZmxvYXQteHMtcmlnaHRcXFwiPjE4PC9zcGFuPjwvYT5cXHJcXG4gICAgICA8L2xpPlxcclxcbiAgICA8L3VsPlxcclxcbiAgPC9kaXY+XFxyXFxuICA8ZGl2IGNsYXNzPVxcXCJjb2wteGwtOSBwdWxsLXhsLTMgY29sLXhzLTEyXFxcIj5cXHJcXG4gICAgPHAgY2xhc3M9XFxcInNlYXJjaC1yZXN1bHRzLWNvdW50XFxcIj5BYm91dCA5NCA3MDAgMDAwICgwLjM5IHNlYy4pIHJlc3VsdHM8L3A+XFxyXFxuICAgIDxzZWN0aW9uIGNsYXNzPVxcXCJzZWFyY2gtcmVzdWx0LWl0ZW1cXFwiPlxcclxcbiAgICAgIDxhIGNsYXNzPVxcXCJpbWFnZS1saW5rXFxcIiBocmVmPVxcXCIjXFxcIj5cXHJcXG4gICAgICAgIDxpbWcgY2xhc3M9XFxcImltYWdlXFxcIiBzcmM9XFxcImFzc2V0cy9pbWcvcGljdHVyZXMvMS5qcGdcXFwiPlxcclxcbiAgICAgIDwvYT5cXHJcXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJzZWFyY2gtcmVzdWx0LWl0ZW0tYm9keVxcXCI+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcclxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtOSBjb2wteHMtMTJcXFwiPlxcclxcbiAgICAgICAgICAgIDxoNSBjbGFzcz1cXFwic2VhcmNoLXJlc3VsdC1pdGVtLWhlYWRpbmdcXFwiPlxcclxcbiAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiI1xcXCI+TmV4dCBnZW5lcmF0aW9uIGFkbWluIHRlbXBsYXRlPC9hPlxcclxcbiAgICAgICAgICAgIDwvaDU+XFxyXFxuICAgICAgICAgICAgPHAgY2xhc3M9XFxcImluZm9cXFwiPlxcclxcbiAgICAgICAgICAgICAgTmV3IFlvcmssIE5ZIDIwMTg4XFxyXFxuICAgICAgICAgICAgPC9wPlxcclxcbiAgICAgICAgICAgIDxwIGNsYXNzPVxcXCJkZXNjcmlwdGlvblxcXCI+XFxyXFxuICAgICAgICAgICAgICBOb3QganVzdCB1c3VhbCBNZXRyby4gQnV0IHNvbWV0aGluZyBiaWdnZXIuIE5vdCBqdXN0IHVzdWFsIHdpZGdldHMsIGJ1dCByZWFsXFxyXFxuICAgICAgICAgICAgICB3aWRnZXRzLiBOb3QganVzdCB5ZXQgYW5vdGhlciBhZG1pbiB0ZW1wbGF0ZSwgYnV0IG5leHQgZ2VuZXJhdGlvbiBhZG1pbiB0ZW1wbGF0ZS5cXHJcXG4gICAgICAgICAgICA8L3A+XFxyXFxuICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtMyBjb2wteHMtMTIgdGV4dC14cy1jZW50ZXJcXFwiPlxcclxcbiAgICAgICAgICAgIDxwIGNsYXNzPVxcXCJ2YWx1ZTMgbXQtc21cXFwiPlxcclxcbiAgICAgICAgICAgICAgJDksIDcwMFxcclxcbiAgICAgICAgICAgIDwvcD5cXHJcXG4gICAgICAgICAgICA8cCBjbGFzcz1cXFwiZnMtbWluaSB0ZXh0LW11dGVkXFxcIj5cXHJcXG4gICAgICAgICAgICAgIFBFUiBXRUVLXFxyXFxuICAgICAgICAgICAgPC9wPlxcclxcbiAgICAgICAgICAgIDxhIGNsYXNzPVxcXCJidG4gYnRuLXByaW1hcnkgYnRuLWluZm8gYnRuLXNtXFxcIiBocmVmPVxcXCIjXFxcIj5MZWFybiBNb3JlPC9hPlxcclxcbiAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICAgIDwvZGl2PlxcclxcbiAgICA8L3NlY3Rpb24+XFxyXFxuICAgIDxzZWN0aW9uIGNsYXNzPVxcXCJzZWFyY2gtcmVzdWx0LWl0ZW1cXFwiPlxcclxcbiAgICAgIDxhIGNsYXNzPVxcXCJpbWFnZS1saW5rXFxcIiBocmVmPVxcXCIjXFxcIj5cXHJcXG4gICAgICAgIDxpbWcgY2xhc3M9XFxcImltYWdlXFxcIiBzcmM9XFxcImFzc2V0cy9pbWcvcGljdHVyZXMvNS5qcGdcXFwiPlxcclxcbiAgICAgIDwvYT5cXHJcXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJzZWFyY2gtcmVzdWx0LWl0ZW0tYm9keVxcXCI+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcclxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wtbWQtOSBjb2wteHMtMTJcXFwiPlxcclxcbiAgICAgICAgICAgIDxoNSBjbGFzcz1cXFwic2VhcmNoLXJlc3VsdC1pdGVtLWhlYWRpbmdcXFwiPlxcclxcbiAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiI1xcXCI+VHJ5LiBQb3N0ZWQgYnkgT2tlbmRva2VuPC9hPlxcclxcbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInRhZyB0YWctcGlsbCB0YWctZGFuZ2VyIGZ3LW5vcm1hbCBmbG9hdC14cy1yaWdodFxcXCI+QmVzdCBEZWFsITwvc3Bhbj5cXHJcXG4gICAgICAgICAgICA8L2g1PlxcclxcbiAgICAgICAgICAgIDxwIGNsYXNzPVxcXCJpbmZvXFxcIj5cXHJcXG4gICAgICAgICAgICAgIExvcyBBbmdlbGVzLCBOWSAyMDE4OFxcclxcbiAgICAgICAgICAgIDwvcD5cXHJcXG4gICAgICAgICAgICA8cCBjbGFzcz1cXFwiZGVzY3JpcHRpb25cXFwiPlxcclxcbiAgICAgICAgICAgICAgWW91IHdpbGwgbmV2ZXIga25vdyBleGFjdGx5IGhvdyBzb21ldGhpbmcgd2lsbCBnbyB1bnRpbCB5b3UgdHJ5IGl0LiBZb3UgY2FuXFxyXFxuICAgICAgICAgICAgICB0aGluayB0aHJlZSBodW5kcmVkIHRpbWVzIGFuZCBzdGlsbCBoYXZlIG5vIHByZWNpc2UgcmVzdWx0LlxcclxcbiAgICAgICAgICAgIDwvcD5cXHJcXG4gICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC0zIGNvbC14cy0xMiB0ZXh0LXhzLWNlbnRlclxcXCI+XFxyXFxuICAgICAgICAgICAgPHAgY2xhc3M9XFxcInZhbHVlMyBtdC1zbVxcXCI+XFxyXFxuICAgICAgICAgICAgICAkMTAsIDMwMFxcclxcbiAgICAgICAgICAgIDwvcD5cXHJcXG4gICAgICAgICAgICA8cCBjbGFzcz1cXFwiZnMtbWluaSB0ZXh0LW11dGVkXFxcIj5cXHJcXG4gICAgICAgICAgICAgIFBFUiBXRUVLXFxyXFxuICAgICAgICAgICAgPC9wPlxcclxcbiAgICAgICAgICAgIDxhIGNsYXNzPVxcXCJidG4gYnRuLXByaW1hcnkgYnRuLWluZm8gYnRuLXNtXFxcIiBocmVmPVxcXCIjXFxcIj5MZWFybiBNb3JlPC9hPlxcclxcbiAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICAgIDwvZGl2PlxcclxcbiAgICA8L3NlY3Rpb24+XFxyXFxuICAgIDxzZWN0aW9uIGNsYXNzPVxcXCJzZWFyY2gtcmVzdWx0LWl0ZW1cXFwiPlxcclxcbiAgICAgIDxhIGNsYXNzPVxcXCJpbWFnZS1saW5rXFxcIiBocmVmPVxcXCIjXFxcIj5cXHJcXG4gICAgICAgIDxpbWcgY2xhc3M9XFxcImltYWdlXFxcIiBzcmM9XFxcImFzc2V0cy9pbWcvcGljdHVyZXMvMTMuanBnXFxcIj5cXHJcXG4gICAgICA8L2E+XFxyXFxuICAgICAgPGRpdiBjbGFzcz1cXFwic2VhcmNoLXJlc3VsdC1pdGVtLWJvZHlcXFwiPlxcclxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXHJcXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTkgY29sLXhzLTEyXFxcIj5cXHJcXG4gICAgICAgICAgICA8aDUgY2xhc3M9XFxcInNlYXJjaC1yZXN1bHQtaXRlbS1oZWFkaW5nXFxcIj5cXHJcXG4gICAgICAgICAgICAgIDxhIGhyZWY9XFxcIiNcXFwiPlZpdGF1dCB0aGUgR3JlYXQ8L2E+XFxyXFxuICAgICAgICAgICAgPC9oNT5cXHJcXG4gICAgICAgICAgICA8cCBjbGFzcz1cXFwiaW5mb1xcXCI+XFxyXFxuICAgICAgICAgICAgICBOZXcgWW9yaywgTlkgMjAxODhcXHJcXG4gICAgICAgICAgICA8L3A+XFxyXFxuICAgICAgICAgICAgPHAgY2xhc3M9XFxcImRlc2NyaXB0aW9uXFxcIj5cXHJcXG4gICAgICAgICAgICAgIFRoZSBHcmVhdCBQcmluY2Ugb2YgdGhlIEdyYW5kIER1Y2h5IG9mIExpdGh1YW5pYSBoZSBoYWQgc3RvcHBlZCB0aGUgaW52YXNpb24gdG9cXHJcXG4gICAgICAgICAgICAgIEV1cm9wZSBvZiBUaW11ciAoVGFtZXJsYW4pIGZyb20gQXNpYSBoZWFkaW5nIGEgYmlnIEFybXkgb2YgQmVsYXJ1c2lhbnMsIExpdGh1YW5pYW5zLlxcclxcbiAgICAgICAgICAgIDwvcD5cXHJcXG4gICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC0zIGNvbC14cy0xMiB0ZXh0LXhzLWNlbnRlclxcXCI+XFxyXFxuICAgICAgICAgICAgPHAgY2xhc3M9XFxcInZhbHVlMyBtdC1zbVxcXCI+XFxyXFxuICAgICAgICAgICAgICAkMywgMjAwXFxyXFxuICAgICAgICAgICAgPC9wPlxcclxcbiAgICAgICAgICAgIDxwIGNsYXNzPVxcXCJmcy1taW5pIHRleHQtbXV0ZWRcXFwiPlxcclxcbiAgICAgICAgICAgICAgUEVSIFdFRUtcXHJcXG4gICAgICAgICAgICA8L3A+XFxyXFxuICAgICAgICAgICAgPGEgY2xhc3M9XFxcImJ0biBidG4taW5mbyBidG4tc21cXFwiIGhyZWY9XFxcIiNcXFwiPkxlYXJuIE1vcmU8L2E+XFxyXFxuICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgPC9kaXY+XFxyXFxuICAgIDwvc2VjdGlvbj5cXHJcXG4gICAgPHNlY3Rpb24gY2xhc3M9XFxcInNlYXJjaC1yZXN1bHQtaXRlbVxcXCI+XFxyXFxuICAgICAgPGEgY2xhc3M9XFxcImltYWdlLWxpbmtcXFwiIGhyZWY9XFxcIiNcXFwiPlxcclxcbiAgICAgICAgPGltZyBjbGFzcz1cXFwiaW1hZ2VcXFwiIHNyYz1cXFwiYXNzZXRzL2ltZy9waWN0dXJlcy8zLmpwZ1xcXCI+XFxyXFxuICAgICAgPC9hPlxcclxcbiAgICAgIDxkaXYgY2xhc3M9XFxcInNlYXJjaC1yZXN1bHQtaXRlbS1ib2R5XFxcIj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxyXFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC05IGNvbC14cy0xMlxcXCI+XFxyXFxuICAgICAgICAgICAgPGg1IGNsYXNzPVxcXCJzZWFyY2gtcmVzdWx0LWl0ZW0taGVhZGluZ1xcXCI+XFxyXFxuICAgICAgICAgICAgICA8YSBocmVmPVxcXCIjXFxcIj5DYW4gSSB1c2UgQ1NTMyBSYWRpYWwtR3JhZGllbnQ/PC9hPlxcclxcbiAgICAgICAgICAgIDwvaDU+XFxyXFxuICAgICAgICAgICAgPHAgY2xhc3M9XFxcImluZm9cXFwiPlxcclxcbiAgICAgICAgICAgICAgTWluc2ssIE5ZIDIwMTg4XFxyXFxuICAgICAgICAgICAgPC9wPlxcclxcbiAgICAgICAgICAgIDxwIGNsYXNzPVxcXCJkZXNjcmlwdGlvblxcXCI+XFxyXFxuICAgICAgICAgICAgICBZZXMgeW91IGNhbiEgRnVydGhlciBtb3JlLCB5b3Ugc2hvdWxkISBJdCBsZXQncyB5b3UgY3JlYXRlIHJlYWxseSBiZWF1dGlmdWwgaW1hZ2VzXFxyXFxuICAgICAgICAgICAgICBlaXRoZXIgZm9yIGVsZW1lbnRzIG9yIGZvciB0aGUgZW50aXJlIGJhY2tncm91bmQuXFxyXFxuICAgICAgICAgICAgPC9wPlxcclxcbiAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTMgY29sLXhzLTEyIHRleHQteHMtY2VudGVyXFxcIj5cXHJcXG4gICAgICAgICAgICA8cCBjbGFzcz1cXFwidmFsdWUzIG10LXNtXFxcIj5cXHJcXG4gICAgICAgICAgICAgICQyLCA0MDBcXHJcXG4gICAgICAgICAgICA8L3A+XFxyXFxuICAgICAgICAgICAgPHAgY2xhc3M9XFxcImZzLW1pbmkgdGV4dC1tdXRlZFxcXCI+XFxyXFxuICAgICAgICAgICAgICBQRVIgTU9OVEhcXHJcXG4gICAgICAgICAgICA8L3A+XFxyXFxuICAgICAgICAgICAgPGEgY2xhc3M9XFxcImJ0biBidG4taW5mbyBidG4tc21cXFwiIGhyZWY9XFxcIiNcXFwiPkxlYXJuIE1vcmU8L2E+XFxyXFxuICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgPC9kaXY+XFxyXFxuICAgIDwvc2VjdGlvbj5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwidGV4dC14cy1jZW50ZXJcXFwiPlxcclxcbiAgICAgIDx1bCBjbGFzcz1cXFwicGFnaW5hdGlvbiBwYWdpbmF0aW9uLXNtXFxcIj5cXHJcXG4gICAgICAgIDxsaSBjbGFzcz1cXFwiZGlzYWJsZWQgcGFnZS1pdGVtXFxcIj48YSBjbGFzcz1cXFwicGFnZS1saW5rXFxcIiBocmVmPVxcXCIjXFxcIj5QcmV2PC9hPjwvbGk+XFxyXFxuICAgICAgICA8bGkgY2xhc3M9XFxcImFjdGl2ZSBwYWdlLWl0ZW1cXFwiPjxhIGNsYXNzPVxcXCJwYWdlLWxpbmtcXFwiIGhyZWY9XFxcIiNcXFwiPjE8L2E+PC9saT5cXHJcXG4gICAgICAgIDxsaSBjbGFzcz1cXFwicGFnZS1pdGVtXFxcIj48YSBjbGFzcz1cXFwicGFnZS1saW5rXFxcIiBocmVmPVxcXCIjXFxcIj4yPC9hPjwvbGk+XFxyXFxuICAgICAgICA8bGkgY2xhc3M9XFxcInBhZ2UtaXRlbVxcXCI+PGEgY2xhc3M9XFxcInBhZ2UtbGlua1xcXCIgaHJlZj1cXFwiI1xcXCI+MzwvYT48L2xpPlxcclxcbiAgICAgICAgPGxpIGNsYXNzPVxcXCJwYWdlLWl0ZW1cXFwiPjxhIGNsYXNzPVxcXCJwYWdlLWxpbmtcXFwiIGhyZWY9XFxcIiNcXFwiPjQ8L2E+PC9saT5cXHJcXG4gICAgICAgIDxsaSBjbGFzcz1cXFwicGFnZS1pdGVtXFxcIj48YSBjbGFzcz1cXFwicGFnZS1saW5rXFxcIiBocmVmPVxcXCIjXFxcIj41PC9hPjwvbGk+XFxyXFxuICAgICAgICA8bGkgY2xhc3M9XFxcInBhZ2UtaXRlbVxcXCI+PGEgY2xhc3M9XFxcInBhZ2UtbGlua1xcXCIgaHJlZj1cXFwiI1xcXCI+TmV4dDwvYT48L2xpPlxcclxcbiAgICAgIDwvdWw+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgPC9kaXY+XFxyXFxuPC9kaXY+XFxyXFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9hcHAvZXh0cmEvc2VhcmNoLXJlc3VsdHMvc2VhcmNoLXJlc3VsdHMudGVtcGxhdGUuaHRtbFxuLy8gbW9kdWxlIGlkID0gMTE0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDUiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 1149:
/* unknown exports provided */
/* all exports used */
/*!*********************************************************!*\
  !*** ./src/app/extra/time-line/time-line.template.html ***!
  \*********************************************************/
/***/ (function(module, exports) {

eval("module.exports = \"<ol class=\\\"breadcrumb\\\">\\r\\n  <li class=\\\"breadcrumb-item\\\">YOU ARE HERE</li>\\r\\n  <li class=\\\"breadcrumb-item active\\\">Time Line</li>\\r\\n</ol>\\r\\n<h1 class=\\\"page-title\\\">Events - <span class=\\\"fw-semi-bold\\\">Feed</span></h1>\\r\\n<ul class=\\\"timeline\\\">\\r\\n  <li class=\\\"on-left\\\">\\r\\n    <time class=\\\"event-time\\\" datetime=\\\"2014-05-19 03:04\\\">\\r\\n      <span class=\\\"date\\\">yesterday</span>\\r\\n      <span class=\\\"time\\\">8:03 <span class=\\\"fw-semi-bold\\\">pm</span></span>\\r\\n    </time>\\r\\n                <span class=\\\"event-icon event-icon-success\\\">\\r\\n                    <i class=\\\"glyphicon glyphicon-map-marker\\\"></i>\\r\\n                </span>\\r\\n    <section class=\\\"event\\\">\\r\\n                    <span class=\\\"thumb-sm avatar pull-left mr-sm\\\">\\r\\n                        <img class=\\\"rounded-circle\\\" src=\\\"assets/img/people/a2.jpg\\\" alt=\\\"...\\\">\\r\\n                    </span>\\r\\n      <h4 class=\\\"event-heading\\\"><a href=\\\"#\\\">Jessica Nilson</a> <small>@jess</small></h4>\\r\\n      <p class=\\\"fs-sm text-muted\\\">10:12 am - Publicly near Minsk</p>\\r\\n      <sebm-google-map [latitude]=\\\"51\\\" [longitude]=\\\"7\\\" class=\\\"event-map\\\">\\r\\n        <sebm-google-map-marker [latitude]=\\\"51\\\" [longitude]=\\\"7\\\" [markerDraggable]=\\\"true\\\">\\r\\n        </sebm-google-map-marker>\\r\\n      </sebm-google-map>\\r\\n      <footer>\\r\\n        <ul class=\\\"post-links\\\">\\r\\n          <li><a href=\\\"#\\\">1 hour</a></li>\\r\\n          <li><a href=\\\"#\\\"><span class=\\\"text-danger\\\"><i class=\\\"fa fa-heart\\\"></i> Like</span></a></li>\\r\\n          <li><a href=\\\"#\\\">Comment</a></li>\\r\\n        </ul>\\r\\n        <ul class=\\\"post-comments\\\">\\r\\n          <li>\\r\\n                                <span class=\\\"thumb-xs avatar pull-left mr-sm\\\">\\r\\n                                    <img class=\\\"rounded-circle\\\" src=\\\"assets/img/people/a2.jpg\\\" alt=\\\"...\\\">\\r\\n                                </span>\\r\\n            <div class=\\\"comment-body\\\">\\r\\n              <h6 class=\\\"author fs-sm fw-semi-bold\\\">Radrigo Gonzales <small>7 mins ago</small></h6>\\r\\n              <p>Someone said they were the best people out there just few years ago. Don't know\\r\\n                better options.</p>\\r\\n            </div>\\r\\n          </li>\\r\\n          <li>\\r\\n                                <span class=\\\"thumb-xs avatar pull-left mr-sm\\\">\\r\\n                                    <img class=\\\"rounded-circle\\\" src=\\\"assets/img/people/a4.jpg\\\" alt=\\\"...\\\">\\r\\n                                </span>\\r\\n            <div class=\\\"comment-body\\\">\\r\\n              <h6 class=\\\"author fs-sm fw-semi-bold\\\">Ignacio Abad <small>6 mins ago</small></h6>\\r\\n              <p>True. Heard absolutely the same.</p>\\r\\n            </div>\\r\\n          </li>\\r\\n          <li>\\r\\n                                <span class=\\\"thumb-xs avatar pull-left mr-sm\\\">\\r\\n                                    <img class=\\\"rounded-circle\\\" src=\\\"assets/img/avatar.png\\\" alt=\\\"...\\\">\\r\\n                                </span>\\r\\n            <div class=\\\"comment-body\\\">\\r\\n              <input class=\\\"form-control form-control-sm\\\" type=\\\"text\\\" placeholder=\\\"Write your comment...\\\">\\r\\n            </div>\\r\\n          </li>\\r\\n        </ul>\\r\\n      </footer>\\r\\n    </section>\\r\\n  </li>\\r\\n  <li>\\r\\n    <time class=\\\"event-time\\\" datetime=\\\"2014-05-19 03:04\\\">\\r\\n      <span class=\\\"date\\\">today</span>\\r\\n      <span class=\\\"time\\\">9:41 <span class=\\\"fw-semi-bold\\\">am</span></span>\\r\\n    </time>\\r\\n                <span class=\\\"event-icon event-icon-primary\\\">\\r\\n                    <i class=\\\"glyphicon glyphicon-comment\\\"></i>\\r\\n                </span>\\r\\n    <section class=\\\"event\\\">\\r\\n                    <span class=\\\"thumb-sm avatar pull-left mr-sm\\\">\\r\\n                        <img class=\\\"rounded-circle\\\" src=\\\"assets/img/people/a5.jpg\\\" alt=\\\"...\\\">\\r\\n                    </span>\\r\\n      <h5 class=\\\"event-heading\\\"><a href=\\\"#\\\">Bob Nilson</a> <small><a href=\\\"#\\\">@nils</a></small></h5>\\r\\n      <p class=\\\"fs-sm text-muted\\\">February 22, 2014 at 01:59 PM</p>\\r\\n      <p class=\\\"fs-mini\\\">\\r\\n        There is no such thing as maturity. There is instead an ever-evolving process of maturing.\\r\\n        Because when there is a maturity, there is ...\\r\\n      </p>\\r\\n      <footer>\\r\\n        <ul class=\\\"post-links\\\">\\r\\n          <li><a href=\\\"#\\\">1 hour</a></li>\\r\\n          <li><a href=\\\"#\\\"><span class=\\\"text-danger\\\"><i class=\\\"fa fa-heart\\\"></i> Like</span></a></li>\\r\\n          <li><a href=\\\"#\\\">Comment</a></li>\\r\\n        </ul>\\r\\n      </footer>\\r\\n    </section>\\r\\n  </li>\\r\\n  <li class=\\\"on-left\\\">\\r\\n    <time class=\\\"event-time\\\" datetime=\\\"2014-05-19 03:04\\\">\\r\\n      <span class=\\\"date\\\">yesterday</span>\\r\\n      <span class=\\\"time\\\">9:03 <span class=\\\"fw-semi-bold\\\">am</span></span>\\r\\n    </time>\\r\\n                <span class=\\\"event-icon event-icon-danger\\\">\\r\\n                    <i class=\\\"glyphicon glyphicon-cutlery\\\"></i>\\r\\n                </span>\\r\\n    <section class=\\\"event\\\">\\r\\n      <h5 class=\\\"event-heading\\\"><a href=\\\"#\\\">Jessica Smith</a> <small>@jess</small></h5>\\r\\n      <p class=\\\"fs-sm text-muted\\\">February 22, 2014 at 01:59 PM</p>\\r\\n      <p class=\\\"fs-mini\\\">\\r\\n        Check out this awesome photo I made in Italy last summer. Seems it was lost somewhere deep inside\\r\\n        my brand new HDD 40TB. Thanks god I found it!\\r\\n      </p>\\r\\n      <div class=\\\"event-image\\\">\\r\\n        <a href=\\\"assets/img/pictures/8.jpg\\\"  data-ui-jq=\\\"magnificPopup\\\" data-ui-options=\\\"{type: 'image'}\\\">\\r\\n          <img src=\\\"assets/img/pictures/8.jpg\\\">\\r\\n        </a>\\r\\n      </div>\\r\\n      <footer>\\r\\n        <div class=\\\"clearfix\\\">\\r\\n          <ul class=\\\"post-links mt-sm pull-left\\\">\\r\\n            <li><a href=\\\"#\\\">1 hour</a></li>\\r\\n            <li><a href=\\\"#\\\"><span class=\\\"text-danger\\\"><i class=\\\"fa fa-heart-o\\\"></i> Like</span></a></li>\\r\\n            <li><a href=\\\"#\\\">Comment</a></li>\\r\\n          </ul>\\r\\n\\r\\n                            <span class=\\\"thumb thumb-sm pull-right\\\">\\r\\n                                <a href=\\\"#\\\">\\r\\n                                  <img class=\\\"rounded-circle\\\" src=\\\"assets/img/people/a1.jpg\\\">\\r\\n                                </a>\\r\\n                            </span>\\r\\n                            <span class=\\\"thumb thumb-sm pull-right\\\">\\r\\n                                <a href=\\\"#\\\"><img class=\\\"rounded-circle\\\" src=\\\"assets/img/people/a5.jpg\\\"></a>\\r\\n                            </span>\\r\\n                            <span class=\\\"thumb thumb-sm pull-right\\\">\\r\\n                                <a href=\\\"#\\\"><img class=\\\"rounded-circle\\\" src=\\\"assets/img/people/a3.jpg\\\"></a>\\r\\n                            </span>\\r\\n        </div>\\r\\n        <ul class=\\\"post-comments mt-sm\\\">\\r\\n          <li>\\r\\n                                <span class=\\\"thumb-xs avatar pull-left mr-sm\\\">\\r\\n                                    <img class=\\\"rounded-circle\\\" src=\\\"assets/img/people/a1.jpg\\\" alt=\\\"...\\\">\\r\\n                                </span>\\r\\n            <div class=\\\"comment-body\\\">\\r\\n              <h6 class=\\\"author fs-sm fw-semi-bold\\\">Ignacio Abad <small>6 mins ago</small></h6>\\r\\n              <p>Hey, have you heard anything about that?</p>\\r\\n            </div>\\r\\n          </li>\\r\\n          <li>\\r\\n                                <span class=\\\"thumb-xs avatar pull-left mr-sm\\\">\\r\\n                                    <img class=\\\"rounded-circle\\\" src=\\\"assets/img/avatar.png\\\" alt=\\\"...\\\">\\r\\n                                </span>\\r\\n            <div class=\\\"comment-body\\\">\\r\\n              <input class=\\\"form-control form-control-sm\\\" type=\\\"text\\\" placeholder=\\\"Write your comment...\\\">\\r\\n            </div>\\r\\n          </li>\\r\\n        </ul>\\r\\n      </footer>\\r\\n    </section>\\r\\n  </li>\\r\\n  <li>\\r\\n    <time class=\\\"event-time\\\" datetime=\\\"2014-05-19 03:04\\\">\\r\\n      <span class=\\\"date\\\">yesterday</span>\\r\\n      <span class=\\\"time\\\">9:03 <span class=\\\"fw-semi-bold\\\">am</span></span>\\r\\n    </time>\\r\\n                <span class=\\\"event-icon\\\">\\r\\n                    <img class=\\\"rounded-circle\\\" src=\\\"assets/img/avatar.png\\\">\\r\\n                </span>\\r\\n    <section class=\\\"event\\\">\\r\\n                    <span class=\\\"thumb-sm avatar pull-left mr-sm\\\">\\r\\n                        <img class=\\\"rounded-circle\\\" src=\\\"assets/img/people/a6.jpg\\\" alt=\\\"...\\\">\\r\\n                    </span>\\r\\n      <h5 class=\\\"event-heading\\\"><a href=\\\"#\\\">Jessica Smith</a> <small>@jess</small></h5>\\r\\n      <p class=\\\"fs-sm text-muted\\\">9:03 am - Publicly near Minsk</p>\\r\\n      <h5>New <span class=\\\"fw-semi-bold\\\">Project</span> Launch</h5>\\r\\n      <p class=\\\"fs-mini\\\">\\r\\n        Let's try something different this time. Hey, do you wanna join us tonight?\\r\\n        We're planning to a launch a new project soon. Want to discuss with all of you...\\r\\n      </p>\\r\\n      <a class=\\\"mt-n-xs fs-mini text-muted\\\" href=\\\"#\\\">Read more...</a>\\r\\n      <footer>\\r\\n        <ul class=\\\"post-links\\\">\\r\\n          <li><a href=\\\"#\\\">1 hour</a></li>\\r\\n          <li><a href=\\\"#\\\"><span class=\\\"text-danger\\\"><i class=\\\"fa fa-heart-o\\\"></i> Like</span></a></li>\\r\\n          <li><a href=\\\"#\\\">Comment</a></li>\\r\\n        </ul>\\r\\n      </footer>\\r\\n    </section>\\r\\n  </li>\\r\\n</ul>\\r\\n\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE0OS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9hcHAvZXh0cmEvdGltZS1saW5lL3RpbWUtbGluZS50ZW1wbGF0ZS5odG1sPzBhMGMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIjxvbCBjbGFzcz1cXFwiYnJlYWRjcnVtYlxcXCI+XFxyXFxuICA8bGkgY2xhc3M9XFxcImJyZWFkY3J1bWItaXRlbVxcXCI+WU9VIEFSRSBIRVJFPC9saT5cXHJcXG4gIDxsaSBjbGFzcz1cXFwiYnJlYWRjcnVtYi1pdGVtIGFjdGl2ZVxcXCI+VGltZSBMaW5lPC9saT5cXHJcXG48L29sPlxcclxcbjxoMSBjbGFzcz1cXFwicGFnZS10aXRsZVxcXCI+RXZlbnRzIC0gPHNwYW4gY2xhc3M9XFxcImZ3LXNlbWktYm9sZFxcXCI+RmVlZDwvc3Bhbj48L2gxPlxcclxcbjx1bCBjbGFzcz1cXFwidGltZWxpbmVcXFwiPlxcclxcbiAgPGxpIGNsYXNzPVxcXCJvbi1sZWZ0XFxcIj5cXHJcXG4gICAgPHRpbWUgY2xhc3M9XFxcImV2ZW50LXRpbWVcXFwiIGRhdGV0aW1lPVxcXCIyMDE0LTA1LTE5IDAzOjA0XFxcIj5cXHJcXG4gICAgICA8c3BhbiBjbGFzcz1cXFwiZGF0ZVxcXCI+eWVzdGVyZGF5PC9zcGFuPlxcclxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJ0aW1lXFxcIj44OjAzIDxzcGFuIGNsYXNzPVxcXCJmdy1zZW1pLWJvbGRcXFwiPnBtPC9zcGFuPjwvc3Bhbj5cXHJcXG4gICAgPC90aW1lPlxcclxcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiZXZlbnQtaWNvbiBldmVudC1pY29uLXN1Y2Nlc3NcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tbWFwLW1hcmtlclxcXCI+PC9pPlxcclxcbiAgICAgICAgICAgICAgICA8L3NwYW4+XFxyXFxuICAgIDxzZWN0aW9uIGNsYXNzPVxcXCJldmVudFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidGh1bWItc20gYXZhdGFyIHB1bGwtbGVmdCBtci1zbVxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBjbGFzcz1cXFwicm91bmRlZC1jaXJjbGVcXFwiIHNyYz1cXFwiYXNzZXRzL2ltZy9wZW9wbGUvYTIuanBnXFxcIiBhbHQ9XFxcIi4uLlxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XFxyXFxuICAgICAgPGg0IGNsYXNzPVxcXCJldmVudC1oZWFkaW5nXFxcIj48YSBocmVmPVxcXCIjXFxcIj5KZXNzaWNhIE5pbHNvbjwvYT4gPHNtYWxsPkBqZXNzPC9zbWFsbD48L2g0PlxcclxcbiAgICAgIDxwIGNsYXNzPVxcXCJmcy1zbSB0ZXh0LW11dGVkXFxcIj4xMDoxMiBhbSAtIFB1YmxpY2x5IG5lYXIgTWluc2s8L3A+XFxyXFxuICAgICAgPHNlYm0tZ29vZ2xlLW1hcCBbbGF0aXR1ZGVdPVxcXCI1MVxcXCIgW2xvbmdpdHVkZV09XFxcIjdcXFwiIGNsYXNzPVxcXCJldmVudC1tYXBcXFwiPlxcclxcbiAgICAgICAgPHNlYm0tZ29vZ2xlLW1hcC1tYXJrZXIgW2xhdGl0dWRlXT1cXFwiNTFcXFwiIFtsb25naXR1ZGVdPVxcXCI3XFxcIiBbbWFya2VyRHJhZ2dhYmxlXT1cXFwidHJ1ZVxcXCI+XFxyXFxuICAgICAgICA8L3NlYm0tZ29vZ2xlLW1hcC1tYXJrZXI+XFxyXFxuICAgICAgPC9zZWJtLWdvb2dsZS1tYXA+XFxyXFxuICAgICAgPGZvb3Rlcj5cXHJcXG4gICAgICAgIDx1bCBjbGFzcz1cXFwicG9zdC1saW5rc1xcXCI+XFxyXFxuICAgICAgICAgIDxsaT48YSBocmVmPVxcXCIjXFxcIj4xIGhvdXI8L2E+PC9saT5cXHJcXG4gICAgICAgICAgPGxpPjxhIGhyZWY9XFxcIiNcXFwiPjxzcGFuIGNsYXNzPVxcXCJ0ZXh0LWRhbmdlclxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLWhlYXJ0XFxcIj48L2k+IExpa2U8L3NwYW4+PC9hPjwvbGk+XFxyXFxuICAgICAgICAgIDxsaT48YSBocmVmPVxcXCIjXFxcIj5Db21tZW50PC9hPjwvbGk+XFxyXFxuICAgICAgICA8L3VsPlxcclxcbiAgICAgICAgPHVsIGNsYXNzPVxcXCJwb3N0LWNvbW1lbnRzXFxcIj5cXHJcXG4gICAgICAgICAgPGxpPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInRodW1iLXhzIGF2YXRhciBwdWxsLWxlZnQgbXItc21cXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgY2xhc3M9XFxcInJvdW5kZWQtY2lyY2xlXFxcIiBzcmM9XFxcImFzc2V0cy9pbWcvcGVvcGxlL2EyLmpwZ1xcXCIgYWx0PVxcXCIuLi5cXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxcclxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbW1lbnQtYm9keVxcXCI+XFxyXFxuICAgICAgICAgICAgICA8aDYgY2xhc3M9XFxcImF1dGhvciBmcy1zbSBmdy1zZW1pLWJvbGRcXFwiPlJhZHJpZ28gR29uemFsZXMgPHNtYWxsPjcgbWlucyBhZ288L3NtYWxsPjwvaDY+XFxyXFxuICAgICAgICAgICAgICA8cD5Tb21lb25lIHNhaWQgdGhleSB3ZXJlIHRoZSBiZXN0IHBlb3BsZSBvdXQgdGhlcmUganVzdCBmZXcgeWVhcnMgYWdvLiBEb24ndCBrbm93XFxyXFxuICAgICAgICAgICAgICAgIGJldHRlciBvcHRpb25zLjwvcD5cXHJcXG4gICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgPC9saT5cXHJcXG4gICAgICAgICAgPGxpPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInRodW1iLXhzIGF2YXRhciBwdWxsLWxlZnQgbXItc21cXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgY2xhc3M9XFxcInJvdW5kZWQtY2lyY2xlXFxcIiBzcmM9XFxcImFzc2V0cy9pbWcvcGVvcGxlL2E0LmpwZ1xcXCIgYWx0PVxcXCIuLi5cXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxcclxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbW1lbnQtYm9keVxcXCI+XFxyXFxuICAgICAgICAgICAgICA8aDYgY2xhc3M9XFxcImF1dGhvciBmcy1zbSBmdy1zZW1pLWJvbGRcXFwiPklnbmFjaW8gQWJhZCA8c21hbGw+NiBtaW5zIGFnbzwvc21hbGw+PC9oNj5cXHJcXG4gICAgICAgICAgICAgIDxwPlRydWUuIEhlYXJkIGFic29sdXRlbHkgdGhlIHNhbWUuPC9wPlxcclxcbiAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICA8L2xpPlxcclxcbiAgICAgICAgICA8bGk+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidGh1bWIteHMgYXZhdGFyIHB1bGwtbGVmdCBtci1zbVxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBjbGFzcz1cXFwicm91bmRlZC1jaXJjbGVcXFwiIHNyYz1cXFwiYXNzZXRzL2ltZy9hdmF0YXIucG5nXFxcIiBhbHQ9XFxcIi4uLlxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XFxyXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29tbWVudC1ib2R5XFxcIj5cXHJcXG4gICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cXFwiZm9ybS1jb250cm9sIGZvcm0tY29udHJvbC1zbVxcXCIgdHlwZT1cXFwidGV4dFxcXCIgcGxhY2Vob2xkZXI9XFxcIldyaXRlIHlvdXIgY29tbWVudC4uLlxcXCI+XFxyXFxuICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgIDwvbGk+XFxyXFxuICAgICAgICA8L3VsPlxcclxcbiAgICAgIDwvZm9vdGVyPlxcclxcbiAgICA8L3NlY3Rpb24+XFxyXFxuICA8L2xpPlxcclxcbiAgPGxpPlxcclxcbiAgICA8dGltZSBjbGFzcz1cXFwiZXZlbnQtdGltZVxcXCIgZGF0ZXRpbWU9XFxcIjIwMTQtMDUtMTkgMDM6MDRcXFwiPlxcclxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJkYXRlXFxcIj50b2RheTwvc3Bhbj5cXHJcXG4gICAgICA8c3BhbiBjbGFzcz1cXFwidGltZVxcXCI+OTo0MSA8c3BhbiBjbGFzcz1cXFwiZnctc2VtaS1ib2xkXFxcIj5hbTwvc3Bhbj48L3NwYW4+XFxyXFxuICAgIDwvdGltZT5cXHJcXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImV2ZW50LWljb24gZXZlbnQtaWNvbi1wcmltYXJ5XFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNvbW1lbnRcXFwiPjwvaT5cXHJcXG4gICAgICAgICAgICAgICAgPC9zcGFuPlxcclxcbiAgICA8c2VjdGlvbiBjbGFzcz1cXFwiZXZlbnRcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInRodW1iLXNtIGF2YXRhciBwdWxsLWxlZnQgbXItc21cXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgY2xhc3M9XFxcInJvdW5kZWQtY2lyY2xlXFxcIiBzcmM9XFxcImFzc2V0cy9pbWcvcGVvcGxlL2E1LmpwZ1xcXCIgYWx0PVxcXCIuLi5cXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxcclxcbiAgICAgIDxoNSBjbGFzcz1cXFwiZXZlbnQtaGVhZGluZ1xcXCI+PGEgaHJlZj1cXFwiI1xcXCI+Qm9iIE5pbHNvbjwvYT4gPHNtYWxsPjxhIGhyZWY9XFxcIiNcXFwiPkBuaWxzPC9hPjwvc21hbGw+PC9oNT5cXHJcXG4gICAgICA8cCBjbGFzcz1cXFwiZnMtc20gdGV4dC1tdXRlZFxcXCI+RmVicnVhcnkgMjIsIDIwMTQgYXQgMDE6NTkgUE08L3A+XFxyXFxuICAgICAgPHAgY2xhc3M9XFxcImZzLW1pbmlcXFwiPlxcclxcbiAgICAgICAgVGhlcmUgaXMgbm8gc3VjaCB0aGluZyBhcyBtYXR1cml0eS4gVGhlcmUgaXMgaW5zdGVhZCBhbiBldmVyLWV2b2x2aW5nIHByb2Nlc3Mgb2YgbWF0dXJpbmcuXFxyXFxuICAgICAgICBCZWNhdXNlIHdoZW4gdGhlcmUgaXMgYSBtYXR1cml0eSwgdGhlcmUgaXMgLi4uXFxyXFxuICAgICAgPC9wPlxcclxcbiAgICAgIDxmb290ZXI+XFxyXFxuICAgICAgICA8dWwgY2xhc3M9XFxcInBvc3QtbGlua3NcXFwiPlxcclxcbiAgICAgICAgICA8bGk+PGEgaHJlZj1cXFwiI1xcXCI+MSBob3VyPC9hPjwvbGk+XFxyXFxuICAgICAgICAgIDxsaT48YSBocmVmPVxcXCIjXFxcIj48c3BhbiBjbGFzcz1cXFwidGV4dC1kYW5nZXJcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1oZWFydFxcXCI+PC9pPiBMaWtlPC9zcGFuPjwvYT48L2xpPlxcclxcbiAgICAgICAgICA8bGk+PGEgaHJlZj1cXFwiI1xcXCI+Q29tbWVudDwvYT48L2xpPlxcclxcbiAgICAgICAgPC91bD5cXHJcXG4gICAgICA8L2Zvb3Rlcj5cXHJcXG4gICAgPC9zZWN0aW9uPlxcclxcbiAgPC9saT5cXHJcXG4gIDxsaSBjbGFzcz1cXFwib24tbGVmdFxcXCI+XFxyXFxuICAgIDx0aW1lIGNsYXNzPVxcXCJldmVudC10aW1lXFxcIiBkYXRldGltZT1cXFwiMjAxNC0wNS0xOSAwMzowNFxcXCI+XFxyXFxuICAgICAgPHNwYW4gY2xhc3M9XFxcImRhdGVcXFwiPnllc3RlcmRheTwvc3Bhbj5cXHJcXG4gICAgICA8c3BhbiBjbGFzcz1cXFwidGltZVxcXCI+OTowMyA8c3BhbiBjbGFzcz1cXFwiZnctc2VtaS1ib2xkXFxcIj5hbTwvc3Bhbj48L3NwYW4+XFxyXFxuICAgIDwvdGltZT5cXHJcXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImV2ZW50LWljb24gZXZlbnQtaWNvbi1kYW5nZXJcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tY3V0bGVyeVxcXCI+PC9pPlxcclxcbiAgICAgICAgICAgICAgICA8L3NwYW4+XFxyXFxuICAgIDxzZWN0aW9uIGNsYXNzPVxcXCJldmVudFxcXCI+XFxyXFxuICAgICAgPGg1IGNsYXNzPVxcXCJldmVudC1oZWFkaW5nXFxcIj48YSBocmVmPVxcXCIjXFxcIj5KZXNzaWNhIFNtaXRoPC9hPiA8c21hbGw+QGplc3M8L3NtYWxsPjwvaDU+XFxyXFxuICAgICAgPHAgY2xhc3M9XFxcImZzLXNtIHRleHQtbXV0ZWRcXFwiPkZlYnJ1YXJ5IDIyLCAyMDE0IGF0IDAxOjU5IFBNPC9wPlxcclxcbiAgICAgIDxwIGNsYXNzPVxcXCJmcy1taW5pXFxcIj5cXHJcXG4gICAgICAgIENoZWNrIG91dCB0aGlzIGF3ZXNvbWUgcGhvdG8gSSBtYWRlIGluIEl0YWx5IGxhc3Qgc3VtbWVyLiBTZWVtcyBpdCB3YXMgbG9zdCBzb21ld2hlcmUgZGVlcCBpbnNpZGVcXHJcXG4gICAgICAgIG15IGJyYW5kIG5ldyBIREQgNDBUQi4gVGhhbmtzIGdvZCBJIGZvdW5kIGl0IVxcclxcbiAgICAgIDwvcD5cXHJcXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJldmVudC1pbWFnZVxcXCI+XFxyXFxuICAgICAgICA8YSBocmVmPVxcXCJhc3NldHMvaW1nL3BpY3R1cmVzLzguanBnXFxcIiAgZGF0YS11aS1qcT1cXFwibWFnbmlmaWNQb3B1cFxcXCIgZGF0YS11aS1vcHRpb25zPVxcXCJ7dHlwZTogJ2ltYWdlJ31cXFwiPlxcclxcbiAgICAgICAgICA8aW1nIHNyYz1cXFwiYXNzZXRzL2ltZy9waWN0dXJlcy84LmpwZ1xcXCI+XFxyXFxuICAgICAgICA8L2E+XFxyXFxuICAgICAgPC9kaXY+XFxyXFxuICAgICAgPGZvb3Rlcj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNsZWFyZml4XFxcIj5cXHJcXG4gICAgICAgICAgPHVsIGNsYXNzPVxcXCJwb3N0LWxpbmtzIG10LXNtIHB1bGwtbGVmdFxcXCI+XFxyXFxuICAgICAgICAgICAgPGxpPjxhIGhyZWY9XFxcIiNcXFwiPjEgaG91cjwvYT48L2xpPlxcclxcbiAgICAgICAgICAgIDxsaT48YSBocmVmPVxcXCIjXFxcIj48c3BhbiBjbGFzcz1cXFwidGV4dC1kYW5nZXJcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1oZWFydC1vXFxcIj48L2k+IExpa2U8L3NwYW4+PC9hPjwvbGk+XFxyXFxuICAgICAgICAgICAgPGxpPjxhIGhyZWY9XFxcIiNcXFwiPkNvbW1lbnQ8L2E+PC9saT5cXHJcXG4gICAgICAgICAgPC91bD5cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInRodW1iIHRodW1iLXNtIHB1bGwtcmlnaHRcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiI1xcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgY2xhc3M9XFxcInJvdW5kZWQtY2lyY2xlXFxcIiBzcmM9XFxcImFzc2V0cy9pbWcvcGVvcGxlL2ExLmpwZ1xcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2E+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInRodW1iIHRodW1iLXNtIHB1bGwtcmlnaHRcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiI1xcXCI+PGltZyBjbGFzcz1cXFwicm91bmRlZC1jaXJjbGVcXFwiIHNyYz1cXFwiYXNzZXRzL2ltZy9wZW9wbGUvYTUuanBnXFxcIj48L2E+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInRodW1iIHRodW1iLXNtIHB1bGwtcmlnaHRcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiI1xcXCI+PGltZyBjbGFzcz1cXFwicm91bmRlZC1jaXJjbGVcXFwiIHNyYz1cXFwiYXNzZXRzL2ltZy9wZW9wbGUvYTMuanBnXFxcIj48L2E+XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPHVsIGNsYXNzPVxcXCJwb3N0LWNvbW1lbnRzIG10LXNtXFxcIj5cXHJcXG4gICAgICAgICAgPGxpPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInRodW1iLXhzIGF2YXRhciBwdWxsLWxlZnQgbXItc21cXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgY2xhc3M9XFxcInJvdW5kZWQtY2lyY2xlXFxcIiBzcmM9XFxcImFzc2V0cy9pbWcvcGVvcGxlL2ExLmpwZ1xcXCIgYWx0PVxcXCIuLi5cXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxcclxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbW1lbnQtYm9keVxcXCI+XFxyXFxuICAgICAgICAgICAgICA8aDYgY2xhc3M9XFxcImF1dGhvciBmcy1zbSBmdy1zZW1pLWJvbGRcXFwiPklnbmFjaW8gQWJhZCA8c21hbGw+NiBtaW5zIGFnbzwvc21hbGw+PC9oNj5cXHJcXG4gICAgICAgICAgICAgIDxwPkhleSwgaGF2ZSB5b3UgaGVhcmQgYW55dGhpbmcgYWJvdXQgdGhhdD88L3A+XFxyXFxuICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgIDwvbGk+XFxyXFxuICAgICAgICAgIDxsaT5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ0aHVtYi14cyBhdmF0YXIgcHVsbC1sZWZ0IG1yLXNtXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW1nIGNsYXNzPVxcXCJyb3VuZGVkLWNpcmNsZVxcXCIgc3JjPVxcXCJhc3NldHMvaW1nL2F2YXRhci5wbmdcXFwiIGFsdD1cXFwiLi4uXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cXHJcXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb21tZW50LWJvZHlcXFwiPlxcclxcbiAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVxcXCJmb3JtLWNvbnRyb2wgZm9ybS1jb250cm9sLXNtXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBwbGFjZWhvbGRlcj1cXFwiV3JpdGUgeW91ciBjb21tZW50Li4uXFxcIj5cXHJcXG4gICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgPC9saT5cXHJcXG4gICAgICAgIDwvdWw+XFxyXFxuICAgICAgPC9mb290ZXI+XFxyXFxuICAgIDwvc2VjdGlvbj5cXHJcXG4gIDwvbGk+XFxyXFxuICA8bGk+XFxyXFxuICAgIDx0aW1lIGNsYXNzPVxcXCJldmVudC10aW1lXFxcIiBkYXRldGltZT1cXFwiMjAxNC0wNS0xOSAwMzowNFxcXCI+XFxyXFxuICAgICAgPHNwYW4gY2xhc3M9XFxcImRhdGVcXFwiPnllc3RlcmRheTwvc3Bhbj5cXHJcXG4gICAgICA8c3BhbiBjbGFzcz1cXFwidGltZVxcXCI+OTowMyA8c3BhbiBjbGFzcz1cXFwiZnctc2VtaS1ib2xkXFxcIj5hbTwvc3Bhbj48L3NwYW4+XFxyXFxuICAgIDwvdGltZT5cXHJcXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImV2ZW50LWljb25cXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgPGltZyBjbGFzcz1cXFwicm91bmRlZC1jaXJjbGVcXFwiIHNyYz1cXFwiYXNzZXRzL2ltZy9hdmF0YXIucG5nXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgPC9zcGFuPlxcclxcbiAgICA8c2VjdGlvbiBjbGFzcz1cXFwiZXZlbnRcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInRodW1iLXNtIGF2YXRhciBwdWxsLWxlZnQgbXItc21cXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgY2xhc3M9XFxcInJvdW5kZWQtY2lyY2xlXFxcIiBzcmM9XFxcImFzc2V0cy9pbWcvcGVvcGxlL2E2LmpwZ1xcXCIgYWx0PVxcXCIuLi5cXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxcclxcbiAgICAgIDxoNSBjbGFzcz1cXFwiZXZlbnQtaGVhZGluZ1xcXCI+PGEgaHJlZj1cXFwiI1xcXCI+SmVzc2ljYSBTbWl0aDwvYT4gPHNtYWxsPkBqZXNzPC9zbWFsbD48L2g1PlxcclxcbiAgICAgIDxwIGNsYXNzPVxcXCJmcy1zbSB0ZXh0LW11dGVkXFxcIj45OjAzIGFtIC0gUHVibGljbHkgbmVhciBNaW5zazwvcD5cXHJcXG4gICAgICA8aDU+TmV3IDxzcGFuIGNsYXNzPVxcXCJmdy1zZW1pLWJvbGRcXFwiPlByb2plY3Q8L3NwYW4+IExhdW5jaDwvaDU+XFxyXFxuICAgICAgPHAgY2xhc3M9XFxcImZzLW1pbmlcXFwiPlxcclxcbiAgICAgICAgTGV0J3MgdHJ5IHNvbWV0aGluZyBkaWZmZXJlbnQgdGhpcyB0aW1lLiBIZXksIGRvIHlvdSB3YW5uYSBqb2luIHVzIHRvbmlnaHQ/XFxyXFxuICAgICAgICBXZSdyZSBwbGFubmluZyB0byBhIGxhdW5jaCBhIG5ldyBwcm9qZWN0IHNvb24uIFdhbnQgdG8gZGlzY3VzcyB3aXRoIGFsbCBvZiB5b3UuLi5cXHJcXG4gICAgICA8L3A+XFxyXFxuICAgICAgPGEgY2xhc3M9XFxcIm10LW4teHMgZnMtbWluaSB0ZXh0LW11dGVkXFxcIiBocmVmPVxcXCIjXFxcIj5SZWFkIG1vcmUuLi48L2E+XFxyXFxuICAgICAgPGZvb3Rlcj5cXHJcXG4gICAgICAgIDx1bCBjbGFzcz1cXFwicG9zdC1saW5rc1xcXCI+XFxyXFxuICAgICAgICAgIDxsaT48YSBocmVmPVxcXCIjXFxcIj4xIGhvdXI8L2E+PC9saT5cXHJcXG4gICAgICAgICAgPGxpPjxhIGhyZWY9XFxcIiNcXFwiPjxzcGFuIGNsYXNzPVxcXCJ0ZXh0LWRhbmdlclxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLWhlYXJ0LW9cXFwiPjwvaT4gTGlrZTwvc3Bhbj48L2E+PC9saT5cXHJcXG4gICAgICAgICAgPGxpPjxhIGhyZWY9XFxcIiNcXFwiPkNvbW1lbnQ8L2E+PC9saT5cXHJcXG4gICAgICAgIDwvdWw+XFxyXFxuICAgICAgPC9mb290ZXI+XFxyXFxuICAgIDwvc2VjdGlvbj5cXHJcXG4gIDwvbGk+XFxyXFxuPC91bD5cXHJcXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2FwcC9leHRyYS90aW1lLWxpbmUvdGltZS1saW5lLnRlbXBsYXRlLmh0bWxcbi8vIG1vZHVsZSBpZCA9IDExNDlcbi8vIG1vZHVsZSBjaHVua3MgPSA1Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 703:
/* unknown exports provided */
/* all exports used */
/*!*************************************************************************!*\
  !*** ./~/angular2-google-maps/core/services/google-maps-api-wrapper.js ***!
  \*************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar core_1 = __webpack_require__(/*! @angular/core */ 0);\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ 12);\nvar maps_api_loader_1 = __webpack_require__(/*! ./maps-api-loader/maps-api-loader */ 711);\n/**\n * Wrapper class that handles the communication with the Google Maps Javascript\n * API v3\n */\nvar GoogleMapsAPIWrapper = (function () {\n    function GoogleMapsAPIWrapper(_loader, _zone) {\n        var _this = this;\n        this._loader = _loader;\n        this._zone = _zone;\n        this._map =\n            new Promise(function (resolve) { _this._mapResolver = resolve; });\n    }\n    GoogleMapsAPIWrapper.prototype.createMap = function (el, mapOptions) {\n        var _this = this;\n        return this._loader.load().then(function () {\n            var map = new google.maps.Map(el, mapOptions);\n            _this._mapResolver(map);\n            return;\n        });\n    };\n    GoogleMapsAPIWrapper.prototype.setMapOptions = function (options) {\n        this._map.then(function (m) { m.setOptions(options); });\n    };\n    /**\n     * Creates a google map marker with the map context\n     */\n    GoogleMapsAPIWrapper.prototype.createMarker = function (options) {\n        if (options === void 0) { options = {}; }\n        return this._map.then(function (map) {\n            options.map = map;\n            return new google.maps.Marker(options);\n        });\n    };\n    GoogleMapsAPIWrapper.prototype.createInfoWindow = function (options) {\n        return this._map.then(function () { return new google.maps.InfoWindow(options); });\n    };\n    /**\n     * Creates a google.map.Circle for the current map.\n     */\n    GoogleMapsAPIWrapper.prototype.createCircle = function (options) {\n        return this._map.then(function (map) {\n            options.map = map;\n            return new google.maps.Circle(options);\n        });\n    };\n    GoogleMapsAPIWrapper.prototype.createPolyline = function (options) {\n        return this.getNativeMap().then(function (map) {\n            var line = new google.maps.Polyline(options);\n            line.setMap(map);\n            return line;\n        });\n    };\n    GoogleMapsAPIWrapper.prototype.createPolygon = function (options) {\n        return this.getNativeMap().then(function (map) {\n            var polygon = new google.maps.Polygon(options);\n            polygon.setMap(map);\n            return polygon;\n        });\n    };\n    /**\n     * Determines if given coordinates are insite a Polygon path.\n     */\n    GoogleMapsAPIWrapper.prototype.containsLocation = function (latLng, polygon) {\n        return google.maps.geometry.poly.containsLocation(latLng, polygon);\n    };\n    GoogleMapsAPIWrapper.prototype.subscribeToMapEvent = function (eventName) {\n        var _this = this;\n        return Observable_1.Observable.create(function (observer) {\n            _this._map.then(function (m) {\n                m.addListener(eventName, function (arg) { _this._zone.run(function () { return observer.next(arg); }); });\n            });\n        });\n    };\n    GoogleMapsAPIWrapper.prototype.setCenter = function (latLng) {\n        return this._map.then(function (map) { return map.setCenter(latLng); });\n    };\n    GoogleMapsAPIWrapper.prototype.getZoom = function () { return this._map.then(function (map) { return map.getZoom(); }); };\n    GoogleMapsAPIWrapper.prototype.getBounds = function () {\n        return this._map.then(function (map) { return map.getBounds(); });\n    };\n    GoogleMapsAPIWrapper.prototype.setZoom = function (zoom) {\n        return this._map.then(function (map) { return map.setZoom(zoom); });\n    };\n    GoogleMapsAPIWrapper.prototype.getCenter = function () {\n        return this._map.then(function (map) { return map.getCenter(); });\n    };\n    GoogleMapsAPIWrapper.prototype.panTo = function (latLng) {\n        return this._map.then(function (map) { return map.panTo(latLng); });\n    };\n    GoogleMapsAPIWrapper.prototype.fitBounds = function (latLng) {\n        return this._map.then(function (map) { return map.fitBounds(latLng); });\n    };\n    GoogleMapsAPIWrapper.prototype.panToBounds = function (latLng) {\n        return this._map.then(function (map) { return map.panToBounds(latLng); });\n    };\n    /**\n     * Returns the native Google Maps Map instance. Be careful when using this instance directly.\n     */\n    GoogleMapsAPIWrapper.prototype.getNativeMap = function () { return this._map; };\n    /**\n     * Triggers the given event name on the map instance.\n     */\n    GoogleMapsAPIWrapper.prototype.triggerMapEvent = function (eventName) {\n        return this._map.then(function (m) { return google.maps.event.trigger(m, eventName); });\n    };\n    GoogleMapsAPIWrapper.decorators = [\n        { type: core_1.Injectable },\n    ];\n    /** @nocollapse */\n    GoogleMapsAPIWrapper.ctorParameters = function () { return [\n        { type: maps_api_loader_1.MapsAPILoader, },\n        { type: core_1.NgZone, },\n    ]; };\n    return GoogleMapsAPIWrapper;\n}());\nexports.GoogleMapsAPIWrapper = GoogleMapsAPIWrapper;\n//# sourceMappingURL=google-maps-api-wrapper.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzAzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL3NlcnZpY2VzL2dvb2dsZS1tYXBzLWFwaS13cmFwcGVyLmpzPzYzOTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJ3J4anMvT2JzZXJ2YWJsZScpO1xudmFyIG1hcHNfYXBpX2xvYWRlcl8xID0gcmVxdWlyZSgnLi9tYXBzLWFwaS1sb2FkZXIvbWFwcy1hcGktbG9hZGVyJyk7XG4vKipcbiAqIFdyYXBwZXIgY2xhc3MgdGhhdCBoYW5kbGVzIHRoZSBjb21tdW5pY2F0aW9uIHdpdGggdGhlIEdvb2dsZSBNYXBzIEphdmFzY3JpcHRcbiAqIEFQSSB2M1xuICovXG52YXIgR29vZ2xlTWFwc0FQSVdyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdvb2dsZU1hcHNBUElXcmFwcGVyKF9sb2FkZXIsIF96b25lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2xvYWRlciA9IF9sb2FkZXI7XG4gICAgICAgIHRoaXMuX3pvbmUgPSBfem9uZTtcbiAgICAgICAgdGhpcy5fbWFwID1cbiAgICAgICAgICAgIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7IF90aGlzLl9tYXBSZXNvbHZlciA9IHJlc29sdmU7IH0pO1xuICAgIH1cbiAgICBHb29nbGVNYXBzQVBJV3JhcHBlci5wcm90b3R5cGUuY3JlYXRlTWFwID0gZnVuY3Rpb24gKGVsLCBtYXBPcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2FkZXIubG9hZCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1hcCA9IG5ldyBnb29nbGUubWFwcy5NYXAoZWwsIG1hcE9wdGlvbnMpO1xuICAgICAgICAgICAgX3RoaXMuX21hcFJlc29sdmVyKG1hcCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgR29vZ2xlTWFwc0FQSVdyYXBwZXIucHJvdG90eXBlLnNldE1hcE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9tYXAudGhlbihmdW5jdGlvbiAobSkgeyBtLnNldE9wdGlvbnMob3B0aW9ucyk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGdvb2dsZSBtYXAgbWFya2VyIHdpdGggdGhlIG1hcCBjb250ZXh0XG4gICAgICovXG4gICAgR29vZ2xlTWFwc0FQSVdyYXBwZXIucHJvdG90eXBlLmNyZWF0ZU1hcmtlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbihmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICBvcHRpb25zLm1hcCA9IG1hcDtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZ29vZ2xlLm1hcHMuTWFya2VyKG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdvb2dsZU1hcHNBUElXcmFwcGVyLnByb3RvdHlwZS5jcmVhdGVJbmZvV2luZG93ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBnb29nbGUubWFwcy5JbmZvV2luZG93KG9wdGlvbnMpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBnb29nbGUubWFwLkNpcmNsZSBmb3IgdGhlIGN1cnJlbnQgbWFwLlxuICAgICAqL1xuICAgIEdvb2dsZU1hcHNBUElXcmFwcGVyLnByb3RvdHlwZS5jcmVhdGVDaXJjbGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAgICAgb3B0aW9ucy5tYXAgPSBtYXA7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGdvb2dsZS5tYXBzLkNpcmNsZShvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHb29nbGVNYXBzQVBJV3JhcHBlci5wcm90b3R5cGUuY3JlYXRlUG9seWxpbmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXROYXRpdmVNYXAoKS50aGVuKGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgICAgIHZhciBsaW5lID0gbmV3IGdvb2dsZS5tYXBzLlBvbHlsaW5lKG9wdGlvbnMpO1xuICAgICAgICAgICAgbGluZS5zZXRNYXAobWFwKTtcbiAgICAgICAgICAgIHJldHVybiBsaW5lO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdvb2dsZU1hcHNBUElXcmFwcGVyLnByb3RvdHlwZS5jcmVhdGVQb2x5Z29uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TmF0aXZlTWFwKCkudGhlbihmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICB2YXIgcG9seWdvbiA9IG5ldyBnb29nbGUubWFwcy5Qb2x5Z29uKG9wdGlvbnMpO1xuICAgICAgICAgICAgcG9seWdvbi5zZXRNYXAobWFwKTtcbiAgICAgICAgICAgIHJldHVybiBwb2x5Z29uO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgZ2l2ZW4gY29vcmRpbmF0ZXMgYXJlIGluc2l0ZSBhIFBvbHlnb24gcGF0aC5cbiAgICAgKi9cbiAgICBHb29nbGVNYXBzQVBJV3JhcHBlci5wcm90b3R5cGUuY29udGFpbnNMb2NhdGlvbiA9IGZ1bmN0aW9uIChsYXRMbmcsIHBvbHlnb24pIHtcbiAgICAgICAgcmV0dXJuIGdvb2dsZS5tYXBzLmdlb21ldHJ5LnBvbHkuY29udGFpbnNMb2NhdGlvbihsYXRMbmcsIHBvbHlnb24pO1xuICAgIH07XG4gICAgR29vZ2xlTWFwc0FQSVdyYXBwZXIucHJvdG90eXBlLnN1YnNjcmliZVRvTWFwRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5jcmVhdGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgICAgICBfdGhpcy5fbWFwLnRoZW4oZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgICAgICBtLmFkZExpc3RlbmVyKGV2ZW50TmFtZSwgZnVuY3Rpb24gKGFyZykgeyBfdGhpcy5fem9uZS5ydW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gb2JzZXJ2ZXIubmV4dChhcmcpOyB9KTsgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHb29nbGVNYXBzQVBJV3JhcHBlci5wcm90b3R5cGUuc2V0Q2VudGVyID0gZnVuY3Rpb24gKGxhdExuZykge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oZnVuY3Rpb24gKG1hcCkgeyByZXR1cm4gbWFwLnNldENlbnRlcihsYXRMbmcpOyB9KTtcbiAgICB9O1xuICAgIEdvb2dsZU1hcHNBUElXcmFwcGVyLnByb3RvdHlwZS5nZXRab29tID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbWFwLnRoZW4oZnVuY3Rpb24gKG1hcCkgeyByZXR1cm4gbWFwLmdldFpvb20oKTsgfSk7IH07XG4gICAgR29vZ2xlTWFwc0FQSVdyYXBwZXIucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKGZ1bmN0aW9uIChtYXApIHsgcmV0dXJuIG1hcC5nZXRCb3VuZHMoKTsgfSk7XG4gICAgfTtcbiAgICBHb29nbGVNYXBzQVBJV3JhcHBlci5wcm90b3R5cGUuc2V0Wm9vbSA9IGZ1bmN0aW9uICh6b29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbihmdW5jdGlvbiAobWFwKSB7IHJldHVybiBtYXAuc2V0Wm9vbSh6b29tKTsgfSk7XG4gICAgfTtcbiAgICBHb29nbGVNYXBzQVBJV3JhcHBlci5wcm90b3R5cGUuZ2V0Q2VudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oZnVuY3Rpb24gKG1hcCkgeyByZXR1cm4gbWFwLmdldENlbnRlcigpOyB9KTtcbiAgICB9O1xuICAgIEdvb2dsZU1hcHNBUElXcmFwcGVyLnByb3RvdHlwZS5wYW5UbyA9IGZ1bmN0aW9uIChsYXRMbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC50aGVuKGZ1bmN0aW9uIChtYXApIHsgcmV0dXJuIG1hcC5wYW5UbyhsYXRMbmcpOyB9KTtcbiAgICB9O1xuICAgIEdvb2dsZU1hcHNBUElXcmFwcGVyLnByb3RvdHlwZS5maXRCb3VuZHMgPSBmdW5jdGlvbiAobGF0TG5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbihmdW5jdGlvbiAobWFwKSB7IHJldHVybiBtYXAuZml0Qm91bmRzKGxhdExuZyk7IH0pO1xuICAgIH07XG4gICAgR29vZ2xlTWFwc0FQSVdyYXBwZXIucHJvdG90eXBlLnBhblRvQm91bmRzID0gZnVuY3Rpb24gKGxhdExuZykge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnRoZW4oZnVuY3Rpb24gKG1hcCkgeyByZXR1cm4gbWFwLnBhblRvQm91bmRzKGxhdExuZyk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmF0aXZlIEdvb2dsZSBNYXBzIE1hcCBpbnN0YW5jZS4gQmUgY2FyZWZ1bCB3aGVuIHVzaW5nIHRoaXMgaW5zdGFuY2UgZGlyZWN0bHkuXG4gICAgICovXG4gICAgR29vZ2xlTWFwc0FQSVdyYXBwZXIucHJvdG90eXBlLmdldE5hdGl2ZU1hcCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21hcDsgfTtcbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyB0aGUgZ2l2ZW4gZXZlbnQgbmFtZSBvbiB0aGUgbWFwIGluc3RhbmNlLlxuICAgICAqL1xuICAgIEdvb2dsZU1hcHNBUElXcmFwcGVyLnByb3RvdHlwZS50cmlnZ2VyTWFwRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAudGhlbihmdW5jdGlvbiAobSkgeyByZXR1cm4gZ29vZ2xlLm1hcHMuZXZlbnQudHJpZ2dlcihtLCBldmVudE5hbWUpOyB9KTtcbiAgICB9O1xuICAgIEdvb2dsZU1hcHNBUElXcmFwcGVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIEdvb2dsZU1hcHNBUElXcmFwcGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IG1hcHNfYXBpX2xvYWRlcl8xLk1hcHNBUElMb2FkZXIsIH0sXG4gICAgICAgIHsgdHlwZTogY29yZV8xLk5nWm9uZSwgfSxcbiAgICBdOyB9O1xuICAgIHJldHVybiBHb29nbGVNYXBzQVBJV3JhcHBlcjtcbn0oKSk7XG5leHBvcnRzLkdvb2dsZU1hcHNBUElXcmFwcGVyID0gR29vZ2xlTWFwc0FQSVdyYXBwZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nb29nbGUtbWFwcy1hcGktd3JhcHBlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9zZXJ2aWNlcy9nb29nbGUtbWFwcy1hcGktd3JhcHBlci5qc1xuLy8gbW9kdWxlIGlkID0gNzAzXG4vLyBtb2R1bGUgY2h1bmtzID0gNSA4Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 710:
/* unknown exports provided */
/* all exports used */
/*!*************************************************************************!*\
  !*** ./~/angular2-google-maps/core/services/managers/marker-manager.js ***!
  \*************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar core_1 = __webpack_require__(/*! @angular/core */ 0);\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ 12);\nvar google_maps_api_wrapper_1 = __webpack_require__(/*! ./../google-maps-api-wrapper */ 703);\nvar MarkerManager = (function () {\n    function MarkerManager(_mapsWrapper, _zone) {\n        this._mapsWrapper = _mapsWrapper;\n        this._zone = _zone;\n        this._markers = new Map();\n    }\n    MarkerManager.prototype.deleteMarker = function (marker) {\n        var _this = this;\n        var m = this._markers.get(marker);\n        if (m == null) {\n            // marker already deleted\n            return Promise.resolve();\n        }\n        return m.then(function (m) {\n            return _this._zone.run(function () {\n                m.setMap(null);\n                _this._markers.delete(marker);\n            });\n        });\n    };\n    MarkerManager.prototype.updateMarkerPosition = function (marker) {\n        return this._markers.get(marker).then(function (m) { return m.setPosition({ lat: marker.latitude, lng: marker.longitude }); });\n    };\n    MarkerManager.prototype.updateTitle = function (marker) {\n        return this._markers.get(marker).then(function (m) { return m.setTitle(marker.title); });\n    };\n    MarkerManager.prototype.updateLabel = function (marker) {\n        return this._markers.get(marker).then(function (m) { m.setLabel(marker.label); });\n    };\n    MarkerManager.prototype.updateDraggable = function (marker) {\n        return this._markers.get(marker).then(function (m) { return m.setDraggable(marker.draggable); });\n    };\n    MarkerManager.prototype.updateIcon = function (marker) {\n        return this._markers.get(marker).then(function (m) { return m.setIcon(marker.iconUrl); });\n    };\n    MarkerManager.prototype.updateOpacity = function (marker) {\n        return this._markers.get(marker).then(function (m) { return m.setOpacity(marker.opacity); });\n    };\n    MarkerManager.prototype.updateVisible = function (marker) {\n        return this._markers.get(marker).then(function (m) { return m.setVisible(marker.visible); });\n    };\n    MarkerManager.prototype.updateZIndex = function (marker) {\n        return this._markers.get(marker).then(function (m) { return m.setZIndex(marker.zIndex); });\n    };\n    MarkerManager.prototype.addMarker = function (marker) {\n        var markerPromise = this._mapsWrapper.createMarker({\n            position: { lat: marker.latitude, lng: marker.longitude },\n            label: marker.label,\n            draggable: marker.draggable,\n            icon: marker.iconUrl,\n            opacity: marker.opacity,\n            visible: marker.visible,\n            zIndex: marker.zIndex,\n            title: marker.title\n        });\n        this._markers.set(marker, markerPromise);\n    };\n    MarkerManager.prototype.getNativeMarker = function (marker) {\n        return this._markers.get(marker);\n    };\n    MarkerManager.prototype.createEventObservable = function (eventName, marker) {\n        var _this = this;\n        return Observable_1.Observable.create(function (observer) {\n            _this._markers.get(marker).then(function (m) {\n                m.addListener(eventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); });\n            });\n        });\n    };\n    MarkerManager.decorators = [\n        { type: core_1.Injectable },\n    ];\n    /** @nocollapse */\n    MarkerManager.ctorParameters = function () { return [\n        { type: google_maps_api_wrapper_1.GoogleMapsAPIWrapper, },\n        { type: core_1.NgZone, },\n    ]; };\n    return MarkerManager;\n}());\nexports.MarkerManager = MarkerManager;\n//# sourceMappingURL=marker-manager.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzEwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL3NlcnZpY2VzL21hbmFnZXJzL21hcmtlci1tYW5hZ2VyLmpzPzQ4N2QiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJ3J4anMvT2JzZXJ2YWJsZScpO1xudmFyIGdvb2dsZV9tYXBzX2FwaV93cmFwcGVyXzEgPSByZXF1aXJlKCcuLy4uL2dvb2dsZS1tYXBzLWFwaS13cmFwcGVyJyk7XG52YXIgTWFya2VyTWFuYWdlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFya2VyTWFuYWdlcihfbWFwc1dyYXBwZXIsIF96b25lKSB7XG4gICAgICAgIHRoaXMuX21hcHNXcmFwcGVyID0gX21hcHNXcmFwcGVyO1xuICAgICAgICB0aGlzLl96b25lID0gX3pvbmU7XG4gICAgICAgIHRoaXMuX21hcmtlcnMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIE1hcmtlck1hbmFnZXIucHJvdG90eXBlLmRlbGV0ZU1hcmtlciA9IGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG0gPSB0aGlzLl9tYXJrZXJzLmdldChtYXJrZXIpO1xuICAgICAgICBpZiAobSA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBtYXJrZXIgYWxyZWFkeSBkZWxldGVkXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0udGhlbihmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl96b25lLnJ1bihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbS5zZXRNYXAobnVsbCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX21hcmtlcnMuZGVsZXRlKG1hcmtlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNYXJrZXJNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVNYXJrZXJQb3NpdGlvbiA9IGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlcnMuZ2V0KG1hcmtlcikudGhlbihmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5zZXRQb3NpdGlvbih7IGxhdDogbWFya2VyLmxhdGl0dWRlLCBsbmc6IG1hcmtlci5sb25naXR1ZGUgfSk7IH0pO1xuICAgIH07XG4gICAgTWFya2VyTWFuYWdlci5wcm90b3R5cGUudXBkYXRlVGl0bGUgPSBmdW5jdGlvbiAobWFya2VyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXJrZXJzLmdldChtYXJrZXIpLnRoZW4oZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0uc2V0VGl0bGUobWFya2VyLnRpdGxlKTsgfSk7XG4gICAgfTtcbiAgICBNYXJrZXJNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVMYWJlbCA9IGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlcnMuZ2V0KG1hcmtlcikudGhlbihmdW5jdGlvbiAobSkgeyBtLnNldExhYmVsKG1hcmtlci5sYWJlbCk7IH0pO1xuICAgIH07XG4gICAgTWFya2VyTWFuYWdlci5wcm90b3R5cGUudXBkYXRlRHJhZ2dhYmxlID0gZnVuY3Rpb24gKG1hcmtlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFya2Vycy5nZXQobWFya2VyKS50aGVuKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLnNldERyYWdnYWJsZShtYXJrZXIuZHJhZ2dhYmxlKTsgfSk7XG4gICAgfTtcbiAgICBNYXJrZXJNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVJY29uID0gZnVuY3Rpb24gKG1hcmtlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFya2Vycy5nZXQobWFya2VyKS50aGVuKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLnNldEljb24obWFya2VyLmljb25VcmwpOyB9KTtcbiAgICB9O1xuICAgIE1hcmtlck1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZU9wYWNpdHkgPSBmdW5jdGlvbiAobWFya2VyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXJrZXJzLmdldChtYXJrZXIpLnRoZW4oZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0uc2V0T3BhY2l0eShtYXJrZXIub3BhY2l0eSk7IH0pO1xuICAgIH07XG4gICAgTWFya2VyTWFuYWdlci5wcm90b3R5cGUudXBkYXRlVmlzaWJsZSA9IGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcmtlcnMuZ2V0KG1hcmtlcikudGhlbihmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5zZXRWaXNpYmxlKG1hcmtlci52aXNpYmxlKTsgfSk7XG4gICAgfTtcbiAgICBNYXJrZXJNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVaSW5kZXggPSBmdW5jdGlvbiAobWFya2VyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXJrZXJzLmdldChtYXJrZXIpLnRoZW4oZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0uc2V0WkluZGV4KG1hcmtlci56SW5kZXgpOyB9KTtcbiAgICB9O1xuICAgIE1hcmtlck1hbmFnZXIucHJvdG90eXBlLmFkZE1hcmtlciA9IGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICAgICAgdmFyIG1hcmtlclByb21pc2UgPSB0aGlzLl9tYXBzV3JhcHBlci5jcmVhdGVNYXJrZXIoe1xuICAgICAgICAgICAgcG9zaXRpb246IHsgbGF0OiBtYXJrZXIubGF0aXR1ZGUsIGxuZzogbWFya2VyLmxvbmdpdHVkZSB9LFxuICAgICAgICAgICAgbGFiZWw6IG1hcmtlci5sYWJlbCxcbiAgICAgICAgICAgIGRyYWdnYWJsZTogbWFya2VyLmRyYWdnYWJsZSxcbiAgICAgICAgICAgIGljb246IG1hcmtlci5pY29uVXJsLFxuICAgICAgICAgICAgb3BhY2l0eTogbWFya2VyLm9wYWNpdHksXG4gICAgICAgICAgICB2aXNpYmxlOiBtYXJrZXIudmlzaWJsZSxcbiAgICAgICAgICAgIHpJbmRleDogbWFya2VyLnpJbmRleCxcbiAgICAgICAgICAgIHRpdGxlOiBtYXJrZXIudGl0bGVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX21hcmtlcnMuc2V0KG1hcmtlciwgbWFya2VyUHJvbWlzZSk7XG4gICAgfTtcbiAgICBNYXJrZXJNYW5hZ2VyLnByb3RvdHlwZS5nZXROYXRpdmVNYXJrZXIgPSBmdW5jdGlvbiAobWFya2VyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXJrZXJzLmdldChtYXJrZXIpO1xuICAgIH07XG4gICAgTWFya2VyTWFuYWdlci5wcm90b3R5cGUuY3JlYXRlRXZlbnRPYnNlcnZhYmxlID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgbWFya2VyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5jcmVhdGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgICAgICBfdGhpcy5fbWFya2Vycy5nZXQobWFya2VyKS50aGVuKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICAgICAgbS5hZGRMaXN0ZW5lcihldmVudE5hbWUsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBfdGhpcy5fem9uZS5ydW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gb2JzZXJ2ZXIubmV4dChlKTsgfSk7IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWFya2VyTWFuYWdlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5JbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBNYXJrZXJNYW5hZ2VyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IGdvb2dsZV9tYXBzX2FwaV93cmFwcGVyXzEuR29vZ2xlTWFwc0FQSVdyYXBwZXIsIH0sXG4gICAgICAgIHsgdHlwZTogY29yZV8xLk5nWm9uZSwgfSxcbiAgICBdOyB9O1xuICAgIHJldHVybiBNYXJrZXJNYW5hZ2VyO1xufSgpKTtcbmV4cG9ydHMuTWFya2VyTWFuYWdlciA9IE1hcmtlck1hbmFnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXJrZXItbWFuYWdlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9zZXJ2aWNlcy9tYW5hZ2Vycy9tYXJrZXItbWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gNzEwXG4vLyBtb2R1bGUgY2h1bmtzID0gNSA4Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 711:
/* unknown exports provided */
/* all exports used */
/*!*********************************************************************************!*\
  !*** ./~/angular2-google-maps/core/services/maps-api-loader/maps-api-loader.js ***!
  \*********************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar core_1 = __webpack_require__(/*! @angular/core */ 0);\nvar MapsAPILoader = (function () {\n    function MapsAPILoader() {\n    }\n    MapsAPILoader.decorators = [\n        { type: core_1.Injectable },\n    ];\n    /** @nocollapse */\n    MapsAPILoader.ctorParameters = function () { return []; };\n    return MapsAPILoader;\n}());\nexports.MapsAPILoader = MapsAPILoader;\n//# sourceMappingURL=maps-api-loader.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzExLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL3NlcnZpY2VzL21hcHMtYXBpLWxvYWRlci9tYXBzLWFwaS1sb2FkZXIuanM/MjBhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgTWFwc0FQSUxvYWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFwc0FQSUxvYWRlcigpIHtcbiAgICB9XG4gICAgTWFwc0FQSUxvYWRlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5JbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBNYXBzQVBJTG9hZGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgcmV0dXJuIE1hcHNBUElMb2FkZXI7XG59KCkpO1xuZXhwb3J0cy5NYXBzQVBJTG9hZGVyID0gTWFwc0FQSUxvYWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hcHMtYXBpLWxvYWRlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9zZXJ2aWNlcy9tYXBzLWFwaS1sb2FkZXIvbWFwcy1hcGktbG9hZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA3MTFcbi8vIG1vZHVsZSBjaHVua3MgPSA1IDgiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 712:
/* unknown exports provided */
/* all exports used */
/*!**********************************!*\
  !*** ./~/jquery-ui/ui/widget.js ***!
  \**********************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery UI Widget 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/jQuery.widget/\n */\n(function( factory ) {\n\tif ( true ) {\n\n\t\t// AMD. Register as an anonymous module.\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(/*! jquery */ 41) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {\n\n\t\t// Browser globals\n\t\tfactory( jQuery );\n\t}\n}(function( $ ) {\n\nvar widget_uuid = 0,\n\twidget_slice = Array.prototype.slice;\n\n$.cleanData = (function( orig ) {\n\treturn function( elems ) {\n\t\tvar events, elem, i;\n\t\tfor ( i = 0; (elem = elems[i]) != null; i++ ) {\n\t\t\ttry {\n\n\t\t\t\t// Only trigger remove when necessary to save time\n\t\t\t\tevents = $._data( elem, \"events\" );\n\t\t\t\tif ( events && events.remove ) {\n\t\t\t\t\t$( elem ).triggerHandler( \"remove\" );\n\t\t\t\t}\n\n\t\t\t// http://bugs.jquery.com/ticket/8235\n\t\t\t} catch ( e ) {}\n\t\t}\n\t\torig( elems );\n\t};\n})( $.cleanData );\n\n$.widget = function( name, base, prototype ) {\n\tvar fullName, existingConstructor, constructor, basePrototype,\n\t\t// proxiedPrototype allows the provided prototype to remain unmodified\n\t\t// so that it can be used as a mixin for multiple widgets (#8876)\n\t\tproxiedPrototype = {},\n\t\tnamespace = name.split( \".\" )[ 0 ];\n\n\tname = name.split( \".\" )[ 1 ];\n\tfullName = namespace + \"-\" + name;\n\n\tif ( !prototype ) {\n\t\tprototype = base;\n\t\tbase = $.Widget;\n\t}\n\n\t// create selector for plugin\n\t$.expr[ \":\" ][ fullName.toLowerCase() ] = function( elem ) {\n\t\treturn !!$.data( elem, fullName );\n\t};\n\n\t$[ namespace ] = $[ namespace ] || {};\n\texistingConstructor = $[ namespace ][ name ];\n\tconstructor = $[ namespace ][ name ] = function( options, element ) {\n\t\t// allow instantiation without \"new\" keyword\n\t\tif ( !this._createWidget ) {\n\t\t\treturn new constructor( options, element );\n\t\t}\n\n\t\t// allow instantiation without initializing for simple inheritance\n\t\t// must use \"new\" keyword (the code above always passes args)\n\t\tif ( arguments.length ) {\n\t\t\tthis._createWidget( options, element );\n\t\t}\n\t};\n\t// extend with the existing constructor to carry over any static properties\n\t$.extend( constructor, existingConstructor, {\n\t\tversion: prototype.version,\n\t\t// copy the object used to create the prototype in case we need to\n\t\t// redefine the widget later\n\t\t_proto: $.extend( {}, prototype ),\n\t\t// track widgets that inherit from this widget in case this widget is\n\t\t// redefined after a widget inherits from it\n\t\t_childConstructors: []\n\t});\n\n\tbasePrototype = new base();\n\t// we need to make the options hash a property directly on the new instance\n\t// otherwise we'll modify the options hash on the prototype that we're\n\t// inheriting from\n\tbasePrototype.options = $.widget.extend( {}, basePrototype.options );\n\t$.each( prototype, function( prop, value ) {\n\t\tif ( !$.isFunction( value ) ) {\n\t\t\tproxiedPrototype[ prop ] = value;\n\t\t\treturn;\n\t\t}\n\t\tproxiedPrototype[ prop ] = (function() {\n\t\t\tvar _super = function() {\n\t\t\t\t\treturn base.prototype[ prop ].apply( this, arguments );\n\t\t\t\t},\n\t\t\t\t_superApply = function( args ) {\n\t\t\t\t\treturn base.prototype[ prop ].apply( this, args );\n\t\t\t\t};\n\t\t\treturn function() {\n\t\t\t\tvar __super = this._super,\n\t\t\t\t\t__superApply = this._superApply,\n\t\t\t\t\treturnValue;\n\n\t\t\t\tthis._super = _super;\n\t\t\t\tthis._superApply = _superApply;\n\n\t\t\t\treturnValue = value.apply( this, arguments );\n\n\t\t\t\tthis._super = __super;\n\t\t\t\tthis._superApply = __superApply;\n\n\t\t\t\treturn returnValue;\n\t\t\t};\n\t\t})();\n\t});\n\tconstructor.prototype = $.widget.extend( basePrototype, {\n\t\t// TODO: remove support for widgetEventPrefix\n\t\t// always use the name + a colon as the prefix, e.g., draggable:start\n\t\t// don't prefix for widgets that aren't DOM-based\n\t\twidgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name\n\t}, proxiedPrototype, {\n\t\tconstructor: constructor,\n\t\tnamespace: namespace,\n\t\twidgetName: name,\n\t\twidgetFullName: fullName\n\t});\n\n\t// If this widget is being redefined then we need to find all widgets that\n\t// are inheriting from it and redefine all of them so that they inherit from\n\t// the new version of this widget. We're essentially trying to replace one\n\t// level in the prototype chain.\n\tif ( existingConstructor ) {\n\t\t$.each( existingConstructor._childConstructors, function( i, child ) {\n\t\t\tvar childPrototype = child.prototype;\n\n\t\t\t// redefine the child widget using the same prototype that was\n\t\t\t// originally used, but inherit from the new version of the base\n\t\t\t$.widget( childPrototype.namespace + \".\" + childPrototype.widgetName, constructor, child._proto );\n\t\t});\n\t\t// remove the list of existing child constructors from the old constructor\n\t\t// so the old child constructors can be garbage collected\n\t\tdelete existingConstructor._childConstructors;\n\t} else {\n\t\tbase._childConstructors.push( constructor );\n\t}\n\n\t$.widget.bridge( name, constructor );\n\n\treturn constructor;\n};\n\n$.widget.extend = function( target ) {\n\tvar input = widget_slice.call( arguments, 1 ),\n\t\tinputIndex = 0,\n\t\tinputLength = input.length,\n\t\tkey,\n\t\tvalue;\n\tfor ( ; inputIndex < inputLength; inputIndex++ ) {\n\t\tfor ( key in input[ inputIndex ] ) {\n\t\t\tvalue = input[ inputIndex ][ key ];\n\t\t\tif ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {\n\t\t\t\t// Clone objects\n\t\t\t\tif ( $.isPlainObject( value ) ) {\n\t\t\t\t\ttarget[ key ] = $.isPlainObject( target[ key ] ) ?\n\t\t\t\t\t\t$.widget.extend( {}, target[ key ], value ) :\n\t\t\t\t\t\t// Don't extend strings, arrays, etc. with objects\n\t\t\t\t\t\t$.widget.extend( {}, value );\n\t\t\t\t// Copy everything else by reference\n\t\t\t\t} else {\n\t\t\t\t\ttarget[ key ] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn target;\n};\n\n$.widget.bridge = function( name, object ) {\n\tvar fullName = object.prototype.widgetFullName || name;\n\t$.fn[ name ] = function( options ) {\n\t\tvar isMethodCall = typeof options === \"string\",\n\t\t\targs = widget_slice.call( arguments, 1 ),\n\t\t\treturnValue = this;\n\n\t\tif ( isMethodCall ) {\n\t\t\tthis.each(function() {\n\t\t\t\tvar methodValue,\n\t\t\t\t\tinstance = $.data( this, fullName );\n\t\t\t\tif ( options === \"instance\" ) {\n\t\t\t\t\treturnValue = instance;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif ( !instance ) {\n\t\t\t\t\treturn $.error( \"cannot call methods on \" + name + \" prior to initialization; \" +\n\t\t\t\t\t\t\"attempted to call method '\" + options + \"'\" );\n\t\t\t\t}\n\t\t\t\tif ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === \"_\" ) {\n\t\t\t\t\treturn $.error( \"no such method '\" + options + \"' for \" + name + \" widget instance\" );\n\t\t\t\t}\n\t\t\t\tmethodValue = instance[ options ].apply( instance, args );\n\t\t\t\tif ( methodValue !== instance && methodValue !== undefined ) {\n\t\t\t\t\treturnValue = methodValue && methodValue.jquery ?\n\t\t\t\t\t\treturnValue.pushStack( methodValue.get() ) :\n\t\t\t\t\t\tmethodValue;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\n\t\t\t// Allow multiple hashes to be passed on init\n\t\t\tif ( args.length ) {\n\t\t\t\toptions = $.widget.extend.apply( null, [ options ].concat(args) );\n\t\t\t}\n\n\t\t\tthis.each(function() {\n\t\t\t\tvar instance = $.data( this, fullName );\n\t\t\t\tif ( instance ) {\n\t\t\t\t\tinstance.option( options || {} );\n\t\t\t\t\tif ( instance._init ) {\n\t\t\t\t\t\tinstance._init();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$.data( this, fullName, new object( options, this ) );\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn returnValue;\n\t};\n};\n\n$.Widget = function( /* options, element */ ) {};\n$.Widget._childConstructors = [];\n\n$.Widget.prototype = {\n\twidgetName: \"widget\",\n\twidgetEventPrefix: \"\",\n\tdefaultElement: \"<div>\",\n\toptions: {\n\t\tdisabled: false,\n\n\t\t// callbacks\n\t\tcreate: null\n\t},\n\t_createWidget: function( options, element ) {\n\t\telement = $( element || this.defaultElement || this )[ 0 ];\n\t\tthis.element = $( element );\n\t\tthis.uuid = widget_uuid++;\n\t\tthis.eventNamespace = \".\" + this.widgetName + this.uuid;\n\n\t\tthis.bindings = $();\n\t\tthis.hoverable = $();\n\t\tthis.focusable = $();\n\n\t\tif ( element !== this ) {\n\t\t\t$.data( element, this.widgetFullName, this );\n\t\t\tthis._on( true, this.element, {\n\t\t\t\tremove: function( event ) {\n\t\t\t\t\tif ( event.target === element ) {\n\t\t\t\t\t\tthis.destroy();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.document = $( element.style ?\n\t\t\t\t// element within the document\n\t\t\t\telement.ownerDocument :\n\t\t\t\t// element is window or document\n\t\t\t\telement.document || element );\n\t\t\tthis.window = $( this.document[0].defaultView || this.document[0].parentWindow );\n\t\t}\n\n\t\tthis.options = $.widget.extend( {},\n\t\t\tthis.options,\n\t\t\tthis._getCreateOptions(),\n\t\t\toptions );\n\n\t\tthis._create();\n\t\tthis._trigger( \"create\", null, this._getCreateEventData() );\n\t\tthis._init();\n\t},\n\t_getCreateOptions: $.noop,\n\t_getCreateEventData: $.noop,\n\t_create: $.noop,\n\t_init: $.noop,\n\n\tdestroy: function() {\n\t\tthis._destroy();\n\t\t// we can probably remove the unbind calls in 2.0\n\t\t// all event bindings should go through this._on()\n\t\tthis.element\n\t\t\t.unbind( this.eventNamespace )\n\t\t\t.removeData( this.widgetFullName )\n\t\t\t// support: jquery <1.6.3\n\t\t\t// http://bugs.jquery.com/ticket/9413\n\t\t\t.removeData( $.camelCase( this.widgetFullName ) );\n\t\tthis.widget()\n\t\t\t.unbind( this.eventNamespace )\n\t\t\t.removeAttr( \"aria-disabled\" )\n\t\t\t.removeClass(\n\t\t\t\tthis.widgetFullName + \"-disabled \" +\n\t\t\t\t\"ui-state-disabled\" );\n\n\t\t// clean up events and states\n\t\tthis.bindings.unbind( this.eventNamespace );\n\t\tthis.hoverable.removeClass( \"ui-state-hover\" );\n\t\tthis.focusable.removeClass( \"ui-state-focus\" );\n\t},\n\t_destroy: $.noop,\n\n\twidget: function() {\n\t\treturn this.element;\n\t},\n\n\toption: function( key, value ) {\n\t\tvar options = key,\n\t\t\tparts,\n\t\t\tcurOption,\n\t\t\ti;\n\n\t\tif ( arguments.length === 0 ) {\n\t\t\t// don't return a reference to the internal hash\n\t\t\treturn $.widget.extend( {}, this.options );\n\t\t}\n\n\t\tif ( typeof key === \"string\" ) {\n\t\t\t// handle nested keys, e.g., \"foo.bar\" => { foo: { bar: ___ } }\n\t\t\toptions = {};\n\t\t\tparts = key.split( \".\" );\n\t\t\tkey = parts.shift();\n\t\t\tif ( parts.length ) {\n\t\t\t\tcurOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );\n\t\t\t\tfor ( i = 0; i < parts.length - 1; i++ ) {\n\t\t\t\t\tcurOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};\n\t\t\t\t\tcurOption = curOption[ parts[ i ] ];\n\t\t\t\t}\n\t\t\t\tkey = parts.pop();\n\t\t\t\tif ( arguments.length === 1 ) {\n\t\t\t\t\treturn curOption[ key ] === undefined ? null : curOption[ key ];\n\t\t\t\t}\n\t\t\t\tcurOption[ key ] = value;\n\t\t\t} else {\n\t\t\t\tif ( arguments.length === 1 ) {\n\t\t\t\t\treturn this.options[ key ] === undefined ? null : this.options[ key ];\n\t\t\t\t}\n\t\t\t\toptions[ key ] = value;\n\t\t\t}\n\t\t}\n\n\t\tthis._setOptions( options );\n\n\t\treturn this;\n\t},\n\t_setOptions: function( options ) {\n\t\tvar key;\n\n\t\tfor ( key in options ) {\n\t\t\tthis._setOption( key, options[ key ] );\n\t\t}\n\n\t\treturn this;\n\t},\n\t_setOption: function( key, value ) {\n\t\tthis.options[ key ] = value;\n\n\t\tif ( key === \"disabled\" ) {\n\t\t\tthis.widget()\n\t\t\t\t.toggleClass( this.widgetFullName + \"-disabled\", !!value );\n\n\t\t\t// If the widget is becoming disabled, then nothing is interactive\n\t\t\tif ( value ) {\n\t\t\t\tthis.hoverable.removeClass( \"ui-state-hover\" );\n\t\t\t\tthis.focusable.removeClass( \"ui-state-focus\" );\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tenable: function() {\n\t\treturn this._setOptions({ disabled: false });\n\t},\n\tdisable: function() {\n\t\treturn this._setOptions({ disabled: true });\n\t},\n\n\t_on: function( suppressDisabledCheck, element, handlers ) {\n\t\tvar delegateElement,\n\t\t\tinstance = this;\n\n\t\t// no suppressDisabledCheck flag, shuffle arguments\n\t\tif ( typeof suppressDisabledCheck !== \"boolean\" ) {\n\t\t\thandlers = element;\n\t\t\telement = suppressDisabledCheck;\n\t\t\tsuppressDisabledCheck = false;\n\t\t}\n\n\t\t// no element argument, shuffle and use this.element\n\t\tif ( !handlers ) {\n\t\t\thandlers = element;\n\t\t\telement = this.element;\n\t\t\tdelegateElement = this.widget();\n\t\t} else {\n\t\t\telement = delegateElement = $( element );\n\t\t\tthis.bindings = this.bindings.add( element );\n\t\t}\n\n\t\t$.each( handlers, function( event, handler ) {\n\t\t\tfunction handlerProxy() {\n\t\t\t\t// allow widgets to customize the disabled handling\n\t\t\t\t// - disabled as an array instead of boolean\n\t\t\t\t// - disabled class as method for disabling individual parts\n\t\t\t\tif ( !suppressDisabledCheck &&\n\t\t\t\t\t\t( instance.options.disabled === true ||\n\t\t\t\t\t\t\t$( this ).hasClass( \"ui-state-disabled\" ) ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\treturn ( typeof handler === \"string\" ? instance[ handler ] : handler )\n\t\t\t\t\t.apply( instance, arguments );\n\t\t\t}\n\n\t\t\t// copy the guid so direct unbinding works\n\t\t\tif ( typeof handler !== \"string\" ) {\n\t\t\t\thandlerProxy.guid = handler.guid =\n\t\t\t\t\thandler.guid || handlerProxy.guid || $.guid++;\n\t\t\t}\n\n\t\t\tvar match = event.match( /^([\\w:-]*)\\s*(.*)$/ ),\n\t\t\t\teventName = match[1] + instance.eventNamespace,\n\t\t\t\tselector = match[2];\n\t\t\tif ( selector ) {\n\t\t\t\tdelegateElement.delegate( selector, eventName, handlerProxy );\n\t\t\t} else {\n\t\t\t\telement.bind( eventName, handlerProxy );\n\t\t\t}\n\t\t});\n\t},\n\n\t_off: function( element, eventName ) {\n\t\teventName = (eventName || \"\").split( \" \" ).join( this.eventNamespace + \" \" ) +\n\t\t\tthis.eventNamespace;\n\t\telement.unbind( eventName ).undelegate( eventName );\n\n\t\t// Clear the stack to avoid memory leaks (#10056)\n\t\tthis.bindings = $( this.bindings.not( element ).get() );\n\t\tthis.focusable = $( this.focusable.not( element ).get() );\n\t\tthis.hoverable = $( this.hoverable.not( element ).get() );\n\t},\n\n\t_delay: function( handler, delay ) {\n\t\tfunction handlerProxy() {\n\t\t\treturn ( typeof handler === \"string\" ? instance[ handler ] : handler )\n\t\t\t\t.apply( instance, arguments );\n\t\t}\n\t\tvar instance = this;\n\t\treturn setTimeout( handlerProxy, delay || 0 );\n\t},\n\n\t_hoverable: function( element ) {\n\t\tthis.hoverable = this.hoverable.add( element );\n\t\tthis._on( element, {\n\t\t\tmouseenter: function( event ) {\n\t\t\t\t$( event.currentTarget ).addClass( \"ui-state-hover\" );\n\t\t\t},\n\t\t\tmouseleave: function( event ) {\n\t\t\t\t$( event.currentTarget ).removeClass( \"ui-state-hover\" );\n\t\t\t}\n\t\t});\n\t},\n\n\t_focusable: function( element ) {\n\t\tthis.focusable = this.focusable.add( element );\n\t\tthis._on( element, {\n\t\t\tfocusin: function( event ) {\n\t\t\t\t$( event.currentTarget ).addClass( \"ui-state-focus\" );\n\t\t\t},\n\t\t\tfocusout: function( event ) {\n\t\t\t\t$( event.currentTarget ).removeClass( \"ui-state-focus\" );\n\t\t\t}\n\t\t});\n\t},\n\n\t_trigger: function( type, event, data ) {\n\t\tvar prop, orig,\n\t\t\tcallback = this.options[ type ];\n\n\t\tdata = data || {};\n\t\tevent = $.Event( event );\n\t\tevent.type = ( type === this.widgetEventPrefix ?\n\t\t\ttype :\n\t\t\tthis.widgetEventPrefix + type ).toLowerCase();\n\t\t// the original event may come from any element\n\t\t// so we need to reset the target on the new event\n\t\tevent.target = this.element[ 0 ];\n\n\t\t// copy original event properties over to the new event\n\t\torig = event.originalEvent;\n\t\tif ( orig ) {\n\t\t\tfor ( prop in orig ) {\n\t\t\t\tif ( !( prop in event ) ) {\n\t\t\t\t\tevent[ prop ] = orig[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.element.trigger( event, data );\n\t\treturn !( $.isFunction( callback ) &&\n\t\t\tcallback.apply( this.element[0], [ event ].concat( data ) ) === false ||\n\t\t\tevent.isDefaultPrevented() );\n\t}\n};\n\n$.each( { show: \"fadeIn\", hide: \"fadeOut\" }, function( method, defaultEffect ) {\n\t$.Widget.prototype[ \"_\" + method ] = function( element, options, callback ) {\n\t\tif ( typeof options === \"string\" ) {\n\t\t\toptions = { effect: options };\n\t\t}\n\t\tvar hasOptions,\n\t\t\teffectName = !options ?\n\t\t\t\tmethod :\n\t\t\t\toptions === true || typeof options === \"number\" ?\n\t\t\t\t\tdefaultEffect :\n\t\t\t\t\toptions.effect || defaultEffect;\n\t\toptions = options || {};\n\t\tif ( typeof options === \"number\" ) {\n\t\t\toptions = { duration: options };\n\t\t}\n\t\thasOptions = !$.isEmptyObject( options );\n\t\toptions.complete = callback;\n\t\tif ( options.delay ) {\n\t\t\telement.delay( options.delay );\n\t\t}\n\t\tif ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {\n\t\t\telement[ method ]( options );\n\t\t} else if ( effectName !== method && element[ effectName ] ) {\n\t\t\telement[ effectName ]( options.duration, options.easing, callback );\n\t\t} else {\n\t\t\telement.queue(function( next ) {\n\t\t\t\t$( this )[ method ]();\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback.call( element[ 0 ] );\n\t\t\t\t}\n\t\t\t\tnext();\n\t\t\t});\n\t\t}\n\t};\n});\n\nreturn $.widget;\n\n}));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzEyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9qcXVlcnktdWkvdWkvd2lkZ2V0LmpzPzQ5YmYiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBqUXVlcnkgVUkgV2lkZ2V0IDEuMTEuNFxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20valF1ZXJ5LndpZGdldC9cbiAqL1xuKGZ1bmN0aW9uKCBmYWN0b3J5ICkge1xuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXG5cdFx0Ly8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuXHRcdGRlZmluZSggWyBcImpxdWVyeVwiIF0sIGZhY3RvcnkgKTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIEJyb3dzZXIgZ2xvYmFsc1xuXHRcdGZhY3RvcnkoIGpRdWVyeSApO1xuXHR9XG59KGZ1bmN0aW9uKCAkICkge1xuXG52YXIgd2lkZ2V0X3V1aWQgPSAwLFxuXHR3aWRnZXRfc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiQuY2xlYW5EYXRhID0gKGZ1bmN0aW9uKCBvcmlnICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdHZhciBldmVudHMsIGVsZW0sIGk7XG5cdFx0Zm9yICggaSA9IDA7IChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdHRyeSB7XG5cblx0XHRcdFx0Ly8gT25seSB0cmlnZ2VyIHJlbW92ZSB3aGVuIG5lY2Vzc2FyeSB0byBzYXZlIHRpbWVcblx0XHRcdFx0ZXZlbnRzID0gJC5fZGF0YSggZWxlbSwgXCJldmVudHNcIiApO1xuXHRcdFx0XHRpZiAoIGV2ZW50cyAmJiBldmVudHMucmVtb3ZlICkge1xuXHRcdFx0XHRcdCQoIGVsZW0gKS50cmlnZ2VySGFuZGxlciggXCJyZW1vdmVcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzgyMzVcblx0XHRcdH0gY2F0Y2ggKCBlICkge31cblx0XHR9XG5cdFx0b3JpZyggZWxlbXMgKTtcblx0fTtcbn0pKCAkLmNsZWFuRGF0YSApO1xuXG4kLndpZGdldCA9IGZ1bmN0aW9uKCBuYW1lLCBiYXNlLCBwcm90b3R5cGUgKSB7XG5cdHZhciBmdWxsTmFtZSwgZXhpc3RpbmdDb25zdHJ1Y3RvciwgY29uc3RydWN0b3IsIGJhc2VQcm90b3R5cGUsXG5cdFx0Ly8gcHJveGllZFByb3RvdHlwZSBhbGxvd3MgdGhlIHByb3ZpZGVkIHByb3RvdHlwZSB0byByZW1haW4gdW5tb2RpZmllZFxuXHRcdC8vIHNvIHRoYXQgaXQgY2FuIGJlIHVzZWQgYXMgYSBtaXhpbiBmb3IgbXVsdGlwbGUgd2lkZ2V0cyAoIzg4NzYpXG5cdFx0cHJveGllZFByb3RvdHlwZSA9IHt9LFxuXHRcdG5hbWVzcGFjZSA9IG5hbWUuc3BsaXQoIFwiLlwiIClbIDAgXTtcblxuXHRuYW1lID0gbmFtZS5zcGxpdCggXCIuXCIgKVsgMSBdO1xuXHRmdWxsTmFtZSA9IG5hbWVzcGFjZSArIFwiLVwiICsgbmFtZTtcblxuXHRpZiAoICFwcm90b3R5cGUgKSB7XG5cdFx0cHJvdG90eXBlID0gYmFzZTtcblx0XHRiYXNlID0gJC5XaWRnZXQ7XG5cdH1cblxuXHQvLyBjcmVhdGUgc2VsZWN0b3IgZm9yIHBsdWdpblxuXHQkLmV4cHJbIFwiOlwiIF1bIGZ1bGxOYW1lLnRvTG93ZXJDYXNlKCkgXSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiAhISQuZGF0YSggZWxlbSwgZnVsbE5hbWUgKTtcblx0fTtcblxuXHQkWyBuYW1lc3BhY2UgXSA9ICRbIG5hbWVzcGFjZSBdIHx8IHt9O1xuXHRleGlzdGluZ0NvbnN0cnVjdG9yID0gJFsgbmFtZXNwYWNlIF1bIG5hbWUgXTtcblx0Y29uc3RydWN0b3IgPSAkWyBuYW1lc3BhY2UgXVsgbmFtZSBdID0gZnVuY3Rpb24oIG9wdGlvbnMsIGVsZW1lbnQgKSB7XG5cdFx0Ly8gYWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IFwibmV3XCIga2V5d29yZFxuXHRcdGlmICggIXRoaXMuX2NyZWF0ZVdpZGdldCApIHtcblx0XHRcdHJldHVybiBuZXcgY29uc3RydWN0b3IoIG9wdGlvbnMsIGVsZW1lbnQgKTtcblx0XHR9XG5cblx0XHQvLyBhbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgaW5pdGlhbGl6aW5nIGZvciBzaW1wbGUgaW5oZXJpdGFuY2Vcblx0XHQvLyBtdXN0IHVzZSBcIm5ld1wiIGtleXdvcmQgKHRoZSBjb2RlIGFib3ZlIGFsd2F5cyBwYXNzZXMgYXJncylcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHR0aGlzLl9jcmVhdGVXaWRnZXQoIG9wdGlvbnMsIGVsZW1lbnQgKTtcblx0XHR9XG5cdH07XG5cdC8vIGV4dGVuZCB3aXRoIHRoZSBleGlzdGluZyBjb25zdHJ1Y3RvciB0byBjYXJyeSBvdmVyIGFueSBzdGF0aWMgcHJvcGVydGllc1xuXHQkLmV4dGVuZCggY29uc3RydWN0b3IsIGV4aXN0aW5nQ29uc3RydWN0b3IsIHtcblx0XHR2ZXJzaW9uOiBwcm90b3R5cGUudmVyc2lvbixcblx0XHQvLyBjb3B5IHRoZSBvYmplY3QgdXNlZCB0byBjcmVhdGUgdGhlIHByb3RvdHlwZSBpbiBjYXNlIHdlIG5lZWQgdG9cblx0XHQvLyByZWRlZmluZSB0aGUgd2lkZ2V0IGxhdGVyXG5cdFx0X3Byb3RvOiAkLmV4dGVuZCgge30sIHByb3RvdHlwZSApLFxuXHRcdC8vIHRyYWNrIHdpZGdldHMgdGhhdCBpbmhlcml0IGZyb20gdGhpcyB3aWRnZXQgaW4gY2FzZSB0aGlzIHdpZGdldCBpc1xuXHRcdC8vIHJlZGVmaW5lZCBhZnRlciBhIHdpZGdldCBpbmhlcml0cyBmcm9tIGl0XG5cdFx0X2NoaWxkQ29uc3RydWN0b3JzOiBbXVxuXHR9KTtcblxuXHRiYXNlUHJvdG90eXBlID0gbmV3IGJhc2UoKTtcblx0Ly8gd2UgbmVlZCB0byBtYWtlIHRoZSBvcHRpb25zIGhhc2ggYSBwcm9wZXJ0eSBkaXJlY3RseSBvbiB0aGUgbmV3IGluc3RhbmNlXG5cdC8vIG90aGVyd2lzZSB3ZSdsbCBtb2RpZnkgdGhlIG9wdGlvbnMgaGFzaCBvbiB0aGUgcHJvdG90eXBlIHRoYXQgd2UncmVcblx0Ly8gaW5oZXJpdGluZyBmcm9tXG5cdGJhc2VQcm90b3R5cGUub3B0aW9ucyA9ICQud2lkZ2V0LmV4dGVuZCgge30sIGJhc2VQcm90b3R5cGUub3B0aW9ucyApO1xuXHQkLmVhY2goIHByb3RvdHlwZSwgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdGlmICggISQuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHByb3hpZWRQcm90b3R5cGVbIHByb3AgXSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRwcm94aWVkUHJvdG90eXBlWyBwcm9wIF0gPSAoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgX3N1cGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJhc2UucHJvdG90eXBlWyBwcm9wIF0uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRfc3VwZXJBcHBseSA9IGZ1bmN0aW9uKCBhcmdzICkge1xuXHRcdFx0XHRcdHJldHVybiBiYXNlLnByb3RvdHlwZVsgcHJvcCBdLmFwcGx5KCB0aGlzLCBhcmdzICk7XG5cdFx0XHRcdH07XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBfX3N1cGVyID0gdGhpcy5fc3VwZXIsXG5cdFx0XHRcdFx0X19zdXBlckFwcGx5ID0gdGhpcy5fc3VwZXJBcHBseSxcblx0XHRcdFx0XHRyZXR1cm5WYWx1ZTtcblxuXHRcdFx0XHR0aGlzLl9zdXBlciA9IF9zdXBlcjtcblx0XHRcdFx0dGhpcy5fc3VwZXJBcHBseSA9IF9zdXBlckFwcGx5O1xuXG5cdFx0XHRcdHJldHVyblZhbHVlID0gdmFsdWUuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXG5cdFx0XHRcdHRoaXMuX3N1cGVyID0gX19zdXBlcjtcblx0XHRcdFx0dGhpcy5fc3VwZXJBcHBseSA9IF9fc3VwZXJBcHBseTtcblxuXHRcdFx0XHRyZXR1cm4gcmV0dXJuVmFsdWU7XG5cdFx0XHR9O1xuXHRcdH0pKCk7XG5cdH0pO1xuXHRjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSAkLndpZGdldC5leHRlbmQoIGJhc2VQcm90b3R5cGUsIHtcblx0XHQvLyBUT0RPOiByZW1vdmUgc3VwcG9ydCBmb3Igd2lkZ2V0RXZlbnRQcmVmaXhcblx0XHQvLyBhbHdheXMgdXNlIHRoZSBuYW1lICsgYSBjb2xvbiBhcyB0aGUgcHJlZml4LCBlLmcuLCBkcmFnZ2FibGU6c3RhcnRcblx0XHQvLyBkb24ndCBwcmVmaXggZm9yIHdpZGdldHMgdGhhdCBhcmVuJ3QgRE9NLWJhc2VkXG5cdFx0d2lkZ2V0RXZlbnRQcmVmaXg6IGV4aXN0aW5nQ29uc3RydWN0b3IgPyAoYmFzZVByb3RvdHlwZS53aWRnZXRFdmVudFByZWZpeCB8fCBuYW1lKSA6IG5hbWVcblx0fSwgcHJveGllZFByb3RvdHlwZSwge1xuXHRcdGNvbnN0cnVjdG9yOiBjb25zdHJ1Y3Rvcixcblx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZSxcblx0XHR3aWRnZXROYW1lOiBuYW1lLFxuXHRcdHdpZGdldEZ1bGxOYW1lOiBmdWxsTmFtZVxuXHR9KTtcblxuXHQvLyBJZiB0aGlzIHdpZGdldCBpcyBiZWluZyByZWRlZmluZWQgdGhlbiB3ZSBuZWVkIHRvIGZpbmQgYWxsIHdpZGdldHMgdGhhdFxuXHQvLyBhcmUgaW5oZXJpdGluZyBmcm9tIGl0IGFuZCByZWRlZmluZSBhbGwgb2YgdGhlbSBzbyB0aGF0IHRoZXkgaW5oZXJpdCBmcm9tXG5cdC8vIHRoZSBuZXcgdmVyc2lvbiBvZiB0aGlzIHdpZGdldC4gV2UncmUgZXNzZW50aWFsbHkgdHJ5aW5nIHRvIHJlcGxhY2Ugb25lXG5cdC8vIGxldmVsIGluIHRoZSBwcm90b3R5cGUgY2hhaW4uXG5cdGlmICggZXhpc3RpbmdDb25zdHJ1Y3RvciApIHtcblx0XHQkLmVhY2goIGV4aXN0aW5nQ29uc3RydWN0b3IuX2NoaWxkQ29uc3RydWN0b3JzLCBmdW5jdGlvbiggaSwgY2hpbGQgKSB7XG5cdFx0XHR2YXIgY2hpbGRQcm90b3R5cGUgPSBjaGlsZC5wcm90b3R5cGU7XG5cblx0XHRcdC8vIHJlZGVmaW5lIHRoZSBjaGlsZCB3aWRnZXQgdXNpbmcgdGhlIHNhbWUgcHJvdG90eXBlIHRoYXQgd2FzXG5cdFx0XHQvLyBvcmlnaW5hbGx5IHVzZWQsIGJ1dCBpbmhlcml0IGZyb20gdGhlIG5ldyB2ZXJzaW9uIG9mIHRoZSBiYXNlXG5cdFx0XHQkLndpZGdldCggY2hpbGRQcm90b3R5cGUubmFtZXNwYWNlICsgXCIuXCIgKyBjaGlsZFByb3RvdHlwZS53aWRnZXROYW1lLCBjb25zdHJ1Y3RvciwgY2hpbGQuX3Byb3RvICk7XG5cdFx0fSk7XG5cdFx0Ly8gcmVtb3ZlIHRoZSBsaXN0IG9mIGV4aXN0aW5nIGNoaWxkIGNvbnN0cnVjdG9ycyBmcm9tIHRoZSBvbGQgY29uc3RydWN0b3Jcblx0XHQvLyBzbyB0aGUgb2xkIGNoaWxkIGNvbnN0cnVjdG9ycyBjYW4gYmUgZ2FyYmFnZSBjb2xsZWN0ZWRcblx0XHRkZWxldGUgZXhpc3RpbmdDb25zdHJ1Y3Rvci5fY2hpbGRDb25zdHJ1Y3RvcnM7XG5cdH0gZWxzZSB7XG5cdFx0YmFzZS5fY2hpbGRDb25zdHJ1Y3RvcnMucHVzaCggY29uc3RydWN0b3IgKTtcblx0fVxuXG5cdCQud2lkZ2V0LmJyaWRnZSggbmFtZSwgY29uc3RydWN0b3IgKTtcblxuXHRyZXR1cm4gY29uc3RydWN0b3I7XG59O1xuXG4kLndpZGdldC5leHRlbmQgPSBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHR2YXIgaW5wdXQgPSB3aWRnZXRfc2xpY2UuY2FsbCggYXJndW1lbnRzLCAxICksXG5cdFx0aW5wdXRJbmRleCA9IDAsXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0a2V5LFxuXHRcdHZhbHVlO1xuXHRmb3IgKCA7IGlucHV0SW5kZXggPCBpbnB1dExlbmd0aDsgaW5wdXRJbmRleCsrICkge1xuXHRcdGZvciAoIGtleSBpbiBpbnB1dFsgaW5wdXRJbmRleCBdICkge1xuXHRcdFx0dmFsdWUgPSBpbnB1dFsgaW5wdXRJbmRleCBdWyBrZXkgXTtcblx0XHRcdGlmICggaW5wdXRbIGlucHV0SW5kZXggXS5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0Ly8gQ2xvbmUgb2JqZWN0c1xuXHRcdFx0XHRpZiAoICQuaXNQbGFpbk9iamVjdCggdmFsdWUgKSApIHtcblx0XHRcdFx0XHR0YXJnZXRbIGtleSBdID0gJC5pc1BsYWluT2JqZWN0KCB0YXJnZXRbIGtleSBdICkgP1xuXHRcdFx0XHRcdFx0JC53aWRnZXQuZXh0ZW5kKCB7fSwgdGFyZ2V0WyBrZXkgXSwgdmFsdWUgKSA6XG5cdFx0XHRcdFx0XHQvLyBEb24ndCBleHRlbmQgc3RyaW5ncywgYXJyYXlzLCBldGMuIHdpdGggb2JqZWN0c1xuXHRcdFx0XHRcdFx0JC53aWRnZXQuZXh0ZW5kKCB7fSwgdmFsdWUgKTtcblx0XHRcdFx0Ly8gQ29weSBldmVyeXRoaW5nIGVsc2UgYnkgcmVmZXJlbmNlXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBrZXkgXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG4kLndpZGdldC5icmlkZ2UgPSBmdW5jdGlvbiggbmFtZSwgb2JqZWN0ICkge1xuXHR2YXIgZnVsbE5hbWUgPSBvYmplY3QucHJvdG90eXBlLndpZGdldEZ1bGxOYW1lIHx8IG5hbWU7XG5cdCQuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdHZhciBpc01ldGhvZENhbGwgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIixcblx0XHRcdGFyZ3MgPSB3aWRnZXRfc2xpY2UuY2FsbCggYXJndW1lbnRzLCAxICksXG5cdFx0XHRyZXR1cm5WYWx1ZSA9IHRoaXM7XG5cblx0XHRpZiAoIGlzTWV0aG9kQ2FsbCApIHtcblx0XHRcdHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG1ldGhvZFZhbHVlLFxuXHRcdFx0XHRcdGluc3RhbmNlID0gJC5kYXRhKCB0aGlzLCBmdWxsTmFtZSApO1xuXHRcdFx0XHRpZiAoIG9wdGlvbnMgPT09IFwiaW5zdGFuY2VcIiApIHtcblx0XHRcdFx0XHRyZXR1cm5WYWx1ZSA9IGluc3RhbmNlO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFpbnN0YW5jZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gJC5lcnJvciggXCJjYW5ub3QgY2FsbCBtZXRob2RzIG9uIFwiICsgbmFtZSArIFwiIHByaW9yIHRvIGluaXRpYWxpemF0aW9uOyBcIiArXG5cdFx0XHRcdFx0XHRcImF0dGVtcHRlZCB0byBjYWxsIG1ldGhvZCAnXCIgKyBvcHRpb25zICsgXCInXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICEkLmlzRnVuY3Rpb24oIGluc3RhbmNlW29wdGlvbnNdICkgfHwgb3B0aW9ucy5jaGFyQXQoIDAgKSA9PT0gXCJfXCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuICQuZXJyb3IoIFwibm8gc3VjaCBtZXRob2QgJ1wiICsgb3B0aW9ucyArIFwiJyBmb3IgXCIgKyBuYW1lICsgXCIgd2lkZ2V0IGluc3RhbmNlXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRtZXRob2RWYWx1ZSA9IGluc3RhbmNlWyBvcHRpb25zIF0uYXBwbHkoIGluc3RhbmNlLCBhcmdzICk7XG5cdFx0XHRcdGlmICggbWV0aG9kVmFsdWUgIT09IGluc3RhbmNlICYmIG1ldGhvZFZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuVmFsdWUgPSBtZXRob2RWYWx1ZSAmJiBtZXRob2RWYWx1ZS5qcXVlcnkgP1xuXHRcdFx0XHRcdFx0cmV0dXJuVmFsdWUucHVzaFN0YWNrKCBtZXRob2RWYWx1ZS5nZXQoKSApIDpcblx0XHRcdFx0XHRcdG1ldGhvZFZhbHVlO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQWxsb3cgbXVsdGlwbGUgaGFzaGVzIHRvIGJlIHBhc3NlZCBvbiBpbml0XG5cdFx0XHRpZiAoIGFyZ3MubGVuZ3RoICkge1xuXHRcdFx0XHRvcHRpb25zID0gJC53aWRnZXQuZXh0ZW5kLmFwcGx5KCBudWxsLCBbIG9wdGlvbnMgXS5jb25jYXQoYXJncykgKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgaW5zdGFuY2UgPSAkLmRhdGEoIHRoaXMsIGZ1bGxOYW1lICk7XG5cdFx0XHRcdGlmICggaW5zdGFuY2UgKSB7XG5cdFx0XHRcdFx0aW5zdGFuY2Uub3B0aW9uKCBvcHRpb25zIHx8IHt9ICk7XG5cdFx0XHRcdFx0aWYgKCBpbnN0YW5jZS5faW5pdCApIHtcblx0XHRcdFx0XHRcdGluc3RhbmNlLl9pbml0KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCQuZGF0YSggdGhpcywgZnVsbE5hbWUsIG5ldyBvYmplY3QoIG9wdGlvbnMsIHRoaXMgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0dXJuVmFsdWU7XG5cdH07XG59O1xuXG4kLldpZGdldCA9IGZ1bmN0aW9uKCAvKiBvcHRpb25zLCBlbGVtZW50ICovICkge307XG4kLldpZGdldC5fY2hpbGRDb25zdHJ1Y3RvcnMgPSBbXTtcblxuJC5XaWRnZXQucHJvdG90eXBlID0ge1xuXHR3aWRnZXROYW1lOiBcIndpZGdldFwiLFxuXHR3aWRnZXRFdmVudFByZWZpeDogXCJcIixcblx0ZGVmYXVsdEVsZW1lbnQ6IFwiPGRpdj5cIixcblx0b3B0aW9uczoge1xuXHRcdGRpc2FibGVkOiBmYWxzZSxcblxuXHRcdC8vIGNhbGxiYWNrc1xuXHRcdGNyZWF0ZTogbnVsbFxuXHR9LFxuXHRfY3JlYXRlV2lkZ2V0OiBmdW5jdGlvbiggb3B0aW9ucywgZWxlbWVudCApIHtcblx0XHRlbGVtZW50ID0gJCggZWxlbWVudCB8fCB0aGlzLmRlZmF1bHRFbGVtZW50IHx8IHRoaXMgKVsgMCBdO1xuXHRcdHRoaXMuZWxlbWVudCA9ICQoIGVsZW1lbnQgKTtcblx0XHR0aGlzLnV1aWQgPSB3aWRnZXRfdXVpZCsrO1xuXHRcdHRoaXMuZXZlbnROYW1lc3BhY2UgPSBcIi5cIiArIHRoaXMud2lkZ2V0TmFtZSArIHRoaXMudXVpZDtcblxuXHRcdHRoaXMuYmluZGluZ3MgPSAkKCk7XG5cdFx0dGhpcy5ob3ZlcmFibGUgPSAkKCk7XG5cdFx0dGhpcy5mb2N1c2FibGUgPSAkKCk7XG5cblx0XHRpZiAoIGVsZW1lbnQgIT09IHRoaXMgKSB7XG5cdFx0XHQkLmRhdGEoIGVsZW1lbnQsIHRoaXMud2lkZ2V0RnVsbE5hbWUsIHRoaXMgKTtcblx0XHRcdHRoaXMuX29uKCB0cnVlLCB0aGlzLmVsZW1lbnQsIHtcblx0XHRcdFx0cmVtb3ZlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0aWYgKCBldmVudC50YXJnZXQgPT09IGVsZW1lbnQgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmRlc3Ryb3koKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0dGhpcy5kb2N1bWVudCA9ICQoIGVsZW1lbnQuc3R5bGUgP1xuXHRcdFx0XHQvLyBlbGVtZW50IHdpdGhpbiB0aGUgZG9jdW1lbnRcblx0XHRcdFx0ZWxlbWVudC5vd25lckRvY3VtZW50IDpcblx0XHRcdFx0Ly8gZWxlbWVudCBpcyB3aW5kb3cgb3IgZG9jdW1lbnRcblx0XHRcdFx0ZWxlbWVudC5kb2N1bWVudCB8fCBlbGVtZW50ICk7XG5cdFx0XHR0aGlzLndpbmRvdyA9ICQoIHRoaXMuZG9jdW1lbnRbMF0uZGVmYXVsdFZpZXcgfHwgdGhpcy5kb2N1bWVudFswXS5wYXJlbnRXaW5kb3cgKTtcblx0XHR9XG5cblx0XHR0aGlzLm9wdGlvbnMgPSAkLndpZGdldC5leHRlbmQoIHt9LFxuXHRcdFx0dGhpcy5vcHRpb25zLFxuXHRcdFx0dGhpcy5fZ2V0Q3JlYXRlT3B0aW9ucygpLFxuXHRcdFx0b3B0aW9ucyApO1xuXG5cdFx0dGhpcy5fY3JlYXRlKCk7XG5cdFx0dGhpcy5fdHJpZ2dlciggXCJjcmVhdGVcIiwgbnVsbCwgdGhpcy5fZ2V0Q3JlYXRlRXZlbnREYXRhKCkgKTtcblx0XHR0aGlzLl9pbml0KCk7XG5cdH0sXG5cdF9nZXRDcmVhdGVPcHRpb25zOiAkLm5vb3AsXG5cdF9nZXRDcmVhdGVFdmVudERhdGE6ICQubm9vcCxcblx0X2NyZWF0ZTogJC5ub29wLFxuXHRfaW5pdDogJC5ub29wLFxuXG5cdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2Rlc3Ryb3koKTtcblx0XHQvLyB3ZSBjYW4gcHJvYmFibHkgcmVtb3ZlIHRoZSB1bmJpbmQgY2FsbHMgaW4gMi4wXG5cdFx0Ly8gYWxsIGV2ZW50IGJpbmRpbmdzIHNob3VsZCBnbyB0aHJvdWdoIHRoaXMuX29uKClcblx0XHR0aGlzLmVsZW1lbnRcblx0XHRcdC51bmJpbmQoIHRoaXMuZXZlbnROYW1lc3BhY2UgKVxuXHRcdFx0LnJlbW92ZURhdGEoIHRoaXMud2lkZ2V0RnVsbE5hbWUgKVxuXHRcdFx0Ly8gc3VwcG9ydDoganF1ZXJ5IDwxLjYuM1xuXHRcdFx0Ly8gaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvOTQxM1xuXHRcdFx0LnJlbW92ZURhdGEoICQuY2FtZWxDYXNlKCB0aGlzLndpZGdldEZ1bGxOYW1lICkgKTtcblx0XHR0aGlzLndpZGdldCgpXG5cdFx0XHQudW5iaW5kKCB0aGlzLmV2ZW50TmFtZXNwYWNlIClcblx0XHRcdC5yZW1vdmVBdHRyKCBcImFyaWEtZGlzYWJsZWRcIiApXG5cdFx0XHQucmVtb3ZlQ2xhc3MoXG5cdFx0XHRcdHRoaXMud2lkZ2V0RnVsbE5hbWUgKyBcIi1kaXNhYmxlZCBcIiArXG5cdFx0XHRcdFwidWktc3RhdGUtZGlzYWJsZWRcIiApO1xuXG5cdFx0Ly8gY2xlYW4gdXAgZXZlbnRzIGFuZCBzdGF0ZXNcblx0XHR0aGlzLmJpbmRpbmdzLnVuYmluZCggdGhpcy5ldmVudE5hbWVzcGFjZSApO1xuXHRcdHRoaXMuaG92ZXJhYmxlLnJlbW92ZUNsYXNzKCBcInVpLXN0YXRlLWhvdmVyXCIgKTtcblx0XHR0aGlzLmZvY3VzYWJsZS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1mb2N1c1wiICk7XG5cdH0sXG5cdF9kZXN0cm95OiAkLm5vb3AsXG5cblx0d2lkZ2V0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lbGVtZW50O1xuXHR9LFxuXG5cdG9wdGlvbjogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSBrZXksXG5cdFx0XHRwYXJ0cyxcblx0XHRcdGN1ck9wdGlvbixcblx0XHRcdGk7XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHQvLyBkb24ndCByZXR1cm4gYSByZWZlcmVuY2UgdG8gdGhlIGludGVybmFsIGhhc2hcblx0XHRcdHJldHVybiAkLndpZGdldC5leHRlbmQoIHt9LCB0aGlzLm9wdGlvbnMgKTtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHQvLyBoYW5kbGUgbmVzdGVkIGtleXMsIGUuZy4sIFwiZm9vLmJhclwiID0+IHsgZm9vOiB7IGJhcjogX19fIH0gfVxuXHRcdFx0b3B0aW9ucyA9IHt9O1xuXHRcdFx0cGFydHMgPSBrZXkuc3BsaXQoIFwiLlwiICk7XG5cdFx0XHRrZXkgPSBwYXJ0cy5zaGlmdCgpO1xuXHRcdFx0aWYgKCBwYXJ0cy5sZW5ndGggKSB7XG5cdFx0XHRcdGN1ck9wdGlvbiA9IG9wdGlvbnNbIGtleSBdID0gJC53aWRnZXQuZXh0ZW5kKCB7fSwgdGhpcy5vcHRpb25zWyBrZXkgXSApO1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7IGkrKyApIHtcblx0XHRcdFx0XHRjdXJPcHRpb25bIHBhcnRzWyBpIF0gXSA9IGN1ck9wdGlvblsgcGFydHNbIGkgXSBdIHx8IHt9O1xuXHRcdFx0XHRcdGN1ck9wdGlvbiA9IGN1ck9wdGlvblsgcGFydHNbIGkgXSBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGtleSA9IHBhcnRzLnBvcCgpO1xuXHRcdFx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGN1ck9wdGlvblsga2V5IF0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjdXJPcHRpb25bIGtleSBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGN1ck9wdGlvblsga2V5IF0gPSB2YWx1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zWyBrZXkgXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHRoaXMub3B0aW9uc1sga2V5IF07XG5cdFx0XHRcdH1cblx0XHRcdFx0b3B0aW9uc1sga2V5IF0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9zZXRPcHRpb25zKCBvcHRpb25zICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblx0X3NldE9wdGlvbnM6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdHZhciBrZXk7XG5cblx0XHRmb3IgKCBrZXkgaW4gb3B0aW9ucyApIHtcblx0XHRcdHRoaXMuX3NldE9wdGlvbigga2V5LCBvcHRpb25zWyBrZXkgXSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXHRfc2V0T3B0aW9uOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR0aGlzLm9wdGlvbnNbIGtleSBdID0gdmFsdWU7XG5cblx0XHRpZiAoIGtleSA9PT0gXCJkaXNhYmxlZFwiICkge1xuXHRcdFx0dGhpcy53aWRnZXQoKVxuXHRcdFx0XHQudG9nZ2xlQ2xhc3MoIHRoaXMud2lkZ2V0RnVsbE5hbWUgKyBcIi1kaXNhYmxlZFwiLCAhIXZhbHVlICk7XG5cblx0XHRcdC8vIElmIHRoZSB3aWRnZXQgaXMgYmVjb21pbmcgZGlzYWJsZWQsIHRoZW4gbm90aGluZyBpcyBpbnRlcmFjdGl2ZVxuXHRcdFx0aWYgKCB2YWx1ZSApIHtcblx0XHRcdFx0dGhpcy5ob3ZlcmFibGUucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtaG92ZXJcIiApO1xuXHRcdFx0XHR0aGlzLmZvY3VzYWJsZS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1mb2N1c1wiICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0ZW5hYmxlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2V0T3B0aW9ucyh7IGRpc2FibGVkOiBmYWxzZSB9KTtcblx0fSxcblx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NldE9wdGlvbnMoeyBkaXNhYmxlZDogdHJ1ZSB9KTtcblx0fSxcblxuXHRfb246IGZ1bmN0aW9uKCBzdXBwcmVzc0Rpc2FibGVkQ2hlY2ssIGVsZW1lbnQsIGhhbmRsZXJzICkge1xuXHRcdHZhciBkZWxlZ2F0ZUVsZW1lbnQsXG5cdFx0XHRpbnN0YW5jZSA9IHRoaXM7XG5cblx0XHQvLyBubyBzdXBwcmVzc0Rpc2FibGVkQ2hlY2sgZmxhZywgc2h1ZmZsZSBhcmd1bWVudHNcblx0XHRpZiAoIHR5cGVvZiBzdXBwcmVzc0Rpc2FibGVkQ2hlY2sgIT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0aGFuZGxlcnMgPSBlbGVtZW50O1xuXHRcdFx0ZWxlbWVudCA9IHN1cHByZXNzRGlzYWJsZWRDaGVjaztcblx0XHRcdHN1cHByZXNzRGlzYWJsZWRDaGVjayA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIG5vIGVsZW1lbnQgYXJndW1lbnQsIHNodWZmbGUgYW5kIHVzZSB0aGlzLmVsZW1lbnRcblx0XHRpZiAoICFoYW5kbGVycyApIHtcblx0XHRcdGhhbmRsZXJzID0gZWxlbWVudDtcblx0XHRcdGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG5cdFx0XHRkZWxlZ2F0ZUVsZW1lbnQgPSB0aGlzLndpZGdldCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtZW50ID0gZGVsZWdhdGVFbGVtZW50ID0gJCggZWxlbWVudCApO1xuXHRcdFx0dGhpcy5iaW5kaW5ncyA9IHRoaXMuYmluZGluZ3MuYWRkKCBlbGVtZW50ICk7XG5cdFx0fVxuXG5cdFx0JC5lYWNoKCBoYW5kbGVycywgZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVyICkge1xuXHRcdFx0ZnVuY3Rpb24gaGFuZGxlclByb3h5KCkge1xuXHRcdFx0XHQvLyBhbGxvdyB3aWRnZXRzIHRvIGN1c3RvbWl6ZSB0aGUgZGlzYWJsZWQgaGFuZGxpbmdcblx0XHRcdFx0Ly8gLSBkaXNhYmxlZCBhcyBhbiBhcnJheSBpbnN0ZWFkIG9mIGJvb2xlYW5cblx0XHRcdFx0Ly8gLSBkaXNhYmxlZCBjbGFzcyBhcyBtZXRob2QgZm9yIGRpc2FibGluZyBpbmRpdmlkdWFsIHBhcnRzXG5cdFx0XHRcdGlmICggIXN1cHByZXNzRGlzYWJsZWRDaGVjayAmJlxuXHRcdFx0XHRcdFx0KCBpbnN0YW5jZS5vcHRpb25zLmRpc2FibGVkID09PSB0cnVlIHx8XG5cdFx0XHRcdFx0XHRcdCQoIHRoaXMgKS5oYXNDbGFzcyggXCJ1aS1zdGF0ZS1kaXNhYmxlZFwiICkgKSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuICggdHlwZW9mIGhhbmRsZXIgPT09IFwic3RyaW5nXCIgPyBpbnN0YW5jZVsgaGFuZGxlciBdIDogaGFuZGxlciApXG5cdFx0XHRcdFx0LmFwcGx5KCBpbnN0YW5jZSwgYXJndW1lbnRzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNvcHkgdGhlIGd1aWQgc28gZGlyZWN0IHVuYmluZGluZyB3b3Jrc1xuXHRcdFx0aWYgKCB0eXBlb2YgaGFuZGxlciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0aGFuZGxlclByb3h5Lmd1aWQgPSBoYW5kbGVyLmd1aWQgPVxuXHRcdFx0XHRcdGhhbmRsZXIuZ3VpZCB8fCBoYW5kbGVyUHJveHkuZ3VpZCB8fCAkLmd1aWQrKztcblx0XHRcdH1cblxuXHRcdFx0dmFyIG1hdGNoID0gZXZlbnQubWF0Y2goIC9eKFtcXHc6LV0qKVxccyooLiopJC8gKSxcblx0XHRcdFx0ZXZlbnROYW1lID0gbWF0Y2hbMV0gKyBpbnN0YW5jZS5ldmVudE5hbWVzcGFjZSxcblx0XHRcdFx0c2VsZWN0b3IgPSBtYXRjaFsyXTtcblx0XHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdGRlbGVnYXRlRWxlbWVudC5kZWxlZ2F0ZSggc2VsZWN0b3IsIGV2ZW50TmFtZSwgaGFuZGxlclByb3h5ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtZW50LmJpbmQoIGV2ZW50TmFtZSwgaGFuZGxlclByb3h5ICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0X29mZjogZnVuY3Rpb24oIGVsZW1lbnQsIGV2ZW50TmFtZSApIHtcblx0XHRldmVudE5hbWUgPSAoZXZlbnROYW1lIHx8IFwiXCIpLnNwbGl0KCBcIiBcIiApLmpvaW4oIHRoaXMuZXZlbnROYW1lc3BhY2UgKyBcIiBcIiApICtcblx0XHRcdHRoaXMuZXZlbnROYW1lc3BhY2U7XG5cdFx0ZWxlbWVudC51bmJpbmQoIGV2ZW50TmFtZSApLnVuZGVsZWdhdGUoIGV2ZW50TmFtZSApO1xuXG5cdFx0Ly8gQ2xlYXIgdGhlIHN0YWNrIHRvIGF2b2lkIG1lbW9yeSBsZWFrcyAoIzEwMDU2KVxuXHRcdHRoaXMuYmluZGluZ3MgPSAkKCB0aGlzLmJpbmRpbmdzLm5vdCggZWxlbWVudCApLmdldCgpICk7XG5cdFx0dGhpcy5mb2N1c2FibGUgPSAkKCB0aGlzLmZvY3VzYWJsZS5ub3QoIGVsZW1lbnQgKS5nZXQoKSApO1xuXHRcdHRoaXMuaG92ZXJhYmxlID0gJCggdGhpcy5ob3ZlcmFibGUubm90KCBlbGVtZW50ICkuZ2V0KCkgKTtcblx0fSxcblxuXHRfZGVsYXk6IGZ1bmN0aW9uKCBoYW5kbGVyLCBkZWxheSApIHtcblx0XHRmdW5jdGlvbiBoYW5kbGVyUHJveHkoKSB7XG5cdFx0XHRyZXR1cm4gKCB0eXBlb2YgaGFuZGxlciA9PT0gXCJzdHJpbmdcIiA/IGluc3RhbmNlWyBoYW5kbGVyIF0gOiBoYW5kbGVyIClcblx0XHRcdFx0LmFwcGx5KCBpbnN0YW5jZSwgYXJndW1lbnRzICk7XG5cdFx0fVxuXHRcdHZhciBpbnN0YW5jZSA9IHRoaXM7XG5cdFx0cmV0dXJuIHNldFRpbWVvdXQoIGhhbmRsZXJQcm94eSwgZGVsYXkgfHwgMCApO1xuXHR9LFxuXG5cdF9ob3ZlcmFibGU6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHRoaXMuaG92ZXJhYmxlID0gdGhpcy5ob3ZlcmFibGUuYWRkKCBlbGVtZW50ICk7XG5cdFx0dGhpcy5fb24oIGVsZW1lbnQsIHtcblx0XHRcdG1vdXNlZW50ZXI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0JCggZXZlbnQuY3VycmVudFRhcmdldCApLmFkZENsYXNzKCBcInVpLXN0YXRlLWhvdmVyXCIgKTtcblx0XHRcdH0sXG5cdFx0XHRtb3VzZWxlYXZlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdCQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1ob3ZlclwiICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0X2ZvY3VzYWJsZTogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0dGhpcy5mb2N1c2FibGUgPSB0aGlzLmZvY3VzYWJsZS5hZGQoIGVsZW1lbnQgKTtcblx0XHR0aGlzLl9vbiggZWxlbWVudCwge1xuXHRcdFx0Zm9jdXNpbjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHQkKCBldmVudC5jdXJyZW50VGFyZ2V0ICkuYWRkQ2xhc3MoIFwidWktc3RhdGUtZm9jdXNcIiApO1xuXHRcdFx0fSxcblx0XHRcdGZvY3Vzb3V0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdCQoIGV2ZW50LmN1cnJlbnRUYXJnZXQgKS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1mb2N1c1wiICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0X3RyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBldmVudCwgZGF0YSApIHtcblx0XHR2YXIgcHJvcCwgb3JpZyxcblx0XHRcdGNhbGxiYWNrID0gdGhpcy5vcHRpb25zWyB0eXBlIF07XG5cblx0XHRkYXRhID0gZGF0YSB8fCB7fTtcblx0XHRldmVudCA9ICQuRXZlbnQoIGV2ZW50ICk7XG5cdFx0ZXZlbnQudHlwZSA9ICggdHlwZSA9PT0gdGhpcy53aWRnZXRFdmVudFByZWZpeCA/XG5cdFx0XHR0eXBlIDpcblx0XHRcdHRoaXMud2lkZ2V0RXZlbnRQcmVmaXggKyB0eXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHQvLyB0aGUgb3JpZ2luYWwgZXZlbnQgbWF5IGNvbWUgZnJvbSBhbnkgZWxlbWVudFxuXHRcdC8vIHNvIHdlIG5lZWQgdG8gcmVzZXQgdGhlIHRhcmdldCBvbiB0aGUgbmV3IGV2ZW50XG5cdFx0ZXZlbnQudGFyZ2V0ID0gdGhpcy5lbGVtZW50WyAwIF07XG5cblx0XHQvLyBjb3B5IG9yaWdpbmFsIGV2ZW50IHByb3BlcnRpZXMgb3ZlciB0byB0aGUgbmV3IGV2ZW50XG5cdFx0b3JpZyA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQ7XG5cdFx0aWYgKCBvcmlnICkge1xuXHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRpZiAoICEoIHByb3AgaW4gZXZlbnQgKSApIHtcblx0XHRcdFx0XHRldmVudFsgcHJvcCBdID0gb3JpZ1sgcHJvcCBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5lbGVtZW50LnRyaWdnZXIoIGV2ZW50LCBkYXRhICk7XG5cdFx0cmV0dXJuICEoICQuaXNGdW5jdGlvbiggY2FsbGJhY2sgKSAmJlxuXHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMuZWxlbWVudFswXSwgWyBldmVudCBdLmNvbmNhdCggZGF0YSApICkgPT09IGZhbHNlIHx8XG5cdFx0XHRldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApO1xuXHR9XG59O1xuXG4kLmVhY2goIHsgc2hvdzogXCJmYWRlSW5cIiwgaGlkZTogXCJmYWRlT3V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgZGVmYXVsdEVmZmVjdCApIHtcblx0JC5XaWRnZXQucHJvdG90eXBlWyBcIl9cIiArIG1ldGhvZCBdID0gZnVuY3Rpb24oIGVsZW1lbnQsIG9wdGlvbnMsIGNhbGxiYWNrICkge1xuXHRcdGlmICggdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvcHRpb25zID0geyBlZmZlY3Q6IG9wdGlvbnMgfTtcblx0XHR9XG5cdFx0dmFyIGhhc09wdGlvbnMsXG5cdFx0XHRlZmZlY3ROYW1lID0gIW9wdGlvbnMgP1xuXHRcdFx0XHRtZXRob2QgOlxuXHRcdFx0XHRvcHRpb25zID09PSB0cnVlIHx8IHR5cGVvZiBvcHRpb25zID09PSBcIm51bWJlclwiID9cblx0XHRcdFx0XHRkZWZhdWx0RWZmZWN0IDpcblx0XHRcdFx0XHRvcHRpb25zLmVmZmVjdCB8fCBkZWZhdWx0RWZmZWN0O1xuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdGlmICggdHlwZW9mIG9wdGlvbnMgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRvcHRpb25zID0geyBkdXJhdGlvbjogb3B0aW9ucyB9O1xuXHRcdH1cblx0XHRoYXNPcHRpb25zID0gISQuaXNFbXB0eU9iamVjdCggb3B0aW9ucyApO1xuXHRcdG9wdGlvbnMuY29tcGxldGUgPSBjYWxsYmFjaztcblx0XHRpZiAoIG9wdGlvbnMuZGVsYXkgKSB7XG5cdFx0XHRlbGVtZW50LmRlbGF5KCBvcHRpb25zLmRlbGF5ICk7XG5cdFx0fVxuXHRcdGlmICggaGFzT3B0aW9ucyAmJiAkLmVmZmVjdHMgJiYgJC5lZmZlY3RzLmVmZmVjdFsgZWZmZWN0TmFtZSBdICkge1xuXHRcdFx0ZWxlbWVudFsgbWV0aG9kIF0oIG9wdGlvbnMgKTtcblx0XHR9IGVsc2UgaWYgKCBlZmZlY3ROYW1lICE9PSBtZXRob2QgJiYgZWxlbWVudFsgZWZmZWN0TmFtZSBdICkge1xuXHRcdFx0ZWxlbWVudFsgZWZmZWN0TmFtZSBdKCBvcHRpb25zLmR1cmF0aW9uLCBvcHRpb25zLmVhc2luZywgY2FsbGJhY2sgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbWVudC5xdWV1ZShmdW5jdGlvbiggbmV4dCApIHtcblx0XHRcdFx0JCggdGhpcyApWyBtZXRob2QgXSgpO1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGVsZW1lbnRbIDAgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5leHQoKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcbn0pO1xuXG5yZXR1cm4gJC53aWRnZXQ7XG5cbn0pKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9qcXVlcnktdWkvdWkvd2lkZ2V0LmpzXG4vLyBtb2R1bGUgaWQgPSA3MTJcbi8vIG1vZHVsZSBjaHVua3MgPSA1IDkgMTMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 713:
/* unknown exports provided */
/* all exports used */
/*!**************************************************************************!*\
  !*** ./~/angular2-google-maps/core/directives/google-map-info-window.js ***!
  \**************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar core_1 = __webpack_require__(/*! @angular/core */ 0);\nvar info_window_manager_1 = __webpack_require__(/*! ../services/managers/info-window-manager */ 716);\nvar infoWindowId = 0;\n/**\n * SebmGoogleMapInfoWindow renders a info window inside a {@link SebmGoogleMapMarker} or standalone.\n *\n * ### Example\n * ```typescript\n * import { Component } from 'angular2/core';\n * import { SebmGoogleMap, SebmGoogleMapMarker, SebmGoogleMapInfoWindow } from\n * 'angular2-google-maps/core';\n *\n * @Component({\n *  selector: 'my-map-cmp',\n *  directives: [SebmGoogleMap, SebmGoogleMapMarker, SebmGoogleMapInfoWindow],\n *  styles: [`\n *    .sebm-google-map-container {\n *      height: 300px;\n *    }\n * `],\n *  template: `\n *    <sebm-google-map [latitude]=\"lat\" [longitude]=\"lng\" [zoom]=\"zoom\">\n *      <sebm-google-map-marker [latitude]=\"lat\" [longitude]=\"lng\" [label]=\"'M'\">\n *        <sebm-google-map-info-window [disableAutoPan]=\"true\">\n *          Hi, this is the content of the <strong>info window</strong>\n *        </sebm-google-map-info-window>\n *      </sebm-google-map-marker>\n *    </sebm-google-map>\n *  `\n * })\n * ```\n */\nvar SebmGoogleMapInfoWindow = (function () {\n    function SebmGoogleMapInfoWindow(_infoWindowManager, _el) {\n        this._infoWindowManager = _infoWindowManager;\n        this._el = _el;\n        /**\n         * Sets the open state for the InfoWindow. You can also call the open() and close() methods.\n         */\n        this.isOpen = false;\n        /**\n         * Emits an event when the info window is closed.\n         */\n        this.infoWindowClose = new core_1.EventEmitter();\n        this._infoWindowAddedToManager = false;\n        this._id = (infoWindowId++).toString();\n    }\n    SebmGoogleMapInfoWindow.prototype.ngOnInit = function () {\n        this.content = this._el.nativeElement.querySelector('.sebm-google-map-info-window-content');\n        this._infoWindowManager.addInfoWindow(this);\n        this._infoWindowAddedToManager = true;\n        this._updateOpenState();\n        this._registerEventListeners();\n    };\n    /** @internal */\n    SebmGoogleMapInfoWindow.prototype.ngOnChanges = function (changes) {\n        if (!this._infoWindowAddedToManager) {\n            return;\n        }\n        if ((changes['latitude'] || changes['longitude']) && typeof this.latitude === 'number' &&\n            typeof this.longitude === 'number') {\n            this._infoWindowManager.setPosition(this);\n        }\n        if (changes['zIndex']) {\n            this._infoWindowManager.setZIndex(this);\n        }\n        if (changes['isOpen']) {\n            this._updateOpenState();\n        }\n        this._setInfoWindowOptions(changes);\n    };\n    SebmGoogleMapInfoWindow.prototype._registerEventListeners = function () {\n        var _this = this;\n        this._infoWindowManager.createEventObservable('closeclick', this).subscribe(function () {\n            _this.isOpen = false;\n            _this.infoWindowClose.emit();\n        });\n    };\n    SebmGoogleMapInfoWindow.prototype._updateOpenState = function () {\n        this.isOpen ? this.open() : this.close();\n    };\n    SebmGoogleMapInfoWindow.prototype._setInfoWindowOptions = function (changes) {\n        var options = {};\n        var optionKeys = Object.keys(changes).filter(function (k) { return SebmGoogleMapInfoWindow._infoWindowOptionsInputs.indexOf(k) !== -1; });\n        optionKeys.forEach(function (k) { options[k] = changes[k].currentValue; });\n        this._infoWindowManager.setOptions(this, options);\n    };\n    /**\n     * Opens the info window.\n     */\n    SebmGoogleMapInfoWindow.prototype.open = function () { return this._infoWindowManager.open(this); };\n    /**\n     * Closes the info window.\n     */\n    SebmGoogleMapInfoWindow.prototype.close = function () {\n        var _this = this;\n        return this._infoWindowManager.close(this).then(function () { _this.infoWindowClose.emit(); });\n    };\n    /** @internal */\n    SebmGoogleMapInfoWindow.prototype.id = function () { return this._id; };\n    /** @internal */\n    SebmGoogleMapInfoWindow.prototype.toString = function () { return 'SebmGoogleMapInfoWindow-' + this._id.toString(); };\n    /** @internal */\n    SebmGoogleMapInfoWindow.prototype.ngOnDestroy = function () { this._infoWindowManager.deleteInfoWindow(this); };\n    SebmGoogleMapInfoWindow._infoWindowOptionsInputs = ['disableAutoPan', 'maxWidth'];\n    SebmGoogleMapInfoWindow.decorators = [\n        { type: core_1.Component, args: [{\n                    selector: 'sebm-google-map-info-window',\n                    inputs: ['latitude', 'longitude', 'disableAutoPan', 'isOpen', 'zIndex', 'maxWidth'],\n                    outputs: ['infoWindowClose'],\n                    template: \"<div class='sebm-google-map-info-window-content'>\\n      <ng-content></ng-content>\\n    </div>\\n  \"\n                },] },\n    ];\n    /** @nocollapse */\n    SebmGoogleMapInfoWindow.ctorParameters = function () { return [\n        { type: info_window_manager_1.InfoWindowManager, },\n        { type: core_1.ElementRef, },\n    ]; };\n    return SebmGoogleMapInfoWindow;\n}());\nexports.SebmGoogleMapInfoWindow = SebmGoogleMapInfoWindow;\n//# sourceMappingURL=google-map-info-window.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzEzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC1pbmZvLXdpbmRvdy5qcz8xNTQ2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBpbmZvX3dpbmRvd19tYW5hZ2VyXzEgPSByZXF1aXJlKCcuLi9zZXJ2aWNlcy9tYW5hZ2Vycy9pbmZvLXdpbmRvdy1tYW5hZ2VyJyk7XG52YXIgaW5mb1dpbmRvd0lkID0gMDtcbi8qKlxuICogU2VibUdvb2dsZU1hcEluZm9XaW5kb3cgcmVuZGVycyBhIGluZm8gd2luZG93IGluc2lkZSBhIHtAbGluayBTZWJtR29vZ2xlTWFwTWFya2VyfSBvciBzdGFuZGFsb25lLlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdhbmd1bGFyMi9jb3JlJztcbiAqIGltcG9ydCB7IFNlYm1Hb29nbGVNYXAsIFNlYm1Hb29nbGVNYXBNYXJrZXIsIFNlYm1Hb29nbGVNYXBJbmZvV2luZG93IH0gZnJvbVxuICogJ2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUnO1xuICpcbiAqIEBDb21wb25lbnQoe1xuICogIHNlbGVjdG9yOiAnbXktbWFwLWNtcCcsXG4gKiAgZGlyZWN0aXZlczogW1NlYm1Hb29nbGVNYXAsIFNlYm1Hb29nbGVNYXBNYXJrZXIsIFNlYm1Hb29nbGVNYXBJbmZvV2luZG93XSxcbiAqICBzdHlsZXM6IFtgXG4gKiAgICAuc2VibS1nb29nbGUtbWFwLWNvbnRhaW5lciB7XG4gKiAgICAgIGhlaWdodDogMzAwcHg7XG4gKiAgICB9XG4gKiBgXSxcbiAqICB0ZW1wbGF0ZTogYFxuICogICAgPHNlYm0tZ29vZ2xlLW1hcCBbbGF0aXR1ZGVdPVwibGF0XCIgW2xvbmdpdHVkZV09XCJsbmdcIiBbem9vbV09XCJ6b29tXCI+XG4gKiAgICAgIDxzZWJtLWdvb2dsZS1tYXAtbWFya2VyIFtsYXRpdHVkZV09XCJsYXRcIiBbbG9uZ2l0dWRlXT1cImxuZ1wiIFtsYWJlbF09XCInTSdcIj5cbiAqICAgICAgICA8c2VibS1nb29nbGUtbWFwLWluZm8td2luZG93IFtkaXNhYmxlQXV0b1Bhbl09XCJ0cnVlXCI+XG4gKiAgICAgICAgICBIaSwgdGhpcyBpcyB0aGUgY29udGVudCBvZiB0aGUgPHN0cm9uZz5pbmZvIHdpbmRvdzwvc3Ryb25nPlxuICogICAgICAgIDwvc2VibS1nb29nbGUtbWFwLWluZm8td2luZG93PlxuICogICAgICA8L3NlYm0tZ29vZ2xlLW1hcC1tYXJrZXI+XG4gKiAgICA8L3NlYm0tZ29vZ2xlLW1hcD5cbiAqICBgXG4gKiB9KVxuICogYGBgXG4gKi9cbnZhciBTZWJtR29vZ2xlTWFwSW5mb1dpbmRvdyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VibUdvb2dsZU1hcEluZm9XaW5kb3coX2luZm9XaW5kb3dNYW5hZ2VyLCBfZWwpIHtcbiAgICAgICAgdGhpcy5faW5mb1dpbmRvd01hbmFnZXIgPSBfaW5mb1dpbmRvd01hbmFnZXI7XG4gICAgICAgIHRoaXMuX2VsID0gX2VsO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgb3BlbiBzdGF0ZSBmb3IgdGhlIEluZm9XaW5kb3cuIFlvdSBjYW4gYWxzbyBjYWxsIHRoZSBvcGVuKCkgYW5kIGNsb3NlKCkgbWV0aG9kcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbWl0cyBhbiBldmVudCB3aGVuIHRoZSBpbmZvIHdpbmRvdyBpcyBjbG9zZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluZm9XaW5kb3dDbG9zZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuX2luZm9XaW5kb3dBZGRlZFRvTWFuYWdlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pZCA9IChpbmZvV2luZG93SWQrKykudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgU2VibUdvb2dsZU1hcEluZm9XaW5kb3cucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSB0aGlzLl9lbC5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zZWJtLWdvb2dsZS1tYXAtaW5mby13aW5kb3ctY29udGVudCcpO1xuICAgICAgICB0aGlzLl9pbmZvV2luZG93TWFuYWdlci5hZGRJbmZvV2luZG93KHRoaXMpO1xuICAgICAgICB0aGlzLl9pbmZvV2luZG93QWRkZWRUb01hbmFnZXIgPSB0cnVlO1xuICAgICAgICB0aGlzLl91cGRhdGVPcGVuU3RhdGUoKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJFdmVudExpc3RlbmVycygpO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFNlYm1Hb29nbGVNYXBJbmZvV2luZG93LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIGlmICghdGhpcy5faW5mb1dpbmRvd0FkZGVkVG9NYW5hZ2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChjaGFuZ2VzWydsYXRpdHVkZSddIHx8IGNoYW5nZXNbJ2xvbmdpdHVkZSddKSAmJiB0eXBlb2YgdGhpcy5sYXRpdHVkZSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgIHR5cGVvZiB0aGlzLmxvbmdpdHVkZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMuX2luZm9XaW5kb3dNYW5hZ2VyLnNldFBvc2l0aW9uKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzWyd6SW5kZXgnXSkge1xuICAgICAgICAgICAgdGhpcy5faW5mb1dpbmRvd01hbmFnZXIuc2V0WkluZGV4KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzWydpc09wZW4nXSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlT3BlblN0YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0SW5mb1dpbmRvd09wdGlvbnMoY2hhbmdlcyk7XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwSW5mb1dpbmRvdy5wcm90b3R5cGUuX3JlZ2lzdGVyRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2luZm9XaW5kb3dNYW5hZ2VyLmNyZWF0ZUV2ZW50T2JzZXJ2YWJsZSgnY2xvc2VjbGljaycsIHRoaXMpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIF90aGlzLmluZm9XaW5kb3dDbG9zZS5lbWl0KCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcEluZm9XaW5kb3cucHJvdG90eXBlLl91cGRhdGVPcGVuU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNPcGVuID8gdGhpcy5vcGVuKCkgOiB0aGlzLmNsb3NlKCk7XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwSW5mb1dpbmRvdy5wcm90b3R5cGUuX3NldEluZm9XaW5kb3dPcHRpb25zID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgdmFyIG9wdGlvbktleXMgPSBPYmplY3Qua2V5cyhjaGFuZ2VzKS5maWx0ZXIoZnVuY3Rpb24gKGspIHsgcmV0dXJuIFNlYm1Hb29nbGVNYXBJbmZvV2luZG93Ll9pbmZvV2luZG93T3B0aW9uc0lucHV0cy5pbmRleE9mKGspICE9PSAtMTsgfSk7XG4gICAgICAgIG9wdGlvbktleXMuZm9yRWFjaChmdW5jdGlvbiAoaykgeyBvcHRpb25zW2tdID0gY2hhbmdlc1trXS5jdXJyZW50VmFsdWU7IH0pO1xuICAgICAgICB0aGlzLl9pbmZvV2luZG93TWFuYWdlci5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogT3BlbnMgdGhlIGluZm8gd2luZG93LlxuICAgICAqL1xuICAgIFNlYm1Hb29nbGVNYXBJbmZvV2luZG93LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faW5mb1dpbmRvd01hbmFnZXIub3Blbih0aGlzKTsgfTtcbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIGluZm8gd2luZG93LlxuICAgICAqL1xuICAgIFNlYm1Hb29nbGVNYXBJbmZvV2luZG93LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZm9XaW5kb3dNYW5hZ2VyLmNsb3NlKHRoaXMpLnRoZW4oZnVuY3Rpb24gKCkgeyBfdGhpcy5pbmZvV2luZG93Q2xvc2UuZW1pdCgpOyB9KTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwSW5mb1dpbmRvdy5wcm90b3R5cGUuaWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9pZDsgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgU2VibUdvb2dsZU1hcEluZm9XaW5kb3cucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ1NlYm1Hb29nbGVNYXBJbmZvV2luZG93LScgKyB0aGlzLl9pZC50b1N0cmluZygpOyB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwSW5mb1dpbmRvdy5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2luZm9XaW5kb3dNYW5hZ2VyLmRlbGV0ZUluZm9XaW5kb3codGhpcyk7IH07XG4gICAgU2VibUdvb2dsZU1hcEluZm9XaW5kb3cuX2luZm9XaW5kb3dPcHRpb25zSW5wdXRzID0gWydkaXNhYmxlQXV0b1BhbicsICdtYXhXaWR0aCddO1xuICAgIFNlYm1Hb29nbGVNYXBJbmZvV2luZG93LmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkNvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdzZWJtLWdvb2dsZS1tYXAtaW5mby13aW5kb3cnLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dHM6IFsnbGF0aXR1ZGUnLCAnbG9uZ2l0dWRlJywgJ2Rpc2FibGVBdXRvUGFuJywgJ2lzT3BlbicsICd6SW5kZXgnLCAnbWF4V2lkdGgnXSxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0czogWydpbmZvV2luZG93Q2xvc2UnXSxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGRpdiBjbGFzcz0nc2VibS1nb29nbGUtbWFwLWluZm8td2luZG93LWNvbnRlbnQnPlxcbiAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cXG4gICAgPC9kaXY+XFxuICBcIlxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgU2VibUdvb2dsZU1hcEluZm9XaW5kb3cuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogaW5mb193aW5kb3dfbWFuYWdlcl8xLkluZm9XaW5kb3dNYW5hZ2VyLCB9LFxuICAgICAgICB7IHR5cGU6IGNvcmVfMS5FbGVtZW50UmVmLCB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIFNlYm1Hb29nbGVNYXBJbmZvV2luZG93O1xufSgpKTtcbmV4cG9ydHMuU2VibUdvb2dsZU1hcEluZm9XaW5kb3cgPSBTZWJtR29vZ2xlTWFwSW5mb1dpbmRvdztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdvb2dsZS1tYXAtaW5mby13aW5kb3cuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvZGlyZWN0aXZlcy9nb29nbGUtbWFwLWluZm8td2luZG93LmpzXG4vLyBtb2R1bGUgaWQgPSA3MTNcbi8vIG1vZHVsZSBjaHVua3MgPSA1IDgiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 714:
/* unknown exports provided */
/* all exports used */
/*!*****************************************************************************!*\
  !*** ./~/angular2-google-maps/core/directives/google-map-polyline-point.js ***!
  \*****************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar core_1 = __webpack_require__(/*! @angular/core */ 0);\n/**\n * SebmGoogleMapPolylinePoint represents one element of a polyline within a  {@link\n * SembGoogleMapPolyline}\n */\nvar SebmGoogleMapPolylinePoint = (function () {\n    function SebmGoogleMapPolylinePoint() {\n        /**\n         * This event emitter gets emitted when the position of the point changed.\n         */\n        this.positionChanged = new core_1.EventEmitter();\n    }\n    SebmGoogleMapPolylinePoint.prototype.ngOnChanges = function (changes) {\n        if (changes['latitude'] || changes['longitude']) {\n            var position = {\n                lat: changes['latitude'].currentValue,\n                lng: changes['longitude'].currentValue\n            };\n            this.positionChanged.emit(position);\n        }\n    };\n    SebmGoogleMapPolylinePoint.decorators = [\n        { type: core_1.Directive, args: [{ selector: 'sebm-google-map-polyline-point' },] },\n    ];\n    /** @nocollapse */\n    SebmGoogleMapPolylinePoint.ctorParameters = function () { return []; };\n    SebmGoogleMapPolylinePoint.propDecorators = {\n        'latitude': [{ type: core_1.Input },],\n        'longitude': [{ type: core_1.Input },],\n        'positionChanged': [{ type: core_1.Output },],\n    };\n    return SebmGoogleMapPolylinePoint;\n}());\nexports.SebmGoogleMapPolylinePoint = SebmGoogleMapPolylinePoint;\n//# sourceMappingURL=google-map-polyline-point.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzE0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC1wb2x5bGluZS1wb2ludC5qcz9mM2Q3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbi8qKlxuICogU2VibUdvb2dsZU1hcFBvbHlsaW5lUG9pbnQgcmVwcmVzZW50cyBvbmUgZWxlbWVudCBvZiBhIHBvbHlsaW5lIHdpdGhpbiBhICB7QGxpbmtcbiAqIFNlbWJHb29nbGVNYXBQb2x5bGluZX1cbiAqL1xudmFyIFNlYm1Hb29nbGVNYXBQb2x5bGluZVBvaW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZWJtR29vZ2xlTWFwUG9seWxpbmVQb2ludCgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgZW1pdHRlciBnZXRzIGVtaXR0ZWQgd2hlbiB0aGUgcG9zaXRpb24gb2YgdGhlIHBvaW50IGNoYW5nZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvc2l0aW9uQ2hhbmdlZCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIFNlYm1Hb29nbGVNYXBQb2x5bGluZVBvaW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzWydsYXRpdHVkZSddIHx8IGNoYW5nZXNbJ2xvbmdpdHVkZSddKSB7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgbGF0OiBjaGFuZ2VzWydsYXRpdHVkZSddLmN1cnJlbnRWYWx1ZSxcbiAgICAgICAgICAgICAgICBsbmc6IGNoYW5nZXNbJ2xvbmdpdHVkZSddLmN1cnJlbnRWYWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25DaGFuZ2VkLmVtaXQocG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwUG9seWxpbmVQb2ludC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5EaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnc2VibS1nb29nbGUtbWFwLXBvbHlsaW5lLXBvaW50JyB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIFNlYm1Hb29nbGVNYXBQb2x5bGluZVBvaW50LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgU2VibUdvb2dsZU1hcFBvbHlsaW5lUG9pbnQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICdsYXRpdHVkZSc6IFt7IHR5cGU6IGNvcmVfMS5JbnB1dCB9LF0sXG4gICAgICAgICdsb25naXR1ZGUnOiBbeyB0eXBlOiBjb3JlXzEuSW5wdXQgfSxdLFxuICAgICAgICAncG9zaXRpb25DaGFuZ2VkJzogW3sgdHlwZTogY29yZV8xLk91dHB1dCB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gU2VibUdvb2dsZU1hcFBvbHlsaW5lUG9pbnQ7XG59KCkpO1xuZXhwb3J0cy5TZWJtR29vZ2xlTWFwUG9seWxpbmVQb2ludCA9IFNlYm1Hb29nbGVNYXBQb2x5bGluZVBvaW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z29vZ2xlLW1hcC1wb2x5bGluZS1wb2ludC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9kaXJlY3RpdmVzL2dvb2dsZS1tYXAtcG9seWxpbmUtcG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDcxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDUgOCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 715:
/* unknown exports provided */
/* all exports used */
/*!*************************************************************************!*\
  !*** ./~/angular2-google-maps/core/services/managers/circle-manager.js ***!
  \*************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar core_1 = __webpack_require__(/*! @angular/core */ 0);\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ 12);\nvar google_maps_api_wrapper_1 = __webpack_require__(/*! ../google-maps-api-wrapper */ 703);\nvar CircleManager = (function () {\n    function CircleManager(_apiWrapper, _zone) {\n        this._apiWrapper = _apiWrapper;\n        this._zone = _zone;\n        this._circles = new Map();\n    }\n    CircleManager.prototype.addCircle = function (circle) {\n        this._circles.set(circle, this._apiWrapper.createCircle({\n            center: { lat: circle.latitude, lng: circle.longitude },\n            clickable: circle.clickable,\n            draggable: circle.draggable,\n            editable: circle.editable,\n            fillColor: circle.fillColor,\n            fillOpacity: circle.fillOpacity,\n            radius: circle.radius,\n            strokeColor: circle.strokeColor,\n            strokeOpacity: circle.strokeOpacity,\n            strokePosition: circle.strokePosition,\n            strokeWeight: circle.strokeWeight,\n            visible: circle.visible,\n            zIndex: circle.zIndex\n        }));\n    };\n    ;\n    /**\n     * Removes the given circle from the map.\n     */\n    CircleManager.prototype.removeCircle = function (circle) {\n        var _this = this;\n        return this._circles.get(circle).then(function (c) {\n            c.setMap(null);\n            _this._circles.delete(circle);\n        });\n    };\n    CircleManager.prototype.setOptions = function (circle, options) {\n        return this._circles.get(circle).then(function (c) { return c.setOptions(options); });\n    };\n    ;\n    CircleManager.prototype.getBounds = function (circle) {\n        return this._circles.get(circle).then(function (c) { return c.getBounds(); });\n    };\n    ;\n    CircleManager.prototype.getCenter = function (circle) {\n        return this._circles.get(circle).then(function (c) { return c.getCenter(); });\n    };\n    ;\n    CircleManager.prototype.getRadius = function (circle) {\n        return this._circles.get(circle).then(function (c) { return c.getRadius(); });\n    };\n    CircleManager.prototype.setCenter = function (circle) {\n        return this._circles.get(circle).then(function (c) { return c.setCenter({ lat: circle.latitude, lng: circle.longitude }); });\n    };\n    ;\n    CircleManager.prototype.setEditable = function (circle) {\n        return this._circles.get(circle).then(function (c) { return c.setEditable(circle.editable); });\n    };\n    ;\n    CircleManager.prototype.setDraggable = function (circle) {\n        return this._circles.get(circle).then(function (c) { return c.setDraggable(circle.draggable); });\n    };\n    ;\n    CircleManager.prototype.setVisible = function (circle) {\n        return this._circles.get(circle).then(function (c) { return c.setVisible(circle.visible); });\n    };\n    ;\n    CircleManager.prototype.setRadius = function (circle) {\n        return this._circles.get(circle).then(function (c) { return c.setRadius(circle.radius); });\n    };\n    ;\n    CircleManager.prototype.createEventObservable = function (eventName, circle) {\n        var _this = this;\n        return Observable_1.Observable.create(function (observer) {\n            var listener = null;\n            _this._circles.get(circle).then(function (c) {\n                listener = c.addListener(eventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); });\n            });\n            return function () {\n                if (listener !== null) {\n                    listener.remove();\n                }\n            };\n        });\n    };\n    CircleManager.decorators = [\n        { type: core_1.Injectable },\n    ];\n    /** @nocollapse */\n    CircleManager.ctorParameters = function () { return [\n        { type: google_maps_api_wrapper_1.GoogleMapsAPIWrapper, },\n        { type: core_1.NgZone, },\n    ]; };\n    return CircleManager;\n}());\nexports.CircleManager = CircleManager;\n//# sourceMappingURL=circle-manager.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzE1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL3NlcnZpY2VzL21hbmFnZXJzL2NpcmNsZS1tYW5hZ2VyLmpzPzIwYzkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJ3J4anMvT2JzZXJ2YWJsZScpO1xudmFyIGdvb2dsZV9tYXBzX2FwaV93cmFwcGVyXzEgPSByZXF1aXJlKCcuLi9nb29nbGUtbWFwcy1hcGktd3JhcHBlcicpO1xudmFyIENpcmNsZU1hbmFnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENpcmNsZU1hbmFnZXIoX2FwaVdyYXBwZXIsIF96b25lKSB7XG4gICAgICAgIHRoaXMuX2FwaVdyYXBwZXIgPSBfYXBpV3JhcHBlcjtcbiAgICAgICAgdGhpcy5fem9uZSA9IF96b25lO1xuICAgICAgICB0aGlzLl9jaXJjbGVzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBDaXJjbGVNYW5hZ2VyLnByb3RvdHlwZS5hZGRDaXJjbGUgPSBmdW5jdGlvbiAoY2lyY2xlKSB7XG4gICAgICAgIHRoaXMuX2NpcmNsZXMuc2V0KGNpcmNsZSwgdGhpcy5fYXBpV3JhcHBlci5jcmVhdGVDaXJjbGUoe1xuICAgICAgICAgICAgY2VudGVyOiB7IGxhdDogY2lyY2xlLmxhdGl0dWRlLCBsbmc6IGNpcmNsZS5sb25naXR1ZGUgfSxcbiAgICAgICAgICAgIGNsaWNrYWJsZTogY2lyY2xlLmNsaWNrYWJsZSxcbiAgICAgICAgICAgIGRyYWdnYWJsZTogY2lyY2xlLmRyYWdnYWJsZSxcbiAgICAgICAgICAgIGVkaXRhYmxlOiBjaXJjbGUuZWRpdGFibGUsXG4gICAgICAgICAgICBmaWxsQ29sb3I6IGNpcmNsZS5maWxsQ29sb3IsXG4gICAgICAgICAgICBmaWxsT3BhY2l0eTogY2lyY2xlLmZpbGxPcGFjaXR5LFxuICAgICAgICAgICAgcmFkaXVzOiBjaXJjbGUucmFkaXVzLFxuICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IGNpcmNsZS5zdHJva2VDb2xvcixcbiAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IGNpcmNsZS5zdHJva2VPcGFjaXR5LFxuICAgICAgICAgICAgc3Ryb2tlUG9zaXRpb246IGNpcmNsZS5zdHJva2VQb3NpdGlvbixcbiAgICAgICAgICAgIHN0cm9rZVdlaWdodDogY2lyY2xlLnN0cm9rZVdlaWdodCxcbiAgICAgICAgICAgIHZpc2libGU6IGNpcmNsZS52aXNpYmxlLFxuICAgICAgICAgICAgekluZGV4OiBjaXJjbGUuekluZGV4XG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBjaXJjbGUgZnJvbSB0aGUgbWFwLlxuICAgICAqL1xuICAgIENpcmNsZU1hbmFnZXIucHJvdG90eXBlLnJlbW92ZUNpcmNsZSA9IGZ1bmN0aW9uIChjaXJjbGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NpcmNsZXMuZ2V0KGNpcmNsZSkudGhlbihmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgYy5zZXRNYXAobnVsbCk7XG4gICAgICAgICAgICBfdGhpcy5fY2lyY2xlcy5kZWxldGUoY2lyY2xlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDaXJjbGVNYW5hZ2VyLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKGNpcmNsZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2lyY2xlcy5nZXQoY2lyY2xlKS50aGVuKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnNldE9wdGlvbnMob3B0aW9ucyk7IH0pO1xuICAgIH07XG4gICAgO1xuICAgIENpcmNsZU1hbmFnZXIucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uIChjaXJjbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NpcmNsZXMuZ2V0KGNpcmNsZSkudGhlbihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5nZXRCb3VuZHMoKTsgfSk7XG4gICAgfTtcbiAgICA7XG4gICAgQ2lyY2xlTWFuYWdlci5wcm90b3R5cGUuZ2V0Q2VudGVyID0gZnVuY3Rpb24gKGNpcmNsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2lyY2xlcy5nZXQoY2lyY2xlKS50aGVuKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLmdldENlbnRlcigpOyB9KTtcbiAgICB9O1xuICAgIDtcbiAgICBDaXJjbGVNYW5hZ2VyLnByb3RvdHlwZS5nZXRSYWRpdXMgPSBmdW5jdGlvbiAoY2lyY2xlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaXJjbGVzLmdldChjaXJjbGUpLnRoZW4oZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMuZ2V0UmFkaXVzKCk7IH0pO1xuICAgIH07XG4gICAgQ2lyY2xlTWFuYWdlci5wcm90b3R5cGUuc2V0Q2VudGVyID0gZnVuY3Rpb24gKGNpcmNsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2lyY2xlcy5nZXQoY2lyY2xlKS50aGVuKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnNldENlbnRlcih7IGxhdDogY2lyY2xlLmxhdGl0dWRlLCBsbmc6IGNpcmNsZS5sb25naXR1ZGUgfSk7IH0pO1xuICAgIH07XG4gICAgO1xuICAgIENpcmNsZU1hbmFnZXIucHJvdG90eXBlLnNldEVkaXRhYmxlID0gZnVuY3Rpb24gKGNpcmNsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2lyY2xlcy5nZXQoY2lyY2xlKS50aGVuKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnNldEVkaXRhYmxlKGNpcmNsZS5lZGl0YWJsZSk7IH0pO1xuICAgIH07XG4gICAgO1xuICAgIENpcmNsZU1hbmFnZXIucHJvdG90eXBlLnNldERyYWdnYWJsZSA9IGZ1bmN0aW9uIChjaXJjbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NpcmNsZXMuZ2V0KGNpcmNsZSkudGhlbihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5zZXREcmFnZ2FibGUoY2lyY2xlLmRyYWdnYWJsZSk7IH0pO1xuICAgIH07XG4gICAgO1xuICAgIENpcmNsZU1hbmFnZXIucHJvdG90eXBlLnNldFZpc2libGUgPSBmdW5jdGlvbiAoY2lyY2xlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaXJjbGVzLmdldChjaXJjbGUpLnRoZW4oZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMuc2V0VmlzaWJsZShjaXJjbGUudmlzaWJsZSk7IH0pO1xuICAgIH07XG4gICAgO1xuICAgIENpcmNsZU1hbmFnZXIucHJvdG90eXBlLnNldFJhZGl1cyA9IGZ1bmN0aW9uIChjaXJjbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NpcmNsZXMuZ2V0KGNpcmNsZSkudGhlbihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5zZXRSYWRpdXMoY2lyY2xlLnJhZGl1cyk7IH0pO1xuICAgIH07XG4gICAgO1xuICAgIENpcmNsZU1hbmFnZXIucHJvdG90eXBlLmNyZWF0ZUV2ZW50T2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGNpcmNsZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUuY3JlYXRlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLl9jaXJjbGVzLmdldChjaXJjbGUpLnRoZW4oZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IGMuYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gX3RoaXMuX3pvbmUucnVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9ic2VydmVyLm5leHQoZSk7IH0pOyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDaXJjbGVNYW5hZ2VyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIENpcmNsZU1hbmFnZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogZ29vZ2xlX21hcHNfYXBpX3dyYXBwZXJfMS5Hb29nbGVNYXBzQVBJV3JhcHBlciwgfSxcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuTmdab25lLCB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIENpcmNsZU1hbmFnZXI7XG59KCkpO1xuZXhwb3J0cy5DaXJjbGVNYW5hZ2VyID0gQ2lyY2xlTWFuYWdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNpcmNsZS1tYW5hZ2VyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL3NlcnZpY2VzL21hbmFnZXJzL2NpcmNsZS1tYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA3MTVcbi8vIG1vZHVsZSBjaHVua3MgPSA1IDgiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 716:
/* unknown exports provided */
/* all exports used */
/*!******************************************************************************!*\
  !*** ./~/angular2-google-maps/core/services/managers/info-window-manager.js ***!
  \******************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ 12);\nvar core_1 = __webpack_require__(/*! @angular/core */ 0);\nvar google_maps_api_wrapper_1 = __webpack_require__(/*! ../google-maps-api-wrapper */ 703);\nvar marker_manager_1 = __webpack_require__(/*! ./marker-manager */ 710);\nvar InfoWindowManager = (function () {\n    function InfoWindowManager(_mapsWrapper, _zone, _markerManager) {\n        this._mapsWrapper = _mapsWrapper;\n        this._zone = _zone;\n        this._markerManager = _markerManager;\n        this._infoWindows = new Map();\n    }\n    InfoWindowManager.prototype.deleteInfoWindow = function (infoWindow) {\n        var _this = this;\n        var iWindow = this._infoWindows.get(infoWindow);\n        if (iWindow == null) {\n            // info window already deleted\n            return Promise.resolve();\n        }\n        return iWindow.then(function (i) {\n            return _this._zone.run(function () {\n                i.close();\n                _this._infoWindows.delete(infoWindow);\n            });\n        });\n    };\n    InfoWindowManager.prototype.setPosition = function (infoWindow) {\n        return this._infoWindows.get(infoWindow).then(function (i) { return i.setPosition({\n            lat: infoWindow.latitude,\n            lng: infoWindow.longitude\n        }); });\n    };\n    InfoWindowManager.prototype.setZIndex = function (infoWindow) {\n        return this._infoWindows.get(infoWindow)\n            .then(function (i) { return i.setZIndex(infoWindow.zIndex); });\n    };\n    InfoWindowManager.prototype.open = function (infoWindow) {\n        var _this = this;\n        return this._infoWindows.get(infoWindow).then(function (w) {\n            if (infoWindow.hostMarker != null) {\n                return _this._markerManager.getNativeMarker(infoWindow.hostMarker).then(function (marker) {\n                    return _this._mapsWrapper.getNativeMap().then(function (map) { return w.open(map, marker); });\n                });\n            }\n            return _this._mapsWrapper.getNativeMap().then(function (map) { return w.open(map); });\n        });\n    };\n    InfoWindowManager.prototype.close = function (infoWindow) {\n        return this._infoWindows.get(infoWindow).then(function (w) { return w.close(); });\n    };\n    InfoWindowManager.prototype.setOptions = function (infoWindow, options) {\n        return this._infoWindows.get(infoWindow).then(function (i) { return i.setOptions(options); });\n    };\n    InfoWindowManager.prototype.addInfoWindow = function (infoWindow) {\n        var options = {\n            content: infoWindow.content,\n            maxWidth: infoWindow.maxWidth,\n            zIndex: infoWindow.zIndex,\n        };\n        if (typeof infoWindow.latitude === 'number' && typeof infoWindow.longitude === 'number') {\n            options.position = { lat: infoWindow.latitude, lng: infoWindow.longitude };\n        }\n        var infoWindowPromise = this._mapsWrapper.createInfoWindow(options);\n        this._infoWindows.set(infoWindow, infoWindowPromise);\n    };\n    /**\n     * Creates a Google Maps event listener for the given InfoWindow as an Observable\n     */\n    InfoWindowManager.prototype.createEventObservable = function (eventName, infoWindow) {\n        var _this = this;\n        return Observable_1.Observable.create(function (observer) {\n            _this._infoWindows.get(infoWindow).then(function (i) {\n                i.addListener(eventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); });\n            });\n        });\n    };\n    InfoWindowManager.decorators = [\n        { type: core_1.Injectable },\n    ];\n    /** @nocollapse */\n    InfoWindowManager.ctorParameters = function () { return [\n        { type: google_maps_api_wrapper_1.GoogleMapsAPIWrapper, },\n        { type: core_1.NgZone, },\n        { type: marker_manager_1.MarkerManager, },\n    ]; };\n    return InfoWindowManager;\n}());\nexports.InfoWindowManager = InfoWindowManager;\n//# sourceMappingURL=info-window-manager.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzE2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL3NlcnZpY2VzL21hbmFnZXJzL2luZm8td2luZG93LW1hbmFnZXIuanM/YmNhMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCdyeGpzL09ic2VydmFibGUnKTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgZ29vZ2xlX21hcHNfYXBpX3dyYXBwZXJfMSA9IHJlcXVpcmUoJy4uL2dvb2dsZS1tYXBzLWFwaS13cmFwcGVyJyk7XG52YXIgbWFya2VyX21hbmFnZXJfMSA9IHJlcXVpcmUoJy4vbWFya2VyLW1hbmFnZXInKTtcbnZhciBJbmZvV2luZG93TWFuYWdlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW5mb1dpbmRvd01hbmFnZXIoX21hcHNXcmFwcGVyLCBfem9uZSwgX21hcmtlck1hbmFnZXIpIHtcbiAgICAgICAgdGhpcy5fbWFwc1dyYXBwZXIgPSBfbWFwc1dyYXBwZXI7XG4gICAgICAgIHRoaXMuX3pvbmUgPSBfem9uZTtcbiAgICAgICAgdGhpcy5fbWFya2VyTWFuYWdlciA9IF9tYXJrZXJNYW5hZ2VyO1xuICAgICAgICB0aGlzLl9pbmZvV2luZG93cyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgSW5mb1dpbmRvd01hbmFnZXIucHJvdG90eXBlLmRlbGV0ZUluZm9XaW5kb3cgPSBmdW5jdGlvbiAoaW5mb1dpbmRvdykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgaVdpbmRvdyA9IHRoaXMuX2luZm9XaW5kb3dzLmdldChpbmZvV2luZG93KTtcbiAgICAgICAgaWYgKGlXaW5kb3cgPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gaW5mbyB3aW5kb3cgYWxyZWFkeSBkZWxldGVkXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlXaW5kb3cudGhlbihmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl96b25lLnJ1bihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9pbmZvV2luZG93cy5kZWxldGUoaW5mb1dpbmRvdyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBJbmZvV2luZG93TWFuYWdlci5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoaW5mb1dpbmRvdykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5mb1dpbmRvd3MuZ2V0KGluZm9XaW5kb3cpLnRoZW4oZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGkuc2V0UG9zaXRpb24oe1xuICAgICAgICAgICAgbGF0OiBpbmZvV2luZG93LmxhdGl0dWRlLFxuICAgICAgICAgICAgbG5nOiBpbmZvV2luZG93LmxvbmdpdHVkZVxuICAgICAgICB9KTsgfSk7XG4gICAgfTtcbiAgICBJbmZvV2luZG93TWFuYWdlci5wcm90b3R5cGUuc2V0WkluZGV4ID0gZnVuY3Rpb24gKGluZm9XaW5kb3cpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZm9XaW5kb3dzLmdldChpbmZvV2luZG93KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGkuc2V0WkluZGV4KGluZm9XaW5kb3cuekluZGV4KTsgfSk7XG4gICAgfTtcbiAgICBJbmZvV2luZG93TWFuYWdlci5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIChpbmZvV2luZG93KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmZvV2luZG93cy5nZXQoaW5mb1dpbmRvdykudGhlbihmdW5jdGlvbiAodykge1xuICAgICAgICAgICAgaWYgKGluZm9XaW5kb3cuaG9zdE1hcmtlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9tYXJrZXJNYW5hZ2VyLmdldE5hdGl2ZU1hcmtlcihpbmZvV2luZG93Lmhvc3RNYXJrZXIpLnRoZW4oZnVuY3Rpb24gKG1hcmtlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX21hcHNXcmFwcGVyLmdldE5hdGl2ZU1hcCgpLnRoZW4oZnVuY3Rpb24gKG1hcCkgeyByZXR1cm4gdy5vcGVuKG1hcCwgbWFya2VyKTsgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX21hcHNXcmFwcGVyLmdldE5hdGl2ZU1hcCgpLnRoZW4oZnVuY3Rpb24gKG1hcCkgeyByZXR1cm4gdy5vcGVuKG1hcCk7IH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEluZm9XaW5kb3dNYW5hZ2VyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChpbmZvV2luZG93KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmZvV2luZG93cy5nZXQoaW5mb1dpbmRvdykudGhlbihmdW5jdGlvbiAodykgeyByZXR1cm4gdy5jbG9zZSgpOyB9KTtcbiAgICB9O1xuICAgIEluZm9XaW5kb3dNYW5hZ2VyLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKGluZm9XaW5kb3csIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZm9XaW5kb3dzLmdldChpbmZvV2luZG93KS50aGVuKGZ1bmN0aW9uIChpKSB7IHJldHVybiBpLnNldE9wdGlvbnMob3B0aW9ucyk7IH0pO1xuICAgIH07XG4gICAgSW5mb1dpbmRvd01hbmFnZXIucHJvdG90eXBlLmFkZEluZm9XaW5kb3cgPSBmdW5jdGlvbiAoaW5mb1dpbmRvdykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IGluZm9XaW5kb3cuY29udGVudCxcbiAgICAgICAgICAgIG1heFdpZHRoOiBpbmZvV2luZG93Lm1heFdpZHRoLFxuICAgICAgICAgICAgekluZGV4OiBpbmZvV2luZG93LnpJbmRleCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbmZvV2luZG93LmxhdGl0dWRlID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgaW5mb1dpbmRvdy5sb25naXR1ZGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBvcHRpb25zLnBvc2l0aW9uID0geyBsYXQ6IGluZm9XaW5kb3cubGF0aXR1ZGUsIGxuZzogaW5mb1dpbmRvdy5sb25naXR1ZGUgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5mb1dpbmRvd1Byb21pc2UgPSB0aGlzLl9tYXBzV3JhcHBlci5jcmVhdGVJbmZvV2luZG93KG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9pbmZvV2luZG93cy5zZXQoaW5mb1dpbmRvdywgaW5mb1dpbmRvd1Byb21pc2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIEdvb2dsZSBNYXBzIGV2ZW50IGxpc3RlbmVyIGZvciB0aGUgZ2l2ZW4gSW5mb1dpbmRvdyBhcyBhbiBPYnNlcnZhYmxlXG4gICAgICovXG4gICAgSW5mb1dpbmRvd01hbmFnZXIucHJvdG90eXBlLmNyZWF0ZUV2ZW50T2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGluZm9XaW5kb3cpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGVfMS5PYnNlcnZhYmxlLmNyZWF0ZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIF90aGlzLl9pbmZvV2luZG93cy5nZXQoaW5mb1dpbmRvdykudGhlbihmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIGkuYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gX3RoaXMuX3pvbmUucnVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9ic2VydmVyLm5leHQoZSk7IH0pOyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEluZm9XaW5kb3dNYW5hZ2VyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIEluZm9XaW5kb3dNYW5hZ2VyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IGdvb2dsZV9tYXBzX2FwaV93cmFwcGVyXzEuR29vZ2xlTWFwc0FQSVdyYXBwZXIsIH0sXG4gICAgICAgIHsgdHlwZTogY29yZV8xLk5nWm9uZSwgfSxcbiAgICAgICAgeyB0eXBlOiBtYXJrZXJfbWFuYWdlcl8xLk1hcmtlck1hbmFnZXIsIH0sXG4gICAgXTsgfTtcbiAgICByZXR1cm4gSW5mb1dpbmRvd01hbmFnZXI7XG59KCkpO1xuZXhwb3J0cy5JbmZvV2luZG93TWFuYWdlciA9IEluZm9XaW5kb3dNYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5mby13aW5kb3ctbWFuYWdlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9zZXJ2aWNlcy9tYW5hZ2Vycy9pbmZvLXdpbmRvdy1tYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA3MTZcbi8vIG1vZHVsZSBjaHVua3MgPSA1IDgiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 717:
/* unknown exports provided */
/* all exports used */
/*!****************************************************************************!*\
  !*** ./~/angular2-google-maps/core/services/managers/kml-layer-manager.js ***!
  \****************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar core_1 = __webpack_require__(/*! @angular/core */ 0);\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ 12);\nvar google_maps_api_wrapper_1 = __webpack_require__(/*! ./../google-maps-api-wrapper */ 703);\n/**\n * Manages all KML Layers for a Google Map instance.\n */\nvar KmlLayerManager = (function () {\n    function KmlLayerManager(_wrapper, _zone) {\n        this._wrapper = _wrapper;\n        this._zone = _zone;\n        this._layers = new Map();\n    }\n    /**\n     * Adds a new KML Layer to the map.\n     */\n    KmlLayerManager.prototype.addKmlLayer = function (layer) {\n        var newLayer = this._wrapper.getNativeMap().then(function (m) {\n            return new google.maps.KmlLayer({\n                clickable: layer.clickable,\n                map: m,\n                preserveViewport: layer.preserveViewport,\n                screenOverlays: layer.screenOverlays,\n                suppressInfoWindows: layer.suppressInfoWindows,\n                url: layer.url,\n                zIndex: layer.zIndex\n            });\n        });\n        this._layers.set(layer, newLayer);\n    };\n    KmlLayerManager.prototype.setOptions = function (layer, options) {\n        this._layers.get(layer).then(function (l) { return l.setOptions(options); });\n    };\n    KmlLayerManager.prototype.deleteKmlLayer = function (layer) {\n        var _this = this;\n        this._layers.get(layer).then(function (l) {\n            l.setMap(null);\n            _this._layers.delete(layer);\n        });\n    };\n    /**\n     * Creates a Google Maps event listener for the given KmlLayer as an Observable\n     */\n    KmlLayerManager.prototype.createEventObservable = function (eventName, layer) {\n        var _this = this;\n        return Observable_1.Observable.create(function (observer) {\n            _this._layers.get(layer).then(function (m) {\n                m.addListener(eventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); });\n            });\n        });\n    };\n    KmlLayerManager.decorators = [\n        { type: core_1.Injectable },\n    ];\n    /** @nocollapse */\n    KmlLayerManager.ctorParameters = function () { return [\n        { type: google_maps_api_wrapper_1.GoogleMapsAPIWrapper, },\n        { type: core_1.NgZone, },\n    ]; };\n    return KmlLayerManager;\n}());\nexports.KmlLayerManager = KmlLayerManager;\n//# sourceMappingURL=kml-layer-manager.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzE3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL3NlcnZpY2VzL21hbmFnZXJzL2ttbC1sYXllci1tYW5hZ2VyLmpzPzVmZmUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJ3J4anMvT2JzZXJ2YWJsZScpO1xudmFyIGdvb2dsZV9tYXBzX2FwaV93cmFwcGVyXzEgPSByZXF1aXJlKCcuLy4uL2dvb2dsZS1tYXBzLWFwaS13cmFwcGVyJyk7XG4vKipcbiAqIE1hbmFnZXMgYWxsIEtNTCBMYXllcnMgZm9yIGEgR29vZ2xlIE1hcCBpbnN0YW5jZS5cbiAqL1xudmFyIEttbExheWVyTWFuYWdlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gS21sTGF5ZXJNYW5hZ2VyKF93cmFwcGVyLCBfem9uZSkge1xuICAgICAgICB0aGlzLl93cmFwcGVyID0gX3dyYXBwZXI7XG4gICAgICAgIHRoaXMuX3pvbmUgPSBfem9uZTtcbiAgICAgICAgdGhpcy5fbGF5ZXJzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IEtNTCBMYXllciB0byB0aGUgbWFwLlxuICAgICAqL1xuICAgIEttbExheWVyTWFuYWdlci5wcm90b3R5cGUuYWRkS21sTGF5ZXIgPSBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgdmFyIG5ld0xheWVyID0gdGhpcy5fd3JhcHBlci5nZXROYXRpdmVNYXAoKS50aGVuKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGdvb2dsZS5tYXBzLkttbExheWVyKHtcbiAgICAgICAgICAgICAgICBjbGlja2FibGU6IGxheWVyLmNsaWNrYWJsZSxcbiAgICAgICAgICAgICAgICBtYXA6IG0sXG4gICAgICAgICAgICAgICAgcHJlc2VydmVWaWV3cG9ydDogbGF5ZXIucHJlc2VydmVWaWV3cG9ydCxcbiAgICAgICAgICAgICAgICBzY3JlZW5PdmVybGF5czogbGF5ZXIuc2NyZWVuT3ZlcmxheXMsXG4gICAgICAgICAgICAgICAgc3VwcHJlc3NJbmZvV2luZG93czogbGF5ZXIuc3VwcHJlc3NJbmZvV2luZG93cyxcbiAgICAgICAgICAgICAgICB1cmw6IGxheWVyLnVybCxcbiAgICAgICAgICAgICAgICB6SW5kZXg6IGxheWVyLnpJbmRleFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9sYXllcnMuc2V0KGxheWVyLCBuZXdMYXllcik7XG4gICAgfTtcbiAgICBLbWxMYXllck1hbmFnZXIucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAobGF5ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fbGF5ZXJzLmdldChsYXllcikudGhlbihmdW5jdGlvbiAobCkgeyByZXR1cm4gbC5zZXRPcHRpb25zKG9wdGlvbnMpOyB9KTtcbiAgICB9O1xuICAgIEttbExheWVyTWFuYWdlci5wcm90b3R5cGUuZGVsZXRlS21sTGF5ZXIgPSBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fbGF5ZXJzLmdldChsYXllcikudGhlbihmdW5jdGlvbiAobCkge1xuICAgICAgICAgICAgbC5zZXRNYXAobnVsbCk7XG4gICAgICAgICAgICBfdGhpcy5fbGF5ZXJzLmRlbGV0ZShsYXllcik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIEdvb2dsZSBNYXBzIGV2ZW50IGxpc3RlbmVyIGZvciB0aGUgZ2l2ZW4gS21sTGF5ZXIgYXMgYW4gT2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIEttbExheWVyTWFuYWdlci5wcm90b3R5cGUuY3JlYXRlRXZlbnRPYnNlcnZhYmxlID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgbGF5ZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGVfMS5PYnNlcnZhYmxlLmNyZWF0ZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIF90aGlzLl9sYXllcnMuZ2V0KGxheWVyKS50aGVuKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICAgICAgbS5hZGRMaXN0ZW5lcihldmVudE5hbWUsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBfdGhpcy5fem9uZS5ydW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gb2JzZXJ2ZXIubmV4dChlKTsgfSk7IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgS21sTGF5ZXJNYW5hZ2VyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIEttbExheWVyTWFuYWdlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBnb29nbGVfbWFwc19hcGlfd3JhcHBlcl8xLkdvb2dsZU1hcHNBUElXcmFwcGVyLCB9LFxuICAgICAgICB7IHR5cGU6IGNvcmVfMS5OZ1pvbmUsIH0sXG4gICAgXTsgfTtcbiAgICByZXR1cm4gS21sTGF5ZXJNYW5hZ2VyO1xufSgpKTtcbmV4cG9ydHMuS21sTGF5ZXJNYW5hZ2VyID0gS21sTGF5ZXJNYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a21sLWxheWVyLW1hbmFnZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvc2VydmljZXMvbWFuYWdlcnMva21sLWxheWVyLW1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDcxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDUgOCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 718:
/* unknown exports provided */
/* all exports used */
/*!**************************************************************************!*\
  !*** ./~/angular2-google-maps/core/services/managers/polygon-manager.js ***!
  \**************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar core_1 = __webpack_require__(/*! @angular/core */ 0);\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ 12);\nvar google_maps_api_wrapper_1 = __webpack_require__(/*! ../google-maps-api-wrapper */ 703);\nvar PolygonManager = (function () {\n    function PolygonManager(_mapsWrapper, _zone) {\n        this._mapsWrapper = _mapsWrapper;\n        this._zone = _zone;\n        this._polygons = new Map();\n    }\n    PolygonManager.prototype.addPolygon = function (path) {\n        var polygonPromise = this._mapsWrapper.createPolygon({\n            clickable: path.clickable,\n            draggable: path.draggable,\n            editable: path.editable,\n            fillColor: path.fillColor,\n            fillOpacity: path.fillOpacity,\n            geodesic: path.geodesic,\n            paths: path.paths,\n            strokeColor: path.strokeColor,\n            strokeOpacity: path.strokeOpacity,\n            strokeWeight: path.strokeWeight,\n            visible: path.visible,\n            zIndex: path.zIndex,\n        });\n        this._polygons.set(path, polygonPromise);\n    };\n    PolygonManager.prototype.updatePolygon = function (polygon) {\n        var _this = this;\n        var m = this._polygons.get(polygon);\n        if (m == null) {\n            return Promise.resolve();\n        }\n        return m.then(function (l) { return _this._zone.run(function () { l.setPaths(polygon.paths); }); });\n    };\n    PolygonManager.prototype.setPolygonOptions = function (path, options) {\n        return this._polygons.get(path).then(function (l) { l.setOptions(options); });\n    };\n    PolygonManager.prototype.deletePolygon = function (paths) {\n        var _this = this;\n        var m = this._polygons.get(paths);\n        if (m == null) {\n            return Promise.resolve();\n        }\n        return m.then(function (l) {\n            return _this._zone.run(function () {\n                l.setMap(null);\n                _this._polygons.delete(paths);\n            });\n        });\n    };\n    PolygonManager.prototype.createEventObservable = function (eventName, path) {\n        var _this = this;\n        return Observable_1.Observable.create(function (observer) {\n            _this._polygons.get(path).then(function (l) {\n                l.addListener(eventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); });\n            });\n        });\n    };\n    PolygonManager.decorators = [\n        { type: core_1.Injectable },\n    ];\n    /** @nocollapse */\n    PolygonManager.ctorParameters = function () { return [\n        { type: google_maps_api_wrapper_1.GoogleMapsAPIWrapper, },\n        { type: core_1.NgZone, },\n    ]; };\n    return PolygonManager;\n}());\nexports.PolygonManager = PolygonManager;\n//# sourceMappingURL=polygon-manager.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzE4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL3NlcnZpY2VzL21hbmFnZXJzL3BvbHlnb24tbWFuYWdlci5qcz8xMGM1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCdyeGpzL09ic2VydmFibGUnKTtcbnZhciBnb29nbGVfbWFwc19hcGlfd3JhcHBlcl8xID0gcmVxdWlyZSgnLi4vZ29vZ2xlLW1hcHMtYXBpLXdyYXBwZXInKTtcbnZhciBQb2x5Z29uTWFuYWdlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUG9seWdvbk1hbmFnZXIoX21hcHNXcmFwcGVyLCBfem9uZSkge1xuICAgICAgICB0aGlzLl9tYXBzV3JhcHBlciA9IF9tYXBzV3JhcHBlcjtcbiAgICAgICAgdGhpcy5fem9uZSA9IF96b25lO1xuICAgICAgICB0aGlzLl9wb2x5Z29ucyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgUG9seWdvbk1hbmFnZXIucHJvdG90eXBlLmFkZFBvbHlnb24gPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICB2YXIgcG9seWdvblByb21pc2UgPSB0aGlzLl9tYXBzV3JhcHBlci5jcmVhdGVQb2x5Z29uKHtcbiAgICAgICAgICAgIGNsaWNrYWJsZTogcGF0aC5jbGlja2FibGUsXG4gICAgICAgICAgICBkcmFnZ2FibGU6IHBhdGguZHJhZ2dhYmxlLFxuICAgICAgICAgICAgZWRpdGFibGU6IHBhdGguZWRpdGFibGUsXG4gICAgICAgICAgICBmaWxsQ29sb3I6IHBhdGguZmlsbENvbG9yLFxuICAgICAgICAgICAgZmlsbE9wYWNpdHk6IHBhdGguZmlsbE9wYWNpdHksXG4gICAgICAgICAgICBnZW9kZXNpYzogcGF0aC5nZW9kZXNpYyxcbiAgICAgICAgICAgIHBhdGhzOiBwYXRoLnBhdGhzLFxuICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IHBhdGguc3Ryb2tlQ29sb3IsXG4gICAgICAgICAgICBzdHJva2VPcGFjaXR5OiBwYXRoLnN0cm9rZU9wYWNpdHksXG4gICAgICAgICAgICBzdHJva2VXZWlnaHQ6IHBhdGguc3Ryb2tlV2VpZ2h0LFxuICAgICAgICAgICAgdmlzaWJsZTogcGF0aC52aXNpYmxlLFxuICAgICAgICAgICAgekluZGV4OiBwYXRoLnpJbmRleCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3BvbHlnb25zLnNldChwYXRoLCBwb2x5Z29uUHJvbWlzZSk7XG4gICAgfTtcbiAgICBQb2x5Z29uTWFuYWdlci5wcm90b3R5cGUudXBkYXRlUG9seWdvbiA9IGZ1bmN0aW9uIChwb2x5Z29uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBtID0gdGhpcy5fcG9seWdvbnMuZ2V0KHBvbHlnb24pO1xuICAgICAgICBpZiAobSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0udGhlbihmdW5jdGlvbiAobCkgeyByZXR1cm4gX3RoaXMuX3pvbmUucnVuKGZ1bmN0aW9uICgpIHsgbC5zZXRQYXRocyhwb2x5Z29uLnBhdGhzKTsgfSk7IH0pO1xuICAgIH07XG4gICAgUG9seWdvbk1hbmFnZXIucHJvdG90eXBlLnNldFBvbHlnb25PcHRpb25zID0gZnVuY3Rpb24gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvbHlnb25zLmdldChwYXRoKS50aGVuKGZ1bmN0aW9uIChsKSB7IGwuc2V0T3B0aW9ucyhvcHRpb25zKTsgfSk7XG4gICAgfTtcbiAgICBQb2x5Z29uTWFuYWdlci5wcm90b3R5cGUuZGVsZXRlUG9seWdvbiA9IGZ1bmN0aW9uIChwYXRocykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbSA9IHRoaXMuX3BvbHlnb25zLmdldChwYXRocyk7XG4gICAgICAgIGlmIChtID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS50aGVuKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3pvbmUucnVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBsLnNldE1hcChudWxsKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcG9seWdvbnMuZGVsZXRlKHBhdGhzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFBvbHlnb25NYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVFdmVudE9ic2VydmFibGUgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBwYXRoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5jcmVhdGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgICAgICBfdGhpcy5fcG9seWdvbnMuZ2V0KHBhdGgpLnRoZW4oZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgICAgICAgICBsLmFkZExpc3RlbmVyKGV2ZW50TmFtZSwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF90aGlzLl96b25lLnJ1bihmdW5jdGlvbiAoKSB7IHJldHVybiBvYnNlcnZlci5uZXh0KGUpOyB9KTsgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBQb2x5Z29uTWFuYWdlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5JbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBQb2x5Z29uTWFuYWdlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBnb29nbGVfbWFwc19hcGlfd3JhcHBlcl8xLkdvb2dsZU1hcHNBUElXcmFwcGVyLCB9LFxuICAgICAgICB7IHR5cGU6IGNvcmVfMS5OZ1pvbmUsIH0sXG4gICAgXTsgfTtcbiAgICByZXR1cm4gUG9seWdvbk1hbmFnZXI7XG59KCkpO1xuZXhwb3J0cy5Qb2x5Z29uTWFuYWdlciA9IFBvbHlnb25NYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9seWdvbi1tYW5hZ2VyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL3NlcnZpY2VzL21hbmFnZXJzL3BvbHlnb24tbWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gNzE4XG4vLyBtb2R1bGUgY2h1bmtzID0gNSA4Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 719:
/* unknown exports provided */
/* all exports used */
/*!***************************************************************************!*\
  !*** ./~/angular2-google-maps/core/services/managers/polyline-manager.js ***!
  \***************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar core_1 = __webpack_require__(/*! @angular/core */ 0);\nvar Observable_1 = __webpack_require__(/*! rxjs/Observable */ 12);\nvar google_maps_api_wrapper_1 = __webpack_require__(/*! ../google-maps-api-wrapper */ 703);\nvar PolylineManager = (function () {\n    function PolylineManager(_mapsWrapper, _zone) {\n        this._mapsWrapper = _mapsWrapper;\n        this._zone = _zone;\n        this._polylines = new Map();\n    }\n    PolylineManager._convertPoints = function (line) {\n        var path = line._getPoints().map(function (point) {\n            return { lat: point.latitude, lng: point.longitude };\n        });\n        return path;\n    };\n    PolylineManager.prototype.addPolyline = function (line) {\n        var path = PolylineManager._convertPoints(line);\n        var polylinePromise = this._mapsWrapper.createPolyline({\n            clickable: line.clickable,\n            draggable: line.draggable,\n            editable: line.editable,\n            geodesic: line.geodesic,\n            strokeColor: line.strokeColor,\n            strokeOpacity: line.strokeOpacity,\n            strokeWeight: line.strokeWeight,\n            visible: line.visible,\n            zIndex: line.zIndex,\n            path: path\n        });\n        this._polylines.set(line, polylinePromise);\n    };\n    PolylineManager.prototype.updatePolylinePoints = function (line) {\n        var _this = this;\n        var path = PolylineManager._convertPoints(line);\n        var m = this._polylines.get(line);\n        if (m == null) {\n            return Promise.resolve();\n        }\n        return m.then(function (l) { return _this._zone.run(function () { l.setPath(path); }); });\n    };\n    PolylineManager.prototype.setPolylineOptions = function (line, options) {\n        return this._polylines.get(line).then(function (l) { l.setOptions(options); });\n    };\n    PolylineManager.prototype.deletePolyline = function (line) {\n        var _this = this;\n        var m = this._polylines.get(line);\n        if (m == null) {\n            return Promise.resolve();\n        }\n        return m.then(function (l) {\n            return _this._zone.run(function () {\n                l.setMap(null);\n                _this._polylines.delete(line);\n            });\n        });\n    };\n    PolylineManager.prototype.createEventObservable = function (eventName, line) {\n        var _this = this;\n        return Observable_1.Observable.create(function (observer) {\n            _this._polylines.get(line).then(function (l) {\n                l.addListener(eventName, function (e) { return _this._zone.run(function () { return observer.next(e); }); });\n            });\n        });\n    };\n    PolylineManager.decorators = [\n        { type: core_1.Injectable },\n    ];\n    /** @nocollapse */\n    PolylineManager.ctorParameters = function () { return [\n        { type: google_maps_api_wrapper_1.GoogleMapsAPIWrapper, },\n        { type: core_1.NgZone, },\n    ]; };\n    return PolylineManager;\n}());\nexports.PolylineManager = PolylineManager;\n//# sourceMappingURL=polyline-manager.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzE5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL3NlcnZpY2VzL21hbmFnZXJzL3BvbHlsaW5lLW1hbmFnZXIuanM/YTEyOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgncnhqcy9PYnNlcnZhYmxlJyk7XG52YXIgZ29vZ2xlX21hcHNfYXBpX3dyYXBwZXJfMSA9IHJlcXVpcmUoJy4uL2dvb2dsZS1tYXBzLWFwaS13cmFwcGVyJyk7XG52YXIgUG9seWxpbmVNYW5hZ2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQb2x5bGluZU1hbmFnZXIoX21hcHNXcmFwcGVyLCBfem9uZSkge1xuICAgICAgICB0aGlzLl9tYXBzV3JhcHBlciA9IF9tYXBzV3JhcHBlcjtcbiAgICAgICAgdGhpcy5fem9uZSA9IF96b25lO1xuICAgICAgICB0aGlzLl9wb2x5bGluZXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIFBvbHlsaW5lTWFuYWdlci5fY29udmVydFBvaW50cyA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHZhciBwYXRoID0gbGluZS5fZ2V0UG9pbnRzKCkubWFwKGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbGF0OiBwb2ludC5sYXRpdHVkZSwgbG5nOiBwb2ludC5sb25naXR1ZGUgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH07XG4gICAgUG9seWxpbmVNYW5hZ2VyLnByb3RvdHlwZS5hZGRQb2x5bGluZSA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHZhciBwYXRoID0gUG9seWxpbmVNYW5hZ2VyLl9jb252ZXJ0UG9pbnRzKGxpbmUpO1xuICAgICAgICB2YXIgcG9seWxpbmVQcm9taXNlID0gdGhpcy5fbWFwc1dyYXBwZXIuY3JlYXRlUG9seWxpbmUoe1xuICAgICAgICAgICAgY2xpY2thYmxlOiBsaW5lLmNsaWNrYWJsZSxcbiAgICAgICAgICAgIGRyYWdnYWJsZTogbGluZS5kcmFnZ2FibGUsXG4gICAgICAgICAgICBlZGl0YWJsZTogbGluZS5lZGl0YWJsZSxcbiAgICAgICAgICAgIGdlb2Rlc2ljOiBsaW5lLmdlb2Rlc2ljLFxuICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IGxpbmUuc3Ryb2tlQ29sb3IsXG4gICAgICAgICAgICBzdHJva2VPcGFjaXR5OiBsaW5lLnN0cm9rZU9wYWNpdHksXG4gICAgICAgICAgICBzdHJva2VXZWlnaHQ6IGxpbmUuc3Ryb2tlV2VpZ2h0LFxuICAgICAgICAgICAgdmlzaWJsZTogbGluZS52aXNpYmxlLFxuICAgICAgICAgICAgekluZGV4OiBsaW5lLnpJbmRleCxcbiAgICAgICAgICAgIHBhdGg6IHBhdGhcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3BvbHlsaW5lcy5zZXQobGluZSwgcG9seWxpbmVQcm9taXNlKTtcbiAgICB9O1xuICAgIFBvbHlsaW5lTWFuYWdlci5wcm90b3R5cGUudXBkYXRlUG9seWxpbmVQb2ludHMgPSBmdW5jdGlvbiAobGluZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcGF0aCA9IFBvbHlsaW5lTWFuYWdlci5fY29udmVydFBvaW50cyhsaW5lKTtcbiAgICAgICAgdmFyIG0gPSB0aGlzLl9wb2x5bGluZXMuZ2V0KGxpbmUpO1xuICAgICAgICBpZiAobSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0udGhlbihmdW5jdGlvbiAobCkgeyByZXR1cm4gX3RoaXMuX3pvbmUucnVuKGZ1bmN0aW9uICgpIHsgbC5zZXRQYXRoKHBhdGgpOyB9KTsgfSk7XG4gICAgfTtcbiAgICBQb2x5bGluZU1hbmFnZXIucHJvdG90eXBlLnNldFBvbHlsaW5lT3B0aW9ucyA9IGZ1bmN0aW9uIChsaW5lLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb2x5bGluZXMuZ2V0KGxpbmUpLnRoZW4oZnVuY3Rpb24gKGwpIHsgbC5zZXRPcHRpb25zKG9wdGlvbnMpOyB9KTtcbiAgICB9O1xuICAgIFBvbHlsaW5lTWFuYWdlci5wcm90b3R5cGUuZGVsZXRlUG9seWxpbmUgPSBmdW5jdGlvbiAobGluZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbSA9IHRoaXMuX3BvbHlsaW5lcy5nZXQobGluZSk7XG4gICAgICAgIGlmIChtID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS50aGVuKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX3pvbmUucnVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBsLnNldE1hcChudWxsKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcG9seWxpbmVzLmRlbGV0ZShsaW5lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFBvbHlsaW5lTWFuYWdlci5wcm90b3R5cGUuY3JlYXRlRXZlbnRPYnNlcnZhYmxlID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgbGluZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUuY3JlYXRlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgX3RoaXMuX3BvbHlsaW5lcy5nZXQobGluZSkudGhlbihmdW5jdGlvbiAobCkge1xuICAgICAgICAgICAgICAgIGwuYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gX3RoaXMuX3pvbmUucnVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9ic2VydmVyLm5leHQoZSk7IH0pOyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFBvbHlsaW5lTWFuYWdlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5JbmplY3RhYmxlIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBQb2x5bGluZU1hbmFnZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogZ29vZ2xlX21hcHNfYXBpX3dyYXBwZXJfMS5Hb29nbGVNYXBzQVBJV3JhcHBlciwgfSxcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuTmdab25lLCB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIFBvbHlsaW5lTWFuYWdlcjtcbn0oKSk7XG5leHBvcnRzLlBvbHlsaW5lTWFuYWdlciA9IFBvbHlsaW5lTWFuYWdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvbHlsaW5lLW1hbmFnZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvc2VydmljZXMvbWFuYWdlcnMvcG9seWxpbmUtbWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gNzE5XG4vLyBtb2R1bGUgY2h1bmtzID0gNSA4Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 720:
/* unknown exports provided */
/* all exports used */
/*!**************************************************************************************!*\
  !*** ./~/angular2-google-maps/core/services/maps-api-loader/lazy-maps-api-loader.js ***!
  \**************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar core_1 = __webpack_require__(/*! @angular/core */ 0);\nvar browser_globals_1 = __webpack_require__(/*! ../../utils/browser-globals */ 735);\nvar maps_api_loader_1 = __webpack_require__(/*! ./maps-api-loader */ 711);\n(function (GoogleMapsScriptProtocol) {\n    GoogleMapsScriptProtocol[GoogleMapsScriptProtocol[\"HTTP\"] = 1] = \"HTTP\";\n    GoogleMapsScriptProtocol[GoogleMapsScriptProtocol[\"HTTPS\"] = 2] = \"HTTPS\";\n    GoogleMapsScriptProtocol[GoogleMapsScriptProtocol[\"AUTO\"] = 3] = \"AUTO\";\n})(exports.GoogleMapsScriptProtocol || (exports.GoogleMapsScriptProtocol = {}));\nvar GoogleMapsScriptProtocol = exports.GoogleMapsScriptProtocol;\n/**\n * Token for the config of the LazyMapsAPILoader. Please provide an object of type {@link\n * LazyMapsAPILoaderConfig}.\n */\nexports.LAZY_MAPS_API_CONFIG = new core_1.OpaqueToken('angular2-google-maps LAZY_MAPS_API_CONFIG');\nvar LazyMapsAPILoader = (function (_super) {\n    __extends(LazyMapsAPILoader, _super);\n    function LazyMapsAPILoader(config, w, d) {\n        _super.call(this);\n        this._config = config || {};\n        this._windowRef = w;\n        this._documentRef = d;\n    }\n    LazyMapsAPILoader.prototype.load = function () {\n        var _this = this;\n        if (this._scriptLoadingPromise) {\n            return this._scriptLoadingPromise;\n        }\n        var script = this._documentRef.getNativeDocument().createElement('script');\n        script.type = 'text/javascript';\n        script.async = true;\n        script.defer = true;\n        var callbackName = \"angular2GoogleMapsLazyMapsAPILoader\";\n        script.src = this._getScriptSrc(callbackName);\n        this._scriptLoadingPromise = new Promise(function (resolve, reject) {\n            _this._windowRef.getNativeWindow()[callbackName] = function () { resolve(); };\n            script.onerror = function (error) { reject(error); };\n        });\n        this._documentRef.getNativeDocument().body.appendChild(script);\n        return this._scriptLoadingPromise;\n    };\n    LazyMapsAPILoader.prototype._getScriptSrc = function (callbackName) {\n        var protocolType = (this._config && this._config.protocol) || GoogleMapsScriptProtocol.HTTPS;\n        var protocol;\n        switch (protocolType) {\n            case GoogleMapsScriptProtocol.AUTO:\n                protocol = '';\n                break;\n            case GoogleMapsScriptProtocol.HTTP:\n                protocol = 'http:';\n                break;\n            case GoogleMapsScriptProtocol.HTTPS:\n                protocol = 'https:';\n                break;\n        }\n        var hostAndPath = this._config.hostAndPath || 'maps.googleapis.com/maps/api/js';\n        var queryParams = {\n            v: this._config.apiVersion || '3',\n            callback: callbackName,\n            key: this._config.apiKey,\n            client: this._config.clientId,\n            channel: this._config.channel,\n            libraries: this._config.libraries,\n            region: this._config.region,\n            language: this._config.language\n        };\n        var params = Object.keys(queryParams)\n            .filter(function (k) { return queryParams[k] != null; })\n            .filter(function (k) {\n            // remove empty arrays\n            return !Array.isArray(queryParams[k]) ||\n                (Array.isArray(queryParams[k]) && queryParams[k].length > 0);\n        })\n            .map(function (k) {\n            // join arrays as comma seperated strings\n            var i = queryParams[k];\n            if (Array.isArray(i)) {\n                return { key: k, value: i.join(',') };\n            }\n            return { key: k, value: queryParams[k] };\n        })\n            .map(function (entry) { return entry.key + \"=\" + entry.value; })\n            .join('&');\n        return protocol + \"//\" + hostAndPath + \"?\" + params;\n    };\n    LazyMapsAPILoader.decorators = [\n        { type: core_1.Injectable },\n    ];\n    /** @nocollapse */\n    LazyMapsAPILoader.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: core_1.Inject, args: [exports.LAZY_MAPS_API_CONFIG,] },] },\n        { type: browser_globals_1.WindowRef, },\n        { type: browser_globals_1.DocumentRef, },\n    ]; };\n    return LazyMapsAPILoader;\n}(maps_api_loader_1.MapsAPILoader));\nexports.LazyMapsAPILoader = LazyMapsAPILoader;\n//# sourceMappingURL=lazy-maps-api-loader.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzIwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL3NlcnZpY2VzL21hcHMtYXBpLWxvYWRlci9sYXp5LW1hcHMtYXBpLWxvYWRlci5qcz8zZTQxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIGJyb3dzZXJfZ2xvYmFsc18xID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYnJvd3Nlci1nbG9iYWxzJyk7XG52YXIgbWFwc19hcGlfbG9hZGVyXzEgPSByZXF1aXJlKCcuL21hcHMtYXBpLWxvYWRlcicpO1xuKGZ1bmN0aW9uIChHb29nbGVNYXBzU2NyaXB0UHJvdG9jb2wpIHtcbiAgICBHb29nbGVNYXBzU2NyaXB0UHJvdG9jb2xbR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sW1wiSFRUUFwiXSA9IDFdID0gXCJIVFRQXCI7XG4gICAgR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sW0dvb2dsZU1hcHNTY3JpcHRQcm90b2NvbFtcIkhUVFBTXCJdID0gMl0gPSBcIkhUVFBTXCI7XG4gICAgR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sW0dvb2dsZU1hcHNTY3JpcHRQcm90b2NvbFtcIkFVVE9cIl0gPSAzXSA9IFwiQVVUT1wiO1xufSkoZXhwb3J0cy5Hb29nbGVNYXBzU2NyaXB0UHJvdG9jb2wgfHwgKGV4cG9ydHMuR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sID0ge30pKTtcbnZhciBHb29nbGVNYXBzU2NyaXB0UHJvdG9jb2wgPSBleHBvcnRzLkdvb2dsZU1hcHNTY3JpcHRQcm90b2NvbDtcbi8qKlxuICogVG9rZW4gZm9yIHRoZSBjb25maWcgb2YgdGhlIExhenlNYXBzQVBJTG9hZGVyLiBQbGVhc2UgcHJvdmlkZSBhbiBvYmplY3Qgb2YgdHlwZSB7QGxpbmtcbiAqIExhenlNYXBzQVBJTG9hZGVyQ29uZmlnfS5cbiAqL1xuZXhwb3J0cy5MQVpZX01BUFNfQVBJX0NPTkZJRyA9IG5ldyBjb3JlXzEuT3BhcXVlVG9rZW4oJ2FuZ3VsYXIyLWdvb2dsZS1tYXBzIExBWllfTUFQU19BUElfQ09ORklHJyk7XG52YXIgTGF6eU1hcHNBUElMb2FkZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMYXp5TWFwc0FQSUxvYWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMYXp5TWFwc0FQSUxvYWRlcihjb25maWcsIHcsIGQpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICAgICAgdGhpcy5fd2luZG93UmVmID0gdztcbiAgICAgICAgdGhpcy5fZG9jdW1lbnRSZWYgPSBkO1xuICAgIH1cbiAgICBMYXp5TWFwc0FQSUxvYWRlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX3NjcmlwdExvYWRpbmdQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2NyaXB0TG9hZGluZ1Byb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjcmlwdCA9IHRoaXMuX2RvY3VtZW50UmVmLmdldE5hdGl2ZURvY3VtZW50KCkuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgICAgIHNjcmlwdC5kZWZlciA9IHRydWU7XG4gICAgICAgIHZhciBjYWxsYmFja05hbWUgPSBcImFuZ3VsYXIyR29vZ2xlTWFwc0xhenlNYXBzQVBJTG9hZGVyXCI7XG4gICAgICAgIHNjcmlwdC5zcmMgPSB0aGlzLl9nZXRTY3JpcHRTcmMoY2FsbGJhY2tOYW1lKTtcbiAgICAgICAgdGhpcy5fc2NyaXB0TG9hZGluZ1Byb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBfdGhpcy5fd2luZG93UmVmLmdldE5hdGl2ZVdpbmRvdygpW2NhbGxiYWNrTmFtZV0gPSBmdW5jdGlvbiAoKSB7IHJlc29sdmUoKTsgfTtcbiAgICAgICAgICAgIHNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7IHJlamVjdChlcnJvcik7IH07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9kb2N1bWVudFJlZi5nZXROYXRpdmVEb2N1bWVudCgpLmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NjcmlwdExvYWRpbmdQcm9taXNlO1xuICAgIH07XG4gICAgTGF6eU1hcHNBUElMb2FkZXIucHJvdG90eXBlLl9nZXRTY3JpcHRTcmMgPSBmdW5jdGlvbiAoY2FsbGJhY2tOYW1lKSB7XG4gICAgICAgIHZhciBwcm90b2NvbFR5cGUgPSAodGhpcy5fY29uZmlnICYmIHRoaXMuX2NvbmZpZy5wcm90b2NvbCkgfHwgR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sLkhUVFBTO1xuICAgICAgICB2YXIgcHJvdG9jb2w7XG4gICAgICAgIHN3aXRjaCAocHJvdG9jb2xUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIEdvb2dsZU1hcHNTY3JpcHRQcm90b2NvbC5BVVRPOlxuICAgICAgICAgICAgICAgIHByb3RvY29sID0gJyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEdvb2dsZU1hcHNTY3JpcHRQcm90b2NvbC5IVFRQOlxuICAgICAgICAgICAgICAgIHByb3RvY29sID0gJ2h0dHA6JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgR29vZ2xlTWFwc1NjcmlwdFByb3RvY29sLkhUVFBTOlxuICAgICAgICAgICAgICAgIHByb3RvY29sID0gJ2h0dHBzOic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhvc3RBbmRQYXRoID0gdGhpcy5fY29uZmlnLmhvc3RBbmRQYXRoIHx8ICdtYXBzLmdvb2dsZWFwaXMuY29tL21hcHMvYXBpL2pzJztcbiAgICAgICAgdmFyIHF1ZXJ5UGFyYW1zID0ge1xuICAgICAgICAgICAgdjogdGhpcy5fY29uZmlnLmFwaVZlcnNpb24gfHwgJzMnLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrTmFtZSxcbiAgICAgICAgICAgIGtleTogdGhpcy5fY29uZmlnLmFwaUtleSxcbiAgICAgICAgICAgIGNsaWVudDogdGhpcy5fY29uZmlnLmNsaWVudElkLFxuICAgICAgICAgICAgY2hhbm5lbDogdGhpcy5fY29uZmlnLmNoYW5uZWwsXG4gICAgICAgICAgICBsaWJyYXJpZXM6IHRoaXMuX2NvbmZpZy5saWJyYXJpZXMsXG4gICAgICAgICAgICByZWdpb246IHRoaXMuX2NvbmZpZy5yZWdpb24sXG4gICAgICAgICAgICBsYW5ndWFnZTogdGhpcy5fY29uZmlnLmxhbmd1YWdlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBwYXJhbXMgPSBPYmplY3Qua2V5cyhxdWVyeVBhcmFtcylcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGspIHsgcmV0dXJuIHF1ZXJ5UGFyYW1zW2tdICE9IG51bGw7IH0pXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgZW1wdHkgYXJyYXlzXG4gICAgICAgICAgICByZXR1cm4gIUFycmF5LmlzQXJyYXkocXVlcnlQYXJhbXNba10pIHx8XG4gICAgICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkocXVlcnlQYXJhbXNba10pICYmIHF1ZXJ5UGFyYW1zW2tdLmxlbmd0aCA+IDApO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgLy8gam9pbiBhcnJheXMgYXMgY29tbWEgc2VwZXJhdGVkIHN0cmluZ3NcbiAgICAgICAgICAgIHZhciBpID0gcXVlcnlQYXJhbXNba107XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGtleTogaywgdmFsdWU6IGkuam9pbignLCcpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBrZXk6IGssIHZhbHVlOiBxdWVyeVBhcmFtc1trXSB9O1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIGVudHJ5LmtleSArIFwiPVwiICsgZW50cnkudmFsdWU7IH0pXG4gICAgICAgICAgICAuam9pbignJicpO1xuICAgICAgICByZXR1cm4gcHJvdG9jb2wgKyBcIi8vXCIgKyBob3N0QW5kUGF0aCArIFwiP1wiICsgcGFyYW1zO1xuICAgIH07XG4gICAgTGF6eU1hcHNBUElMb2FkZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgTGF6eU1hcHNBUElMb2FkZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBjb3JlXzEuSW5qZWN0LCBhcmdzOiBbZXhwb3J0cy5MQVpZX01BUFNfQVBJX0NPTkZJRyxdIH0sXSB9LFxuICAgICAgICB7IHR5cGU6IGJyb3dzZXJfZ2xvYmFsc18xLldpbmRvd1JlZiwgfSxcbiAgICAgICAgeyB0eXBlOiBicm93c2VyX2dsb2JhbHNfMS5Eb2N1bWVudFJlZiwgfSxcbiAgICBdOyB9O1xuICAgIHJldHVybiBMYXp5TWFwc0FQSUxvYWRlcjtcbn0obWFwc19hcGlfbG9hZGVyXzEuTWFwc0FQSUxvYWRlcikpO1xuZXhwb3J0cy5MYXp5TWFwc0FQSUxvYWRlciA9IExhenlNYXBzQVBJTG9hZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGF6eS1tYXBzLWFwaS1sb2FkZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvc2VydmljZXMvbWFwcy1hcGktbG9hZGVyL2xhenktbWFwcy1hcGktbG9hZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA3MjBcbi8vIG1vZHVsZSBjaHVua3MgPSA1IDgiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 729:
/* unknown exports provided */
/* all exports used */
/*!*********************************************************************!*\
  !*** ./~/angular2-google-maps/core/directives/google-map-circle.js ***!
  \*********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar core_1 = __webpack_require__(/*! @angular/core */ 0);\nvar circle_manager_1 = __webpack_require__(/*! ../services/managers/circle-manager */ 715);\nvar SebmGoogleMapCircle = (function () {\n    function SebmGoogleMapCircle(_manager) {\n        this._manager = _manager;\n        /**\n         * Indicates whether this Circle handles mouse events. Defaults to true.\n         */\n        this.clickable = true;\n        /**\n         * If set to true, the user can drag this circle over the map. Defaults to false.\n         */\n        this.draggable = false;\n        /**\n         * If set to true, the user can edit this circle by dragging the control points shown at\n         * the center and around the circumference of the circle. Defaults to false.\n         */\n        this.editable = false;\n        /**\n         * The radius in meters on the Earth's surface.\n         */\n        this.radius = 0;\n        /**\n         * The stroke position. Defaults to CENTER.\n         * This property is not supported on Internet Explorer 8 and earlier.\n         */\n        this.strokePosition = 'CENTER';\n        /**\n         * The stroke width in pixels.\n         */\n        this.strokeWeight = 0;\n        /**\n         * Whether this circle is visible on the map. Defaults to true.\n         */\n        this.visible = true;\n        /**\n         * This event is fired when the circle's center is changed.\n         */\n        this.centerChange = new core_1.EventEmitter();\n        /**\n         * This event emitter gets emitted when the user clicks on the circle.\n         */\n        this.circleClick = new core_1.EventEmitter();\n        /**\n         * This event emitter gets emitted when the user clicks on the circle.\n         */\n        this.circleDblClick = new core_1.EventEmitter();\n        /**\n         * This event is repeatedly fired while the user drags the circle.\n         */\n        this.drag = new core_1.EventEmitter();\n        /**\n         * This event is fired when the user stops dragging the circle.\n         */\n        this.dragEnd = new core_1.EventEmitter();\n        /**\n         * This event is fired when the user starts dragging the circle.\n         */\n        this.dragStart = new core_1.EventEmitter();\n        /**\n         * This event is fired when the DOM mousedown event is fired on the circle.\n         */\n        this.mouseDown = new core_1.EventEmitter();\n        /**\n         * This event is fired when the DOM mousemove event is fired on the circle.\n         */\n        this.mouseMove = new core_1.EventEmitter();\n        /**\n         * This event is fired on circle mouseout.\n         */\n        this.mouseOut = new core_1.EventEmitter();\n        /**\n         * This event is fired on circle mouseover.\n         */\n        this.mouseOver = new core_1.EventEmitter();\n        /**\n         * This event is fired when the DOM mouseup event is fired on the circle.\n         */\n        this.mouseUp = new core_1.EventEmitter();\n        /**\n         * This event is fired when the circle's radius is changed.\n         */\n        this.radiusChange = new core_1.EventEmitter();\n        /**\n         * This event is fired when the circle is right-clicked on.\n         */\n        this.rightClick = new core_1.EventEmitter();\n        this._circleAddedToManager = false;\n        this._eventSubscriptions = [];\n    }\n    /** @internal */\n    SebmGoogleMapCircle.prototype.ngOnInit = function () {\n        this._manager.addCircle(this);\n        this._circleAddedToManager = true;\n        this._registerEventListeners();\n    };\n    /** @internal */\n    SebmGoogleMapCircle.prototype.ngOnChanges = function (changes) {\n        if (!this._circleAddedToManager) {\n            return;\n        }\n        if (changes['latitude'] || changes['longitude']) {\n            this._manager.setCenter(this);\n        }\n        if (changes['editable']) {\n            this._manager.setEditable(this);\n        }\n        if (changes['draggable']) {\n            this._manager.setDraggable(this);\n        }\n        if (changes['visible']) {\n            this._manager.setVisible(this);\n        }\n        if (changes['radius']) {\n            this._manager.setRadius(this);\n        }\n        this._updateCircleOptionsChanges(changes);\n    };\n    SebmGoogleMapCircle.prototype._updateCircleOptionsChanges = function (changes) {\n        var options = {};\n        var optionKeys = Object.keys(changes).filter(function (k) { return SebmGoogleMapCircle._mapOptions.indexOf(k) !== -1; });\n        optionKeys.forEach(function (k) { options[k] = changes[k].currentValue; });\n        if (optionKeys.length > 0) {\n            this._manager.setOptions(this, options);\n        }\n    };\n    SebmGoogleMapCircle.prototype._registerEventListeners = function () {\n        var _this = this;\n        var events = new Map();\n        events.set('center_changed', this.centerChange);\n        events.set('click', this.circleClick);\n        events.set('dblclick', this.circleDblClick);\n        events.set('drag', this.drag);\n        events.set('dragend', this.dragEnd);\n        events.set('dragStart', this.dragStart);\n        events.set('mousedown', this.mouseDown);\n        events.set('mousemove', this.mouseMove);\n        events.set('mouseout', this.mouseOut);\n        events.set('mouseover', this.mouseOver);\n        events.set('mouseup', this.mouseUp);\n        events.set('radius_changed', this.radiusChange);\n        events.set('rightclick', this.rightClick);\n        events.forEach(function (eventEmitter, eventName) {\n            _this._eventSubscriptions.push(_this._manager.createEventObservable(eventName, _this).subscribe(function (value) {\n                switch (eventName) {\n                    case 'radius_changed':\n                        _this._manager.getRadius(_this).then(function (radius) { return eventEmitter.emit(radius); });\n                        break;\n                    case 'center_changed':\n                        _this._manager.getCenter(_this).then(function (center) {\n                            return eventEmitter.emit({ lat: center.lat(), lng: center.lng() });\n                        });\n                        break;\n                    default:\n                        eventEmitter.emit({ coords: { lat: value.latLng.lat(), lng: value.latLng.lng() } });\n                }\n            }));\n        });\n    };\n    /** @internal */\n    SebmGoogleMapCircle.prototype.ngOnDestroy = function () {\n        this._eventSubscriptions.forEach(function (s) { s.unsubscribe(); });\n        this._eventSubscriptions = null;\n        this._manager.removeCircle(this);\n    };\n    /**\n     * Gets the LatLngBounds of this Circle.\n     */\n    SebmGoogleMapCircle.prototype.getBounds = function () { return this._manager.getBounds(this); };\n    SebmGoogleMapCircle.prototype.getCenter = function () { return this._manager.getCenter(this); };\n    SebmGoogleMapCircle._mapOptions = [\n        'fillColor', 'fillOpacity', 'strokeColor', 'strokeOpacity', 'strokePosition', 'strokeWeight',\n        'visible', 'zIndex'\n    ];\n    SebmGoogleMapCircle.decorators = [\n        { type: core_1.Directive, args: [{\n                    selector: 'sebm-google-map-circle',\n                    inputs: [\n                        'latitude', 'longitude', 'clickable', 'draggable: circleDraggable', 'editable', 'fillColor',\n                        'fillOpacity', 'radius', 'strokeColor', 'strokeOpacity', 'strokePosition', 'strokeWeight',\n                        'visible', 'zIndex'\n                    ],\n                    outputs: [\n                        'centerChange', 'circleClick', 'circleDblClick', 'drag', 'dragEnd', 'dragStart', 'mouseDown',\n                        'mouseMove', 'mouseOut', 'mouseOver', 'mouseUp', 'radiusChange', 'rightClick'\n                    ]\n                },] },\n    ];\n    /** @nocollapse */\n    SebmGoogleMapCircle.ctorParameters = function () { return [\n        { type: circle_manager_1.CircleManager, },\n    ]; };\n    return SebmGoogleMapCircle;\n}());\nexports.SebmGoogleMapCircle = SebmGoogleMapCircle;\n//# sourceMappingURL=google-map-circle.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzI5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC1jaXJjbGUuanM/ZmE1OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgY2lyY2xlX21hbmFnZXJfMSA9IHJlcXVpcmUoJy4uL3NlcnZpY2VzL21hbmFnZXJzL2NpcmNsZS1tYW5hZ2VyJyk7XG52YXIgU2VibUdvb2dsZU1hcENpcmNsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VibUdvb2dsZU1hcENpcmNsZShfbWFuYWdlcikge1xuICAgICAgICB0aGlzLl9tYW5hZ2VyID0gX21hbmFnZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIENpcmNsZSBoYW5kbGVzIG1vdXNlIGV2ZW50cy4gRGVmYXVsdHMgdG8gdHJ1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xpY2thYmxlID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHNldCB0byB0cnVlLCB0aGUgdXNlciBjYW4gZHJhZyB0aGlzIGNpcmNsZSBvdmVyIHRoZSBtYXAuIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHNldCB0byB0cnVlLCB0aGUgdXNlciBjYW4gZWRpdCB0aGlzIGNpcmNsZSBieSBkcmFnZ2luZyB0aGUgY29udHJvbCBwb2ludHMgc2hvd24gYXRcbiAgICAgICAgICogdGhlIGNlbnRlciBhbmQgYXJvdW5kIHRoZSBjaXJjdW1mZXJlbmNlIG9mIHRoZSBjaXJjbGUuIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lZGl0YWJsZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHJhZGl1cyBpbiBtZXRlcnMgb24gdGhlIEVhcnRoJ3Mgc3VyZmFjZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmFkaXVzID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzdHJva2UgcG9zaXRpb24uIERlZmF1bHRzIHRvIENFTlRFUi5cbiAgICAgICAgICogVGhpcyBwcm9wZXJ0eSBpcyBub3Qgc3VwcG9ydGVkIG9uIEludGVybmV0IEV4cGxvcmVyIDggYW5kIGVhcmxpZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0cm9rZVBvc2l0aW9uID0gJ0NFTlRFUic7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc3Ryb2tlIHdpZHRoIGluIHBpeGVscy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3Ryb2tlV2VpZ2h0ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhpcyBjaXJjbGUgaXMgdmlzaWJsZSBvbiB0aGUgbWFwLiBEZWZhdWx0cyB0byB0cnVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgY2lyY2xlJ3MgY2VudGVyIGlzIGNoYW5nZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNlbnRlckNoYW5nZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGVtaXR0ZXIgZ2V0cyBlbWl0dGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSBjaXJjbGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNpcmNsZUNsaWNrID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgZW1pdHRlciBnZXRzIGVtaXR0ZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gdGhlIGNpcmNsZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2lyY2xlRGJsQ2xpY2sgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyByZXBlYXRlZGx5IGZpcmVkIHdoaWxlIHRoZSB1c2VyIGRyYWdzIHRoZSBjaXJjbGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRyYWcgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSB1c2VyIHN0b3BzIGRyYWdnaW5nIHRoZSBjaXJjbGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRyYWdFbmQgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgY2lyY2xlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kcmFnU3RhcnQgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBET00gbW91c2Vkb3duIGV2ZW50IGlzIGZpcmVkIG9uIHRoZSBjaXJjbGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1vdXNlRG93biA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBtb3VzZW1vdmUgZXZlbnQgaXMgZmlyZWQgb24gdGhlIGNpcmNsZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubW91c2VNb3ZlID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgb24gY2lyY2xlIG1vdXNlb3V0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tb3VzZU91dCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIG9uIGNpcmNsZSBtb3VzZW92ZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1vdXNlT3ZlciA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBtb3VzZXVwIGV2ZW50IGlzIGZpcmVkIG9uIHRoZSBjaXJjbGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1vdXNlVXAgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBjaXJjbGUncyByYWRpdXMgaXMgY2hhbmdlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmFkaXVzQ2hhbmdlID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgY2lyY2xlIGlzIHJpZ2h0LWNsaWNrZWQgb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJpZ2h0Q2xpY2sgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLl9jaXJjbGVBZGRlZFRvTWFuYWdlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9ldmVudFN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFNlYm1Hb29nbGVNYXBDaXJjbGUucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9tYW5hZ2VyLmFkZENpcmNsZSh0aGlzKTtcbiAgICAgICAgdGhpcy5fY2lyY2xlQWRkZWRUb01hbmFnZXIgPSB0cnVlO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgU2VibUdvb2dsZU1hcENpcmNsZS5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICBpZiAoIXRoaXMuX2NpcmNsZUFkZGVkVG9NYW5hZ2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXNbJ2xhdGl0dWRlJ10gfHwgY2hhbmdlc1snbG9uZ2l0dWRlJ10pIHtcbiAgICAgICAgICAgIHRoaXMuX21hbmFnZXIuc2V0Q2VudGVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzWydlZGl0YWJsZSddKSB7XG4gICAgICAgICAgICB0aGlzLl9tYW5hZ2VyLnNldEVkaXRhYmxlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzWydkcmFnZ2FibGUnXSkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlci5zZXREcmFnZ2FibGUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXNbJ3Zpc2libGUnXSkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlci5zZXRWaXNpYmxlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzWydyYWRpdXMnXSkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlci5zZXRSYWRpdXModGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlQ2lyY2xlT3B0aW9uc0NoYW5nZXMoY2hhbmdlcyk7XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwQ2lyY2xlLnByb3RvdHlwZS5fdXBkYXRlQ2lyY2xlT3B0aW9uc0NoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgICAgICB2YXIgb3B0aW9uS2V5cyA9IE9iamVjdC5rZXlzKGNoYW5nZXMpLmZpbHRlcihmdW5jdGlvbiAoaykgeyByZXR1cm4gU2VibUdvb2dsZU1hcENpcmNsZS5fbWFwT3B0aW9ucy5pbmRleE9mKGspICE9PSAtMTsgfSk7XG4gICAgICAgIG9wdGlvbktleXMuZm9yRWFjaChmdW5jdGlvbiAoaykgeyBvcHRpb25zW2tdID0gY2hhbmdlc1trXS5jdXJyZW50VmFsdWU7IH0pO1xuICAgICAgICBpZiAob3B0aW9uS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9tYW5hZ2VyLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNlYm1Hb29nbGVNYXBDaXJjbGUucHJvdG90eXBlLl9yZWdpc3RlckV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZXZlbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICBldmVudHMuc2V0KCdjZW50ZXJfY2hhbmdlZCcsIHRoaXMuY2VudGVyQ2hhbmdlKTtcbiAgICAgICAgZXZlbnRzLnNldCgnY2xpY2snLCB0aGlzLmNpcmNsZUNsaWNrKTtcbiAgICAgICAgZXZlbnRzLnNldCgnZGJsY2xpY2snLCB0aGlzLmNpcmNsZURibENsaWNrKTtcbiAgICAgICAgZXZlbnRzLnNldCgnZHJhZycsIHRoaXMuZHJhZyk7XG4gICAgICAgIGV2ZW50cy5zZXQoJ2RyYWdlbmQnLCB0aGlzLmRyYWdFbmQpO1xuICAgICAgICBldmVudHMuc2V0KCdkcmFnU3RhcnQnLCB0aGlzLmRyYWdTdGFydCk7XG4gICAgICAgIGV2ZW50cy5zZXQoJ21vdXNlZG93bicsIHRoaXMubW91c2VEb3duKTtcbiAgICAgICAgZXZlbnRzLnNldCgnbW91c2Vtb3ZlJywgdGhpcy5tb3VzZU1vdmUpO1xuICAgICAgICBldmVudHMuc2V0KCdtb3VzZW91dCcsIHRoaXMubW91c2VPdXQpO1xuICAgICAgICBldmVudHMuc2V0KCdtb3VzZW92ZXInLCB0aGlzLm1vdXNlT3Zlcik7XG4gICAgICAgIGV2ZW50cy5zZXQoJ21vdXNldXAnLCB0aGlzLm1vdXNlVXApO1xuICAgICAgICBldmVudHMuc2V0KCdyYWRpdXNfY2hhbmdlZCcsIHRoaXMucmFkaXVzQ2hhbmdlKTtcbiAgICAgICAgZXZlbnRzLnNldCgncmlnaHRjbGljaycsIHRoaXMucmlnaHRDbGljayk7XG4gICAgICAgIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudEVtaXR0ZXIsIGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgX3RoaXMuX2V2ZW50U3Vic2NyaXB0aW9ucy5wdXNoKF90aGlzLl9tYW5hZ2VyLmNyZWF0ZUV2ZW50T2JzZXJ2YWJsZShldmVudE5hbWUsIF90aGlzKS5zdWJzY3JpYmUoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChldmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncmFkaXVzX2NoYW5nZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX21hbmFnZXIuZ2V0UmFkaXVzKF90aGlzKS50aGVuKGZ1bmN0aW9uIChyYWRpdXMpIHsgcmV0dXJuIGV2ZW50RW1pdHRlci5lbWl0KHJhZGl1cyk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NlbnRlcl9jaGFuZ2VkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9tYW5hZ2VyLmdldENlbnRlcihfdGhpcykudGhlbihmdW5jdGlvbiAoY2VudGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50RW1pdHRlci5lbWl0KHsgbGF0OiBjZW50ZXIubGF0KCksIGxuZzogY2VudGVyLmxuZygpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50RW1pdHRlci5lbWl0KHsgY29vcmRzOiB7IGxhdDogdmFsdWUubGF0TG5nLmxhdCgpLCBsbmc6IHZhbHVlLmxhdExuZy5sbmcoKSB9IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgU2VibUdvb2dsZU1hcENpcmNsZS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50U3Vic2NyaXB0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7IHMudW5zdWJzY3JpYmUoKTsgfSk7XG4gICAgICAgIHRoaXMuX2V2ZW50U3Vic2NyaXB0aW9ucyA9IG51bGw7XG4gICAgICAgIHRoaXMuX21hbmFnZXIucmVtb3ZlQ2lyY2xlKHRoaXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgTGF0TG5nQm91bmRzIG9mIHRoaXMgQ2lyY2xlLlxuICAgICAqL1xuICAgIFNlYm1Hb29nbGVNYXBDaXJjbGUucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21hbmFnZXIuZ2V0Qm91bmRzKHRoaXMpOyB9O1xuICAgIFNlYm1Hb29nbGVNYXBDaXJjbGUucHJvdG90eXBlLmdldENlbnRlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21hbmFnZXIuZ2V0Q2VudGVyKHRoaXMpOyB9O1xuICAgIFNlYm1Hb29nbGVNYXBDaXJjbGUuX21hcE9wdGlvbnMgPSBbXG4gICAgICAgICdmaWxsQ29sb3InLCAnZmlsbE9wYWNpdHknLCAnc3Ryb2tlQ29sb3InLCAnc3Ryb2tlT3BhY2l0eScsICdzdHJva2VQb3NpdGlvbicsICdzdHJva2VXZWlnaHQnLFxuICAgICAgICAndmlzaWJsZScsICd6SW5kZXgnXG4gICAgXTtcbiAgICBTZWJtR29vZ2xlTWFwQ2lyY2xlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdzZWJtLWdvb2dsZS1tYXAtY2lyY2xlJyxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGF0aXR1ZGUnLCAnbG9uZ2l0dWRlJywgJ2NsaWNrYWJsZScsICdkcmFnZ2FibGU6IGNpcmNsZURyYWdnYWJsZScsICdlZGl0YWJsZScsICdmaWxsQ29sb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZpbGxPcGFjaXR5JywgJ3JhZGl1cycsICdzdHJva2VDb2xvcicsICdzdHJva2VPcGFjaXR5JywgJ3N0cm9rZVBvc2l0aW9uJywgJ3N0cm9rZVdlaWdodCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndmlzaWJsZScsICd6SW5kZXgnXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjZW50ZXJDaGFuZ2UnLCAnY2lyY2xlQ2xpY2snLCAnY2lyY2xlRGJsQ2xpY2snLCAnZHJhZycsICdkcmFnRW5kJywgJ2RyYWdTdGFydCcsICdtb3VzZURvd24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21vdXNlTW92ZScsICdtb3VzZU91dCcsICdtb3VzZU92ZXInLCAnbW91c2VVcCcsICdyYWRpdXNDaGFuZ2UnLCAncmlnaHRDbGljaydcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgU2VibUdvb2dsZU1hcENpcmNsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBjaXJjbGVfbWFuYWdlcl8xLkNpcmNsZU1hbmFnZXIsIH0sXG4gICAgXTsgfTtcbiAgICByZXR1cm4gU2VibUdvb2dsZU1hcENpcmNsZTtcbn0oKSk7XG5leHBvcnRzLlNlYm1Hb29nbGVNYXBDaXJjbGUgPSBTZWJtR29vZ2xlTWFwQ2lyY2xlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z29vZ2xlLW1hcC1jaXJjbGUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvZGlyZWN0aXZlcy9nb29nbGUtbWFwLWNpcmNsZS5qc1xuLy8gbW9kdWxlIGlkID0gNzI5XG4vLyBtb2R1bGUgY2h1bmtzID0gNSA4Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 730:
/* unknown exports provided */
/* all exports used */
/*!************************************************************************!*\
  !*** ./~/angular2-google-maps/core/directives/google-map-kml-layer.js ***!
  \************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar core_1 = __webpack_require__(/*! @angular/core */ 0);\nvar kml_layer_manager_1 = __webpack_require__(/*! ./../services/managers/kml-layer-manager */ 717);\nvar layerId = 0;\nvar SebmGoogleMapKmlLayer = (function () {\n    function SebmGoogleMapKmlLayer(_manager) {\n        this._manager = _manager;\n        this._addedToManager = false;\n        this._id = (layerId++).toString();\n        this._subscriptions = [];\n        /**\n         * If true, the layer receives mouse events. Default value is true.\n         */\n        this.clickable = true;\n        /**\n         * By default, the input map is centered and zoomed to the bounding box of the contents of the\n         * layer.\n         * If this option is set to true, the viewport is left unchanged, unless the map's center and zoom\n         * were never set.\n         */\n        this.preserveViewport = false;\n        /**\n         * Whether to render the screen overlays. Default true.\n         */\n        this.screenOverlays = true;\n        /**\n         * Suppress the rendering of info windows when layer features are clicked.\n         */\n        this.suppressInfoWindows = false;\n        /**\n         * The URL of the KML document to display.\n         */\n        this.url = null;\n        /**\n         * The z-index of the layer.\n         */\n        this.zIndex = null;\n        /**\n         * This event is fired when a feature in the layer is clicked.\n         */\n        this.layerClick = new core_1.EventEmitter();\n        /**\n         * This event is fired when the KML layers default viewport has changed.\n         */\n        this.defaultViewportChange = new core_1.EventEmitter();\n        /**\n         * This event is fired when the KML layer has finished loading.\n         * At this point it is safe to read the status property to determine if the layer loaded\n         * successfully.\n         */\n        this.statusChange = new core_1.EventEmitter();\n    }\n    SebmGoogleMapKmlLayer.prototype.ngOnInit = function () {\n        if (this._addedToManager) {\n            return;\n        }\n        this._manager.addKmlLayer(this);\n        this._addedToManager = true;\n        this._addEventListeners();\n    };\n    SebmGoogleMapKmlLayer.prototype.ngOnChanges = function (changes) {\n        if (!this._addedToManager) {\n            return;\n        }\n        this._updatePolygonOptions(changes);\n    };\n    SebmGoogleMapKmlLayer.prototype._updatePolygonOptions = function (changes) {\n        var options = Object.keys(changes)\n            .filter(function (k) { return SebmGoogleMapKmlLayer._kmlLayerOptions.indexOf(k) !== -1; })\n            .reduce(function (obj, k) {\n            obj[k] = changes[k].currentValue;\n            return obj;\n        }, {});\n        if (Object.keys(options).length > 0) {\n            this._manager.setOptions(this, options);\n        }\n    };\n    SebmGoogleMapKmlLayer.prototype._addEventListeners = function () {\n        var _this = this;\n        var listeners = [\n            { name: 'click', handler: function (ev) { return _this.layerClick.emit(ev); } },\n            { name: 'defaultviewport_changed', handler: function () { return _this.defaultViewportChange.emit(); } },\n            { name: 'status_changed', handler: function () { return _this.statusChange.emit(); } },\n        ];\n        listeners.forEach(function (obj) {\n            var os = _this._manager.createEventObservable(obj.name, _this).subscribe(obj.handler);\n            _this._subscriptions.push(os);\n        });\n    };\n    /** @internal */\n    SebmGoogleMapKmlLayer.prototype.id = function () { return this._id; };\n    /** @internal */\n    SebmGoogleMapKmlLayer.prototype.toString = function () { return \"SebmGoogleMapKmlLayer-\" + this._id.toString(); };\n    /** @internal */\n    SebmGoogleMapKmlLayer.prototype.ngOnDestroy = function () {\n        this._manager.deleteKmlLayer(this);\n        // unsubscribe all registered observable subscriptions\n        this._subscriptions.forEach(function (s) { return s.unsubscribe(); });\n    };\n    SebmGoogleMapKmlLayer._kmlLayerOptions = ['clickable', 'preserveViewport', 'screenOverlays', 'suppressInfoWindows', 'url', 'zIndex'];\n    SebmGoogleMapKmlLayer.decorators = [\n        { type: core_1.Directive, args: [{\n                    selector: 'sebm-google-map-kml-layer',\n                    inputs: ['clickable', 'preserveViewport', 'screenOverlays', 'suppressInfoWindows', 'url', 'zIndex'],\n                    outputs: ['layerClick', 'defaultViewportChange', 'statusChange']\n                },] },\n    ];\n    /** @nocollapse */\n    SebmGoogleMapKmlLayer.ctorParameters = function () { return [\n        { type: kml_layer_manager_1.KmlLayerManager, },\n    ]; };\n    return SebmGoogleMapKmlLayer;\n}());\nexports.SebmGoogleMapKmlLayer = SebmGoogleMapKmlLayer;\n//# sourceMappingURL=google-map-kml-layer.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzMwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC1rbWwtbGF5ZXIuanM/MDBlYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIga21sX2xheWVyX21hbmFnZXJfMSA9IHJlcXVpcmUoJy4vLi4vc2VydmljZXMvbWFuYWdlcnMva21sLWxheWVyLW1hbmFnZXInKTtcbnZhciBsYXllcklkID0gMDtcbnZhciBTZWJtR29vZ2xlTWFwS21sTGF5ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlYm1Hb29nbGVNYXBLbWxMYXllcihfbWFuYWdlcikge1xuICAgICAgICB0aGlzLl9tYW5hZ2VyID0gX21hbmFnZXI7XG4gICAgICAgIHRoaXMuX2FkZGVkVG9NYW5hZ2VyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lkID0gKGxheWVySWQrKykudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdHJ1ZSwgdGhlIGxheWVyIHJlY2VpdmVzIG1vdXNlIGV2ZW50cy4gRGVmYXVsdCB2YWx1ZSBpcyB0cnVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGlja2FibGUgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQnkgZGVmYXVsdCwgdGhlIGlucHV0IG1hcCBpcyBjZW50ZXJlZCBhbmQgem9vbWVkIHRvIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIGNvbnRlbnRzIG9mIHRoZVxuICAgICAgICAgKiBsYXllci5cbiAgICAgICAgICogSWYgdGhpcyBvcHRpb24gaXMgc2V0IHRvIHRydWUsIHRoZSB2aWV3cG9ydCBpcyBsZWZ0IHVuY2hhbmdlZCwgdW5sZXNzIHRoZSBtYXAncyBjZW50ZXIgYW5kIHpvb21cbiAgICAgICAgICogd2VyZSBuZXZlciBzZXQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByZXNlcnZlVmlld3BvcnQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdG8gcmVuZGVyIHRoZSBzY3JlZW4gb3ZlcmxheXMuIERlZmF1bHQgdHJ1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2NyZWVuT3ZlcmxheXMgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3VwcHJlc3MgdGhlIHJlbmRlcmluZyBvZiBpbmZvIHdpbmRvd3Mgd2hlbiBsYXllciBmZWF0dXJlcyBhcmUgY2xpY2tlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3VwcHJlc3NJbmZvV2luZG93cyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFVSTCBvZiB0aGUgS01MIGRvY3VtZW50IHRvIGRpc3BsYXkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVybCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgei1pbmRleCBvZiB0aGUgbGF5ZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnpJbmRleCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gYSBmZWF0dXJlIGluIHRoZSBsYXllciBpcyBjbGlja2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXllckNsaWNrID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgS01MIGxheWVycyBkZWZhdWx0IHZpZXdwb3J0IGhhcyBjaGFuZ2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZWZhdWx0Vmlld3BvcnRDaGFuZ2UgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBLTUwgbGF5ZXIgaGFzIGZpbmlzaGVkIGxvYWRpbmcuXG4gICAgICAgICAqIEF0IHRoaXMgcG9pbnQgaXQgaXMgc2FmZSB0byByZWFkIHRoZSBzdGF0dXMgcHJvcGVydHkgdG8gZGV0ZXJtaW5lIGlmIHRoZSBsYXllciBsb2FkZWRcbiAgICAgICAgICogc3VjY2Vzc2Z1bGx5LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGF0dXNDaGFuZ2UgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBTZWJtR29vZ2xlTWFwS21sTGF5ZXIucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fYWRkZWRUb01hbmFnZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tYW5hZ2VyLmFkZEttbExheWVyKHRoaXMpO1xuICAgICAgICB0aGlzLl9hZGRlZFRvTWFuYWdlciA9IHRydWU7XG4gICAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwS21sTGF5ZXIucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9hZGRlZFRvTWFuYWdlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VwZGF0ZVBvbHlnb25PcHRpb25zKGNoYW5nZXMpO1xuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcEttbExheWVyLnByb3RvdHlwZS5fdXBkYXRlUG9seWdvbk9wdGlvbnMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IE9iamVjdC5rZXlzKGNoYW5nZXMpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrKSB7IHJldHVybiBTZWJtR29vZ2xlTWFwS21sTGF5ZXIuX2ttbExheWVyT3B0aW9ucy5pbmRleE9mKGspICE9PSAtMTsgfSlcbiAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwgaykge1xuICAgICAgICAgICAgb2JqW2tdID0gY2hhbmdlc1trXS5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhvcHRpb25zKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9tYW5hZ2VyLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNlYm1Hb29nbGVNYXBLbWxMYXllci5wcm90b3R5cGUuX2FkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0gW1xuICAgICAgICAgICAgeyBuYW1lOiAnY2xpY2snLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLmxheWVyQ2xpY2suZW1pdChldik7IH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2RlZmF1bHR2aWV3cG9ydF9jaGFuZ2VkJywgaGFuZGxlcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZGVmYXVsdFZpZXdwb3J0Q2hhbmdlLmVtaXQoKTsgfSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnc3RhdHVzX2NoYW5nZWQnLCBoYW5kbGVyOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zdGF0dXNDaGFuZ2UuZW1pdCgpOyB9IH0sXG4gICAgICAgIF07XG4gICAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHZhciBvcyA9IF90aGlzLl9tYW5hZ2VyLmNyZWF0ZUV2ZW50T2JzZXJ2YWJsZShvYmoubmFtZSwgX3RoaXMpLnN1YnNjcmliZShvYmouaGFuZGxlcik7XG4gICAgICAgICAgICBfdGhpcy5fc3Vic2NyaXB0aW9ucy5wdXNoKG9zKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgU2VibUdvb2dsZU1hcEttbExheWVyLnByb3RvdHlwZS5pZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2lkOyB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwS21sTGF5ZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJTZWJtR29vZ2xlTWFwS21sTGF5ZXItXCIgKyB0aGlzLl9pZC50b1N0cmluZygpOyB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwS21sTGF5ZXIucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9tYW5hZ2VyLmRlbGV0ZUttbExheWVyKHRoaXMpO1xuICAgICAgICAvLyB1bnN1YnNjcmliZSBhbGwgcmVnaXN0ZXJlZCBvYnNlcnZhYmxlIHN1YnNjcmlwdGlvbnNcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnVuc3Vic2NyaWJlKCk7IH0pO1xuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcEttbExheWVyLl9rbWxMYXllck9wdGlvbnMgPSBbJ2NsaWNrYWJsZScsICdwcmVzZXJ2ZVZpZXdwb3J0JywgJ3NjcmVlbk92ZXJsYXlzJywgJ3N1cHByZXNzSW5mb1dpbmRvd3MnLCAndXJsJywgJ3pJbmRleCddO1xuICAgIFNlYm1Hb29nbGVNYXBLbWxMYXllci5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnc2VibS1nb29nbGUtbWFwLWttbC1sYXllcicsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0czogWydjbGlja2FibGUnLCAncHJlc2VydmVWaWV3cG9ydCcsICdzY3JlZW5PdmVybGF5cycsICdzdXBwcmVzc0luZm9XaW5kb3dzJywgJ3VybCcsICd6SW5kZXgnXSxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0czogWydsYXllckNsaWNrJywgJ2RlZmF1bHRWaWV3cG9ydENoYW5nZScsICdzdGF0dXNDaGFuZ2UnXVxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgU2VibUdvb2dsZU1hcEttbExheWVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IGttbF9sYXllcl9tYW5hZ2VyXzEuS21sTGF5ZXJNYW5hZ2VyLCB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIFNlYm1Hb29nbGVNYXBLbWxMYXllcjtcbn0oKSk7XG5leHBvcnRzLlNlYm1Hb29nbGVNYXBLbWxMYXllciA9IFNlYm1Hb29nbGVNYXBLbWxMYXllcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdvb2dsZS1tYXAta21sLWxheWVyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC1rbWwtbGF5ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDczMFxuLy8gbW9kdWxlIGNodW5rcyA9IDUgOCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 731:
/* unknown exports provided */
/* all exports used */
/*!*********************************************************************!*\
  !*** ./~/angular2-google-maps/core/directives/google-map-marker.js ***!
  \*********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar core_1 = __webpack_require__(/*! @angular/core */ 0);\nvar marker_manager_1 = __webpack_require__(/*! ../services/managers/marker-manager */ 710);\nvar google_map_info_window_1 = __webpack_require__(/*! ./google-map-info-window */ 713);\nvar markerId = 0;\n/**\n * SebmGoogleMapMarker renders a map marker inside a {@link SebmGoogleMap}.\n *\n * ### Example\n * ```typescript\n * import { Component } from 'angular2/core';\n * import { SebmGoogleMap, SebmGoogleMapMarker } from 'angular2-google-maps/core';\n *\n * @Component({\n *  selector: 'my-map-cmp',\n *  directives: [SebmGoogleMap, SebmGoogleMapMarker],\n *  styles: [`\n *    .sebm-google-map-container {\n *      height: 300px;\n *    }\n * `],\n *  template: `\n *    <sebm-google-map [latitude]=\"lat\" [longitude]=\"lng\" [zoom]=\"zoom\">\n *      <sebm-google-map-marker [latitude]=\"lat\" [longitude]=\"lng\" [label]=\"'M'\">\n *      </sebm-google-map-marker>\n *    </sebm-google-map>\n *  `\n * })\n * ```\n */\nvar SebmGoogleMapMarker = (function () {\n    function SebmGoogleMapMarker(_markerManager) {\n        this._markerManager = _markerManager;\n        /**\n         * If true, the marker can be dragged. Default value is false.\n         */\n        this.draggable = false;\n        /**\n         * If true, the marker is visible\n         */\n        this.visible = true;\n        /**\n         * Whether to automatically open the child info window when the marker is clicked.\n         */\n        this.openInfoWindow = true;\n        /**\n         * The marker's opacity between 0.0 and 1.0.\n         */\n        this.opacity = 1;\n        /**\n         * All markers are displayed on the map in order of their zIndex, with higher values displaying in\n         * front of markers with lower values. By default, markers are displayed according to their\n         * vertical position on screen, with lower markers appearing in front of markers further up the\n         * screen.\n         */\n        this.zIndex = 1;\n        /**\n         * This event emitter gets emitted when the user clicks on the marker.\n         */\n        this.markerClick = new core_1.EventEmitter();\n        /**\n         * This event is fired when the user stops dragging the marker.\n         */\n        this.dragEnd = new core_1.EventEmitter();\n        /**\n         * This event is fired when the user mouses over the marker.\n         */\n        this.mouseOver = new core_1.EventEmitter();\n        /**\n         * This event is fired when the user mouses outside the marker.\n         */\n        this.mouseOut = new core_1.EventEmitter();\n        this._markerAddedToManger = false;\n        this._observableSubscriptions = [];\n        this._id = (markerId++).toString();\n    }\n    /* @internal */\n    SebmGoogleMapMarker.prototype.ngAfterContentInit = function () {\n        if (this.infoWindow != null) {\n            this.infoWindow.hostMarker = this;\n        }\n    };\n    /** @internal */\n    SebmGoogleMapMarker.prototype.ngOnChanges = function (changes) {\n        if (typeof this.latitude !== 'number' || typeof this.longitude !== 'number') {\n            return;\n        }\n        if (!this._markerAddedToManger) {\n            this._markerManager.addMarker(this);\n            this._markerAddedToManger = true;\n            this._addEventListeners();\n            return;\n        }\n        if (changes['latitude'] || changes['longitude']) {\n            this._markerManager.updateMarkerPosition(this);\n        }\n        if (changes['title']) {\n            this._markerManager.updateTitle(this);\n        }\n        if (changes['label']) {\n            this._markerManager.updateLabel(this);\n        }\n        if (changes['draggable']) {\n            this._markerManager.updateDraggable(this);\n        }\n        if (changes['iconUrl']) {\n            this._markerManager.updateIcon(this);\n        }\n        if (changes['opacity']) {\n            this._markerManager.updateOpacity(this);\n        }\n        if (changes['visible']) {\n            this._markerManager.updateVisible(this);\n        }\n        if (changes['zIndex']) {\n            this._markerManager.updateZIndex(this);\n        }\n    };\n    SebmGoogleMapMarker.prototype._addEventListeners = function () {\n        var _this = this;\n        var cs = this._markerManager.createEventObservable('click', this).subscribe(function () {\n            if (_this.openInfoWindow && _this.infoWindow != null) {\n                _this.infoWindow.open();\n            }\n            _this.markerClick.emit(null);\n        });\n        this._observableSubscriptions.push(cs);\n        var ds = this._markerManager.createEventObservable('dragend', this)\n            .subscribe(function (e) {\n            _this.dragEnd.emit({ coords: { lat: e.latLng.lat(), lng: e.latLng.lng() } });\n        });\n        this._observableSubscriptions.push(ds);\n        var mover = this._markerManager.createEventObservable('mouseover', this)\n            .subscribe(function (e) {\n            _this.mouseOver.emit({ coords: { lat: e.latLng.lat(), lng: e.latLng.lng() } });\n        });\n        this._observableSubscriptions.push(mover);\n        var mout = this._markerManager.createEventObservable('mouseout', this)\n            .subscribe(function (e) {\n            _this.mouseOut.emit({ coords: { lat: e.latLng.lat(), lng: e.latLng.lng() } });\n        });\n        this._observableSubscriptions.push(mout);\n    };\n    /** @internal */\n    SebmGoogleMapMarker.prototype.id = function () { return this._id; };\n    /** @internal */\n    SebmGoogleMapMarker.prototype.toString = function () { return 'SebmGoogleMapMarker-' + this._id.toString(); };\n    /** @internal */\n    SebmGoogleMapMarker.prototype.ngOnDestroy = function () {\n        this._markerManager.deleteMarker(this);\n        // unsubscribe all registered observable subscriptions\n        this._observableSubscriptions.forEach(function (s) { return s.unsubscribe(); });\n    };\n    SebmGoogleMapMarker.decorators = [\n        { type: core_1.Directive, args: [{\n                    selector: 'sebm-google-map-marker',\n                    inputs: [\n                        'latitude', 'longitude', 'title', 'label', 'draggable: markerDraggable', 'iconUrl',\n                        'openInfoWindow', 'opacity', 'visible', 'zIndex'\n                    ],\n                    outputs: ['markerClick', 'dragEnd', 'mouseOver', 'mouseOut']\n                },] },\n    ];\n    /** @nocollapse */\n    SebmGoogleMapMarker.ctorParameters = function () { return [\n        { type: marker_manager_1.MarkerManager, },\n    ]; };\n    SebmGoogleMapMarker.propDecorators = {\n        'infoWindow': [{ type: core_1.ContentChild, args: [google_map_info_window_1.SebmGoogleMapInfoWindow,] },],\n    };\n    return SebmGoogleMapMarker;\n}());\nexports.SebmGoogleMapMarker = SebmGoogleMapMarker;\n//# sourceMappingURL=google-map-marker.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzMxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC1tYXJrZXIuanM/ZDEyNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XG52YXIgbWFya2VyX21hbmFnZXJfMSA9IHJlcXVpcmUoJy4uL3NlcnZpY2VzL21hbmFnZXJzL21hcmtlci1tYW5hZ2VyJyk7XG52YXIgZ29vZ2xlX21hcF9pbmZvX3dpbmRvd18xID0gcmVxdWlyZSgnLi9nb29nbGUtbWFwLWluZm8td2luZG93Jyk7XG52YXIgbWFya2VySWQgPSAwO1xuLyoqXG4gKiBTZWJtR29vZ2xlTWFwTWFya2VyIHJlbmRlcnMgYSBtYXAgbWFya2VyIGluc2lkZSBhIHtAbGluayBTZWJtR29vZ2xlTWFwfS5cbiAqXG4gKiAjIyMgRXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnYW5ndWxhcjIvY29yZSc7XG4gKiBpbXBvcnQgeyBTZWJtR29vZ2xlTWFwLCBTZWJtR29vZ2xlTWFwTWFya2VyIH0gZnJvbSAnYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZSc7XG4gKlxuICogQENvbXBvbmVudCh7XG4gKiAgc2VsZWN0b3I6ICdteS1tYXAtY21wJyxcbiAqICBkaXJlY3RpdmVzOiBbU2VibUdvb2dsZU1hcCwgU2VibUdvb2dsZU1hcE1hcmtlcl0sXG4gKiAgc3R5bGVzOiBbYFxuICogICAgLnNlYm0tZ29vZ2xlLW1hcC1jb250YWluZXIge1xuICogICAgICBoZWlnaHQ6IDMwMHB4O1xuICogICAgfVxuICogYF0sXG4gKiAgdGVtcGxhdGU6IGBcbiAqICAgIDxzZWJtLWdvb2dsZS1tYXAgW2xhdGl0dWRlXT1cImxhdFwiIFtsb25naXR1ZGVdPVwibG5nXCIgW3pvb21dPVwiem9vbVwiPlxuICogICAgICA8c2VibS1nb29nbGUtbWFwLW1hcmtlciBbbGF0aXR1ZGVdPVwibGF0XCIgW2xvbmdpdHVkZV09XCJsbmdcIiBbbGFiZWxdPVwiJ00nXCI+XG4gKiAgICAgIDwvc2VibS1nb29nbGUtbWFwLW1hcmtlcj5cbiAqICAgIDwvc2VibS1nb29nbGUtbWFwPlxuICogIGBcbiAqIH0pXG4gKiBgYGBcbiAqL1xudmFyIFNlYm1Hb29nbGVNYXBNYXJrZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlYm1Hb29nbGVNYXBNYXJrZXIoX21hcmtlck1hbmFnZXIpIHtcbiAgICAgICAgdGhpcy5fbWFya2VyTWFuYWdlciA9IF9tYXJrZXJNYW5hZ2VyO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdHJ1ZSwgdGhlIG1hcmtlciBjYW4gYmUgZHJhZ2dlZC4gRGVmYXVsdCB2YWx1ZSBpcyBmYWxzZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cnVlLCB0aGUgbWFya2VyIGlzIHZpc2libGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRvIGF1dG9tYXRpY2FsbHkgb3BlbiB0aGUgY2hpbGQgaW5mbyB3aW5kb3cgd2hlbiB0aGUgbWFya2VyIGlzIGNsaWNrZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wZW5JbmZvV2luZG93ID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtYXJrZXIncyBvcGFjaXR5IGJldHdlZW4gMC4wIGFuZCAxLjAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wYWNpdHkgPSAxO1xuICAgICAgICAvKipcbiAgICAgICAgICogQWxsIG1hcmtlcnMgYXJlIGRpc3BsYXllZCBvbiB0aGUgbWFwIGluIG9yZGVyIG9mIHRoZWlyIHpJbmRleCwgd2l0aCBoaWdoZXIgdmFsdWVzIGRpc3BsYXlpbmcgaW5cbiAgICAgICAgICogZnJvbnQgb2YgbWFya2VycyB3aXRoIGxvd2VyIHZhbHVlcy4gQnkgZGVmYXVsdCwgbWFya2VycyBhcmUgZGlzcGxheWVkIGFjY29yZGluZyB0byB0aGVpclxuICAgICAgICAgKiB2ZXJ0aWNhbCBwb3NpdGlvbiBvbiBzY3JlZW4sIHdpdGggbG93ZXIgbWFya2VycyBhcHBlYXJpbmcgaW4gZnJvbnQgb2YgbWFya2VycyBmdXJ0aGVyIHVwIHRoZVxuICAgICAgICAgKiBzY3JlZW4uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnpJbmRleCA9IDE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGVtaXR0ZXIgZ2V0cyBlbWl0dGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSBtYXJrZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hcmtlckNsaWNrID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgdXNlciBzdG9wcyBkcmFnZ2luZyB0aGUgbWFya2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kcmFnRW5kID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgdXNlciBtb3VzZXMgb3ZlciB0aGUgbWFya2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tb3VzZU92ZXIgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSB1c2VyIG1vdXNlcyBvdXRzaWRlIHRoZSBtYXJrZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1vdXNlT3V0ID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5fbWFya2VyQWRkZWRUb01hbmdlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9vYnNlcnZhYmxlU3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLl9pZCA9IChtYXJrZXJJZCsrKS50b1N0cmluZygpO1xuICAgIH1cbiAgICAvKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwTWFya2VyLnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudEluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmluZm9XaW5kb3cgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5pbmZvV2luZG93Lmhvc3RNYXJrZXIgPSB0aGlzO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgU2VibUdvb2dsZU1hcE1hcmtlci5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMubGF0aXR1ZGUgIT09ICdudW1iZXInIHx8IHR5cGVvZiB0aGlzLmxvbmdpdHVkZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX21hcmtlckFkZGVkVG9NYW5nZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcmtlck1hbmFnZXIuYWRkTWFya2VyKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fbWFya2VyQWRkZWRUb01hbmdlciA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzWydsYXRpdHVkZSddIHx8IGNoYW5nZXNbJ2xvbmdpdHVkZSddKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJNYW5hZ2VyLnVwZGF0ZU1hcmtlclBvc2l0aW9uKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzWyd0aXRsZSddKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJNYW5hZ2VyLnVwZGF0ZVRpdGxlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzWydsYWJlbCddKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJNYW5hZ2VyLnVwZGF0ZUxhYmVsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzWydkcmFnZ2FibGUnXSkge1xuICAgICAgICAgICAgdGhpcy5fbWFya2VyTWFuYWdlci51cGRhdGVEcmFnZ2FibGUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXNbJ2ljb25VcmwnXSkge1xuICAgICAgICAgICAgdGhpcy5fbWFya2VyTWFuYWdlci51cGRhdGVJY29uKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VzWydvcGFjaXR5J10pIHtcbiAgICAgICAgICAgIHRoaXMuX21hcmtlck1hbmFnZXIudXBkYXRlT3BhY2l0eSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlc1sndmlzaWJsZSddKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJNYW5hZ2VyLnVwZGF0ZVZpc2libGUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXNbJ3pJbmRleCddKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJNYW5hZ2VyLnVwZGF0ZVpJbmRleCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcE1hcmtlci5wcm90b3R5cGUuX2FkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY3MgPSB0aGlzLl9tYXJrZXJNYW5hZ2VyLmNyZWF0ZUV2ZW50T2JzZXJ2YWJsZSgnY2xpY2snLCB0aGlzKS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLm9wZW5JbmZvV2luZG93ICYmIF90aGlzLmluZm9XaW5kb3cgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmluZm9XaW5kb3cub3BlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMubWFya2VyQ2xpY2suZW1pdChudWxsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX29ic2VydmFibGVTdWJzY3JpcHRpb25zLnB1c2goY3MpO1xuICAgICAgICB2YXIgZHMgPSB0aGlzLl9tYXJrZXJNYW5hZ2VyLmNyZWF0ZUV2ZW50T2JzZXJ2YWJsZSgnZHJhZ2VuZCcsIHRoaXMpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBfdGhpcy5kcmFnRW5kLmVtaXQoeyBjb29yZHM6IHsgbGF0OiBlLmxhdExuZy5sYXQoKSwgbG5nOiBlLmxhdExuZy5sbmcoKSB9IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fb2JzZXJ2YWJsZVN1YnNjcmlwdGlvbnMucHVzaChkcyk7XG4gICAgICAgIHZhciBtb3ZlciA9IHRoaXMuX21hcmtlck1hbmFnZXIuY3JlYXRlRXZlbnRPYnNlcnZhYmxlKCdtb3VzZW92ZXInLCB0aGlzKVxuICAgICAgICAgICAgLnN1YnNjcmliZShmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgX3RoaXMubW91c2VPdmVyLmVtaXQoeyBjb29yZHM6IHsgbGF0OiBlLmxhdExuZy5sYXQoKSwgbG5nOiBlLmxhdExuZy5sbmcoKSB9IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fb2JzZXJ2YWJsZVN1YnNjcmlwdGlvbnMucHVzaChtb3Zlcik7XG4gICAgICAgIHZhciBtb3V0ID0gdGhpcy5fbWFya2VyTWFuYWdlci5jcmVhdGVFdmVudE9ic2VydmFibGUoJ21vdXNlb3V0JywgdGhpcylcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIF90aGlzLm1vdXNlT3V0LmVtaXQoeyBjb29yZHM6IHsgbGF0OiBlLmxhdExuZy5sYXQoKSwgbG5nOiBlLmxhdExuZy5sbmcoKSB9IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fb2JzZXJ2YWJsZVN1YnNjcmlwdGlvbnMucHVzaChtb3V0KTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwTWFya2VyLnByb3RvdHlwZS5pZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2lkOyB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwTWFya2VyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdTZWJtR29vZ2xlTWFwTWFya2VyLScgKyB0aGlzLl9pZC50b1N0cmluZygpOyB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwTWFya2VyLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbWFya2VyTWFuYWdlci5kZWxldGVNYXJrZXIodGhpcyk7XG4gICAgICAgIC8vIHVuc3Vic2NyaWJlIGFsbCByZWdpc3RlcmVkIG9ic2VydmFibGUgc3Vic2NyaXB0aW9uc1xuICAgICAgICB0aGlzLl9vYnNlcnZhYmxlU3Vic2NyaXB0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnVuc3Vic2NyaWJlKCk7IH0pO1xuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcE1hcmtlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnc2VibS1nb29nbGUtbWFwLW1hcmtlcicsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2xhdGl0dWRlJywgJ2xvbmdpdHVkZScsICd0aXRsZScsICdsYWJlbCcsICdkcmFnZ2FibGU6IG1hcmtlckRyYWdnYWJsZScsICdpY29uVXJsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdvcGVuSW5mb1dpbmRvdycsICdvcGFjaXR5JywgJ3Zpc2libGUnLCAnekluZGV4J1xuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRzOiBbJ21hcmtlckNsaWNrJywgJ2RyYWdFbmQnLCAnbW91c2VPdmVyJywgJ21vdXNlT3V0J11cbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIFNlYm1Hb29nbGVNYXBNYXJrZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogbWFya2VyX21hbmFnZXJfMS5NYXJrZXJNYW5hZ2VyLCB9LFxuICAgIF07IH07XG4gICAgU2VibUdvb2dsZU1hcE1hcmtlci5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgJ2luZm9XaW5kb3cnOiBbeyB0eXBlOiBjb3JlXzEuQ29udGVudENoaWxkLCBhcmdzOiBbZ29vZ2xlX21hcF9pbmZvX3dpbmRvd18xLlNlYm1Hb29nbGVNYXBJbmZvV2luZG93LF0gfSxdLFxuICAgIH07XG4gICAgcmV0dXJuIFNlYm1Hb29nbGVNYXBNYXJrZXI7XG59KCkpO1xuZXhwb3J0cy5TZWJtR29vZ2xlTWFwTWFya2VyID0gU2VibUdvb2dsZU1hcE1hcmtlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdvb2dsZS1tYXAtbWFya2VyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC1tYXJrZXIuanNcbi8vIG1vZHVsZSBpZCA9IDczMVxuLy8gbW9kdWxlIGNodW5rcyA9IDUgOCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 732:
/* unknown exports provided */
/* all exports used */
/*!**********************************************************************!*\
  !*** ./~/angular2-google-maps/core/directives/google-map-polygon.js ***!
  \**********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar core_1 = __webpack_require__(/*! @angular/core */ 0);\nvar polygon_manager_1 = __webpack_require__(/*! ../services/managers/polygon-manager */ 718);\n/**\n * SebmGoogleMapPolygon renders a polygon on a {@link SebmGoogleMap}\n *\n * ### Example\n * ```typescript\n * import { Component } from '@angular/core';\n * import { SebmGoogleMap, SebmGooglePolygon, LatLngLiteral } from 'angular2-maps/core';\n *\n * @Component({\n *  selector: 'my-map-cmp',\n *  styles: [`\n *    .semb-map-container {\n *      height: 300px;\n *    }\n * `],\n *  template: `\n *    <semb-map [latitude]=\"lat\" [longitude]=\"lng\" [zoom]=\"zoom\">\n *      <semb-map-polygon [paths]=\"paths\">\n *      </semb-map-polygon>\n *    </semb-map>\n *  `\n * })\n * export class MyMapCmp {\n *   lat: number = 0;\n *   lng: number = 0;\n *   zoom: number = 10;\n *   paths: Array<LatLngLiteral> = [\n *     { lat: 0,  lng: 10 },\n *     { lat: 0,  lng: 20 },\n *     { lat: 10, lng: 20 },\n *     { lat: 10, lng: 10 },\n *     { lat: 0,  lng: 10 }\n *   ]\n *   // Nesting paths will create a hole where they overlap;\n *   nestedPaths: Array<Array<LatLngLiteral>> = [[\n *     { lat: 0,  lng: 10 },\n *     { lat: 0,  lng: 20 },\n *     { lat: 10, lng: 20 },\n *     { lat: 10, lng: 10 },\n *     { lat: 0,  lng: 10 }\n *   ], [\n *     { lat: 0, lng: 15 },\n *     { lat: 0, lng: 20 },\n *     { lat: 5, lng: 20 },\n *     { lat: 5, lng: 15 },\n *     { lat: 0, lng: 15 }\n *   ]]\n * }\n * ```\n */\nvar SebmGoogleMapPolygon = (function () {\n    function SebmGoogleMapPolygon(_polygonManager) {\n        this._polygonManager = _polygonManager;\n        /**\n         * Indicates whether this Polygon handles mouse events. Defaults to true.\n         */\n        this.clickable = true;\n        /**\n         * If set to true, the user can drag this shape over the map. The geodesic\n         * property defines the mode of dragging. Defaults to false.\n         */\n        this.draggable = false;\n        /**\n         * If set to true, the user can edit this shape by dragging the control\n         * points shown at the vertices and on each segment. Defaults to false.\n         */\n        this.editable = false;\n        /**\n         * When true, edges of the polygon are interpreted as geodesic and will\n         * follow the curvature of the Earth. When false, edges of the polygon are\n         * rendered as straight lines in screen space. Note that the shape of a\n         * geodesic polygon may appear to change when dragged, as the dimensions\n         * are maintained relative to the surface of the earth. Defaults to false.\n         */\n        this.geodesic = false;\n        /**\n         * The ordered sequence of coordinates that designates a closed loop.\n         * Unlike polylines, a polygon may consist of one or more paths.\n         *  As a result, the paths property may specify one or more arrays of\n         * LatLng coordinates. Paths are closed automatically; do not repeat the\n         * first vertex of the path as the last vertex. Simple polygons may be\n         * defined using a single array of LatLngs. More complex polygons may\n         * specify an array of arrays. Any simple arrays are converted into Arrays.\n         * Inserting or removing LatLngs from the Array will automatically update\n         * the polygon on the map.\n         */\n        this.paths = [];\n        /**\n         * This event is fired when the DOM click event is fired on the Polygon.\n         */\n        this.polyClick = new core_1.EventEmitter();\n        /**\n         * This event is fired when the DOM dblclick event is fired on the Polygon.\n         */\n        this.polyDblClick = new core_1.EventEmitter();\n        /**\n         * This event is repeatedly fired while the user drags the polygon.\n         */\n        this.polyDrag = new core_1.EventEmitter();\n        /**\n         * This event is fired when the user stops dragging the polygon.\n         */\n        this.polyDragEnd = new core_1.EventEmitter();\n        /**\n         * This event is fired when the user starts dragging the polygon.\n         */\n        this.polyDragStart = new core_1.EventEmitter();\n        /**\n         * This event is fired when the DOM mousedown event is fired on the Polygon.\n         */\n        this.polyMouseDown = new core_1.EventEmitter();\n        /**\n         * This event is fired when the DOM mousemove event is fired on the Polygon.\n         */\n        this.polyMouseMove = new core_1.EventEmitter();\n        /**\n         * This event is fired on Polygon mouseout.\n         */\n        this.polyMouseOut = new core_1.EventEmitter();\n        /**\n         * This event is fired on Polygon mouseover.\n         */\n        this.polyMouseOver = new core_1.EventEmitter();\n        /**\n         * This event is fired whe the DOM mouseup event is fired on the Polygon\n         */\n        this.polyMouseUp = new core_1.EventEmitter();\n        /**\n         * This even is fired when the Polygon is right-clicked on.\n         */\n        this.polyRightClick = new core_1.EventEmitter();\n        this._polygonAddedToManager = false;\n        this._subscriptions = [];\n    }\n    /** @internal */\n    SebmGoogleMapPolygon.prototype.ngAfterContentInit = function () {\n        if (!this._polygonAddedToManager) {\n            this._init();\n        }\n    };\n    SebmGoogleMapPolygon.prototype.ngOnChanges = function (changes) {\n        if (!this._polygonAddedToManager) {\n            this._init();\n            return;\n        }\n        this._polygonManager.setPolygonOptions(this, this._updatePolygonOptions(changes));\n    };\n    SebmGoogleMapPolygon.prototype._init = function () {\n        this._polygonManager.addPolygon(this);\n        this._polygonAddedToManager = true;\n        this._addEventListeners();\n    };\n    SebmGoogleMapPolygon.prototype._addEventListeners = function () {\n        var _this = this;\n        var handlers = [\n            { name: 'click', handler: function (ev) { return _this.polyClick.emit(ev); } },\n            { name: 'dbclick', handler: function (ev) { return _this.polyDblClick.emit(ev); } },\n            { name: 'drag', handler: function (ev) { return _this.polyDrag.emit(ev); } },\n            { name: 'dragend', handler: function (ev) { return _this.polyDragEnd.emit(ev); } },\n            { name: 'dragstart', handler: function (ev) { return _this.polyDragStart.emit(ev); } },\n            { name: 'mousedown', handler: function (ev) { return _this.polyMouseDown.emit(ev); } },\n            { name: 'mousemove', handler: function (ev) { return _this.polyMouseMove.emit(ev); } },\n            { name: 'mouseout', handler: function (ev) { return _this.polyMouseOut.emit(ev); } },\n            { name: 'mouseover', handler: function (ev) { return _this.polyMouseOver.emit(ev); } },\n            { name: 'mouseup', handler: function (ev) { return _this.polyMouseUp.emit(ev); } },\n            { name: 'rightclick', handler: function (ev) { return _this.polyRightClick.emit(ev); } },\n        ];\n        handlers.forEach(function (obj) {\n            var os = _this._polygonManager.createEventObservable(obj.name, _this).subscribe(obj.handler);\n            _this._subscriptions.push(os);\n        });\n    };\n    SebmGoogleMapPolygon.prototype._updatePolygonOptions = function (changes) {\n        return Object.keys(changes)\n            .filter(function (k) { return SebmGoogleMapPolygon._polygonOptionsAttributes.indexOf(k) !== -1; })\n            .reduce(function (obj, k) {\n            obj[k] = changes[k].currentValue;\n            return obj;\n        }, {});\n    };\n    /** @internal */\n    SebmGoogleMapPolygon.prototype.id = function () { return this._id; };\n    /** @internal */\n    SebmGoogleMapPolygon.prototype.ngOnDestroy = function () {\n        this._polygonManager.deletePolygon(this);\n        // unsubscribe all registered observable subscriptions\n        this._subscriptions.forEach(function (s) { return s.unsubscribe(); });\n    };\n    SebmGoogleMapPolygon._polygonOptionsAttributes = [\n        'clickable', 'draggable', 'editable', 'fillColor', 'fillOpacity', 'geodesic', 'icon', 'map',\n        'paths', 'strokeColor', 'strokeOpacity', 'strokeWeight', 'visible', 'zIndex', 'draggable',\n        'editable', 'visible'\n    ];\n    SebmGoogleMapPolygon.decorators = [\n        { type: core_1.Directive, args: [{\n                    selector: 'sebm-map-polygon',\n                    inputs: [\n                        'clickable',\n                        'draggable: polyDraggable',\n                        'editable',\n                        'fillColor',\n                        'fillOpacity',\n                        'geodesic',\n                        'paths',\n                        'strokeColor',\n                        'strokeOpacity',\n                        'strokeWeight',\n                        'visible',\n                        'zIndex',\n                    ],\n                    outputs: [\n                        'polyClick', 'polyDblClick', 'polyDrag', 'polyDragEnd', 'polyMouseDown', 'polyMouseMove',\n                        'polyMouseOut', 'polyMouseOver', 'polyMouseUp', 'polyRightClick'\n                    ]\n                },] },\n    ];\n    /** @nocollapse */\n    SebmGoogleMapPolygon.ctorParameters = function () { return [\n        { type: polygon_manager_1.PolygonManager, },\n    ]; };\n    return SebmGoogleMapPolygon;\n}());\nexports.SebmGoogleMapPolygon = SebmGoogleMapPolygon;\n//# sourceMappingURL=google-map-polygon.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzMyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC1wb2x5Z29uLmpzPzc4MGMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIHBvbHlnb25fbWFuYWdlcl8xID0gcmVxdWlyZSgnLi4vc2VydmljZXMvbWFuYWdlcnMvcG9seWdvbi1tYW5hZ2VyJyk7XG4vKipcbiAqIFNlYm1Hb29nbGVNYXBQb2x5Z29uIHJlbmRlcnMgYSBwb2x5Z29uIG9uIGEge0BsaW5rIFNlYm1Hb29nbGVNYXB9XG4gKlxuICogIyMjIEV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICogaW1wb3J0IHsgU2VibUdvb2dsZU1hcCwgU2VibUdvb2dsZVBvbHlnb24sIExhdExuZ0xpdGVyYWwgfSBmcm9tICdhbmd1bGFyMi1tYXBzL2NvcmUnO1xuICpcbiAqIEBDb21wb25lbnQoe1xuICogIHNlbGVjdG9yOiAnbXktbWFwLWNtcCcsXG4gKiAgc3R5bGVzOiBbYFxuICogICAgLnNlbWItbWFwLWNvbnRhaW5lciB7XG4gKiAgICAgIGhlaWdodDogMzAwcHg7XG4gKiAgICB9XG4gKiBgXSxcbiAqICB0ZW1wbGF0ZTogYFxuICogICAgPHNlbWItbWFwIFtsYXRpdHVkZV09XCJsYXRcIiBbbG9uZ2l0dWRlXT1cImxuZ1wiIFt6b29tXT1cInpvb21cIj5cbiAqICAgICAgPHNlbWItbWFwLXBvbHlnb24gW3BhdGhzXT1cInBhdGhzXCI+XG4gKiAgICAgIDwvc2VtYi1tYXAtcG9seWdvbj5cbiAqICAgIDwvc2VtYi1tYXA+XG4gKiAgYFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBNeU1hcENtcCB7XG4gKiAgIGxhdDogbnVtYmVyID0gMDtcbiAqICAgbG5nOiBudW1iZXIgPSAwO1xuICogICB6b29tOiBudW1iZXIgPSAxMDtcbiAqICAgcGF0aHM6IEFycmF5PExhdExuZ0xpdGVyYWw+ID0gW1xuICogICAgIHsgbGF0OiAwLCAgbG5nOiAxMCB9LFxuICogICAgIHsgbGF0OiAwLCAgbG5nOiAyMCB9LFxuICogICAgIHsgbGF0OiAxMCwgbG5nOiAyMCB9LFxuICogICAgIHsgbGF0OiAxMCwgbG5nOiAxMCB9LFxuICogICAgIHsgbGF0OiAwLCAgbG5nOiAxMCB9XG4gKiAgIF1cbiAqICAgLy8gTmVzdGluZyBwYXRocyB3aWxsIGNyZWF0ZSBhIGhvbGUgd2hlcmUgdGhleSBvdmVybGFwO1xuICogICBuZXN0ZWRQYXRoczogQXJyYXk8QXJyYXk8TGF0TG5nTGl0ZXJhbD4+ID0gW1tcbiAqICAgICB7IGxhdDogMCwgIGxuZzogMTAgfSxcbiAqICAgICB7IGxhdDogMCwgIGxuZzogMjAgfSxcbiAqICAgICB7IGxhdDogMTAsIGxuZzogMjAgfSxcbiAqICAgICB7IGxhdDogMTAsIGxuZzogMTAgfSxcbiAqICAgICB7IGxhdDogMCwgIGxuZzogMTAgfVxuICogICBdLCBbXG4gKiAgICAgeyBsYXQ6IDAsIGxuZzogMTUgfSxcbiAqICAgICB7IGxhdDogMCwgbG5nOiAyMCB9LFxuICogICAgIHsgbGF0OiA1LCBsbmc6IDIwIH0sXG4gKiAgICAgeyBsYXQ6IDUsIGxuZzogMTUgfSxcbiAqICAgICB7IGxhdDogMCwgbG5nOiAxNSB9XG4gKiAgIF1dXG4gKiB9XG4gKiBgYGBcbiAqL1xudmFyIFNlYm1Hb29nbGVNYXBQb2x5Z29uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZWJtR29vZ2xlTWFwUG9seWdvbihfcG9seWdvbk1hbmFnZXIpIHtcbiAgICAgICAgdGhpcy5fcG9seWdvbk1hbmFnZXIgPSBfcG9seWdvbk1hbmFnZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIFBvbHlnb24gaGFuZGxlcyBtb3VzZSBldmVudHMuIERlZmF1bHRzIHRvIHRydWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsaWNrYWJsZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHVzZXIgY2FuIGRyYWcgdGhpcyBzaGFwZSBvdmVyIHRoZSBtYXAuIFRoZSBnZW9kZXNpY1xuICAgICAgICAgKiBwcm9wZXJ0eSBkZWZpbmVzIHRoZSBtb2RlIG9mIGRyYWdnaW5nLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHVzZXIgY2FuIGVkaXQgdGhpcyBzaGFwZSBieSBkcmFnZ2luZyB0aGUgY29udHJvbFxuICAgICAgICAgKiBwb2ludHMgc2hvd24gYXQgdGhlIHZlcnRpY2VzIGFuZCBvbiBlYWNoIHNlZ21lbnQuIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lZGl0YWJsZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiB0cnVlLCBlZGdlcyBvZiB0aGUgcG9seWdvbiBhcmUgaW50ZXJwcmV0ZWQgYXMgZ2VvZGVzaWMgYW5kIHdpbGxcbiAgICAgICAgICogZm9sbG93IHRoZSBjdXJ2YXR1cmUgb2YgdGhlIEVhcnRoLiBXaGVuIGZhbHNlLCBlZGdlcyBvZiB0aGUgcG9seWdvbiBhcmVcbiAgICAgICAgICogcmVuZGVyZWQgYXMgc3RyYWlnaHQgbGluZXMgaW4gc2NyZWVuIHNwYWNlLiBOb3RlIHRoYXQgdGhlIHNoYXBlIG9mIGFcbiAgICAgICAgICogZ2VvZGVzaWMgcG9seWdvbiBtYXkgYXBwZWFyIHRvIGNoYW5nZSB3aGVuIGRyYWdnZWQsIGFzIHRoZSBkaW1lbnNpb25zXG4gICAgICAgICAqIGFyZSBtYWludGFpbmVkIHJlbGF0aXZlIHRvIHRoZSBzdXJmYWNlIG9mIHRoZSBlYXJ0aC4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdlb2Rlc2ljID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgb3JkZXJlZCBzZXF1ZW5jZSBvZiBjb29yZGluYXRlcyB0aGF0IGRlc2lnbmF0ZXMgYSBjbG9zZWQgbG9vcC5cbiAgICAgICAgICogVW5saWtlIHBvbHlsaW5lcywgYSBwb2x5Z29uIG1heSBjb25zaXN0IG9mIG9uZSBvciBtb3JlIHBhdGhzLlxuICAgICAgICAgKiAgQXMgYSByZXN1bHQsIHRoZSBwYXRocyBwcm9wZXJ0eSBtYXkgc3BlY2lmeSBvbmUgb3IgbW9yZSBhcnJheXMgb2ZcbiAgICAgICAgICogTGF0TG5nIGNvb3JkaW5hdGVzLiBQYXRocyBhcmUgY2xvc2VkIGF1dG9tYXRpY2FsbHk7IGRvIG5vdCByZXBlYXQgdGhlXG4gICAgICAgICAqIGZpcnN0IHZlcnRleCBvZiB0aGUgcGF0aCBhcyB0aGUgbGFzdCB2ZXJ0ZXguIFNpbXBsZSBwb2x5Z29ucyBtYXkgYmVcbiAgICAgICAgICogZGVmaW5lZCB1c2luZyBhIHNpbmdsZSBhcnJheSBvZiBMYXRMbmdzLiBNb3JlIGNvbXBsZXggcG9seWdvbnMgbWF5XG4gICAgICAgICAqIHNwZWNpZnkgYW4gYXJyYXkgb2YgYXJyYXlzLiBBbnkgc2ltcGxlIGFycmF5cyBhcmUgY29udmVydGVkIGludG8gQXJyYXlzLlxuICAgICAgICAgKiBJbnNlcnRpbmcgb3IgcmVtb3ZpbmcgTGF0TG5ncyBmcm9tIHRoZSBBcnJheSB3aWxsIGF1dG9tYXRpY2FsbHkgdXBkYXRlXG4gICAgICAgICAqIHRoZSBwb2x5Z29uIG9uIHRoZSBtYXAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhdGhzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBjbGljayBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWdvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucG9seUNsaWNrID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgRE9NIGRibGNsaWNrIGV2ZW50IGlzIGZpcmVkIG9uIHRoZSBQb2x5Z29uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb2x5RGJsQ2xpY2sgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyByZXBlYXRlZGx5IGZpcmVkIHdoaWxlIHRoZSB1c2VyIGRyYWdzIHRoZSBwb2x5Z29uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb2x5RHJhZyA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIHVzZXIgc3RvcHMgZHJhZ2dpbmcgdGhlIHBvbHlnb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvbHlEcmFnRW5kID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIHBvbHlnb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvbHlEcmFnU3RhcnQgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBET00gbW91c2Vkb3duIGV2ZW50IGlzIGZpcmVkIG9uIHRoZSBQb2x5Z29uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb2x5TW91c2VEb3duID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgRE9NIG1vdXNlbW92ZSBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWdvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucG9seU1vdXNlTW92ZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIG9uIFBvbHlnb24gbW91c2VvdXQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvbHlNb3VzZU91dCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIG9uIFBvbHlnb24gbW91c2VvdmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb2x5TW91c2VPdmVyID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlIHRoZSBET00gbW91c2V1cCBldmVudCBpcyBmaXJlZCBvbiB0aGUgUG9seWdvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb2x5TW91c2VVcCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW4gaXMgZmlyZWQgd2hlbiB0aGUgUG9seWdvbiBpcyByaWdodC1jbGlja2VkIG9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb2x5UmlnaHRDbGljayA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuX3BvbHlnb25BZGRlZFRvTWFuYWdlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zID0gW107XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwUG9seWdvbi5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3BvbHlnb25BZGRlZFRvTWFuYWdlcikge1xuICAgICAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwUG9seWdvbi5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICBpZiAoIXRoaXMuX3BvbHlnb25BZGRlZFRvTWFuYWdlcikge1xuICAgICAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BvbHlnb25NYW5hZ2VyLnNldFBvbHlnb25PcHRpb25zKHRoaXMsIHRoaXMuX3VwZGF0ZVBvbHlnb25PcHRpb25zKGNoYW5nZXMpKTtcbiAgICB9O1xuICAgIFNlYm1Hb29nbGVNYXBQb2x5Z29uLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcG9seWdvbk1hbmFnZXIuYWRkUG9seWdvbih0aGlzKTtcbiAgICAgICAgdGhpcy5fcG9seWdvbkFkZGVkVG9NYW5hZ2VyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9O1xuICAgIFNlYm1Hb29nbGVNYXBQb2x5Z29uLnByb3RvdHlwZS5fYWRkRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBoYW5kbGVycyA9IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ2NsaWNrJywgaGFuZGxlcjogZnVuY3Rpb24gKGV2KSB7IHJldHVybiBfdGhpcy5wb2x5Q2xpY2suZW1pdChldik7IH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2RiY2xpY2snLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLnBvbHlEYmxDbGljay5lbWl0KGV2KTsgfSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnZHJhZycsIGhhbmRsZXI6IGZ1bmN0aW9uIChldikgeyByZXR1cm4gX3RoaXMucG9seURyYWcuZW1pdChldik7IH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2RyYWdlbmQnLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLnBvbHlEcmFnRW5kLmVtaXQoZXYpOyB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdkcmFnc3RhcnQnLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLnBvbHlEcmFnU3RhcnQuZW1pdChldik7IH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ21vdXNlZG93bicsIGhhbmRsZXI6IGZ1bmN0aW9uIChldikgeyByZXR1cm4gX3RoaXMucG9seU1vdXNlRG93bi5lbWl0KGV2KTsgfSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnbW91c2Vtb3ZlJywgaGFuZGxlcjogZnVuY3Rpb24gKGV2KSB7IHJldHVybiBfdGhpcy5wb2x5TW91c2VNb3ZlLmVtaXQoZXYpOyB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdtb3VzZW91dCcsIGhhbmRsZXI6IGZ1bmN0aW9uIChldikgeyByZXR1cm4gX3RoaXMucG9seU1vdXNlT3V0LmVtaXQoZXYpOyB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdtb3VzZW92ZXInLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLnBvbHlNb3VzZU92ZXIuZW1pdChldik7IH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ21vdXNldXAnLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLnBvbHlNb3VzZVVwLmVtaXQoZXYpOyB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdyaWdodGNsaWNrJywgaGFuZGxlcjogZnVuY3Rpb24gKGV2KSB7IHJldHVybiBfdGhpcy5wb2x5UmlnaHRDbGljay5lbWl0KGV2KTsgfSB9LFxuICAgICAgICBdO1xuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHZhciBvcyA9IF90aGlzLl9wb2x5Z29uTWFuYWdlci5jcmVhdGVFdmVudE9ic2VydmFibGUob2JqLm5hbWUsIF90aGlzKS5zdWJzY3JpYmUob2JqLmhhbmRsZXIpO1xuICAgICAgICAgICAgX3RoaXMuX3N1YnNjcmlwdGlvbnMucHVzaChvcyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcFBvbHlnb24ucHJvdG90eXBlLl91cGRhdGVQb2x5Z29uT3B0aW9ucyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhjaGFuZ2VzKVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoaykgeyByZXR1cm4gU2VibUdvb2dsZU1hcFBvbHlnb24uX3BvbHlnb25PcHRpb25zQXR0cmlidXRlcy5pbmRleE9mKGspICE9PSAtMTsgfSlcbiAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwgaykge1xuICAgICAgICAgICAgb2JqW2tdID0gY2hhbmdlc1trXS5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9LCB7fSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgU2VibUdvb2dsZU1hcFBvbHlnb24ucHJvdG90eXBlLmlkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faWQ7IH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFNlYm1Hb29nbGVNYXBQb2x5Z29uLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcG9seWdvbk1hbmFnZXIuZGVsZXRlUG9seWdvbih0aGlzKTtcbiAgICAgICAgLy8gdW5zdWJzY3JpYmUgYWxsIHJlZ2lzdGVyZWQgb2JzZXJ2YWJsZSBzdWJzY3JpcHRpb25zXG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAocykgeyByZXR1cm4gcy51bnN1YnNjcmliZSgpOyB9KTtcbiAgICB9O1xuICAgIFNlYm1Hb29nbGVNYXBQb2x5Z29uLl9wb2x5Z29uT3B0aW9uc0F0dHJpYnV0ZXMgPSBbXG4gICAgICAgICdjbGlja2FibGUnLCAnZHJhZ2dhYmxlJywgJ2VkaXRhYmxlJywgJ2ZpbGxDb2xvcicsICdmaWxsT3BhY2l0eScsICdnZW9kZXNpYycsICdpY29uJywgJ21hcCcsXG4gICAgICAgICdwYXRocycsICdzdHJva2VDb2xvcicsICdzdHJva2VPcGFjaXR5JywgJ3N0cm9rZVdlaWdodCcsICd2aXNpYmxlJywgJ3pJbmRleCcsICdkcmFnZ2FibGUnLFxuICAgICAgICAnZWRpdGFibGUnLCAndmlzaWJsZSdcbiAgICBdO1xuICAgIFNlYm1Hb29nbGVNYXBQb2x5Z29uLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdzZWJtLW1hcC1wb2x5Z29uJyxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2xpY2thYmxlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkcmFnZ2FibGU6IHBvbHlEcmFnZ2FibGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2VkaXRhYmxlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmaWxsQ29sb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZpbGxPcGFjaXR5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdnZW9kZXNpYycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncGF0aHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3N0cm9rZUNvbG9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdHJva2VPcGFjaXR5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdHJva2VXZWlnaHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Zpc2libGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3pJbmRleCcsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdwb2x5Q2xpY2snLCAncG9seURibENsaWNrJywgJ3BvbHlEcmFnJywgJ3BvbHlEcmFnRW5kJywgJ3BvbHlNb3VzZURvd24nLCAncG9seU1vdXNlTW92ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAncG9seU1vdXNlT3V0JywgJ3BvbHlNb3VzZU92ZXInLCAncG9seU1vdXNlVXAnLCAncG9seVJpZ2h0Q2xpY2snXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIFNlYm1Hb29nbGVNYXBQb2x5Z29uLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IHBvbHlnb25fbWFuYWdlcl8xLlBvbHlnb25NYW5hZ2VyLCB9LFxuICAgIF07IH07XG4gICAgcmV0dXJuIFNlYm1Hb29nbGVNYXBQb2x5Z29uO1xufSgpKTtcbmV4cG9ydHMuU2VibUdvb2dsZU1hcFBvbHlnb24gPSBTZWJtR29vZ2xlTWFwUG9seWdvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdvb2dsZS1tYXAtcG9seWdvbi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9kaXJlY3RpdmVzL2dvb2dsZS1tYXAtcG9seWdvbi5qc1xuLy8gbW9kdWxlIGlkID0gNzMyXG4vLyBtb2R1bGUgY2h1bmtzID0gNSA4Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 733:
/* unknown exports provided */
/* all exports used */
/*!***********************************************************************!*\
  !*** ./~/angular2-google-maps/core/directives/google-map-polyline.js ***!
  \***********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar core_1 = __webpack_require__(/*! @angular/core */ 0);\nvar polyline_manager_1 = __webpack_require__(/*! ../services/managers/polyline-manager */ 719);\nvar google_map_polyline_point_1 = __webpack_require__(/*! ./google-map-polyline-point */ 714);\nvar polylineId = 0;\n/**\n * SebmGoogleMapPolyline renders a polyline on a {@link SebmGoogleMap}\n *\n * ### Example\n * ```typescript\n * import { Component } from 'angular2/core';\n * import { SebmGoogleMap, SebmGooglePolyline, SebmGooglePolylinePoint } from\n * 'angular2-google-maps/core';\n *\n * @Component({\n *  selector: 'my-map-cmp',\n *  directives: [SebmGoogleMap, SebmGooglePolyline, SebmGooglePolylinePoint],\n *  styles: [`\n *    .sebm-google-map-container {\n *      height: 300px;\n *    }\n * `],\n *  template: `\n *    <sebm-google-map [latitude]=\"lat\" [longitude]=\"lng\" [zoom]=\"zoom\">\n *      <sebm-google-map-polyline>\n *          <sebm-google-map-polyline-point [latitude]=\"latA\" [longitude]=\"lngA\">\n *          </sebm-google-map-polyline-point>\n *          <sebm-google-map-polyline-point [latitude]=\"latB\" [longitude]=\"lngB\">\n *          </sebm-google-map-polyline-point>\n *      </sebm-google-map-polyline>\n *    </sebm-google-map>\n *  `\n * })\n * ```\n */\nvar SebmGoogleMapPolyline = (function () {\n    function SebmGoogleMapPolyline(_polylineManager) {\n        this._polylineManager = _polylineManager;\n        /**\n         * Indicates whether this Polyline handles mouse events. Defaults to true.\n         */\n        this.clickable = true;\n        /**\n         * If set to true, the user can drag this shape over the map. The geodesic property defines the\n         * mode of dragging. Defaults to false.\n         */\n        this.draggable = false;\n        /**\n         * If set to true, the user can edit this shape by dragging the control points shown at the\n         * vertices and on each segment. Defaults to false.\n         */\n        this.editable = false;\n        /**\n         * When true, edges of the polygon are interpreted as geodesic and will follow the curvature of\n         * the Earth. When false, edges of the polygon are rendered as straight lines in screen space.\n         * Note that the shape of a geodesic polygon may appear to change when dragged, as the dimensions\n         * are maintained relative to the surface of the earth. Defaults to false.\n         */\n        this.geodesic = false;\n        /**\n         * Whether this polyline is visible on the map. Defaults to true.\n         */\n        this.visible = true;\n        /**\n         * This event is fired when the DOM click event is fired on the Polyline.\n         */\n        this.lineClick = new core_1.EventEmitter();\n        /**\n         * This event is fired when the DOM dblclick event is fired on the Polyline.\n         */\n        this.lineDblClick = new core_1.EventEmitter();\n        /**\n         * This event is repeatedly fired while the user drags the polyline.\n         */\n        this.lineDrag = new core_1.EventEmitter();\n        /**\n         * This event is fired when the user stops dragging the polyline.\n         */\n        this.lineDragEnd = new core_1.EventEmitter();\n        /**\n         * This event is fired when the user starts dragging the polyline.\n         */\n        this.lineDragStart = new core_1.EventEmitter();\n        /**\n         * This event is fired when the DOM mousedown event is fired on the Polyline.\n         */\n        this.lineMouseDown = new core_1.EventEmitter();\n        /**\n         * This event is fired when the DOM mousemove event is fired on the Polyline.\n         */\n        this.lineMouseMove = new core_1.EventEmitter();\n        /**\n         * This event is fired on Polyline mouseout.\n         */\n        this.lineMouseOut = new core_1.EventEmitter();\n        /**\n         * This event is fired on Polyline mouseover.\n         */\n        this.lineMouseOver = new core_1.EventEmitter();\n        /**\n         * This event is fired whe the DOM mouseup event is fired on the Polyline\n         */\n        this.lineMouseUp = new core_1.EventEmitter();\n        /**\n         * This even is fired when the Polyline is right-clicked on.\n         */\n        this.lineRightClick = new core_1.EventEmitter();\n        this._polylineAddedToManager = false;\n        this._subscriptions = [];\n        this._id = (polylineId++).toString();\n    }\n    /** @internal */\n    SebmGoogleMapPolyline.prototype.ngAfterContentInit = function () {\n        var _this = this;\n        if (this.points.length) {\n            this.points.forEach(function (point) {\n                var s = point.positionChanged.subscribe(function () { _this._polylineManager.updatePolylinePoints(_this); });\n                _this._subscriptions.push(s);\n            });\n        }\n        if (!this._polylineAddedToManager) {\n            this._init();\n        }\n        var s = this.points.changes.subscribe(function () { return _this._polylineManager.updatePolylinePoints(_this); });\n        this._subscriptions.push(s);\n        this._polylineManager.updatePolylinePoints(this);\n    };\n    SebmGoogleMapPolyline.prototype.ngOnChanges = function (changes) {\n        if (!this._polylineAddedToManager) {\n            this._init();\n            return;\n        }\n        var options = {};\n        var optionKeys = Object.keys(changes).filter(function (k) { return SebmGoogleMapPolyline._polylineOptionsAttributes.indexOf(k) !== -1; });\n        optionKeys.forEach(function (k) { return options[k] = changes[k].currentValue; });\n        this._polylineManager.setPolylineOptions(this, options);\n    };\n    SebmGoogleMapPolyline.prototype._init = function () {\n        this._polylineManager.addPolyline(this);\n        this._polylineAddedToManager = true;\n        this._addEventListeners();\n    };\n    SebmGoogleMapPolyline.prototype._addEventListeners = function () {\n        var _this = this;\n        var handlers = [\n            { name: 'click', handler: function (ev) { return _this.lineClick.emit(ev); } },\n            { name: 'dbclick', handler: function (ev) { return _this.lineDblClick.emit(ev); } },\n            { name: 'drag', handler: function (ev) { return _this.lineDrag.emit(ev); } },\n            { name: 'dragend', handler: function (ev) { return _this.lineDragEnd.emit(ev); } },\n            { name: 'dragstart', handler: function (ev) { return _this.lineDragStart.emit(ev); } },\n            { name: 'mousedown', handler: function (ev) { return _this.lineMouseDown.emit(ev); } },\n            { name: 'mousemove', handler: function (ev) { return _this.lineMouseMove.emit(ev); } },\n            { name: 'mouseout', handler: function (ev) { return _this.lineMouseOut.emit(ev); } },\n            { name: 'mouseover', handler: function (ev) { return _this.lineMouseOver.emit(ev); } },\n            { name: 'mouseup', handler: function (ev) { return _this.lineMouseUp.emit(ev); } },\n            { name: 'rightclick', handler: function (ev) { return _this.lineRightClick.emit(ev); } },\n        ];\n        handlers.forEach(function (obj) {\n            var os = _this._polylineManager.createEventObservable(obj.name, _this).subscribe(obj.handler);\n            _this._subscriptions.push(os);\n        });\n    };\n    /** @internal */\n    SebmGoogleMapPolyline.prototype._getPoints = function () {\n        if (this.points) {\n            return this.points.toArray();\n        }\n        return [];\n    };\n    /** @internal */\n    SebmGoogleMapPolyline.prototype.id = function () { return this._id; };\n    /** @internal */\n    SebmGoogleMapPolyline.prototype.ngOnDestroy = function () {\n        this._polylineManager.deletePolyline(this);\n        // unsubscribe all registered observable subscriptions\n        this._subscriptions.forEach(function (s) { return s.unsubscribe(); });\n    };\n    SebmGoogleMapPolyline._polylineOptionsAttributes = [\n        'draggable', 'editable', 'visible', 'geodesic', 'strokeColor', 'strokeOpacity', 'strokeWeight',\n        'zIndex'\n    ];\n    SebmGoogleMapPolyline.decorators = [\n        { type: core_1.Directive, args: [{\n                    selector: 'sebm-google-map-polyline',\n                    inputs: [\n                        'clickable', 'draggable: polylineDraggable', 'editable', 'geodesic', 'strokeColor',\n                        'strokeWeight', 'strokeOpacity', 'visible', 'zIndex'\n                    ],\n                    outputs: [\n                        'lineClick', 'lineDblClick', 'lineDrag', 'lineDragEnd', 'lineMouseDown', 'lineMouseMove',\n                        'lineMouseOut', 'lineMouseOver', 'lineMouseUp', 'lineRightClick'\n                    ]\n                },] },\n    ];\n    /** @nocollapse */\n    SebmGoogleMapPolyline.ctorParameters = function () { return [\n        { type: polyline_manager_1.PolylineManager, },\n    ]; };\n    SebmGoogleMapPolyline.propDecorators = {\n        'points': [{ type: core_1.ContentChildren, args: [google_map_polyline_point_1.SebmGoogleMapPolylinePoint,] },],\n    };\n    return SebmGoogleMapPolyline;\n}());\nexports.SebmGoogleMapPolyline = SebmGoogleMapPolyline;\n//# sourceMappingURL=google-map-polyline.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzMzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC1wb2x5bGluZS5qcz81YWY5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBwb2x5bGluZV9tYW5hZ2VyXzEgPSByZXF1aXJlKCcuLi9zZXJ2aWNlcy9tYW5hZ2Vycy9wb2x5bGluZS1tYW5hZ2VyJyk7XG52YXIgZ29vZ2xlX21hcF9wb2x5bGluZV9wb2ludF8xID0gcmVxdWlyZSgnLi9nb29nbGUtbWFwLXBvbHlsaW5lLXBvaW50Jyk7XG52YXIgcG9seWxpbmVJZCA9IDA7XG4vKipcbiAqIFNlYm1Hb29nbGVNYXBQb2x5bGluZSByZW5kZXJzIGEgcG9seWxpbmUgb24gYSB7QGxpbmsgU2VibUdvb2dsZU1hcH1cbiAqXG4gKiAjIyMgRXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnYW5ndWxhcjIvY29yZSc7XG4gKiBpbXBvcnQgeyBTZWJtR29vZ2xlTWFwLCBTZWJtR29vZ2xlUG9seWxpbmUsIFNlYm1Hb29nbGVQb2x5bGluZVBvaW50IH0gZnJvbVxuICogJ2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUnO1xuICpcbiAqIEBDb21wb25lbnQoe1xuICogIHNlbGVjdG9yOiAnbXktbWFwLWNtcCcsXG4gKiAgZGlyZWN0aXZlczogW1NlYm1Hb29nbGVNYXAsIFNlYm1Hb29nbGVQb2x5bGluZSwgU2VibUdvb2dsZVBvbHlsaW5lUG9pbnRdLFxuICogIHN0eWxlczogW2BcbiAqICAgIC5zZWJtLWdvb2dsZS1tYXAtY29udGFpbmVyIHtcbiAqICAgICAgaGVpZ2h0OiAzMDBweDtcbiAqICAgIH1cbiAqIGBdLFxuICogIHRlbXBsYXRlOiBgXG4gKiAgICA8c2VibS1nb29nbGUtbWFwIFtsYXRpdHVkZV09XCJsYXRcIiBbbG9uZ2l0dWRlXT1cImxuZ1wiIFt6b29tXT1cInpvb21cIj5cbiAqICAgICAgPHNlYm0tZ29vZ2xlLW1hcC1wb2x5bGluZT5cbiAqICAgICAgICAgIDxzZWJtLWdvb2dsZS1tYXAtcG9seWxpbmUtcG9pbnQgW2xhdGl0dWRlXT1cImxhdEFcIiBbbG9uZ2l0dWRlXT1cImxuZ0FcIj5cbiAqICAgICAgICAgIDwvc2VibS1nb29nbGUtbWFwLXBvbHlsaW5lLXBvaW50PlxuICogICAgICAgICAgPHNlYm0tZ29vZ2xlLW1hcC1wb2x5bGluZS1wb2ludCBbbGF0aXR1ZGVdPVwibGF0QlwiIFtsb25naXR1ZGVdPVwibG5nQlwiPlxuICogICAgICAgICAgPC9zZWJtLWdvb2dsZS1tYXAtcG9seWxpbmUtcG9pbnQ+XG4gKiAgICAgIDwvc2VibS1nb29nbGUtbWFwLXBvbHlsaW5lPlxuICogICAgPC9zZWJtLWdvb2dsZS1tYXA+XG4gKiAgYFxuICogfSlcbiAqIGBgYFxuICovXG52YXIgU2VibUdvb2dsZU1hcFBvbHlsaW5lID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZWJtR29vZ2xlTWFwUG9seWxpbmUoX3BvbHlsaW5lTWFuYWdlcikge1xuICAgICAgICB0aGlzLl9wb2x5bGluZU1hbmFnZXIgPSBfcG9seWxpbmVNYW5hZ2VyO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBQb2x5bGluZSBoYW5kbGVzIG1vdXNlIGV2ZW50cy4gRGVmYXVsdHMgdG8gdHJ1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xpY2thYmxlID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHNldCB0byB0cnVlLCB0aGUgdXNlciBjYW4gZHJhZyB0aGlzIHNoYXBlIG92ZXIgdGhlIG1hcC4gVGhlIGdlb2Rlc2ljIHByb3BlcnR5IGRlZmluZXMgdGhlXG4gICAgICAgICAqIG1vZGUgb2YgZHJhZ2dpbmcuIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHNldCB0byB0cnVlLCB0aGUgdXNlciBjYW4gZWRpdCB0aGlzIHNoYXBlIGJ5IGRyYWdnaW5nIHRoZSBjb250cm9sIHBvaW50cyBzaG93biBhdCB0aGVcbiAgICAgICAgICogdmVydGljZXMgYW5kIG9uIGVhY2ggc2VnbWVudC4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVkaXRhYmxlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIHRydWUsIGVkZ2VzIG9mIHRoZSBwb2x5Z29uIGFyZSBpbnRlcnByZXRlZCBhcyBnZW9kZXNpYyBhbmQgd2lsbCBmb2xsb3cgdGhlIGN1cnZhdHVyZSBvZlxuICAgICAgICAgKiB0aGUgRWFydGguIFdoZW4gZmFsc2UsIGVkZ2VzIG9mIHRoZSBwb2x5Z29uIGFyZSByZW5kZXJlZCBhcyBzdHJhaWdodCBsaW5lcyBpbiBzY3JlZW4gc3BhY2UuXG4gICAgICAgICAqIE5vdGUgdGhhdCB0aGUgc2hhcGUgb2YgYSBnZW9kZXNpYyBwb2x5Z29uIG1heSBhcHBlYXIgdG8gY2hhbmdlIHdoZW4gZHJhZ2dlZCwgYXMgdGhlIGRpbWVuc2lvbnNcbiAgICAgICAgICogYXJlIG1haW50YWluZWQgcmVsYXRpdmUgdG8gdGhlIHN1cmZhY2Ugb2YgdGhlIGVhcnRoLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2VvZGVzaWMgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhpcyBwb2x5bGluZSBpcyB2aXNpYmxlIG9uIHRoZSBtYXAuIERlZmF1bHRzIHRvIHRydWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBET00gY2xpY2sgZXZlbnQgaXMgZmlyZWQgb24gdGhlIFBvbHlsaW5lLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saW5lQ2xpY2sgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBET00gZGJsY2xpY2sgZXZlbnQgaXMgZmlyZWQgb24gdGhlIFBvbHlsaW5lLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saW5lRGJsQ2xpY2sgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyByZXBlYXRlZGx5IGZpcmVkIHdoaWxlIHRoZSB1c2VyIGRyYWdzIHRoZSBwb2x5bGluZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGluZURyYWcgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSB1c2VyIHN0b3BzIGRyYWdnaW5nIHRoZSBwb2x5bGluZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGluZURyYWdFbmQgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgcG9seWxpbmUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpbmVEcmFnU3RhcnQgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBET00gbW91c2Vkb3duIGV2ZW50IGlzIGZpcmVkIG9uIHRoZSBQb2x5bGluZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGluZU1vdXNlRG93biA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIERPTSBtb3VzZW1vdmUgZXZlbnQgaXMgZmlyZWQgb24gdGhlIFBvbHlsaW5lLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saW5lTW91c2VNb3ZlID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgb24gUG9seWxpbmUgbW91c2VvdXQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpbmVNb3VzZU91dCA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIG9uIFBvbHlsaW5lIG1vdXNlb3Zlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGluZU1vdXNlT3ZlciA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZSB0aGUgRE9NIG1vdXNldXAgZXZlbnQgaXMgZmlyZWQgb24gdGhlIFBvbHlsaW5lXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpbmVNb3VzZVVwID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbiBpcyBmaXJlZCB3aGVuIHRoZSBQb2x5bGluZSBpcyByaWdodC1jbGlja2VkIG9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saW5lUmlnaHRDbGljayA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuX3BvbHlsaW5lQWRkZWRUb01hbmFnZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLl9pZCA9IChwb2x5bGluZUlkKyspLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBTZWJtR29vZ2xlTWFwUG9seWxpbmUucHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMucG9pbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5wb2ludHMuZm9yRWFjaChmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IHBvaW50LnBvc2l0aW9uQ2hhbmdlZC5zdWJzY3JpYmUoZnVuY3Rpb24gKCkgeyBfdGhpcy5fcG9seWxpbmVNYW5hZ2VyLnVwZGF0ZVBvbHlsaW5lUG9pbnRzKF90aGlzKTsgfSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3N1YnNjcmlwdGlvbnMucHVzaChzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fcG9seWxpbmVBZGRlZFRvTWFuYWdlcikge1xuICAgICAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzID0gdGhpcy5wb2ludHMuY2hhbmdlcy5zdWJzY3JpYmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3BvbHlsaW5lTWFuYWdlci51cGRhdGVQb2x5bGluZVBvaW50cyhfdGhpcyk7IH0pO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zLnB1c2gocyk7XG4gICAgICAgIHRoaXMuX3BvbHlsaW5lTWFuYWdlci51cGRhdGVQb2x5bGluZVBvaW50cyh0aGlzKTtcbiAgICB9O1xuICAgIFNlYm1Hb29nbGVNYXBQb2x5bGluZS5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICBpZiAoIXRoaXMuX3BvbHlsaW5lQWRkZWRUb01hbmFnZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2luaXQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgICAgICB2YXIgb3B0aW9uS2V5cyA9IE9iamVjdC5rZXlzKGNoYW5nZXMpLmZpbHRlcihmdW5jdGlvbiAoaykgeyByZXR1cm4gU2VibUdvb2dsZU1hcFBvbHlsaW5lLl9wb2x5bGluZU9wdGlvbnNBdHRyaWJ1dGVzLmluZGV4T2YoaykgIT09IC0xOyB9KTtcbiAgICAgICAgb3B0aW9uS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7IHJldHVybiBvcHRpb25zW2tdID0gY2hhbmdlc1trXS5jdXJyZW50VmFsdWU7IH0pO1xuICAgICAgICB0aGlzLl9wb2x5bGluZU1hbmFnZXIuc2V0UG9seWxpbmVPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcFBvbHlsaW5lLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcG9seWxpbmVNYW5hZ2VyLmFkZFBvbHlsaW5lKHRoaXMpO1xuICAgICAgICB0aGlzLl9wb2x5bGluZUFkZGVkVG9NYW5hZ2VyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9O1xuICAgIFNlYm1Hb29nbGVNYXBQb2x5bGluZS5wcm90b3R5cGUuX2FkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgaGFuZGxlcnMgPSBbXG4gICAgICAgICAgICB7IG5hbWU6ICdjbGljaycsIGhhbmRsZXI6IGZ1bmN0aW9uIChldikgeyByZXR1cm4gX3RoaXMubGluZUNsaWNrLmVtaXQoZXYpOyB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdkYmNsaWNrJywgaGFuZGxlcjogZnVuY3Rpb24gKGV2KSB7IHJldHVybiBfdGhpcy5saW5lRGJsQ2xpY2suZW1pdChldik7IH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2RyYWcnLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLmxpbmVEcmFnLmVtaXQoZXYpOyB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdkcmFnZW5kJywgaGFuZGxlcjogZnVuY3Rpb24gKGV2KSB7IHJldHVybiBfdGhpcy5saW5lRHJhZ0VuZC5lbWl0KGV2KTsgfSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnZHJhZ3N0YXJ0JywgaGFuZGxlcjogZnVuY3Rpb24gKGV2KSB7IHJldHVybiBfdGhpcy5saW5lRHJhZ1N0YXJ0LmVtaXQoZXYpOyB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdtb3VzZWRvd24nLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLmxpbmVNb3VzZURvd24uZW1pdChldik7IH0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ21vdXNlbW92ZScsIGhhbmRsZXI6IGZ1bmN0aW9uIChldikgeyByZXR1cm4gX3RoaXMubGluZU1vdXNlTW92ZS5lbWl0KGV2KTsgfSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnbW91c2VvdXQnLCBoYW5kbGVyOiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLmxpbmVNb3VzZU91dC5lbWl0KGV2KTsgfSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnbW91c2VvdmVyJywgaGFuZGxlcjogZnVuY3Rpb24gKGV2KSB7IHJldHVybiBfdGhpcy5saW5lTW91c2VPdmVyLmVtaXQoZXYpOyB9IH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdtb3VzZXVwJywgaGFuZGxlcjogZnVuY3Rpb24gKGV2KSB7IHJldHVybiBfdGhpcy5saW5lTW91c2VVcC5lbWl0KGV2KTsgfSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAncmlnaHRjbGljaycsIGhhbmRsZXI6IGZ1bmN0aW9uIChldikgeyByZXR1cm4gX3RoaXMubGluZVJpZ2h0Q2xpY2suZW1pdChldik7IH0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICB2YXIgb3MgPSBfdGhpcy5fcG9seWxpbmVNYW5hZ2VyLmNyZWF0ZUV2ZW50T2JzZXJ2YWJsZShvYmoubmFtZSwgX3RoaXMpLnN1YnNjcmliZShvYmouaGFuZGxlcik7XG4gICAgICAgICAgICBfdGhpcy5fc3Vic2NyaXB0aW9ucy5wdXNoKG9zKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgU2VibUdvb2dsZU1hcFBvbHlsaW5lLnByb3RvdHlwZS5fZ2V0UG9pbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wb2ludHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvaW50cy50b0FycmF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFNlYm1Hb29nbGVNYXBQb2x5bGluZS5wcm90b3R5cGUuaWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9pZDsgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgU2VibUdvb2dsZU1hcFBvbHlsaW5lLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcG9seWxpbmVNYW5hZ2VyLmRlbGV0ZVBvbHlsaW5lKHRoaXMpO1xuICAgICAgICAvLyB1bnN1YnNjcmliZSBhbGwgcmVnaXN0ZXJlZCBvYnNlcnZhYmxlIHN1YnNjcmlwdGlvbnNcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnVuc3Vic2NyaWJlKCk7IH0pO1xuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcFBvbHlsaW5lLl9wb2x5bGluZU9wdGlvbnNBdHRyaWJ1dGVzID0gW1xuICAgICAgICAnZHJhZ2dhYmxlJywgJ2VkaXRhYmxlJywgJ3Zpc2libGUnLCAnZ2VvZGVzaWMnLCAnc3Ryb2tlQ29sb3InLCAnc3Ryb2tlT3BhY2l0eScsICdzdHJva2VXZWlnaHQnLFxuICAgICAgICAnekluZGV4J1xuICAgIF07XG4gICAgU2VibUdvb2dsZU1hcFBvbHlsaW5lLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogY29yZV8xLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdzZWJtLWdvb2dsZS1tYXAtcG9seWxpbmUnLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjbGlja2FibGUnLCAnZHJhZ2dhYmxlOiBwb2x5bGluZURyYWdnYWJsZScsICdlZGl0YWJsZScsICdnZW9kZXNpYycsICdzdHJva2VDb2xvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3Ryb2tlV2VpZ2h0JywgJ3N0cm9rZU9wYWNpdHknLCAndmlzaWJsZScsICd6SW5kZXgnXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdsaW5lQ2xpY2snLCAnbGluZURibENsaWNrJywgJ2xpbmVEcmFnJywgJ2xpbmVEcmFnRW5kJywgJ2xpbmVNb3VzZURvd24nLCAnbGluZU1vdXNlTW92ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGluZU1vdXNlT3V0JywgJ2xpbmVNb3VzZU92ZXInLCAnbGluZU1vdXNlVXAnLCAnbGluZVJpZ2h0Q2xpY2snXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIFNlYm1Hb29nbGVNYXBQb2x5bGluZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBwb2x5bGluZV9tYW5hZ2VyXzEuUG9seWxpbmVNYW5hZ2VyLCB9LFxuICAgIF07IH07XG4gICAgU2VibUdvb2dsZU1hcFBvbHlsaW5lLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAncG9pbnRzJzogW3sgdHlwZTogY29yZV8xLkNvbnRlbnRDaGlsZHJlbiwgYXJnczogW2dvb2dsZV9tYXBfcG9seWxpbmVfcG9pbnRfMS5TZWJtR29vZ2xlTWFwUG9seWxpbmVQb2ludCxdIH0sXSxcbiAgICB9O1xuICAgIHJldHVybiBTZWJtR29vZ2xlTWFwUG9seWxpbmU7XG59KCkpO1xuZXhwb3J0cy5TZWJtR29vZ2xlTWFwUG9seWxpbmUgPSBTZWJtR29vZ2xlTWFwUG9seWxpbmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nb29nbGUtbWFwLXBvbHlsaW5lLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC1wb2x5bGluZS5qc1xuLy8gbW9kdWxlIGlkID0gNzMzXG4vLyBtb2R1bGUgY2h1bmtzID0gNSA4Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 734:
/* unknown exports provided */
/* all exports used */
/*!**************************************************************!*\
  !*** ./~/angular2-google-maps/core/directives/google-map.js ***!
  \**************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar core_1 = __webpack_require__(/*! @angular/core */ 0);\nvar google_maps_api_wrapper_1 = __webpack_require__(/*! ../services/google-maps-api-wrapper */ 703);\nvar circle_manager_1 = __webpack_require__(/*! ../services/managers/circle-manager */ 715);\nvar info_window_manager_1 = __webpack_require__(/*! ../services/managers/info-window-manager */ 716);\nvar marker_manager_1 = __webpack_require__(/*! ../services/managers/marker-manager */ 710);\nvar polygon_manager_1 = __webpack_require__(/*! ../services/managers/polygon-manager */ 718);\nvar polyline_manager_1 = __webpack_require__(/*! ../services/managers/polyline-manager */ 719);\nvar kml_layer_manager_1 = __webpack_require__(/*! ./../services/managers/kml-layer-manager */ 717);\n/**\n * SebMGoogleMap renders a Google Map.\n * **Important note**: To be able see a map in the browser, you have to define a height for the CSS\n * class `sebm-google-map-container`.\n *\n * ### Example\n * ```typescript\n * import { Component } from '@angular/core';\n * import { SebmGoogleMap } from 'angular2-google-maps/core';\n *\n * @Component({\n *  selector: 'my-map-cmp',\n *  directives: [SebmGoogleMap],\n *  styles: [`\n *    .sebm-google-map-container {\n *      height: 300px;\n *    }\n * `],\n *  template: `\n *    <sebm-google-map [latitude]=\"lat\" [longitude]=\"lng\" [zoom]=\"zoom\">\n *    </sebm-google-map>\n *  `\n * })\n * ```\n */\nvar SebmGoogleMap = (function () {\n    function SebmGoogleMap(_elem, _mapsWrapper) {\n        this._elem = _elem;\n        this._mapsWrapper = _mapsWrapper;\n        /**\n         * The longitude that defines the center of the map.\n         */\n        this.longitude = 0;\n        /**\n         * The latitude that defines the center of the map.\n         */\n        this.latitude = 0;\n        /**\n         * The zoom level of the map. The default zoom level is 8.\n         */\n        this.zoom = 8;\n        /**\n         * Enables/disables if map is draggable.\n         */\n        this.draggable = true;\n        /**\n         * Enables/disables zoom and center on double click. Enabled by default.\n         */\n        this.disableDoubleClickZoom = false;\n        /**\n         * Enables/disables all default UI of the Google map. Please note: When the map is created, this\n         * value cannot get updated.\n         */\n        this.disableDefaultUI = false;\n        /**\n         * If false, disables scrollwheel zooming on the map. The scrollwheel is enabled by default.\n         */\n        this.scrollwheel = true;\n        /**\n         * If false, prevents the map from being controlled by the keyboard. Keyboard shortcuts are\n         * enabled by default.\n         */\n        this.keyboardShortcuts = true;\n        /**\n         * The enabled/disabled state of the Zoom control.\n         */\n        this.zoomControl = true;\n        /**\n         * Styles to apply to each of the default map types. Note that for Satellite/Hybrid and Terrain\n         * modes, these styles will only apply to labels and geometry.\n         */\n        this.styles = [];\n        /**\n         * When true and the latitude and/or longitude values changes, the Google Maps panTo method is\n         * used to\n         * center the map. See: https://developers.google.com/maps/documentation/javascript/reference#Map\n         */\n        this.usePanning = false;\n        /**\n         * The initial enabled/disabled state of the Street View Pegman control.\n         * This control is part of the default UI, and should be set to false when displaying a map type\n         * on which the Street View road overlay should not appear (e.g. a non-Earth map type).\n         */\n        this.streetViewControl = true;\n        /**\n         * Sets the viewport to contain the given bounds.\n         */\n        this.fitBounds = null;\n        /**\n         * The initial enabled/disabled state of the Scale control. This is disabled by default.\n         */\n        this.scaleControl = false;\n        /**\n         * The initial enabled/disabled state of the Map type control.\n         */\n        this.mapTypeControl = false;\n        this._observableSubscriptions = [];\n        /**\n         * This event emitter gets emitted when the user clicks on the map (but not when they click on a\n         * marker or infoWindow).\n         */\n        this.mapClick = new core_1.EventEmitter();\n        /**\n         * This event emitter gets emitted when the user right-clicks on the map (but not when they click\n         * on a marker or infoWindow).\n         */\n        this.mapRightClick = new core_1.EventEmitter();\n        /**\n         * This event emitter gets emitted when the user double-clicks on the map (but not when they click\n         * on a marker or infoWindow).\n         */\n        this.mapDblClick = new core_1.EventEmitter();\n        /**\n         * This event emitter is fired when the map center changes.\n         */\n        this.centerChange = new core_1.EventEmitter();\n        /**\n         * This event is fired when the viewport bounds have changed.\n         */\n        this.boundsChange = new core_1.EventEmitter();\n        /**\n         * This event is fired when the map becomes idle after panning or zooming.\n         */\n        this.idle = new core_1.EventEmitter();\n        /**\n         * This event is fired when the zoom level has changed.\n         */\n        this.zoomChange = new core_1.EventEmitter();\n    }\n    /** @internal */\n    SebmGoogleMap.prototype.ngOnInit = function () {\n        // todo: this should be solved with a new component and a viewChild decorator\n        var container = this._elem.nativeElement.querySelector('.sebm-google-map-container-inner');\n        this._initMapInstance(container);\n    };\n    SebmGoogleMap.prototype._initMapInstance = function (el) {\n        this._mapsWrapper.createMap(el, {\n            center: { lat: this.latitude || 0, lng: this.longitude || 0 },\n            zoom: this.zoom,\n            minZoom: this.minZoom,\n            maxZoom: this.maxZoom,\n            disableDefaultUI: this.disableDefaultUI,\n            backgroundColor: this.backgroundColor,\n            draggable: this.draggable,\n            draggableCursor: this.draggableCursor,\n            draggingCursor: this.draggingCursor,\n            keyboardShortcuts: this.keyboardShortcuts,\n            zoomControl: this.zoomControl,\n            styles: this.styles,\n            streetViewControl: this.streetViewControl,\n            scaleControl: this.scaleControl,\n            mapTypeControl: this.mapTypeControl\n        });\n        // register event listeners\n        this._handleMapCenterChange();\n        this._handleMapZoomChange();\n        this._handleMapMouseEvents();\n        this._handleBoundsChange();\n        this._handleIdleEvent();\n    };\n    /** @internal */\n    SebmGoogleMap.prototype.ngOnDestroy = function () {\n        // unsubscribe all registered observable subscriptions\n        this._observableSubscriptions.forEach(function (s) { return s.unsubscribe(); });\n    };\n    /* @internal */\n    SebmGoogleMap.prototype.ngOnChanges = function (changes) {\n        this._updateMapOptionsChanges(changes);\n        this._updatePosition(changes);\n    };\n    SebmGoogleMap.prototype._updateMapOptionsChanges = function (changes) {\n        var options = {};\n        var optionKeys = Object.keys(changes).filter(function (k) { return SebmGoogleMap._mapOptionsAttributes.indexOf(k) !== -1; });\n        optionKeys.forEach(function (k) { options[k] = changes[k].currentValue; });\n        this._mapsWrapper.setMapOptions(options);\n    };\n    /**\n     * Triggers a resize event on the google map instance.\n     * Returns a promise that gets resolved after the event was triggered.\n     */\n    SebmGoogleMap.prototype.triggerResize = function () {\n        var _this = this;\n        // Note: When we would trigger the resize event and show the map in the same turn (which is a\n        // common case for triggering a resize event), then the resize event would not\n        // work (to show the map), so we trigger the event in a timeout.\n        return new Promise(function (resolve) {\n            setTimeout(function () { return _this._mapsWrapper.triggerMapEvent('resize').then(function () { return resolve(); }); });\n        });\n    };\n    SebmGoogleMap.prototype._updatePosition = function (changes) {\n        if (changes['latitude'] == null && changes['longitude'] == null &&\n            changes['fitBounds'] == null) {\n            // no position update needed\n            return;\n        }\n        // we prefer fitBounds in changes\n        if (changes['fitBounds'] && this.fitBounds != null) {\n            this._fitBounds();\n            return;\n        }\n        if (typeof this.latitude !== 'number' || typeof this.longitude !== 'number') {\n            return;\n        }\n        var newCenter = {\n            lat: this.latitude,\n            lng: this.longitude,\n        };\n        if (this.usePanning) {\n            this._mapsWrapper.panTo(newCenter);\n        }\n        else {\n            this._mapsWrapper.setCenter(newCenter);\n        }\n    };\n    SebmGoogleMap.prototype._fitBounds = function () {\n        if (this.usePanning) {\n            this._mapsWrapper.panToBounds(this.fitBounds);\n            return;\n        }\n        this._mapsWrapper.fitBounds(this.fitBounds);\n    };\n    SebmGoogleMap.prototype._handleMapCenterChange = function () {\n        var _this = this;\n        var s = this._mapsWrapper.subscribeToMapEvent('center_changed').subscribe(function () {\n            _this._mapsWrapper.getCenter().then(function (center) {\n                _this.latitude = center.lat();\n                _this.longitude = center.lng();\n                _this.centerChange.emit({ lat: _this.latitude, lng: _this.longitude });\n            });\n        });\n        this._observableSubscriptions.push(s);\n    };\n    SebmGoogleMap.prototype._handleBoundsChange = function () {\n        var _this = this;\n        var s = this._mapsWrapper.subscribeToMapEvent('bounds_changed').subscribe(function () {\n            _this._mapsWrapper.getBounds().then(function (bounds) { _this.boundsChange.emit(bounds); });\n        });\n        this._observableSubscriptions.push(s);\n    };\n    SebmGoogleMap.prototype._handleMapZoomChange = function () {\n        var _this = this;\n        var s = this._mapsWrapper.subscribeToMapEvent('zoom_changed').subscribe(function () {\n            _this._mapsWrapper.getZoom().then(function (z) {\n                _this.zoom = z;\n                _this.zoomChange.emit(z);\n            });\n        });\n        this._observableSubscriptions.push(s);\n    };\n    SebmGoogleMap.prototype._handleIdleEvent = function () {\n        var _this = this;\n        var s = this._mapsWrapper.subscribeToMapEvent('idle').subscribe(function () { _this.idle.emit(void 0); });\n        this._observableSubscriptions.push(s);\n    };\n    SebmGoogleMap.prototype._handleMapMouseEvents = function () {\n        var _this = this;\n        var events = [\n            { name: 'click', emitter: this.mapClick },\n            { name: 'rightclick', emitter: this.mapRightClick },\n        ];\n        events.forEach(function (e) {\n            var s = _this._mapsWrapper.subscribeToMapEvent(e.name).subscribe(function (event) {\n                var value = { coords: { lat: event.latLng.lat(), lng: event.latLng.lng() } };\n                e.emitter.emit(value);\n            });\n            _this._observableSubscriptions.push(s);\n        });\n    };\n    /**\n     * Map option attributes that can change over time\n     */\n    SebmGoogleMap._mapOptionsAttributes = [\n        'disableDoubleClickZoom', 'scrollwheel', 'draggable', 'draggableCursor', 'draggingCursor',\n        'keyboardShortcuts', 'zoomControl', 'styles', 'streetViewControl', 'zoom', 'mapTypeControl',\n        'minZoom', 'maxZoom'\n    ];\n    SebmGoogleMap.decorators = [\n        { type: core_1.Component, args: [{\n                    selector: 'sebm-google-map',\n                    providers: [\n                        google_maps_api_wrapper_1.GoogleMapsAPIWrapper, marker_manager_1.MarkerManager, info_window_manager_1.InfoWindowManager, circle_manager_1.CircleManager, polyline_manager_1.PolylineManager,\n                        polygon_manager_1.PolygonManager, kml_layer_manager_1.KmlLayerManager\n                    ],\n                    inputs: [\n                        'longitude', 'latitude', 'zoom', 'minZoom', 'maxZoom', 'draggable: mapDraggable',\n                        'disableDoubleClickZoom', 'disableDefaultUI', 'scrollwheel', 'backgroundColor', 'draggableCursor',\n                        'draggingCursor', 'keyboardShortcuts', 'zoomControl', 'styles', 'usePanning', 'streetViewControl',\n                        'fitBounds', 'scaleControl', 'mapTypeControl'\n                    ],\n                    outputs: [\n                        'mapClick', 'mapRightClick', 'mapDblClick', 'centerChange', 'idle', 'boundsChange', 'zoomChange'\n                    ],\n                    host: { '[class.sebm-google-map-container]': 'true' },\n                    styles: [\"\\n    .sebm-google-map-container-inner {\\n      width: inherit;\\n      height: inherit;\\n    }\\n    .sebm-google-map-content {\\n      display:none;\\n    }\\n  \"],\n                    template: \"\\n    <div class='sebm-google-map-container-inner'></div>\\n    <div class='sebm-google-map-content'>\\n      <ng-content></ng-content>\\n    </div>\\n  \"\n                },] },\n    ];\n    /** @nocollapse */\n    SebmGoogleMap.ctorParameters = function () { return [\n        { type: core_1.ElementRef, },\n        { type: google_maps_api_wrapper_1.GoogleMapsAPIWrapper, },\n    ]; };\n    return SebmGoogleMap;\n}());\nexports.SebmGoogleMap = SebmGoogleMap;\n//# sourceMappingURL=google-map.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzM0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC5qcz8zYmU2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKTtcbnZhciBnb29nbGVfbWFwc19hcGlfd3JhcHBlcl8xID0gcmVxdWlyZSgnLi4vc2VydmljZXMvZ29vZ2xlLW1hcHMtYXBpLXdyYXBwZXInKTtcbnZhciBjaXJjbGVfbWFuYWdlcl8xID0gcmVxdWlyZSgnLi4vc2VydmljZXMvbWFuYWdlcnMvY2lyY2xlLW1hbmFnZXInKTtcbnZhciBpbmZvX3dpbmRvd19tYW5hZ2VyXzEgPSByZXF1aXJlKCcuLi9zZXJ2aWNlcy9tYW5hZ2Vycy9pbmZvLXdpbmRvdy1tYW5hZ2VyJyk7XG52YXIgbWFya2VyX21hbmFnZXJfMSA9IHJlcXVpcmUoJy4uL3NlcnZpY2VzL21hbmFnZXJzL21hcmtlci1tYW5hZ2VyJyk7XG52YXIgcG9seWdvbl9tYW5hZ2VyXzEgPSByZXF1aXJlKCcuLi9zZXJ2aWNlcy9tYW5hZ2Vycy9wb2x5Z29uLW1hbmFnZXInKTtcbnZhciBwb2x5bGluZV9tYW5hZ2VyXzEgPSByZXF1aXJlKCcuLi9zZXJ2aWNlcy9tYW5hZ2Vycy9wb2x5bGluZS1tYW5hZ2VyJyk7XG52YXIga21sX2xheWVyX21hbmFnZXJfMSA9IHJlcXVpcmUoJy4vLi4vc2VydmljZXMvbWFuYWdlcnMva21sLWxheWVyLW1hbmFnZXInKTtcbi8qKlxuICogU2ViTUdvb2dsZU1hcCByZW5kZXJzIGEgR29vZ2xlIE1hcC5cbiAqICoqSW1wb3J0YW50IG5vdGUqKjogVG8gYmUgYWJsZSBzZWUgYSBtYXAgaW4gdGhlIGJyb3dzZXIsIHlvdSBoYXZlIHRvIGRlZmluZSBhIGhlaWdodCBmb3IgdGhlIENTU1xuICogY2xhc3MgYHNlYm0tZ29vZ2xlLW1hcC1jb250YWluZXJgLlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqIGltcG9ydCB7IFNlYm1Hb29nbGVNYXAgfSBmcm9tICdhbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlJztcbiAqXG4gKiBAQ29tcG9uZW50KHtcbiAqICBzZWxlY3RvcjogJ215LW1hcC1jbXAnLFxuICogIGRpcmVjdGl2ZXM6IFtTZWJtR29vZ2xlTWFwXSxcbiAqICBzdHlsZXM6IFtgXG4gKiAgICAuc2VibS1nb29nbGUtbWFwLWNvbnRhaW5lciB7XG4gKiAgICAgIGhlaWdodDogMzAwcHg7XG4gKiAgICB9XG4gKiBgXSxcbiAqICB0ZW1wbGF0ZTogYFxuICogICAgPHNlYm0tZ29vZ2xlLW1hcCBbbGF0aXR1ZGVdPVwibGF0XCIgW2xvbmdpdHVkZV09XCJsbmdcIiBbem9vbV09XCJ6b29tXCI+XG4gKiAgICA8L3NlYm0tZ29vZ2xlLW1hcD5cbiAqICBgXG4gKiB9KVxuICogYGBgXG4gKi9cbnZhciBTZWJtR29vZ2xlTWFwID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZWJtR29vZ2xlTWFwKF9lbGVtLCBfbWFwc1dyYXBwZXIpIHtcbiAgICAgICAgdGhpcy5fZWxlbSA9IF9lbGVtO1xuICAgICAgICB0aGlzLl9tYXBzV3JhcHBlciA9IF9tYXBzV3JhcHBlcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsb25naXR1ZGUgdGhhdCBkZWZpbmVzIHRoZSBjZW50ZXIgb2YgdGhlIG1hcC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubG9uZ2l0dWRlID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsYXRpdHVkZSB0aGF0IGRlZmluZXMgdGhlIGNlbnRlciBvZiB0aGUgbWFwLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXRpdHVkZSA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgem9vbSBsZXZlbCBvZiB0aGUgbWFwLiBUaGUgZGVmYXVsdCB6b29tIGxldmVsIGlzIDguXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnpvb20gPSA4O1xuICAgICAgICAvKipcbiAgICAgICAgICogRW5hYmxlcy9kaXNhYmxlcyBpZiBtYXAgaXMgZHJhZ2dhYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRW5hYmxlcy9kaXNhYmxlcyB6b29tIGFuZCBjZW50ZXIgb24gZG91YmxlIGNsaWNrLiBFbmFibGVkIGJ5IGRlZmF1bHQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpc2FibGVEb3VibGVDbGlja1pvb20gPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuYWJsZXMvZGlzYWJsZXMgYWxsIGRlZmF1bHQgVUkgb2YgdGhlIEdvb2dsZSBtYXAuIFBsZWFzZSBub3RlOiBXaGVuIHRoZSBtYXAgaXMgY3JlYXRlZCwgdGhpc1xuICAgICAgICAgKiB2YWx1ZSBjYW5ub3QgZ2V0IHVwZGF0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpc2FibGVEZWZhdWx0VUkgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGZhbHNlLCBkaXNhYmxlcyBzY3JvbGx3aGVlbCB6b29taW5nIG9uIHRoZSBtYXAuIFRoZSBzY3JvbGx3aGVlbCBpcyBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjcm9sbHdoZWVsID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGZhbHNlLCBwcmV2ZW50cyB0aGUgbWFwIGZyb20gYmVpbmcgY29udHJvbGxlZCBieSB0aGUga2V5Ym9hcmQuIEtleWJvYXJkIHNob3J0Y3V0cyBhcmVcbiAgICAgICAgICogZW5hYmxlZCBieSBkZWZhdWx0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5rZXlib2FyZFNob3J0Y3V0cyA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZW5hYmxlZC9kaXNhYmxlZCBzdGF0ZSBvZiB0aGUgWm9vbSBjb250cm9sLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy56b29tQ29udHJvbCA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdHlsZXMgdG8gYXBwbHkgdG8gZWFjaCBvZiB0aGUgZGVmYXVsdCBtYXAgdHlwZXMuIE5vdGUgdGhhdCBmb3IgU2F0ZWxsaXRlL0h5YnJpZCBhbmQgVGVycmFpblxuICAgICAgICAgKiBtb2RlcywgdGhlc2Ugc3R5bGVzIHdpbGwgb25seSBhcHBseSB0byBsYWJlbHMgYW5kIGdlb21ldHJ5LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdHlsZXMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gdHJ1ZSBhbmQgdGhlIGxhdGl0dWRlIGFuZC9vciBsb25naXR1ZGUgdmFsdWVzIGNoYW5nZXMsIHRoZSBHb29nbGUgTWFwcyBwYW5UbyBtZXRob2QgaXNcbiAgICAgICAgICogdXNlZCB0b1xuICAgICAgICAgKiBjZW50ZXIgdGhlIG1hcC4gU2VlOiBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2RvY3VtZW50YXRpb24vamF2YXNjcmlwdC9yZWZlcmVuY2UjTWFwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVzZVBhbm5pbmcgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpbml0aWFsIGVuYWJsZWQvZGlzYWJsZWQgc3RhdGUgb2YgdGhlIFN0cmVldCBWaWV3IFBlZ21hbiBjb250cm9sLlxuICAgICAgICAgKiBUaGlzIGNvbnRyb2wgaXMgcGFydCBvZiB0aGUgZGVmYXVsdCBVSSwgYW5kIHNob3VsZCBiZSBzZXQgdG8gZmFsc2Ugd2hlbiBkaXNwbGF5aW5nIGEgbWFwIHR5cGVcbiAgICAgICAgICogb24gd2hpY2ggdGhlIFN0cmVldCBWaWV3IHJvYWQgb3ZlcmxheSBzaG91bGQgbm90IGFwcGVhciAoZS5nLiBhIG5vbi1FYXJ0aCBtYXAgdHlwZSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0cmVldFZpZXdDb250cm9sID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHZpZXdwb3J0IHRvIGNvbnRhaW4gdGhlIGdpdmVuIGJvdW5kcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZml0Qm91bmRzID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpbml0aWFsIGVuYWJsZWQvZGlzYWJsZWQgc3RhdGUgb2YgdGhlIFNjYWxlIGNvbnRyb2wuIFRoaXMgaXMgZGlzYWJsZWQgYnkgZGVmYXVsdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2NhbGVDb250cm9sID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaW5pdGlhbCBlbmFibGVkL2Rpc2FibGVkIHN0YXRlIG9mIHRoZSBNYXAgdHlwZSBjb250cm9sLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXBUeXBlQ29udHJvbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9vYnNlcnZhYmxlU3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBlbWl0dGVyIGdldHMgZW1pdHRlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgbWFwIChidXQgbm90IHdoZW4gdGhleSBjbGljayBvbiBhXG4gICAgICAgICAqIG1hcmtlciBvciBpbmZvV2luZG93KS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWFwQ2xpY2sgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBlbWl0dGVyIGdldHMgZW1pdHRlZCB3aGVuIHRoZSB1c2VyIHJpZ2h0LWNsaWNrcyBvbiB0aGUgbWFwIChidXQgbm90IHdoZW4gdGhleSBjbGlja1xuICAgICAgICAgKiBvbiBhIG1hcmtlciBvciBpbmZvV2luZG93KS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWFwUmlnaHRDbGljayA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGVtaXR0ZXIgZ2V0cyBlbWl0dGVkIHdoZW4gdGhlIHVzZXIgZG91YmxlLWNsaWNrcyBvbiB0aGUgbWFwIChidXQgbm90IHdoZW4gdGhleSBjbGlja1xuICAgICAgICAgKiBvbiBhIG1hcmtlciBvciBpbmZvV2luZG93KS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWFwRGJsQ2xpY2sgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBlbWl0dGVyIGlzIGZpcmVkIHdoZW4gdGhlIG1hcCBjZW50ZXIgY2hhbmdlcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2VudGVyQ2hhbmdlID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgdmlld3BvcnQgYm91bmRzIGhhdmUgY2hhbmdlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYm91bmRzQ2hhbmdlID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgbWFwIGJlY29tZXMgaWRsZSBhZnRlciBwYW5uaW5nIG9yIHpvb21pbmcuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlkbGUgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSB6b29tIGxldmVsIGhhcyBjaGFuZ2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy56b29tQ2hhbmdlID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIFNlYm1Hb29nbGVNYXAucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyB0b2RvOiB0aGlzIHNob3VsZCBiZSBzb2x2ZWQgd2l0aCBhIG5ldyBjb21wb25lbnQgYW5kIGEgdmlld0NoaWxkIGRlY29yYXRvclxuICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5fZWxlbS5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zZWJtLWdvb2dsZS1tYXAtY29udGFpbmVyLWlubmVyJyk7XG4gICAgICAgIHRoaXMuX2luaXRNYXBJbnN0YW5jZShjb250YWluZXIpO1xuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcC5wcm90b3R5cGUuX2luaXRNYXBJbnN0YW5jZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB0aGlzLl9tYXBzV3JhcHBlci5jcmVhdGVNYXAoZWwsIHtcbiAgICAgICAgICAgIGNlbnRlcjogeyBsYXQ6IHRoaXMubGF0aXR1ZGUgfHwgMCwgbG5nOiB0aGlzLmxvbmdpdHVkZSB8fCAwIH0sXG4gICAgICAgICAgICB6b29tOiB0aGlzLnpvb20sXG4gICAgICAgICAgICBtaW5ab29tOiB0aGlzLm1pblpvb20sXG4gICAgICAgICAgICBtYXhab29tOiB0aGlzLm1heFpvb20sXG4gICAgICAgICAgICBkaXNhYmxlRGVmYXVsdFVJOiB0aGlzLmRpc2FibGVEZWZhdWx0VUksXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgZHJhZ2dhYmxlOiB0aGlzLmRyYWdnYWJsZSxcbiAgICAgICAgICAgIGRyYWdnYWJsZUN1cnNvcjogdGhpcy5kcmFnZ2FibGVDdXJzb3IsXG4gICAgICAgICAgICBkcmFnZ2luZ0N1cnNvcjogdGhpcy5kcmFnZ2luZ0N1cnNvcixcbiAgICAgICAgICAgIGtleWJvYXJkU2hvcnRjdXRzOiB0aGlzLmtleWJvYXJkU2hvcnRjdXRzLFxuICAgICAgICAgICAgem9vbUNvbnRyb2w6IHRoaXMuem9vbUNvbnRyb2wsXG4gICAgICAgICAgICBzdHlsZXM6IHRoaXMuc3R5bGVzLFxuICAgICAgICAgICAgc3RyZWV0Vmlld0NvbnRyb2w6IHRoaXMuc3RyZWV0Vmlld0NvbnRyb2wsXG4gICAgICAgICAgICBzY2FsZUNvbnRyb2w6IHRoaXMuc2NhbGVDb250cm9sLFxuICAgICAgICAgICAgbWFwVHlwZUNvbnRyb2w6IHRoaXMubWFwVHlwZUNvbnRyb2xcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHJlZ2lzdGVyIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICB0aGlzLl9oYW5kbGVNYXBDZW50ZXJDaGFuZ2UoKTtcbiAgICAgICAgdGhpcy5faGFuZGxlTWFwWm9vbUNoYW5nZSgpO1xuICAgICAgICB0aGlzLl9oYW5kbGVNYXBNb3VzZUV2ZW50cygpO1xuICAgICAgICB0aGlzLl9oYW5kbGVCb3VuZHNDaGFuZ2UoKTtcbiAgICAgICAgdGhpcy5faGFuZGxlSWRsZUV2ZW50KCk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgU2VibUdvb2dsZU1hcC5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHVuc3Vic2NyaWJlIGFsbCByZWdpc3RlcmVkIG9ic2VydmFibGUgc3Vic2NyaXB0aW9uc1xuICAgICAgICB0aGlzLl9vYnNlcnZhYmxlU3Vic2NyaXB0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnVuc3Vic2NyaWJlKCk7IH0pO1xuICAgIH07XG4gICAgLyogQGludGVybmFsICovXG4gICAgU2VibUdvb2dsZU1hcC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICB0aGlzLl91cGRhdGVNYXBPcHRpb25zQ2hhbmdlcyhjaGFuZ2VzKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oY2hhbmdlcyk7XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwLnByb3RvdHlwZS5fdXBkYXRlTWFwT3B0aW9uc0NoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgICAgICB2YXIgb3B0aW9uS2V5cyA9IE9iamVjdC5rZXlzKGNoYW5nZXMpLmZpbHRlcihmdW5jdGlvbiAoaykgeyByZXR1cm4gU2VibUdvb2dsZU1hcC5fbWFwT3B0aW9uc0F0dHJpYnV0ZXMuaW5kZXhPZihrKSAhPT0gLTE7IH0pO1xuICAgICAgICBvcHRpb25LZXlzLmZvckVhY2goZnVuY3Rpb24gKGspIHsgb3B0aW9uc1trXSA9IGNoYW5nZXNba10uY3VycmVudFZhbHVlOyB9KTtcbiAgICAgICAgdGhpcy5fbWFwc1dyYXBwZXIuc2V0TWFwT3B0aW9ucyhvcHRpb25zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRyaWdnZXJzIGEgcmVzaXplIGV2ZW50IG9uIHRoZSBnb29nbGUgbWFwIGluc3RhbmNlLlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgZ2V0cyByZXNvbHZlZCBhZnRlciB0aGUgZXZlbnQgd2FzIHRyaWdnZXJlZC5cbiAgICAgKi9cbiAgICBTZWJtR29vZ2xlTWFwLnByb3RvdHlwZS50cmlnZ2VyUmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBOb3RlOiBXaGVuIHdlIHdvdWxkIHRyaWdnZXIgdGhlIHJlc2l6ZSBldmVudCBhbmQgc2hvdyB0aGUgbWFwIGluIHRoZSBzYW1lIHR1cm4gKHdoaWNoIGlzIGFcbiAgICAgICAgLy8gY29tbW9uIGNhc2UgZm9yIHRyaWdnZXJpbmcgYSByZXNpemUgZXZlbnQpLCB0aGVuIHRoZSByZXNpemUgZXZlbnQgd291bGQgbm90XG4gICAgICAgIC8vIHdvcmsgKHRvIHNob3cgdGhlIG1hcCksIHNvIHdlIHRyaWdnZXIgdGhlIGV2ZW50IGluIGEgdGltZW91dC5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9tYXBzV3JhcHBlci50cmlnZ2VyTWFwRXZlbnQoJ3Jlc2l6ZScpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZSgpOyB9KTsgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcC5wcm90b3R5cGUuX3VwZGF0ZVBvc2l0aW9uID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGNoYW5nZXNbJ2xhdGl0dWRlJ10gPT0gbnVsbCAmJiBjaGFuZ2VzWydsb25naXR1ZGUnXSA9PSBudWxsICYmXG4gICAgICAgICAgICBjaGFuZ2VzWydmaXRCb3VuZHMnXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBubyBwb3NpdGlvbiB1cGRhdGUgbmVlZGVkXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UgcHJlZmVyIGZpdEJvdW5kcyBpbiBjaGFuZ2VzXG4gICAgICAgIGlmIChjaGFuZ2VzWydmaXRCb3VuZHMnXSAmJiB0aGlzLmZpdEJvdW5kcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9maXRCb3VuZHMoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMubGF0aXR1ZGUgIT09ICdudW1iZXInIHx8IHR5cGVvZiB0aGlzLmxvbmdpdHVkZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3Q2VudGVyID0ge1xuICAgICAgICAgICAgbGF0OiB0aGlzLmxhdGl0dWRlLFxuICAgICAgICAgICAgbG5nOiB0aGlzLmxvbmdpdHVkZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMudXNlUGFubmluZykge1xuICAgICAgICAgICAgdGhpcy5fbWFwc1dyYXBwZXIucGFuVG8obmV3Q2VudGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX21hcHNXcmFwcGVyLnNldENlbnRlcihuZXdDZW50ZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwLnByb3RvdHlwZS5fZml0Qm91bmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy51c2VQYW5uaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXBzV3JhcHBlci5wYW5Ub0JvdW5kcyh0aGlzLmZpdEJvdW5kcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWFwc1dyYXBwZXIuZml0Qm91bmRzKHRoaXMuZml0Qm91bmRzKTtcbiAgICB9O1xuICAgIFNlYm1Hb29nbGVNYXAucHJvdG90eXBlLl9oYW5kbGVNYXBDZW50ZXJDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzID0gdGhpcy5fbWFwc1dyYXBwZXIuc3Vic2NyaWJlVG9NYXBFdmVudCgnY2VudGVyX2NoYW5nZWQnKS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX21hcHNXcmFwcGVyLmdldENlbnRlcigpLnRoZW4oZnVuY3Rpb24gKGNlbnRlcikge1xuICAgICAgICAgICAgICAgIF90aGlzLmxhdGl0dWRlID0gY2VudGVyLmxhdCgpO1xuICAgICAgICAgICAgICAgIF90aGlzLmxvbmdpdHVkZSA9IGNlbnRlci5sbmcoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jZW50ZXJDaGFuZ2UuZW1pdCh7IGxhdDogX3RoaXMubGF0aXR1ZGUsIGxuZzogX3RoaXMubG9uZ2l0dWRlIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9vYnNlcnZhYmxlU3Vic2NyaXB0aW9ucy5wdXNoKHMpO1xuICAgIH07XG4gICAgU2VibUdvb2dsZU1hcC5wcm90b3R5cGUuX2hhbmRsZUJvdW5kc0NoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHMgPSB0aGlzLl9tYXBzV3JhcHBlci5zdWJzY3JpYmVUb01hcEV2ZW50KCdib3VuZHNfY2hhbmdlZCcpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fbWFwc1dyYXBwZXIuZ2V0Qm91bmRzKCkudGhlbihmdW5jdGlvbiAoYm91bmRzKSB7IF90aGlzLmJvdW5kc0NoYW5nZS5lbWl0KGJvdW5kcyk7IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fb2JzZXJ2YWJsZVN1YnNjcmlwdGlvbnMucHVzaChzKTtcbiAgICB9O1xuICAgIFNlYm1Hb29nbGVNYXAucHJvdG90eXBlLl9oYW5kbGVNYXBab29tQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcyA9IHRoaXMuX21hcHNXcmFwcGVyLnN1YnNjcmliZVRvTWFwRXZlbnQoJ3pvb21fY2hhbmdlZCcpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fbWFwc1dyYXBwZXIuZ2V0Wm9vbSgpLnRoZW4oZnVuY3Rpb24gKHopIHtcbiAgICAgICAgICAgICAgICBfdGhpcy56b29tID0gejtcbiAgICAgICAgICAgICAgICBfdGhpcy56b29tQ2hhbmdlLmVtaXQoeik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX29ic2VydmFibGVTdWJzY3JpcHRpb25zLnB1c2gocyk7XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwLnByb3RvdHlwZS5faGFuZGxlSWRsZUV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcyA9IHRoaXMuX21hcHNXcmFwcGVyLnN1YnNjcmliZVRvTWFwRXZlbnQoJ2lkbGUnKS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkgeyBfdGhpcy5pZGxlLmVtaXQodm9pZCAwKTsgfSk7XG4gICAgICAgIHRoaXMuX29ic2VydmFibGVTdWJzY3JpcHRpb25zLnB1c2gocyk7XG4gICAgfTtcbiAgICBTZWJtR29vZ2xlTWFwLnByb3RvdHlwZS5faGFuZGxlTWFwTW91c2VFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBldmVudHMgPSBbXG4gICAgICAgICAgICB7IG5hbWU6ICdjbGljaycsIGVtaXR0ZXI6IHRoaXMubWFwQ2xpY2sgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ3JpZ2h0Y2xpY2snLCBlbWl0dGVyOiB0aGlzLm1hcFJpZ2h0Q2xpY2sgfSxcbiAgICAgICAgXTtcbiAgICAgICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBzID0gX3RoaXMuX21hcHNXcmFwcGVyLnN1YnNjcmliZVRvTWFwRXZlbnQoZS5uYW1lKS5zdWJzY3JpYmUoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0geyBjb29yZHM6IHsgbGF0OiBldmVudC5sYXRMbmcubGF0KCksIGxuZzogZXZlbnQubGF0TG5nLmxuZygpIH0gfTtcbiAgICAgICAgICAgICAgICBlLmVtaXR0ZXIuZW1pdCh2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF90aGlzLl9vYnNlcnZhYmxlU3Vic2NyaXB0aW9ucy5wdXNoKHMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1hcCBvcHRpb24gYXR0cmlidXRlcyB0aGF0IGNhbiBjaGFuZ2Ugb3ZlciB0aW1lXG4gICAgICovXG4gICAgU2VibUdvb2dsZU1hcC5fbWFwT3B0aW9uc0F0dHJpYnV0ZXMgPSBbXG4gICAgICAgICdkaXNhYmxlRG91YmxlQ2xpY2tab29tJywgJ3Njcm9sbHdoZWVsJywgJ2RyYWdnYWJsZScsICdkcmFnZ2FibGVDdXJzb3InLCAnZHJhZ2dpbmdDdXJzb3InLFxuICAgICAgICAna2V5Ym9hcmRTaG9ydGN1dHMnLCAnem9vbUNvbnRyb2wnLCAnc3R5bGVzJywgJ3N0cmVldFZpZXdDb250cm9sJywgJ3pvb20nLCAnbWFwVHlwZUNvbnRyb2wnLFxuICAgICAgICAnbWluWm9vbScsICdtYXhab29tJ1xuICAgIF07XG4gICAgU2VibUdvb2dsZU1hcC5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5Db21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnc2VibS1nb29nbGUtbWFwJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBnb29nbGVfbWFwc19hcGlfd3JhcHBlcl8xLkdvb2dsZU1hcHNBUElXcmFwcGVyLCBtYXJrZXJfbWFuYWdlcl8xLk1hcmtlck1hbmFnZXIsIGluZm9fd2luZG93X21hbmFnZXJfMS5JbmZvV2luZG93TWFuYWdlciwgY2lyY2xlX21hbmFnZXJfMS5DaXJjbGVNYW5hZ2VyLCBwb2x5bGluZV9tYW5hZ2VyXzEuUG9seWxpbmVNYW5hZ2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbl9tYW5hZ2VyXzEuUG9seWdvbk1hbmFnZXIsIGttbF9sYXllcl9tYW5hZ2VyXzEuS21sTGF5ZXJNYW5hZ2VyXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2xvbmdpdHVkZScsICdsYXRpdHVkZScsICd6b29tJywgJ21pblpvb20nLCAnbWF4Wm9vbScsICdkcmFnZ2FibGU6IG1hcERyYWdnYWJsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGlzYWJsZURvdWJsZUNsaWNrWm9vbScsICdkaXNhYmxlRGVmYXVsdFVJJywgJ3Njcm9sbHdoZWVsJywgJ2JhY2tncm91bmRDb2xvcicsICdkcmFnZ2FibGVDdXJzb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RyYWdnaW5nQ3Vyc29yJywgJ2tleWJvYXJkU2hvcnRjdXRzJywgJ3pvb21Db250cm9sJywgJ3N0eWxlcycsICd1c2VQYW5uaW5nJywgJ3N0cmVldFZpZXdDb250cm9sJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmaXRCb3VuZHMnLCAnc2NhbGVDb250cm9sJywgJ21hcFR5cGVDb250cm9sJ1xuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFwQ2xpY2snLCAnbWFwUmlnaHRDbGljaycsICdtYXBEYmxDbGljaycsICdjZW50ZXJDaGFuZ2UnLCAnaWRsZScsICdib3VuZHNDaGFuZ2UnLCAnem9vbUNoYW5nZSdcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnW2NsYXNzLnNlYm0tZ29vZ2xlLW1hcC1jb250YWluZXJdJzogJ3RydWUnIH0sXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlczogW1wiXFxuICAgIC5zZWJtLWdvb2dsZS1tYXAtY29udGFpbmVyLWlubmVyIHtcXG4gICAgICB3aWR0aDogaW5oZXJpdDtcXG4gICAgICBoZWlnaHQ6IGluaGVyaXQ7XFxuICAgIH1cXG4gICAgLnNlYm0tZ29vZ2xlLW1hcC1jb250ZW50IHtcXG4gICAgICBkaXNwbGF5Om5vbmU7XFxuICAgIH1cXG4gIFwiXSxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgIDxkaXYgY2xhc3M9J3NlYm0tZ29vZ2xlLW1hcC1jb250YWluZXItaW5uZXInPjwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPSdzZWJtLWdvb2dsZS1tYXAtY29udGVudCc+XFxuICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxcbiAgICA8L2Rpdj5cXG4gIFwiXG4gICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgXTtcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBTZWJtR29vZ2xlTWFwLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IGNvcmVfMS5FbGVtZW50UmVmLCB9LFxuICAgICAgICB7IHR5cGU6IGdvb2dsZV9tYXBzX2FwaV93cmFwcGVyXzEuR29vZ2xlTWFwc0FQSVdyYXBwZXIsIH0sXG4gICAgXTsgfTtcbiAgICByZXR1cm4gU2VibUdvb2dsZU1hcDtcbn0oKSk7XG5leHBvcnRzLlNlYm1Hb29nbGVNYXAgPSBTZWJtR29vZ2xlTWFwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z29vZ2xlLW1hcC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS9kaXJlY3RpdmVzL2dvb2dsZS1tYXAuanNcbi8vIG1vZHVsZSBpZCA9IDczNFxuLy8gbW9kdWxlIGNodW5rcyA9IDUgOCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 735:
/* unknown exports provided */
/* all exports used */
/*!**************************************************************!*\
  !*** ./~/angular2-google-maps/core/utils/browser-globals.js ***!
  \**************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar WindowRef = (function () {\n    function WindowRef() {\n    }\n    WindowRef.prototype.getNativeWindow = function () { return window; };\n    return WindowRef;\n}());\nexports.WindowRef = WindowRef;\nvar DocumentRef = (function () {\n    function DocumentRef() {\n    }\n    DocumentRef.prototype.getNativeDocument = function () { return document; };\n    return DocumentRef;\n}());\nexports.DocumentRef = DocumentRef;\nexports.BROWSER_GLOBALS_PROVIDERS = [WindowRef, DocumentRef];\n//# sourceMappingURL=browser-globals.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzM1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL3V0aWxzL2Jyb3dzZXItZ2xvYmFscy5qcz82YmJlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIFdpbmRvd1JlZiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gV2luZG93UmVmKCkge1xuICAgIH1cbiAgICBXaW5kb3dSZWYucHJvdG90eXBlLmdldE5hdGl2ZVdpbmRvdyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdpbmRvdzsgfTtcbiAgICByZXR1cm4gV2luZG93UmVmO1xufSgpKTtcbmV4cG9ydHMuV2luZG93UmVmID0gV2luZG93UmVmO1xudmFyIERvY3VtZW50UmVmID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEb2N1bWVudFJlZigpIHtcbiAgICB9XG4gICAgRG9jdW1lbnRSZWYucHJvdG90eXBlLmdldE5hdGl2ZURvY3VtZW50ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9jdW1lbnQ7IH07XG4gICAgcmV0dXJuIERvY3VtZW50UmVmO1xufSgpKTtcbmV4cG9ydHMuRG9jdW1lbnRSZWYgPSBEb2N1bWVudFJlZjtcbmV4cG9ydHMuQlJPV1NFUl9HTE9CQUxTX1BST1ZJREVSUyA9IFtXaW5kb3dSZWYsIERvY3VtZW50UmVmXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJyb3dzZXItZ2xvYmFscy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYW5ndWxhcjItZ29vZ2xlLW1hcHMvY29yZS91dGlscy9icm93c2VyLWdsb2JhbHMuanNcbi8vIG1vZHVsZSBpZCA9IDczNVxuLy8gbW9kdWxlIGNodW5rcyA9IDUgOCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 736:
/* unknown exports provided */
/* all exports used */
/*!********************************!*\
  !*** ./~/jquery-ui/ui/core.js ***!
  \********************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery UI Core 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/category/ui-core/\n */\n(function( factory ) {\n\tif ( true ) {\n\n\t\t// AMD. Register as an anonymous module.\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(/*! jquery */ 41) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {\n\n\t\t// Browser globals\n\t\tfactory( jQuery );\n\t}\n}(function( $ ) {\n\n// $.ui might exist from components with no dependencies, e.g., $.ui.position\n$.ui = $.ui || {};\n\n$.extend( $.ui, {\n\tversion: \"1.11.4\",\n\n\tkeyCode: {\n\t\tBACKSPACE: 8,\n\t\tCOMMA: 188,\n\t\tDELETE: 46,\n\t\tDOWN: 40,\n\t\tEND: 35,\n\t\tENTER: 13,\n\t\tESCAPE: 27,\n\t\tHOME: 36,\n\t\tLEFT: 37,\n\t\tPAGE_DOWN: 34,\n\t\tPAGE_UP: 33,\n\t\tPERIOD: 190,\n\t\tRIGHT: 39,\n\t\tSPACE: 32,\n\t\tTAB: 9,\n\t\tUP: 38\n\t}\n});\n\n// plugins\n$.fn.extend({\n\tscrollParent: function( includeHidden ) {\n\t\tvar position = this.css( \"position\" ),\n\t\t\texcludeStaticParent = position === \"absolute\",\n\t\t\toverflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,\n\t\t\tscrollParent = this.parents().filter( function() {\n\t\t\t\tvar parent = $( this );\n\t\t\t\tif ( excludeStaticParent && parent.css( \"position\" ) === \"static\" ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn overflowRegex.test( parent.css( \"overflow\" ) + parent.css( \"overflow-y\" ) + parent.css( \"overflow-x\" ) );\n\t\t\t}).eq( 0 );\n\n\t\treturn position === \"fixed\" || !scrollParent.length ? $( this[ 0 ].ownerDocument || document ) : scrollParent;\n\t},\n\n\tuniqueId: (function() {\n\t\tvar uuid = 0;\n\n\t\treturn function() {\n\t\t\treturn this.each(function() {\n\t\t\t\tif ( !this.id ) {\n\t\t\t\t\tthis.id = \"ui-id-\" + ( ++uuid );\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t})(),\n\n\tremoveUniqueId: function() {\n\t\treturn this.each(function() {\n\t\t\tif ( /^ui-id-\\d+$/.test( this.id ) ) {\n\t\t\t\t$( this ).removeAttr( \"id\" );\n\t\t\t}\n\t\t});\n\t}\n});\n\n// selectors\nfunction focusable( element, isTabIndexNotNaN ) {\n\tvar map, mapName, img,\n\t\tnodeName = element.nodeName.toLowerCase();\n\tif ( \"area\" === nodeName ) {\n\t\tmap = element.parentNode;\n\t\tmapName = map.name;\n\t\tif ( !element.href || !mapName || map.nodeName.toLowerCase() !== \"map\" ) {\n\t\t\treturn false;\n\t\t}\n\t\timg = $( \"img[usemap='#\" + mapName + \"']\" )[ 0 ];\n\t\treturn !!img && visible( img );\n\t}\n\treturn ( /^(input|select|textarea|button|object)$/.test( nodeName ) ?\n\t\t!element.disabled :\n\t\t\"a\" === nodeName ?\n\t\t\telement.href || isTabIndexNotNaN :\n\t\t\tisTabIndexNotNaN) &&\n\t\t// the element and all of its ancestors must be visible\n\t\tvisible( element );\n}\n\nfunction visible( element ) {\n\treturn $.expr.filters.visible( element ) &&\n\t\t!$( element ).parents().addBack().filter(function() {\n\t\t\treturn $.css( this, \"visibility\" ) === \"hidden\";\n\t\t}).length;\n}\n\n$.extend( $.expr[ \":\" ], {\n\tdata: $.expr.createPseudo ?\n\t\t$.expr.createPseudo(function( dataName ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn !!$.data( elem, dataName );\n\t\t\t};\n\t\t}) :\n\t\t// support: jQuery <1.8\n\t\tfunction( elem, i, match ) {\n\t\t\treturn !!$.data( elem, match[ 3 ] );\n\t\t},\n\n\tfocusable: function( element ) {\n\t\treturn focusable( element, !isNaN( $.attr( element, \"tabindex\" ) ) );\n\t},\n\n\ttabbable: function( element ) {\n\t\tvar tabIndex = $.attr( element, \"tabindex\" ),\n\t\t\tisTabIndexNaN = isNaN( tabIndex );\n\t\treturn ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );\n\t}\n});\n\n// support: jQuery <1.8\nif ( !$( \"<a>\" ).outerWidth( 1 ).jquery ) {\n\t$.each( [ \"Width\", \"Height\" ], function( i, name ) {\n\t\tvar side = name === \"Width\" ? [ \"Left\", \"Right\" ] : [ \"Top\", \"Bottom\" ],\n\t\t\ttype = name.toLowerCase(),\n\t\t\torig = {\n\t\t\t\tinnerWidth: $.fn.innerWidth,\n\t\t\t\tinnerHeight: $.fn.innerHeight,\n\t\t\t\touterWidth: $.fn.outerWidth,\n\t\t\t\touterHeight: $.fn.outerHeight\n\t\t\t};\n\n\t\tfunction reduce( elem, size, border, margin ) {\n\t\t\t$.each( side, function() {\n\t\t\t\tsize -= parseFloat( $.css( elem, \"padding\" + this ) ) || 0;\n\t\t\t\tif ( border ) {\n\t\t\t\t\tsize -= parseFloat( $.css( elem, \"border\" + this + \"Width\" ) ) || 0;\n\t\t\t\t}\n\t\t\t\tif ( margin ) {\n\t\t\t\t\tsize -= parseFloat( $.css( elem, \"margin\" + this ) ) || 0;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn size;\n\t\t}\n\n\t\t$.fn[ \"inner\" + name ] = function( size ) {\n\t\t\tif ( size === undefined ) {\n\t\t\t\treturn orig[ \"inner\" + name ].call( this );\n\t\t\t}\n\n\t\t\treturn this.each(function() {\n\t\t\t\t$( this ).css( type, reduce( this, size ) + \"px\" );\n\t\t\t});\n\t\t};\n\n\t\t$.fn[ \"outer\" + name] = function( size, margin ) {\n\t\t\tif ( typeof size !== \"number\" ) {\n\t\t\t\treturn orig[ \"outer\" + name ].call( this, size );\n\t\t\t}\n\n\t\t\treturn this.each(function() {\n\t\t\t\t$( this).css( type, reduce( this, size, true, margin ) + \"px\" );\n\t\t\t});\n\t\t};\n\t});\n}\n\n// support: jQuery <1.8\nif ( !$.fn.addBack ) {\n\t$.fn.addBack = function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter( selector )\n\t\t);\n\t};\n}\n\n// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)\nif ( $( \"<a>\" ).data( \"a-b\", \"a\" ).removeData( \"a-b\" ).data( \"a-b\" ) ) {\n\t$.fn.removeData = (function( removeData ) {\n\t\treturn function( key ) {\n\t\t\tif ( arguments.length ) {\n\t\t\t\treturn removeData.call( this, $.camelCase( key ) );\n\t\t\t} else {\n\t\t\t\treturn removeData.call( this );\n\t\t\t}\n\t\t};\n\t})( $.fn.removeData );\n}\n\n// deprecated\n$.ui.ie = !!/msie [\\w.]+/.exec( navigator.userAgent.toLowerCase() );\n\n$.fn.extend({\n\tfocus: (function( orig ) {\n\t\treturn function( delay, fn ) {\n\t\t\treturn typeof delay === \"number\" ?\n\t\t\t\tthis.each(function() {\n\t\t\t\t\tvar elem = this;\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\t$( elem ).focus();\n\t\t\t\t\t\tif ( fn ) {\n\t\t\t\t\t\t\tfn.call( elem );\n\t\t\t\t\t\t}\n\t\t\t\t\t}, delay );\n\t\t\t\t}) :\n\t\t\t\torig.apply( this, arguments );\n\t\t};\n\t})( $.fn.focus ),\n\n\tdisableSelection: (function() {\n\t\tvar eventType = \"onselectstart\" in document.createElement( \"div\" ) ?\n\t\t\t\"selectstart\" :\n\t\t\t\"mousedown\";\n\n\t\treturn function() {\n\t\t\treturn this.bind( eventType + \".ui-disableSelection\", function( event ) {\n\t\t\t\tevent.preventDefault();\n\t\t\t});\n\t\t};\n\t})(),\n\n\tenableSelection: function() {\n\t\treturn this.unbind( \".ui-disableSelection\" );\n\t},\n\n\tzIndex: function( zIndex ) {\n\t\tif ( zIndex !== undefined ) {\n\t\t\treturn this.css( \"zIndex\", zIndex );\n\t\t}\n\n\t\tif ( this.length ) {\n\t\t\tvar elem = $( this[ 0 ] ), position, value;\n\t\t\twhile ( elem.length && elem[ 0 ] !== document ) {\n\t\t\t\t// Ignore z-index if position is set to a value where z-index is ignored by the browser\n\t\t\t\t// This makes behavior of this function consistent across browsers\n\t\t\t\t// WebKit always returns auto if the element is positioned\n\t\t\t\tposition = elem.css( \"position\" );\n\t\t\t\tif ( position === \"absolute\" || position === \"relative\" || position === \"fixed\" ) {\n\t\t\t\t\t// IE returns 0 when zIndex is not specified\n\t\t\t\t\t// other browsers return a string\n\t\t\t\t\t// we ignore the case of nested elements with an explicit value of 0\n\t\t\t\t\t// <div style=\"z-index: -10;\"><div style=\"z-index: 0;\"></div></div>\n\t\t\t\t\tvalue = parseInt( elem.css( \"zIndex\" ), 10 );\n\t\t\t\t\tif ( !isNaN( value ) && value !== 0 ) {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telem = elem.parent();\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n});\n\n// $.ui.plugin is deprecated. Use $.widget() extensions instead.\n$.ui.plugin = {\n\tadd: function( module, option, set ) {\n\t\tvar i,\n\t\t\tproto = $.ui[ module ].prototype;\n\t\tfor ( i in set ) {\n\t\t\tproto.plugins[ i ] = proto.plugins[ i ] || [];\n\t\t\tproto.plugins[ i ].push( [ option, set[ i ] ] );\n\t\t}\n\t},\n\tcall: function( instance, name, args, allowDisconnected ) {\n\t\tvar i,\n\t\t\tset = instance.plugins[ name ];\n\n\t\tif ( !set ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !allowDisconnected && ( !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor ( i = 0; i < set.length; i++ ) {\n\t\t\tif ( instance.options[ set[ i ][ 0 ] ] ) {\n\t\t\t\tset[ i ][ 1 ].apply( instance.element, args );\n\t\t\t}\n\t\t}\n\t}\n};\n\n}));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzM2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9qcXVlcnktdWkvdWkvY29yZS5qcz8wNjc5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogalF1ZXJ5IFVJIENvcmUgMS4xMS40XG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9jYXRlZ29yeS91aS1jb3JlL1xuICovXG4oZnVuY3Rpb24oIGZhY3RvcnkgKSB7XG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cblx0XHQvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG5cdFx0ZGVmaW5lKCBbIFwianF1ZXJ5XCIgXSwgZmFjdG9yeSApO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gQnJvd3NlciBnbG9iYWxzXG5cdFx0ZmFjdG9yeSggalF1ZXJ5ICk7XG5cdH1cbn0oZnVuY3Rpb24oICQgKSB7XG5cbi8vICQudWkgbWlnaHQgZXhpc3QgZnJvbSBjb21wb25lbnRzIHdpdGggbm8gZGVwZW5kZW5jaWVzLCBlLmcuLCAkLnVpLnBvc2l0aW9uXG4kLnVpID0gJC51aSB8fCB7fTtcblxuJC5leHRlbmQoICQudWksIHtcblx0dmVyc2lvbjogXCIxLjExLjRcIixcblxuXHRrZXlDb2RlOiB7XG5cdFx0QkFDS1NQQUNFOiA4LFxuXHRcdENPTU1BOiAxODgsXG5cdFx0REVMRVRFOiA0Nixcblx0XHRET1dOOiA0MCxcblx0XHRFTkQ6IDM1LFxuXHRcdEVOVEVSOiAxMyxcblx0XHRFU0NBUEU6IDI3LFxuXHRcdEhPTUU6IDM2LFxuXHRcdExFRlQ6IDM3LFxuXHRcdFBBR0VfRE9XTjogMzQsXG5cdFx0UEFHRV9VUDogMzMsXG5cdFx0UEVSSU9EOiAxOTAsXG5cdFx0UklHSFQ6IDM5LFxuXHRcdFNQQUNFOiAzMixcblx0XHRUQUI6IDksXG5cdFx0VVA6IDM4XG5cdH1cbn0pO1xuXG4vLyBwbHVnaW5zXG4kLmZuLmV4dGVuZCh7XG5cdHNjcm9sbFBhcmVudDogZnVuY3Rpb24oIGluY2x1ZGVIaWRkZW4gKSB7XG5cdFx0dmFyIHBvc2l0aW9uID0gdGhpcy5jc3MoIFwicG9zaXRpb25cIiApLFxuXHRcdFx0ZXhjbHVkZVN0YXRpY1BhcmVudCA9IHBvc2l0aW9uID09PSBcImFic29sdXRlXCIsXG5cdFx0XHRvdmVyZmxvd1JlZ2V4ID0gaW5jbHVkZUhpZGRlbiA/IC8oYXV0b3xzY3JvbGx8aGlkZGVuKS8gOiAvKGF1dG98c2Nyb2xsKS8sXG5cdFx0XHRzY3JvbGxQYXJlbnQgPSB0aGlzLnBhcmVudHMoKS5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcGFyZW50ID0gJCggdGhpcyApO1xuXHRcdFx0XHRpZiAoIGV4Y2x1ZGVTdGF0aWNQYXJlbnQgJiYgcGFyZW50LmNzcyggXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBvdmVyZmxvd1JlZ2V4LnRlc3QoIHBhcmVudC5jc3MoIFwib3ZlcmZsb3dcIiApICsgcGFyZW50LmNzcyggXCJvdmVyZmxvdy15XCIgKSArIHBhcmVudC5jc3MoIFwib3ZlcmZsb3cteFwiICkgKTtcblx0XHRcdH0pLmVxKCAwICk7XG5cblx0XHRyZXR1cm4gcG9zaXRpb24gPT09IFwiZml4ZWRcIiB8fCAhc2Nyb2xsUGFyZW50Lmxlbmd0aCA/ICQoIHRoaXNbIDAgXS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50ICkgOiBzY3JvbGxQYXJlbnQ7XG5cdH0sXG5cblx0dW5pcXVlSWQ6IChmdW5jdGlvbigpIHtcblx0XHR2YXIgdXVpZCA9IDA7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICF0aGlzLmlkICkge1xuXHRcdFx0XHRcdHRoaXMuaWQgPSBcInVpLWlkLVwiICsgKCArK3V1aWQgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fTtcblx0fSkoKSxcblxuXHRyZW1vdmVVbmlxdWVJZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdGlmICggL151aS1pZC1cXGQrJC8udGVzdCggdGhpcy5pZCApICkge1xuXHRcdFx0XHQkKCB0aGlzICkucmVtb3ZlQXR0ciggXCJpZFwiICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG4vLyBzZWxlY3RvcnNcbmZ1bmN0aW9uIGZvY3VzYWJsZSggZWxlbWVudCwgaXNUYWJJbmRleE5vdE5hTiApIHtcblx0dmFyIG1hcCwgbWFwTmFtZSwgaW1nLFxuXHRcdG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRpZiAoIFwiYXJlYVwiID09PSBub2RlTmFtZSApIHtcblx0XHRtYXAgPSBlbGVtZW50LnBhcmVudE5vZGU7XG5cdFx0bWFwTmFtZSA9IG1hcC5uYW1lO1xuXHRcdGlmICggIWVsZW1lbnQuaHJlZiB8fCAhbWFwTmFtZSB8fCBtYXAubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJtYXBcIiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0aW1nID0gJCggXCJpbWdbdXNlbWFwPScjXCIgKyBtYXBOYW1lICsgXCInXVwiIClbIDAgXTtcblx0XHRyZXR1cm4gISFpbWcgJiYgdmlzaWJsZSggaW1nICk7XG5cdH1cblx0cmV0dXJuICggL14oaW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbnxvYmplY3QpJC8udGVzdCggbm9kZU5hbWUgKSA/XG5cdFx0IWVsZW1lbnQuZGlzYWJsZWQgOlxuXHRcdFwiYVwiID09PSBub2RlTmFtZSA/XG5cdFx0XHRlbGVtZW50LmhyZWYgfHwgaXNUYWJJbmRleE5vdE5hTiA6XG5cdFx0XHRpc1RhYkluZGV4Tm90TmFOKSAmJlxuXHRcdC8vIHRoZSBlbGVtZW50IGFuZCBhbGwgb2YgaXRzIGFuY2VzdG9ycyBtdXN0IGJlIHZpc2libGVcblx0XHR2aXNpYmxlKCBlbGVtZW50ICk7XG59XG5cbmZ1bmN0aW9uIHZpc2libGUoIGVsZW1lbnQgKSB7XG5cdHJldHVybiAkLmV4cHIuZmlsdGVycy52aXNpYmxlKCBlbGVtZW50ICkgJiZcblx0XHQhJCggZWxlbWVudCApLnBhcmVudHMoKS5hZGRCYWNrKCkuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuICQuY3NzKCB0aGlzLCBcInZpc2liaWxpdHlcIiApID09PSBcImhpZGRlblwiO1xuXHRcdH0pLmxlbmd0aDtcbn1cblxuJC5leHRlbmQoICQuZXhwclsgXCI6XCIgXSwge1xuXHRkYXRhOiAkLmV4cHIuY3JlYXRlUHNldWRvID9cblx0XHQkLmV4cHIuY3JlYXRlUHNldWRvKGZ1bmN0aW9uKCBkYXRhTmFtZSApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuICEhJC5kYXRhKCBlbGVtLCBkYXRhTmFtZSApO1xuXHRcdFx0fTtcblx0XHR9KSA6XG5cdFx0Ly8gc3VwcG9ydDogalF1ZXJ5IDwxLjhcblx0XHRmdW5jdGlvbiggZWxlbSwgaSwgbWF0Y2ggKSB7XG5cdFx0XHRyZXR1cm4gISEkLmRhdGEoIGVsZW0sIG1hdGNoWyAzIF0gKTtcblx0XHR9LFxuXG5cdGZvY3VzYWJsZTogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuIGZvY3VzYWJsZSggZWxlbWVudCwgIWlzTmFOKCAkLmF0dHIoIGVsZW1lbnQsIFwidGFiaW5kZXhcIiApICkgKTtcblx0fSxcblxuXHR0YWJiYWJsZTogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0dmFyIHRhYkluZGV4ID0gJC5hdHRyKCBlbGVtZW50LCBcInRhYmluZGV4XCIgKSxcblx0XHRcdGlzVGFiSW5kZXhOYU4gPSBpc05hTiggdGFiSW5kZXggKTtcblx0XHRyZXR1cm4gKCBpc1RhYkluZGV4TmFOIHx8IHRhYkluZGV4ID49IDAgKSAmJiBmb2N1c2FibGUoIGVsZW1lbnQsICFpc1RhYkluZGV4TmFOICk7XG5cdH1cbn0pO1xuXG4vLyBzdXBwb3J0OiBqUXVlcnkgPDEuOFxuaWYgKCAhJCggXCI8YT5cIiApLm91dGVyV2lkdGgoIDEgKS5qcXVlcnkgKSB7XG5cdCQuZWFjaCggWyBcIldpZHRoXCIsIFwiSGVpZ2h0XCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdFx0dmFyIHNpZGUgPSBuYW1lID09PSBcIldpZHRoXCIgPyBbIFwiTGVmdFwiLCBcIlJpZ2h0XCIgXSA6IFsgXCJUb3BcIiwgXCJCb3R0b21cIiBdLFxuXHRcdFx0dHlwZSA9IG5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdG9yaWcgPSB7XG5cdFx0XHRcdGlubmVyV2lkdGg6ICQuZm4uaW5uZXJXaWR0aCxcblx0XHRcdFx0aW5uZXJIZWlnaHQ6ICQuZm4uaW5uZXJIZWlnaHQsXG5cdFx0XHRcdG91dGVyV2lkdGg6ICQuZm4ub3V0ZXJXaWR0aCxcblx0XHRcdFx0b3V0ZXJIZWlnaHQ6ICQuZm4ub3V0ZXJIZWlnaHRcblx0XHRcdH07XG5cblx0XHRmdW5jdGlvbiByZWR1Y2UoIGVsZW0sIHNpemUsIGJvcmRlciwgbWFyZ2luICkge1xuXHRcdFx0JC5lYWNoKCBzaWRlLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2l6ZSAtPSBwYXJzZUZsb2F0KCAkLmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyB0aGlzICkgKSB8fCAwO1xuXHRcdFx0XHRpZiAoIGJvcmRlciApIHtcblx0XHRcdFx0XHRzaXplIC09IHBhcnNlRmxvYXQoICQuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgdGhpcyArIFwiV2lkdGhcIiApICkgfHwgMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIG1hcmdpbiApIHtcblx0XHRcdFx0XHRzaXplIC09IHBhcnNlRmxvYXQoICQuY3NzKCBlbGVtLCBcIm1hcmdpblwiICsgdGhpcyApICkgfHwgMDtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gc2l6ZTtcblx0XHR9XG5cblx0XHQkLmZuWyBcImlubmVyXCIgKyBuYW1lIF0gPSBmdW5jdGlvbiggc2l6ZSApIHtcblx0XHRcdGlmICggc2l6ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gb3JpZ1sgXCJpbm5lclwiICsgbmFtZSBdLmNhbGwoIHRoaXMgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0JCggdGhpcyApLmNzcyggdHlwZSwgcmVkdWNlKCB0aGlzLCBzaXplICkgKyBcInB4XCIgKTtcblx0XHRcdH0pO1xuXHRcdH07XG5cblx0XHQkLmZuWyBcIm91dGVyXCIgKyBuYW1lXSA9IGZ1bmN0aW9uKCBzaXplLCBtYXJnaW4gKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBzaXplICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRyZXR1cm4gb3JpZ1sgXCJvdXRlclwiICsgbmFtZSBdLmNhbGwoIHRoaXMsIHNpemUgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0JCggdGhpcykuY3NzKCB0eXBlLCByZWR1Y2UoIHRoaXMsIHNpemUsIHRydWUsIG1hcmdpbiApICsgXCJweFwiICk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXHR9KTtcbn1cblxuLy8gc3VwcG9ydDogalF1ZXJ5IDwxLjhcbmlmICggISQuZm4uYWRkQmFjayApIHtcblx0JC5mbi5hZGRCYWNrID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG5cdFx0XHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKCBzZWxlY3RvciApXG5cdFx0KTtcblx0fTtcbn1cblxuLy8gc3VwcG9ydDogalF1ZXJ5IDEuNi4xLCAxLjYuMiAoaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvOTQxMylcbmlmICggJCggXCI8YT5cIiApLmRhdGEoIFwiYS1iXCIsIFwiYVwiICkucmVtb3ZlRGF0YSggXCJhLWJcIiApLmRhdGEoIFwiYS1iXCIgKSApIHtcblx0JC5mbi5yZW1vdmVEYXRhID0gKGZ1bmN0aW9uKCByZW1vdmVEYXRhICkge1xuXHRcdHJldHVybiBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtb3ZlRGF0YS5jYWxsKCB0aGlzLCAkLmNhbWVsQ2FzZSgga2V5ICkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiByZW1vdmVEYXRhLmNhbGwoIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KSggJC5mbi5yZW1vdmVEYXRhICk7XG59XG5cbi8vIGRlcHJlY2F0ZWRcbiQudWkuaWUgPSAhIS9tc2llIFtcXHcuXSsvLmV4ZWMoIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSApO1xuXG4kLmZuLmV4dGVuZCh7XG5cdGZvY3VzOiAoZnVuY3Rpb24oIG9yaWcgKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBkZWxheSwgZm4gKSB7XG5cdFx0XHRyZXR1cm4gdHlwZW9mIGRlbGF5ID09PSBcIm51bWJlclwiID9cblx0XHRcdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBlbGVtID0gdGhpcztcblx0XHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0JCggZWxlbSApLmZvY3VzKCk7XG5cdFx0XHRcdFx0XHRpZiAoIGZuICkge1xuXHRcdFx0XHRcdFx0XHRmbi5jYWxsKCBlbGVtICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgZGVsYXkgKTtcblx0XHRcdFx0fSkgOlxuXHRcdFx0XHRvcmlnLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9O1xuXHR9KSggJC5mbi5mb2N1cyApLFxuXG5cdGRpc2FibGVTZWxlY3Rpb246IChmdW5jdGlvbigpIHtcblx0XHR2YXIgZXZlbnRUeXBlID0gXCJvbnNlbGVjdHN0YXJ0XCIgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApID9cblx0XHRcdFwic2VsZWN0c3RhcnRcIiA6XG5cdFx0XHRcIm1vdXNlZG93blwiO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYmluZCggZXZlbnRUeXBlICsgXCIudWktZGlzYWJsZVNlbGVjdGlvblwiLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXHR9KSgpLFxuXG5cdGVuYWJsZVNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMudW5iaW5kKCBcIi51aS1kaXNhYmxlU2VsZWN0aW9uXCIgKTtcblx0fSxcblxuXHR6SW5kZXg6IGZ1bmN0aW9uKCB6SW5kZXggKSB7XG5cdFx0aWYgKCB6SW5kZXggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybiB0aGlzLmNzcyggXCJ6SW5kZXhcIiwgekluZGV4ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcblx0XHRcdHZhciBlbGVtID0gJCggdGhpc1sgMCBdICksIHBvc2l0aW9uLCB2YWx1ZTtcblx0XHRcdHdoaWxlICggZWxlbS5sZW5ndGggJiYgZWxlbVsgMCBdICE9PSBkb2N1bWVudCApIHtcblx0XHRcdFx0Ly8gSWdub3JlIHotaW5kZXggaWYgcG9zaXRpb24gaXMgc2V0IHRvIGEgdmFsdWUgd2hlcmUgei1pbmRleCBpcyBpZ25vcmVkIGJ5IHRoZSBicm93c2VyXG5cdFx0XHRcdC8vIFRoaXMgbWFrZXMgYmVoYXZpb3Igb2YgdGhpcyBmdW5jdGlvbiBjb25zaXN0ZW50IGFjcm9zcyBicm93c2Vyc1xuXHRcdFx0XHQvLyBXZWJLaXQgYWx3YXlzIHJldHVybnMgYXV0byBpZiB0aGUgZWxlbWVudCBpcyBwb3NpdGlvbmVkXG5cdFx0XHRcdHBvc2l0aW9uID0gZWxlbS5jc3MoIFwicG9zaXRpb25cIiApO1xuXHRcdFx0XHRpZiAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwicmVsYXRpdmVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkge1xuXHRcdFx0XHRcdC8vIElFIHJldHVybnMgMCB3aGVuIHpJbmRleCBpcyBub3Qgc3BlY2lmaWVkXG5cdFx0XHRcdFx0Ly8gb3RoZXIgYnJvd3NlcnMgcmV0dXJuIGEgc3RyaW5nXG5cdFx0XHRcdFx0Ly8gd2UgaWdub3JlIHRoZSBjYXNlIG9mIG5lc3RlZCBlbGVtZW50cyB3aXRoIGFuIGV4cGxpY2l0IHZhbHVlIG9mIDBcblx0XHRcdFx0XHQvLyA8ZGl2IHN0eWxlPVwiei1pbmRleDogLTEwO1wiPjxkaXYgc3R5bGU9XCJ6LWluZGV4OiAwO1wiPjwvZGl2PjwvZGl2PlxuXHRcdFx0XHRcdHZhbHVlID0gcGFyc2VJbnQoIGVsZW0uY3NzKCBcInpJbmRleFwiICksIDEwICk7XG5cdFx0XHRcdFx0aWYgKCAhaXNOYU4oIHZhbHVlICkgJiYgdmFsdWUgIT09IDAgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsZW0gPSBlbGVtLnBhcmVudCgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiAwO1xuXHR9XG59KTtcblxuLy8gJC51aS5wbHVnaW4gaXMgZGVwcmVjYXRlZC4gVXNlICQud2lkZ2V0KCkgZXh0ZW5zaW9ucyBpbnN0ZWFkLlxuJC51aS5wbHVnaW4gPSB7XG5cdGFkZDogZnVuY3Rpb24oIG1vZHVsZSwgb3B0aW9uLCBzZXQgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHRwcm90byA9ICQudWlbIG1vZHVsZSBdLnByb3RvdHlwZTtcblx0XHRmb3IgKCBpIGluIHNldCApIHtcblx0XHRcdHByb3RvLnBsdWdpbnNbIGkgXSA9IHByb3RvLnBsdWdpbnNbIGkgXSB8fCBbXTtcblx0XHRcdHByb3RvLnBsdWdpbnNbIGkgXS5wdXNoKCBbIG9wdGlvbiwgc2V0WyBpIF0gXSApO1xuXHRcdH1cblx0fSxcblx0Y2FsbDogZnVuY3Rpb24oIGluc3RhbmNlLCBuYW1lLCBhcmdzLCBhbGxvd0Rpc2Nvbm5lY3RlZCApIHtcblx0XHR2YXIgaSxcblx0XHRcdHNldCA9IGluc3RhbmNlLnBsdWdpbnNbIG5hbWUgXTtcblxuXHRcdGlmICggIXNldCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoICFhbGxvd0Rpc2Nvbm5lY3RlZCAmJiAoICFpbnN0YW5jZS5lbGVtZW50WyAwIF0ucGFyZW50Tm9kZSB8fCBpbnN0YW5jZS5lbGVtZW50WyAwIF0ucGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gMTEgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKyApIHtcblx0XHRcdGlmICggaW5zdGFuY2Uub3B0aW9uc1sgc2V0WyBpIF1bIDAgXSBdICkge1xuXHRcdFx0XHRzZXRbIGkgXVsgMSBdLmFwcGx5KCBpbnN0YW5jZS5lbGVtZW50LCBhcmdzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG59KSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vanF1ZXJ5LXVpL3VpL2NvcmUuanNcbi8vIG1vZHVsZSBpZCA9IDczNlxuLy8gbW9kdWxlIGNodW5rcyA9IDUgOSAxMyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 737:
/* unknown exports provided */
/* all exports used */
/*!*********************************!*\
  !*** ./~/jquery-ui/ui/mouse.js ***!
  \*********************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery UI Mouse 1.11.4\n * http://jqueryui.com\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/mouse/\n */\n(function( factory ) {\n\tif ( true ) {\n\n\t\t// AMD. Register as an anonymous module.\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n\t\t\t__webpack_require__(/*! jquery */ 41),\n\t\t\t__webpack_require__(/*! ./widget */ 712)\n\t\t], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {\n\n\t\t// Browser globals\n\t\tfactory( jQuery );\n\t}\n}(function( $ ) {\n\nvar mouseHandled = false;\n$( document ).mouseup( function() {\n\tmouseHandled = false;\n});\n\nreturn $.widget(\"ui.mouse\", {\n\tversion: \"1.11.4\",\n\toptions: {\n\t\tcancel: \"input,textarea,button,select,option\",\n\t\tdistance: 1,\n\t\tdelay: 0\n\t},\n\t_mouseInit: function() {\n\t\tvar that = this;\n\n\t\tthis.element\n\t\t\t.bind(\"mousedown.\" + this.widgetName, function(event) {\n\t\t\t\treturn that._mouseDown(event);\n\t\t\t})\n\t\t\t.bind(\"click.\" + this.widgetName, function(event) {\n\t\t\t\tif (true === $.data(event.target, that.widgetName + \".preventClickEvent\")) {\n\t\t\t\t\t$.removeData(event.target, that.widgetName + \".preventClickEvent\");\n\t\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\n\t\tthis.started = false;\n\t},\n\n\t// TODO: make sure destroying one instance of mouse doesn't mess with\n\t// other instances of mouse\n\t_mouseDestroy: function() {\n\t\tthis.element.unbind(\".\" + this.widgetName);\n\t\tif ( this._mouseMoveDelegate ) {\n\t\t\tthis.document\n\t\t\t\t.unbind(\"mousemove.\" + this.widgetName, this._mouseMoveDelegate)\n\t\t\t\t.unbind(\"mouseup.\" + this.widgetName, this._mouseUpDelegate);\n\t\t}\n\t},\n\n\t_mouseDown: function(event) {\n\t\t// don't let more than one widget handle mouseStart\n\t\tif ( mouseHandled ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._mouseMoved = false;\n\n\t\t// we may have missed mouseup (out of window)\n\t\t(this._mouseStarted && this._mouseUp(event));\n\n\t\tthis._mouseDownEvent = event;\n\n\t\tvar that = this,\n\t\t\tbtnIsLeft = (event.which === 1),\n\t\t\t// event.target.nodeName works around a bug in IE 8 with\n\t\t\t// disabled inputs (#7620)\n\t\t\telIsCancel = (typeof this.options.cancel === \"string\" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);\n\t\tif (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tthis.mouseDelayMet = !this.options.delay;\n\t\tif (!this.mouseDelayMet) {\n\t\t\tthis._mouseDelayTimer = setTimeout(function() {\n\t\t\t\tthat.mouseDelayMet = true;\n\t\t\t}, this.options.delay);\n\t\t}\n\n\t\tif (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {\n\t\t\tthis._mouseStarted = (this._mouseStart(event) !== false);\n\t\t\tif (!this._mouseStarted) {\n\t\t\t\tevent.preventDefault();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// Click event may never have fired (Gecko & Opera)\n\t\tif (true === $.data(event.target, this.widgetName + \".preventClickEvent\")) {\n\t\t\t$.removeData(event.target, this.widgetName + \".preventClickEvent\");\n\t\t}\n\n\t\t// these delegates are required to keep context\n\t\tthis._mouseMoveDelegate = function(event) {\n\t\t\treturn that._mouseMove(event);\n\t\t};\n\t\tthis._mouseUpDelegate = function(event) {\n\t\t\treturn that._mouseUp(event);\n\t\t};\n\n\t\tthis.document\n\t\t\t.bind( \"mousemove.\" + this.widgetName, this._mouseMoveDelegate )\n\t\t\t.bind( \"mouseup.\" + this.widgetName, this._mouseUpDelegate );\n\n\t\tevent.preventDefault();\n\n\t\tmouseHandled = true;\n\t\treturn true;\n\t},\n\n\t_mouseMove: function(event) {\n\t\t// Only check for mouseups outside the document if you've moved inside the document\n\t\t// at least once. This prevents the firing of mouseup in the case of IE<9, which will\n\t\t// fire a mousemove event if content is placed under the cursor. See #7778\n\t\t// Support: IE <9\n\t\tif ( this._mouseMoved ) {\n\t\t\t// IE mouseup check - mouseup happened when mouse was out of window\n\t\t\tif ($.ui.ie && ( !document.documentMode || document.documentMode < 9 ) && !event.button) {\n\t\t\t\treturn this._mouseUp(event);\n\n\t\t\t// Iframe mouseup check - mouseup occurred in another document\n\t\t\t} else if ( !event.which ) {\n\t\t\t\treturn this._mouseUp( event );\n\t\t\t}\n\t\t}\n\n\t\tif ( event.which || event.button ) {\n\t\t\tthis._mouseMoved = true;\n\t\t}\n\n\t\tif (this._mouseStarted) {\n\t\t\tthis._mouseDrag(event);\n\t\t\treturn event.preventDefault();\n\t\t}\n\n\t\tif (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {\n\t\t\tthis._mouseStarted =\n\t\t\t\t(this._mouseStart(this._mouseDownEvent, event) !== false);\n\t\t\t(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));\n\t\t}\n\n\t\treturn !this._mouseStarted;\n\t},\n\n\t_mouseUp: function(event) {\n\t\tthis.document\n\t\t\t.unbind( \"mousemove.\" + this.widgetName, this._mouseMoveDelegate )\n\t\t\t.unbind( \"mouseup.\" + this.widgetName, this._mouseUpDelegate );\n\n\t\tif (this._mouseStarted) {\n\t\t\tthis._mouseStarted = false;\n\n\t\t\tif (event.target === this._mouseDownEvent.target) {\n\t\t\t\t$.data(event.target, this.widgetName + \".preventClickEvent\", true);\n\t\t\t}\n\n\t\t\tthis._mouseStop(event);\n\t\t}\n\n\t\tmouseHandled = false;\n\t\treturn false;\n\t},\n\n\t_mouseDistanceMet: function(event) {\n\t\treturn (Math.max(\n\t\t\t\tMath.abs(this._mouseDownEvent.pageX - event.pageX),\n\t\t\t\tMath.abs(this._mouseDownEvent.pageY - event.pageY)\n\t\t\t) >= this.options.distance\n\t\t);\n\t},\n\n\t_mouseDelayMet: function(/* event */) {\n\t\treturn this.mouseDelayMet;\n\t},\n\n\t// These are placeholder methods, to be overriden by extending plugin\n\t_mouseStart: function(/* event */) {},\n\t_mouseDrag: function(/* event */) {},\n\t_mouseStop: function(/* event */) {},\n\t_mouseCapture: function(/* event */) { return true; }\n});\n\n}));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzM3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9qcXVlcnktdWkvdWkvbW91c2UuanM/YTM4YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGpRdWVyeSBVSSBNb3VzZSAxLjExLjRcbiAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL21vdXNlL1xuICovXG4oZnVuY3Rpb24oIGZhY3RvcnkgKSB7XG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cblx0XHQvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG5cdFx0ZGVmaW5lKFtcblx0XHRcdFwianF1ZXJ5XCIsXG5cdFx0XHRcIi4vd2lkZ2V0XCJcblx0XHRdLCBmYWN0b3J5ICk7XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBCcm93c2VyIGdsb2JhbHNcblx0XHRmYWN0b3J5KCBqUXVlcnkgKTtcblx0fVxufShmdW5jdGlvbiggJCApIHtcblxudmFyIG1vdXNlSGFuZGxlZCA9IGZhbHNlO1xuJCggZG9jdW1lbnQgKS5tb3VzZXVwKCBmdW5jdGlvbigpIHtcblx0bW91c2VIYW5kbGVkID0gZmFsc2U7XG59KTtcblxucmV0dXJuICQud2lkZ2V0KFwidWkubW91c2VcIiwge1xuXHR2ZXJzaW9uOiBcIjEuMTEuNFwiLFxuXHRvcHRpb25zOiB7XG5cdFx0Y2FuY2VsOiBcImlucHV0LHRleHRhcmVhLGJ1dHRvbixzZWxlY3Qsb3B0aW9uXCIsXG5cdFx0ZGlzdGFuY2U6IDEsXG5cdFx0ZGVsYXk6IDBcblx0fSxcblx0X21vdXNlSW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQuYmluZChcIm1vdXNlZG93bi5cIiArIHRoaXMud2lkZ2V0TmFtZSwgZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0cmV0dXJuIHRoYXQuX21vdXNlRG93bihldmVudCk7XG5cdFx0XHR9KVxuXHRcdFx0LmJpbmQoXCJjbGljay5cIiArIHRoaXMud2lkZ2V0TmFtZSwgZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0aWYgKHRydWUgPT09ICQuZGF0YShldmVudC50YXJnZXQsIHRoYXQud2lkZ2V0TmFtZSArIFwiLnByZXZlbnRDbGlja0V2ZW50XCIpKSB7XG5cdFx0XHRcdFx0JC5yZW1vdmVEYXRhKGV2ZW50LnRhcmdldCwgdGhhdC53aWRnZXROYW1lICsgXCIucHJldmVudENsaWNrRXZlbnRcIik7XG5cdFx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuXHR9LFxuXG5cdC8vIFRPRE86IG1ha2Ugc3VyZSBkZXN0cm95aW5nIG9uZSBpbnN0YW5jZSBvZiBtb3VzZSBkb2Vzbid0IG1lc3Mgd2l0aFxuXHQvLyBvdGhlciBpbnN0YW5jZXMgb2YgbW91c2Vcblx0X21vdXNlRGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5lbGVtZW50LnVuYmluZChcIi5cIiArIHRoaXMud2lkZ2V0TmFtZSk7XG5cdFx0aWYgKCB0aGlzLl9tb3VzZU1vdmVEZWxlZ2F0ZSApIHtcblx0XHRcdHRoaXMuZG9jdW1lbnRcblx0XHRcdFx0LnVuYmluZChcIm1vdXNlbW92ZS5cIiArIHRoaXMud2lkZ2V0TmFtZSwgdGhpcy5fbW91c2VNb3ZlRGVsZWdhdGUpXG5cdFx0XHRcdC51bmJpbmQoXCJtb3VzZXVwLlwiICsgdGhpcy53aWRnZXROYW1lLCB0aGlzLl9tb3VzZVVwRGVsZWdhdGUpO1xuXHRcdH1cblx0fSxcblxuXHRfbW91c2VEb3duOiBmdW5jdGlvbihldmVudCkge1xuXHRcdC8vIGRvbid0IGxldCBtb3JlIHRoYW4gb25lIHdpZGdldCBoYW5kbGUgbW91c2VTdGFydFxuXHRcdGlmICggbW91c2VIYW5kbGVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX21vdXNlTW92ZWQgPSBmYWxzZTtcblxuXHRcdC8vIHdlIG1heSBoYXZlIG1pc3NlZCBtb3VzZXVwIChvdXQgb2Ygd2luZG93KVxuXHRcdCh0aGlzLl9tb3VzZVN0YXJ0ZWQgJiYgdGhpcy5fbW91c2VVcChldmVudCkpO1xuXG5cdFx0dGhpcy5fbW91c2VEb3duRXZlbnQgPSBldmVudDtcblxuXHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdGJ0bklzTGVmdCA9IChldmVudC53aGljaCA9PT0gMSksXG5cdFx0XHQvLyBldmVudC50YXJnZXQubm9kZU5hbWUgd29ya3MgYXJvdW5kIGEgYnVnIGluIElFIDggd2l0aFxuXHRcdFx0Ly8gZGlzYWJsZWQgaW5wdXRzICgjNzYyMClcblx0XHRcdGVsSXNDYW5jZWwgPSAodHlwZW9mIHRoaXMub3B0aW9ucy5jYW5jZWwgPT09IFwic3RyaW5nXCIgJiYgZXZlbnQudGFyZ2V0Lm5vZGVOYW1lID8gJChldmVudC50YXJnZXQpLmNsb3Nlc3QodGhpcy5vcHRpb25zLmNhbmNlbCkubGVuZ3RoIDogZmFsc2UpO1xuXHRcdGlmICghYnRuSXNMZWZ0IHx8IGVsSXNDYW5jZWwgfHwgIXRoaXMuX21vdXNlQ2FwdHVyZShldmVudCkpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHRoaXMubW91c2VEZWxheU1ldCA9ICF0aGlzLm9wdGlvbnMuZGVsYXk7XG5cdFx0aWYgKCF0aGlzLm1vdXNlRGVsYXlNZXQpIHtcblx0XHRcdHRoaXMuX21vdXNlRGVsYXlUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoYXQubW91c2VEZWxheU1ldCA9IHRydWU7XG5cdFx0XHR9LCB0aGlzLm9wdGlvbnMuZGVsYXkpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9tb3VzZURpc3RhbmNlTWV0KGV2ZW50KSAmJiB0aGlzLl9tb3VzZURlbGF5TWV0KGV2ZW50KSkge1xuXHRcdFx0dGhpcy5fbW91c2VTdGFydGVkID0gKHRoaXMuX21vdXNlU3RhcnQoZXZlbnQpICE9PSBmYWxzZSk7XG5cdFx0XHRpZiAoIXRoaXMuX21vdXNlU3RhcnRlZCkge1xuXHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDbGljayBldmVudCBtYXkgbmV2ZXIgaGF2ZSBmaXJlZCAoR2Vja28gJiBPcGVyYSlcblx0XHRpZiAodHJ1ZSA9PT0gJC5kYXRhKGV2ZW50LnRhcmdldCwgdGhpcy53aWRnZXROYW1lICsgXCIucHJldmVudENsaWNrRXZlbnRcIikpIHtcblx0XHRcdCQucmVtb3ZlRGF0YShldmVudC50YXJnZXQsIHRoaXMud2lkZ2V0TmFtZSArIFwiLnByZXZlbnRDbGlja0V2ZW50XCIpO1xuXHRcdH1cblxuXHRcdC8vIHRoZXNlIGRlbGVnYXRlcyBhcmUgcmVxdWlyZWQgdG8ga2VlcCBjb250ZXh0XG5cdFx0dGhpcy5fbW91c2VNb3ZlRGVsZWdhdGUgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0cmV0dXJuIHRoYXQuX21vdXNlTW92ZShldmVudCk7XG5cdFx0fTtcblx0XHR0aGlzLl9tb3VzZVVwRGVsZWdhdGUgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0cmV0dXJuIHRoYXQuX21vdXNlVXAoZXZlbnQpO1xuXHRcdH07XG5cblx0XHR0aGlzLmRvY3VtZW50XG5cdFx0XHQuYmluZCggXCJtb3VzZW1vdmUuXCIgKyB0aGlzLndpZGdldE5hbWUsIHRoaXMuX21vdXNlTW92ZURlbGVnYXRlIClcblx0XHRcdC5iaW5kKCBcIm1vdXNldXAuXCIgKyB0aGlzLndpZGdldE5hbWUsIHRoaXMuX21vdXNlVXBEZWxlZ2F0ZSApO1xuXG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdG1vdXNlSGFuZGxlZCA9IHRydWU7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0X21vdXNlTW92ZTogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHQvLyBPbmx5IGNoZWNrIGZvciBtb3VzZXVwcyBvdXRzaWRlIHRoZSBkb2N1bWVudCBpZiB5b3UndmUgbW92ZWQgaW5zaWRlIHRoZSBkb2N1bWVudFxuXHRcdC8vIGF0IGxlYXN0IG9uY2UuIFRoaXMgcHJldmVudHMgdGhlIGZpcmluZyBvZiBtb3VzZXVwIGluIHRoZSBjYXNlIG9mIElFPDksIHdoaWNoIHdpbGxcblx0XHQvLyBmaXJlIGEgbW91c2Vtb3ZlIGV2ZW50IGlmIGNvbnRlbnQgaXMgcGxhY2VkIHVuZGVyIHRoZSBjdXJzb3IuIFNlZSAjNzc3OFxuXHRcdC8vIFN1cHBvcnQ6IElFIDw5XG5cdFx0aWYgKCB0aGlzLl9tb3VzZU1vdmVkICkge1xuXHRcdFx0Ly8gSUUgbW91c2V1cCBjaGVjayAtIG1vdXNldXAgaGFwcGVuZWQgd2hlbiBtb3VzZSB3YXMgb3V0IG9mIHdpbmRvd1xuXHRcdFx0aWYgKCQudWkuaWUgJiYgKCAhZG9jdW1lbnQuZG9jdW1lbnRNb2RlIHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA8IDkgKSAmJiAhZXZlbnQuYnV0dG9uKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9tb3VzZVVwKGV2ZW50KTtcblxuXHRcdFx0Ly8gSWZyYW1lIG1vdXNldXAgY2hlY2sgLSBtb3VzZXVwIG9jY3VycmVkIGluIGFub3RoZXIgZG9jdW1lbnRcblx0XHRcdH0gZWxzZSBpZiAoICFldmVudC53aGljaCApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX21vdXNlVXAoIGV2ZW50ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBldmVudC53aGljaCB8fCBldmVudC5idXR0b24gKSB7XG5cdFx0XHR0aGlzLl9tb3VzZU1vdmVkID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fbW91c2VTdGFydGVkKSB7XG5cdFx0XHR0aGlzLl9tb3VzZURyYWcoZXZlbnQpO1xuXHRcdFx0cmV0dXJuIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX21vdXNlRGlzdGFuY2VNZXQoZXZlbnQpICYmIHRoaXMuX21vdXNlRGVsYXlNZXQoZXZlbnQpKSB7XG5cdFx0XHR0aGlzLl9tb3VzZVN0YXJ0ZWQgPVxuXHRcdFx0XHQodGhpcy5fbW91c2VTdGFydCh0aGlzLl9tb3VzZURvd25FdmVudCwgZXZlbnQpICE9PSBmYWxzZSk7XG5cdFx0XHQodGhpcy5fbW91c2VTdGFydGVkID8gdGhpcy5fbW91c2VEcmFnKGV2ZW50KSA6IHRoaXMuX21vdXNlVXAoZXZlbnQpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gIXRoaXMuX21vdXNlU3RhcnRlZDtcblx0fSxcblxuXHRfbW91c2VVcDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR0aGlzLmRvY3VtZW50XG5cdFx0XHQudW5iaW5kKCBcIm1vdXNlbW92ZS5cIiArIHRoaXMud2lkZ2V0TmFtZSwgdGhpcy5fbW91c2VNb3ZlRGVsZWdhdGUgKVxuXHRcdFx0LnVuYmluZCggXCJtb3VzZXVwLlwiICsgdGhpcy53aWRnZXROYW1lLCB0aGlzLl9tb3VzZVVwRGVsZWdhdGUgKTtcblxuXHRcdGlmICh0aGlzLl9tb3VzZVN0YXJ0ZWQpIHtcblx0XHRcdHRoaXMuX21vdXNlU3RhcnRlZCA9IGZhbHNlO1xuXG5cdFx0XHRpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLl9tb3VzZURvd25FdmVudC50YXJnZXQpIHtcblx0XHRcdFx0JC5kYXRhKGV2ZW50LnRhcmdldCwgdGhpcy53aWRnZXROYW1lICsgXCIucHJldmVudENsaWNrRXZlbnRcIiwgdHJ1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX21vdXNlU3RvcChldmVudCk7XG5cdFx0fVxuXG5cdFx0bW91c2VIYW5kbGVkID0gZmFsc2U7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdF9tb3VzZURpc3RhbmNlTWV0OiBmdW5jdGlvbihldmVudCkge1xuXHRcdHJldHVybiAoTWF0aC5tYXgoXG5cdFx0XHRcdE1hdGguYWJzKHRoaXMuX21vdXNlRG93bkV2ZW50LnBhZ2VYIC0gZXZlbnQucGFnZVgpLFxuXHRcdFx0XHRNYXRoLmFicyh0aGlzLl9tb3VzZURvd25FdmVudC5wYWdlWSAtIGV2ZW50LnBhZ2VZKVxuXHRcdFx0KSA+PSB0aGlzLm9wdGlvbnMuZGlzdGFuY2Vcblx0XHQpO1xuXHR9LFxuXG5cdF9tb3VzZURlbGF5TWV0OiBmdW5jdGlvbigvKiBldmVudCAqLykge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlRGVsYXlNZXQ7XG5cdH0sXG5cblx0Ly8gVGhlc2UgYXJlIHBsYWNlaG9sZGVyIG1ldGhvZHMsIHRvIGJlIG92ZXJyaWRlbiBieSBleHRlbmRpbmcgcGx1Z2luXG5cdF9tb3VzZVN0YXJ0OiBmdW5jdGlvbigvKiBldmVudCAqLykge30sXG5cdF9tb3VzZURyYWc6IGZ1bmN0aW9uKC8qIGV2ZW50ICovKSB7fSxcblx0X21vdXNlU3RvcDogZnVuY3Rpb24oLyogZXZlbnQgKi8pIHt9LFxuXHRfbW91c2VDYXB0dXJlOiBmdW5jdGlvbigvKiBldmVudCAqLykgeyByZXR1cm4gdHJ1ZTsgfVxufSk7XG5cbn0pKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9qcXVlcnktdWkvdWkvbW91c2UuanNcbi8vIG1vZHVsZSBpZCA9IDczN1xuLy8gbW9kdWxlIGNodW5rcyA9IDUgOSAxMyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 761:
/* unknown exports provided */
/* all exports used */
/*!****************************************************!*\
  !*** ./~/angular2-google-maps/core/core-module.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar core_1 = __webpack_require__(/*! @angular/core */ 0);\nvar google_map_kml_layer_1 = __webpack_require__(/*! ./directives/google-map-kml-layer */ 730);\nvar google_map_1 = __webpack_require__(/*! ./directives/google-map */ 734);\nvar google_map_circle_1 = __webpack_require__(/*! ./directives/google-map-circle */ 729);\nvar google_map_info_window_1 = __webpack_require__(/*! ./directives/google-map-info-window */ 713);\nvar google_map_marker_1 = __webpack_require__(/*! ./directives/google-map-marker */ 731);\nvar google_map_polygon_1 = __webpack_require__(/*! ./directives/google-map-polygon */ 732);\nvar google_map_polyline_1 = __webpack_require__(/*! ./directives/google-map-polyline */ 733);\nvar google_map_polyline_point_1 = __webpack_require__(/*! ./directives/google-map-polyline-point */ 714);\nvar lazy_maps_api_loader_1 = __webpack_require__(/*! ./services/maps-api-loader/lazy-maps-api-loader */ 720);\nvar lazy_maps_api_loader_2 = __webpack_require__(/*! ./services/maps-api-loader/lazy-maps-api-loader */ 720);\nvar maps_api_loader_1 = __webpack_require__(/*! ./services/maps-api-loader/maps-api-loader */ 711);\nvar browser_globals_1 = __webpack_require__(/*! ./utils/browser-globals */ 735);\n/**\n * @internal\n */\nfunction coreDirectives() {\n    return [\n        google_map_1.SebmGoogleMap, google_map_marker_1.SebmGoogleMapMarker, google_map_info_window_1.SebmGoogleMapInfoWindow, google_map_circle_1.SebmGoogleMapCircle,\n        google_map_polygon_1.SebmGoogleMapPolygon, google_map_polyline_1.SebmGoogleMapPolyline, google_map_polyline_point_1.SebmGoogleMapPolylinePoint, google_map_kml_layer_1.SebmGoogleMapKmlLayer\n    ];\n}\nexports.coreDirectives = coreDirectives;\n;\n/**\n * The angular2-google-maps core module. Contains all Directives/Services/Pipes\n * of the core module. Please use `AgmCoreModule.forRoot()` in your app module.\n */\nvar AgmCoreModule = (function () {\n    function AgmCoreModule() {\n    }\n    /**\n     * Please use this method when you register the module at the root level.\n     */\n    AgmCoreModule.forRoot = function (lazyMapsAPILoaderConfig) {\n        return {\n            ngModule: AgmCoreModule,\n            providers: browser_globals_1.BROWSER_GLOBALS_PROVIDERS.concat([\n                { provide: maps_api_loader_1.MapsAPILoader, useClass: lazy_maps_api_loader_1.LazyMapsAPILoader },\n                { provide: lazy_maps_api_loader_2.LAZY_MAPS_API_CONFIG, useValue: lazyMapsAPILoaderConfig }\n            ]),\n        };\n    };\n    AgmCoreModule.decorators = [\n        { type: core_1.NgModule, args: [{ declarations: coreDirectives(), exports: coreDirectives() },] },\n    ];\n    /** @nocollapse */\n    AgmCoreModule.ctorParameters = function () { return []; };\n    return AgmCoreModule;\n}());\nexports.AgmCoreModule = AgmCoreModule;\n//# sourceMappingURL=core-module.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzYxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL2NvcmUtbW9kdWxlLmpzP2FjMmYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xudmFyIGdvb2dsZV9tYXBfa21sX2xheWVyXzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC1rbWwtbGF5ZXInKTtcbnZhciBnb29nbGVfbWFwXzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcCcpO1xudmFyIGdvb2dsZV9tYXBfY2lyY2xlXzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC1jaXJjbGUnKTtcbnZhciBnb29nbGVfbWFwX2luZm9fd2luZG93XzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC1pbmZvLXdpbmRvdycpO1xudmFyIGdvb2dsZV9tYXBfbWFya2VyXzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC1tYXJrZXInKTtcbnZhciBnb29nbGVfbWFwX3BvbHlnb25fMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9nb29nbGUtbWFwLXBvbHlnb24nKTtcbnZhciBnb29nbGVfbWFwX3BvbHlsaW5lXzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC1wb2x5bGluZScpO1xudmFyIGdvb2dsZV9tYXBfcG9seWxpbmVfcG9pbnRfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9nb29nbGUtbWFwLXBvbHlsaW5lLXBvaW50Jyk7XG52YXIgbGF6eV9tYXBzX2FwaV9sb2FkZXJfMSA9IHJlcXVpcmUoJy4vc2VydmljZXMvbWFwcy1hcGktbG9hZGVyL2xhenktbWFwcy1hcGktbG9hZGVyJyk7XG52YXIgbGF6eV9tYXBzX2FwaV9sb2FkZXJfMiA9IHJlcXVpcmUoJy4vc2VydmljZXMvbWFwcy1hcGktbG9hZGVyL2xhenktbWFwcy1hcGktbG9hZGVyJyk7XG52YXIgbWFwc19hcGlfbG9hZGVyXzEgPSByZXF1aXJlKCcuL3NlcnZpY2VzL21hcHMtYXBpLWxvYWRlci9tYXBzLWFwaS1sb2FkZXInKTtcbnZhciBicm93c2VyX2dsb2JhbHNfMSA9IHJlcXVpcmUoJy4vdXRpbHMvYnJvd3Nlci1nbG9iYWxzJyk7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBjb3JlRGlyZWN0aXZlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBnb29nbGVfbWFwXzEuU2VibUdvb2dsZU1hcCwgZ29vZ2xlX21hcF9tYXJrZXJfMS5TZWJtR29vZ2xlTWFwTWFya2VyLCBnb29nbGVfbWFwX2luZm9fd2luZG93XzEuU2VibUdvb2dsZU1hcEluZm9XaW5kb3csIGdvb2dsZV9tYXBfY2lyY2xlXzEuU2VibUdvb2dsZU1hcENpcmNsZSxcbiAgICAgICAgZ29vZ2xlX21hcF9wb2x5Z29uXzEuU2VibUdvb2dsZU1hcFBvbHlnb24sIGdvb2dsZV9tYXBfcG9seWxpbmVfMS5TZWJtR29vZ2xlTWFwUG9seWxpbmUsIGdvb2dsZV9tYXBfcG9seWxpbmVfcG9pbnRfMS5TZWJtR29vZ2xlTWFwUG9seWxpbmVQb2ludCwgZ29vZ2xlX21hcF9rbWxfbGF5ZXJfMS5TZWJtR29vZ2xlTWFwS21sTGF5ZXJcbiAgICBdO1xufVxuZXhwb3J0cy5jb3JlRGlyZWN0aXZlcyA9IGNvcmVEaXJlY3RpdmVzO1xuO1xuLyoqXG4gKiBUaGUgYW5ndWxhcjItZ29vZ2xlLW1hcHMgY29yZSBtb2R1bGUuIENvbnRhaW5zIGFsbCBEaXJlY3RpdmVzL1NlcnZpY2VzL1BpcGVzXG4gKiBvZiB0aGUgY29yZSBtb2R1bGUuIFBsZWFzZSB1c2UgYEFnbUNvcmVNb2R1bGUuZm9yUm9vdCgpYCBpbiB5b3VyIGFwcCBtb2R1bGUuXG4gKi9cbnZhciBBZ21Db3JlTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBZ21Db3JlTW9kdWxlKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQbGVhc2UgdXNlIHRoaXMgbWV0aG9kIHdoZW4geW91IHJlZ2lzdGVyIHRoZSBtb2R1bGUgYXQgdGhlIHJvb3QgbGV2ZWwuXG4gICAgICovXG4gICAgQWdtQ29yZU1vZHVsZS5mb3JSb290ID0gZnVuY3Rpb24gKGxhenlNYXBzQVBJTG9hZGVyQ29uZmlnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogQWdtQ29yZU1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogYnJvd3Nlcl9nbG9iYWxzXzEuQlJPV1NFUl9HTE9CQUxTX1BST1ZJREVSUy5jb25jYXQoW1xuICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogbWFwc19hcGlfbG9hZGVyXzEuTWFwc0FQSUxvYWRlciwgdXNlQ2xhc3M6IGxhenlfbWFwc19hcGlfbG9hZGVyXzEuTGF6eU1hcHNBUElMb2FkZXIgfSxcbiAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IGxhenlfbWFwc19hcGlfbG9hZGVyXzIuTEFaWV9NQVBTX0FQSV9DT05GSUcsIHVzZVZhbHVlOiBsYXp5TWFwc0FQSUxvYWRlckNvbmZpZyB9XG4gICAgICAgICAgICBdKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEFnbUNvcmVNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBjb3JlXzEuTmdNb2R1bGUsIGFyZ3M6IFt7IGRlY2xhcmF0aW9uczogY29yZURpcmVjdGl2ZXMoKSwgZXhwb3J0czogY29yZURpcmVjdGl2ZXMoKSB9LF0gfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIEFnbUNvcmVNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbiAgICByZXR1cm4gQWdtQ29yZU1vZHVsZTtcbn0oKSk7XG5leHBvcnRzLkFnbUNvcmVNb2R1bGUgPSBBZ21Db3JlTW9kdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29yZS1tb2R1bGUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FuZ3VsYXIyLWdvb2dsZS1tYXBzL2NvcmUvY29yZS1tb2R1bGUuanNcbi8vIG1vZHVsZSBpZCA9IDc2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDUgOCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 762:
/* unknown exports provided */
/* all exports used */
/*!***************************************************!*\
  !*** ./~/angular2-google-maps/core/directives.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar google_map_1 = __webpack_require__(/*! ./directives/google-map */ 734);\nexports.SebmGoogleMap = google_map_1.SebmGoogleMap;\nvar google_map_circle_1 = __webpack_require__(/*! ./directives/google-map-circle */ 729);\nexports.SebmGoogleMapCircle = google_map_circle_1.SebmGoogleMapCircle;\nvar google_map_info_window_1 = __webpack_require__(/*! ./directives/google-map-info-window */ 713);\nexports.SebmGoogleMapInfoWindow = google_map_info_window_1.SebmGoogleMapInfoWindow;\nvar google_map_kml_layer_1 = __webpack_require__(/*! ./directives/google-map-kml-layer */ 730);\nexports.SebmGoogleMapKmlLayer = google_map_kml_layer_1.SebmGoogleMapKmlLayer;\nvar google_map_marker_1 = __webpack_require__(/*! ./directives/google-map-marker */ 731);\nexports.SebmGoogleMapMarker = google_map_marker_1.SebmGoogleMapMarker;\nvar google_map_polygon_1 = __webpack_require__(/*! ./directives/google-map-polygon */ 732);\nexports.SebmGoogleMapPolygon = google_map_polygon_1.SebmGoogleMapPolygon;\nvar google_map_polyline_1 = __webpack_require__(/*! ./directives/google-map-polyline */ 733);\nexports.SebmGoogleMapPolyline = google_map_polyline_1.SebmGoogleMapPolyline;\nvar google_map_polyline_point_1 = __webpack_require__(/*! ./directives/google-map-polyline-point */ 714);\nexports.SebmGoogleMapPolylinePoint = google_map_polyline_point_1.SebmGoogleMapPolylinePoint;\n//# sourceMappingURL=directives.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzYyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL2RpcmVjdGl2ZXMuanM/MzE4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBnb29nbGVfbWFwXzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcCcpO1xuZXhwb3J0cy5TZWJtR29vZ2xlTWFwID0gZ29vZ2xlX21hcF8xLlNlYm1Hb29nbGVNYXA7XG52YXIgZ29vZ2xlX21hcF9jaXJjbGVfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9nb29nbGUtbWFwLWNpcmNsZScpO1xuZXhwb3J0cy5TZWJtR29vZ2xlTWFwQ2lyY2xlID0gZ29vZ2xlX21hcF9jaXJjbGVfMS5TZWJtR29vZ2xlTWFwQ2lyY2xlO1xudmFyIGdvb2dsZV9tYXBfaW5mb193aW5kb3dfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9nb29nbGUtbWFwLWluZm8td2luZG93Jyk7XG5leHBvcnRzLlNlYm1Hb29nbGVNYXBJbmZvV2luZG93ID0gZ29vZ2xlX21hcF9pbmZvX3dpbmRvd18xLlNlYm1Hb29nbGVNYXBJbmZvV2luZG93O1xudmFyIGdvb2dsZV9tYXBfa21sX2xheWVyXzEgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMvZ29vZ2xlLW1hcC1rbWwtbGF5ZXInKTtcbmV4cG9ydHMuU2VibUdvb2dsZU1hcEttbExheWVyID0gZ29vZ2xlX21hcF9rbWxfbGF5ZXJfMS5TZWJtR29vZ2xlTWFwS21sTGF5ZXI7XG52YXIgZ29vZ2xlX21hcF9tYXJrZXJfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9nb29nbGUtbWFwLW1hcmtlcicpO1xuZXhwb3J0cy5TZWJtR29vZ2xlTWFwTWFya2VyID0gZ29vZ2xlX21hcF9tYXJrZXJfMS5TZWJtR29vZ2xlTWFwTWFya2VyO1xudmFyIGdvb2dsZV9tYXBfcG9seWdvbl8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2dvb2dsZS1tYXAtcG9seWdvbicpO1xuZXhwb3J0cy5TZWJtR29vZ2xlTWFwUG9seWdvbiA9IGdvb2dsZV9tYXBfcG9seWdvbl8xLlNlYm1Hb29nbGVNYXBQb2x5Z29uO1xudmFyIGdvb2dsZV9tYXBfcG9seWxpbmVfMSA9IHJlcXVpcmUoJy4vZGlyZWN0aXZlcy9nb29nbGUtbWFwLXBvbHlsaW5lJyk7XG5leHBvcnRzLlNlYm1Hb29nbGVNYXBQb2x5bGluZSA9IGdvb2dsZV9tYXBfcG9seWxpbmVfMS5TZWJtR29vZ2xlTWFwUG9seWxpbmU7XG52YXIgZ29vZ2xlX21hcF9wb2x5bGluZV9wb2ludF8xID0gcmVxdWlyZSgnLi9kaXJlY3RpdmVzL2dvb2dsZS1tYXAtcG9seWxpbmUtcG9pbnQnKTtcbmV4cG9ydHMuU2VibUdvb2dsZU1hcFBvbHlsaW5lUG9pbnQgPSBnb29nbGVfbWFwX3BvbHlsaW5lX3BvaW50XzEuU2VibUdvb2dsZU1hcFBvbHlsaW5lUG9pbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXJlY3RpdmVzLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL2RpcmVjdGl2ZXMuanNcbi8vIG1vZHVsZSBpZCA9IDc2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDUgOCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 763:
/* unknown exports provided */
/* exports used: AgmCoreModule */
/*!**********************************************!*\
  !*** ./~/angular2-google-maps/core/index.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n// main modules\n__export(__webpack_require__(/*! ./directives */ 762));\n__export(__webpack_require__(/*! ./services */ 764));\n// Google Maps types\n// core module\n// we explicitly export the module here to prevent this Ionic 2 bug:\n// http://stevemichelotti.com/integrate-angular-2-google-maps-into-ionic-2/\nvar core_module_1 = __webpack_require__(/*! ./core-module */ 761);\nexports.AgmCoreModule = core_module_1.AgmCoreModule;\n//# sourceMappingURL=index.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzYzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL2luZGV4LmpzPzQ2ZTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuLy8gbWFpbiBtb2R1bGVzXG5fX2V4cG9ydChyZXF1aXJlKCcuL2RpcmVjdGl2ZXMnKSk7XG5fX2V4cG9ydChyZXF1aXJlKCcuL3NlcnZpY2VzJykpO1xuLy8gR29vZ2xlIE1hcHMgdHlwZXNcbi8vIGNvcmUgbW9kdWxlXG4vLyB3ZSBleHBsaWNpdGx5IGV4cG9ydCB0aGUgbW9kdWxlIGhlcmUgdG8gcHJldmVudCB0aGlzIElvbmljIDIgYnVnOlxuLy8gaHR0cDovL3N0ZXZlbWljaGVsb3R0aS5jb20vaW50ZWdyYXRlLWFuZ3VsYXItMi1nb29nbGUtbWFwcy1pbnRvLWlvbmljLTIvXG52YXIgY29yZV9tb2R1bGVfMSA9IHJlcXVpcmUoJy4vY29yZS1tb2R1bGUnKTtcbmV4cG9ydHMuQWdtQ29yZU1vZHVsZSA9IGNvcmVfbW9kdWxlXzEuQWdtQ29yZU1vZHVsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA3NjNcbi8vIG1vZHVsZSBjaHVua3MgPSA1IDgiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),

/***/ 764:
/* unknown exports provided */
/* all exports used */
/*!*************************************************!*\
  !*** ./~/angular2-google-maps/core/services.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar google_maps_api_wrapper_1 = __webpack_require__(/*! ./services/google-maps-api-wrapper */ 703);\nexports.GoogleMapsAPIWrapper = google_maps_api_wrapper_1.GoogleMapsAPIWrapper;\nvar circle_manager_1 = __webpack_require__(/*! ./services/managers/circle-manager */ 715);\nexports.CircleManager = circle_manager_1.CircleManager;\nvar info_window_manager_1 = __webpack_require__(/*! ./services/managers/info-window-manager */ 716);\nexports.InfoWindowManager = info_window_manager_1.InfoWindowManager;\nvar marker_manager_1 = __webpack_require__(/*! ./services/managers/marker-manager */ 710);\nexports.MarkerManager = marker_manager_1.MarkerManager;\nvar polygon_manager_1 = __webpack_require__(/*! ./services/managers/polygon-manager */ 718);\nexports.PolygonManager = polygon_manager_1.PolygonManager;\nvar polyline_manager_1 = __webpack_require__(/*! ./services/managers/polyline-manager */ 719);\nexports.PolylineManager = polyline_manager_1.PolylineManager;\nvar kml_layer_manager_1 = __webpack_require__(/*! ./services/managers/kml-layer-manager */ 717);\nexports.KmlLayerManager = kml_layer_manager_1.KmlLayerManager;\nvar lazy_maps_api_loader_1 = __webpack_require__(/*! ./services/maps-api-loader/lazy-maps-api-loader */ 720);\nexports.GoogleMapsScriptProtocol = lazy_maps_api_loader_1.GoogleMapsScriptProtocol;\nexports.LAZY_MAPS_API_CONFIG = lazy_maps_api_loader_1.LAZY_MAPS_API_CONFIG;\nexports.LazyMapsAPILoader = lazy_maps_api_loader_1.LazyMapsAPILoader;\nvar maps_api_loader_1 = __webpack_require__(/*! ./services/maps-api-loader/maps-api-loader */ 711);\nexports.MapsAPILoader = maps_api_loader_1.MapsAPILoader;\nvar noop_maps_api_loader_1 = __webpack_require__(/*! ./services/maps-api-loader/noop-maps-api-loader */ 765);\nexports.NoOpMapsAPILoader = noop_maps_api_loader_1.NoOpMapsAPILoader;\n//# sourceMappingURL=services.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzY0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL3NlcnZpY2VzLmpzP2ZjZjMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZ29vZ2xlX21hcHNfYXBpX3dyYXBwZXJfMSA9IHJlcXVpcmUoJy4vc2VydmljZXMvZ29vZ2xlLW1hcHMtYXBpLXdyYXBwZXInKTtcbmV4cG9ydHMuR29vZ2xlTWFwc0FQSVdyYXBwZXIgPSBnb29nbGVfbWFwc19hcGlfd3JhcHBlcl8xLkdvb2dsZU1hcHNBUElXcmFwcGVyO1xudmFyIGNpcmNsZV9tYW5hZ2VyXzEgPSByZXF1aXJlKCcuL3NlcnZpY2VzL21hbmFnZXJzL2NpcmNsZS1tYW5hZ2VyJyk7XG5leHBvcnRzLkNpcmNsZU1hbmFnZXIgPSBjaXJjbGVfbWFuYWdlcl8xLkNpcmNsZU1hbmFnZXI7XG52YXIgaW5mb193aW5kb3dfbWFuYWdlcl8xID0gcmVxdWlyZSgnLi9zZXJ2aWNlcy9tYW5hZ2Vycy9pbmZvLXdpbmRvdy1tYW5hZ2VyJyk7XG5leHBvcnRzLkluZm9XaW5kb3dNYW5hZ2VyID0gaW5mb193aW5kb3dfbWFuYWdlcl8xLkluZm9XaW5kb3dNYW5hZ2VyO1xudmFyIG1hcmtlcl9tYW5hZ2VyXzEgPSByZXF1aXJlKCcuL3NlcnZpY2VzL21hbmFnZXJzL21hcmtlci1tYW5hZ2VyJyk7XG5leHBvcnRzLk1hcmtlck1hbmFnZXIgPSBtYXJrZXJfbWFuYWdlcl8xLk1hcmtlck1hbmFnZXI7XG52YXIgcG9seWdvbl9tYW5hZ2VyXzEgPSByZXF1aXJlKCcuL3NlcnZpY2VzL21hbmFnZXJzL3BvbHlnb24tbWFuYWdlcicpO1xuZXhwb3J0cy5Qb2x5Z29uTWFuYWdlciA9IHBvbHlnb25fbWFuYWdlcl8xLlBvbHlnb25NYW5hZ2VyO1xudmFyIHBvbHlsaW5lX21hbmFnZXJfMSA9IHJlcXVpcmUoJy4vc2VydmljZXMvbWFuYWdlcnMvcG9seWxpbmUtbWFuYWdlcicpO1xuZXhwb3J0cy5Qb2x5bGluZU1hbmFnZXIgPSBwb2x5bGluZV9tYW5hZ2VyXzEuUG9seWxpbmVNYW5hZ2VyO1xudmFyIGttbF9sYXllcl9tYW5hZ2VyXzEgPSByZXF1aXJlKCcuL3NlcnZpY2VzL21hbmFnZXJzL2ttbC1sYXllci1tYW5hZ2VyJyk7XG5leHBvcnRzLkttbExheWVyTWFuYWdlciA9IGttbF9sYXllcl9tYW5hZ2VyXzEuS21sTGF5ZXJNYW5hZ2VyO1xudmFyIGxhenlfbWFwc19hcGlfbG9hZGVyXzEgPSByZXF1aXJlKCcuL3NlcnZpY2VzL21hcHMtYXBpLWxvYWRlci9sYXp5LW1hcHMtYXBpLWxvYWRlcicpO1xuZXhwb3J0cy5Hb29nbGVNYXBzU2NyaXB0UHJvdG9jb2wgPSBsYXp5X21hcHNfYXBpX2xvYWRlcl8xLkdvb2dsZU1hcHNTY3JpcHRQcm90b2NvbDtcbmV4cG9ydHMuTEFaWV9NQVBTX0FQSV9DT05GSUcgPSBsYXp5X21hcHNfYXBpX2xvYWRlcl8xLkxBWllfTUFQU19BUElfQ09ORklHO1xuZXhwb3J0cy5MYXp5TWFwc0FQSUxvYWRlciA9IGxhenlfbWFwc19hcGlfbG9hZGVyXzEuTGF6eU1hcHNBUElMb2FkZXI7XG52YXIgbWFwc19hcGlfbG9hZGVyXzEgPSByZXF1aXJlKCcuL3NlcnZpY2VzL21hcHMtYXBpLWxvYWRlci9tYXBzLWFwaS1sb2FkZXInKTtcbmV4cG9ydHMuTWFwc0FQSUxvYWRlciA9IG1hcHNfYXBpX2xvYWRlcl8xLk1hcHNBUElMb2FkZXI7XG52YXIgbm9vcF9tYXBzX2FwaV9sb2FkZXJfMSA9IHJlcXVpcmUoJy4vc2VydmljZXMvbWFwcy1hcGktbG9hZGVyL25vb3AtbWFwcy1hcGktbG9hZGVyJyk7XG5leHBvcnRzLk5vT3BNYXBzQVBJTG9hZGVyID0gbm9vcF9tYXBzX2FwaV9sb2FkZXJfMS5Ob09wTWFwc0FQSUxvYWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcnZpY2VzLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL3NlcnZpY2VzLmpzXG4vLyBtb2R1bGUgaWQgPSA3NjRcbi8vIG1vZHVsZSBjaHVua3MgPSA1IDgiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 765:
/* unknown exports provided */
/* all exports used */
/*!**************************************************************************************!*\
  !*** ./~/angular2-google-maps/core/services/maps-api-loader/noop-maps-api-loader.js ***!
  \**************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * When using the NoOpMapsAPILoader, the Google Maps API must be added to the page via a `<script>`\n * Tag.\n * It's important that the Google Maps API script gets loaded first on the page.\n */\nvar NoOpMapsAPILoader = (function () {\n    function NoOpMapsAPILoader() {\n    }\n    NoOpMapsAPILoader.prototype.load = function () {\n        if (!window.google || !window.google.maps) {\n            throw new Error('Google Maps API not loaded on page. Make sure window.google.maps is available!');\n        }\n        return Promise.resolve();\n    };\n    ;\n    return NoOpMapsAPILoader;\n}());\nexports.NoOpMapsAPILoader = NoOpMapsAPILoader;\n//# sourceMappingURL=noop-maps-api-loader.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzY1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL3NlcnZpY2VzL21hcHMtYXBpLWxvYWRlci9ub29wLW1hcHMtYXBpLWxvYWRlci5qcz9iNGU0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBXaGVuIHVzaW5nIHRoZSBOb09wTWFwc0FQSUxvYWRlciwgdGhlIEdvb2dsZSBNYXBzIEFQSSBtdXN0IGJlIGFkZGVkIHRvIHRoZSBwYWdlIHZpYSBhIGA8c2NyaXB0PmBcbiAqIFRhZy5cbiAqIEl0J3MgaW1wb3J0YW50IHRoYXQgdGhlIEdvb2dsZSBNYXBzIEFQSSBzY3JpcHQgZ2V0cyBsb2FkZWQgZmlyc3Qgb24gdGhlIHBhZ2UuXG4gKi9cbnZhciBOb09wTWFwc0FQSUxvYWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm9PcE1hcHNBUElMb2FkZXIoKSB7XG4gICAgfVxuICAgIE5vT3BNYXBzQVBJTG9hZGVyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXdpbmRvdy5nb29nbGUgfHwgIXdpbmRvdy5nb29nbGUubWFwcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHb29nbGUgTWFwcyBBUEkgbm90IGxvYWRlZCBvbiBwYWdlLiBNYWtlIHN1cmUgd2luZG93Lmdvb2dsZS5tYXBzIGlzIGF2YWlsYWJsZSEnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfTtcbiAgICA7XG4gICAgcmV0dXJuIE5vT3BNYXBzQVBJTG9hZGVyO1xufSgpKTtcbmV4cG9ydHMuTm9PcE1hcHNBUElMb2FkZXIgPSBOb09wTWFwc0FQSUxvYWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vb3AtbWFwcy1hcGktbG9hZGVyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hbmd1bGFyMi1nb29nbGUtbWFwcy9jb3JlL3NlcnZpY2VzL21hcHMtYXBpLWxvYWRlci9ub29wLW1hcHMtYXBpLWxvYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gNzY1XG4vLyBtb2R1bGUgY2h1bmtzID0gNSA4Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 980:
/* unknown exports provided */
/* all exports used */
/*!*************************************!*\
  !*** ./~/shufflejs/dist/shuffle.js ***!
  \*************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"shuffle\"] = factory();\n\telse\n\t\troot[\"shuffle\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = __webpack_require__(1).default;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\t__webpack_require__(2);\n\t\n\tvar _matchesSelector = __webpack_require__(3);\n\t\n\tvar _matchesSelector2 = _interopRequireDefault(_matchesSelector);\n\t\n\tvar _arrayUniq = __webpack_require__(4);\n\t\n\tvar _arrayUniq2 = _interopRequireDefault(_arrayUniq);\n\t\n\tvar _xtend = __webpack_require__(5);\n\t\n\tvar _xtend2 = _interopRequireDefault(_xtend);\n\t\n\tvar _throttleit = __webpack_require__(6);\n\t\n\tvar _throttleit2 = _interopRequireDefault(_throttleit);\n\t\n\tvar _arrayParallel = __webpack_require__(7);\n\t\n\tvar _arrayParallel2 = _interopRequireDefault(_arrayParallel);\n\t\n\tvar _point = __webpack_require__(8);\n\t\n\tvar _point2 = _interopRequireDefault(_point);\n\t\n\tvar _shuffleItem = __webpack_require__(10);\n\t\n\tvar _shuffleItem2 = _interopRequireDefault(_shuffleItem);\n\t\n\tvar _classes = __webpack_require__(11);\n\t\n\tvar _classes2 = _interopRequireDefault(_classes);\n\t\n\tvar _getNumberStyle = __webpack_require__(12);\n\t\n\tvar _getNumberStyle2 = _interopRequireDefault(_getNumberStyle);\n\t\n\tvar _sorter = __webpack_require__(14);\n\t\n\tvar _sorter2 = _interopRequireDefault(_sorter);\n\t\n\tvar _onTransitionEnd = __webpack_require__(15);\n\t\n\tvar _layout2 = __webpack_require__(16);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction toArray(arrayLike) {\n\t  return Array.prototype.slice.call(arrayLike);\n\t}\n\t\n\tfunction arrayMax(array) {\n\t  return Math.max.apply(Math, array);\n\t}\n\t\n\tfunction arrayIncludes(array, obj) {\n\t  if (arguments.length === 2) {\n\t    return arrayIncludes(array)(obj);\n\t  }\n\t\n\t  return function (obj) {\n\t    return array.indexOf(obj) > -1;\n\t  };\n\t}\n\t\n\t// Used for unique instance variables\n\tvar id = 0;\n\t\n\tvar Shuffle = function () {\n\t\n\t  /**\n\t   * Categorize, sort, and filter a responsive grid of items.\n\t   *\n\t   * @param {Element} element An element which is the parent container for the grid items.\n\t   * @param {Object} [options=Shuffle.options] Options object.\n\t   * @constructor\n\t   */\n\t  function Shuffle(element) {\n\t    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t    _classCallCheck(this, Shuffle);\n\t\n\t    this.options = (0, _xtend2.default)(Shuffle.options, options);\n\t\n\t    this.useSizer = false;\n\t    this.lastSort = {};\n\t    this.group = this.lastFilter = Shuffle.ALL_ITEMS;\n\t    this.isEnabled = true;\n\t    this.isDestroyed = false;\n\t    this.isInitialized = false;\n\t    this._transitions = [];\n\t    this.isTransitioning = false;\n\t    this._queue = [];\n\t\n\t    element = this._getElementOption(element);\n\t\n\t    if (!element) {\n\t      throw new TypeError('Shuffle needs to be initialized with an element.');\n\t    }\n\t\n\t    this.element = element;\n\t    this.id = 'shuffle_' + id++;\n\t\n\t    this._init();\n\t    this.isInitialized = true;\n\t  }\n\t\n\t  _createClass(Shuffle, [{\n\t    key: '_init',\n\t    value: function _init() {\n\t      this.items = this._getItems();\n\t\n\t      this.options.sizer = this._getElementOption(this.options.sizer);\n\t\n\t      if (this.options.sizer) {\n\t        this.useSizer = true;\n\t      }\n\t\n\t      // Add class and invalidate styles\n\t      this.element.classList.add(Shuffle.Classes.BASE);\n\t\n\t      // Set initial css for each item\n\t      this._initItems();\n\t\n\t      // Bind resize events\n\t      this._onResize = this._getResizeFunction();\n\t      window.addEventListener('resize', this._onResize);\n\t\n\t      // Get container css all in one request. Causes reflow\n\t      var containerCss = window.getComputedStyle(this.element, null);\n\t      var containerWidth = Shuffle.getSize(this.element).width;\n\t\n\t      // Add styles to the container if it doesn't have them.\n\t      this._validateStyles(containerCss);\n\t\n\t      // We already got the container's width above, no need to cause another\n\t      // reflow getting it again... Calculate the number of columns there will be\n\t      this._setColumns(containerWidth);\n\t\n\t      // Kick off!\n\t      this.filter(this.options.group, this.options.initialSort);\n\t\n\t      // The shuffle items haven't had transitions set on them yet so the user\n\t      // doesn't see the first layout. Set them now that the first layout is done.\n\t      // First, however, a synchronous layout must be caused for the previous\n\t      // styles to be applied without transitions.\n\t      this.element.offsetWidth; // jshint ignore: line\n\t      this._setTransitions();\n\t      this.element.style.transition = 'height ' + this.options.speed + 'ms ' + this.options.easing;\n\t    }\n\t\n\t    /**\n\t     * Returns a throttled and proxied function for the resize handler.\n\t     * @return {Function}\n\t     * @private\n\t     */\n\t\n\t  }, {\n\t    key: '_getResizeFunction',\n\t    value: function _getResizeFunction() {\n\t      var resizeFunction = this._handleResize.bind(this);\n\t      return this.options.throttle ? this.options.throttle(resizeFunction, this.options.throttleTime) : resizeFunction;\n\t    }\n\t\n\t    /**\n\t     * Retrieve an element from an option.\n\t     * @param {string|jQuery|Element} option The option to check.\n\t     * @return {?Element} The plain element or null.\n\t     * @private\n\t     */\n\t\n\t  }, {\n\t    key: '_getElementOption',\n\t    value: function _getElementOption(option) {\n\t      // If column width is a string, treat is as a selector and search for the\n\t      // sizer element within the outermost container\n\t      if (typeof option === 'string') {\n\t        return this.element.querySelector(option);\n\t\n\t        // Check for an element\n\t      } else if (option && option.nodeType && option.nodeType === 1) {\n\t        return option;\n\t\n\t        // Check for jQuery object\n\t      } else if (option && option.jquery) {\n\t        return option[0];\n\t      }\n\t\n\t      return null;\n\t    }\n\t\n\t    /**\n\t     * Ensures the shuffle container has the css styles it needs applied to it.\n\t     * @param {Object} styles Key value pairs for position and overflow.\n\t     * @private\n\t     */\n\t\n\t  }, {\n\t    key: '_validateStyles',\n\t    value: function _validateStyles(styles) {\n\t      // Position cannot be static.\n\t      if (styles.position === 'static') {\n\t        this.element.style.position = 'relative';\n\t      }\n\t\n\t      // Overflow has to be hidden.\n\t      if (styles.overflow !== 'hidden') {\n\t        this.element.style.overflow = 'hidden';\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Filter the elements by a category.\n\t     * @param {string} [category] Category to filter by. If it's given, the last\n\t     *     category will be used to filter the items.\n\t     * @param {Array} [collection] Optionally filter a collection. Defaults to\n\t     *     all the items.\n\t     * @return {!{visible: Array, hidden: Array}}\n\t     * @private\n\t     */\n\t\n\t  }, {\n\t    key: '_filter',\n\t    value: function _filter() {\n\t      var category = arguments.length <= 0 || arguments[0] === undefined ? this.lastFilter : arguments[0];\n\t      var collection = arguments.length <= 1 || arguments[1] === undefined ? this.items : arguments[1];\n\t\n\t      var set = this._getFilteredSets(category, collection);\n\t\n\t      // Individually add/remove hidden/visible classes\n\t      this._toggleFilterClasses(set);\n\t\n\t      // Save the last filter in case elements are appended.\n\t      this.lastFilter = category;\n\t\n\t      // This is saved mainly because providing a filter function (like searching)\n\t      // will overwrite the `lastFilter` property every time its called.\n\t      if (typeof category === 'string') {\n\t        this.group = category;\n\t      }\n\t\n\t      return set;\n\t    }\n\t\n\t    /**\n\t     * Returns an object containing the visible and hidden elements.\n\t     * @param {string|Function} category Category or function to filter by.\n\t     * @param {Array.<Element>} items A collection of items to filter.\n\t     * @return {!{visible: Array, hidden: Array}}\n\t     * @private\n\t     */\n\t\n\t  }, {\n\t    key: '_getFilteredSets',\n\t    value: function _getFilteredSets(category, items) {\n\t      var _this = this;\n\t\n\t      var visible = [];\n\t      var hidden = [];\n\t\n\t      // category === 'all', add visible class to everything\n\t      if (category === Shuffle.ALL_ITEMS) {\n\t        visible = items;\n\t\n\t        // Loop through each item and use provided function to determine\n\t        // whether to hide it or not.\n\t      } else {\n\t        items.forEach(function (item) {\n\t          if (_this._doesPassFilter(category, item.element)) {\n\t            visible.push(item);\n\t          } else {\n\t            hidden.push(item);\n\t          }\n\t        });\n\t      }\n\t\n\t      return {\n\t        visible: visible,\n\t        hidden: hidden\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Test an item to see if it passes a category.\n\t     * @param {string|Function} category Category or function to filter by.\n\t     * @param {Element} element An element to test.\n\t     * @return {boolean} Whether it passes the category/filter.\n\t     * @private\n\t     */\n\t\n\t  }, {\n\t    key: '_doesPassFilter',\n\t    value: function _doesPassFilter(category, element) {\n\t\n\t      if (typeof category === 'function') {\n\t        return category.call(element, element, this);\n\t\n\t        // Check each element's data-groups attribute against the given category.\n\t      } else {\n\t        var attr = element.getAttribute('data-' + Shuffle.FILTER_ATTRIBUTE_KEY);\n\t        var keys = this.options.delimeter ? attr.split(this.options.delimeter) : JSON.parse(attr);\n\t\n\t        if (Array.isArray(category)) {\n\t          return category.some(arrayIncludes(keys));\n\t        }\n\t\n\t        return arrayIncludes(keys, category);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Toggles the visible and hidden class names.\n\t     * @param {{visible, hidden}} Object with visible and hidden arrays.\n\t     * @private\n\t     */\n\t\n\t  }, {\n\t    key: '_toggleFilterClasses',\n\t    value: function _toggleFilterClasses(_ref) {\n\t      var visible = _ref.visible;\n\t      var hidden = _ref.hidden;\n\t\n\t      visible.forEach(function (item) {\n\t        item.show();\n\t      });\n\t\n\t      hidden.forEach(function (item) {\n\t        item.hide();\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Set the initial css for each item\n\t     * @param {Array.<ShuffleItem>} [items] Optionally specifiy at set to initialize.\n\t     * @private\n\t     */\n\t\n\t  }, {\n\t    key: '_initItems',\n\t    value: function _initItems() {\n\t      var items = arguments.length <= 0 || arguments[0] === undefined ? this.items : arguments[0];\n\t\n\t      items.forEach(function (item) {\n\t        item.init();\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Remove element reference and styles.\n\t     * @private\n\t     */\n\t\n\t  }, {\n\t    key: '_disposeItems',\n\t    value: function _disposeItems() {\n\t      var items = arguments.length <= 0 || arguments[0] === undefined ? this.items : arguments[0];\n\t\n\t      items.forEach(function (item) {\n\t        item.dispose();\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Updates the visible item count.\n\t     * @private\n\t     */\n\t\n\t  }, {\n\t    key: '_updateItemCount',\n\t    value: function _updateItemCount() {\n\t      this.visibleItems = this._getFilteredItems().length;\n\t    }\n\t\n\t    /**\n\t     * Sets css transform transition on a group of elements. This is not executed\n\t     * at the same time as `item.init` so that transitions don't occur upon\n\t     * initialization of Shuffle.\n\t     * @param {Array.<ShuffleItem>} items Shuffle items to set transitions on.\n\t     * @private\n\t     */\n\t\n\t  }, {\n\t    key: '_setTransitions',\n\t    value: function _setTransitions() {\n\t      var items = arguments.length <= 0 || arguments[0] === undefined ? this.items : arguments[0];\n\t\n\t      var speed = this.options.speed;\n\t      var easing = this.options.easing;\n\t\n\t      var str;\n\t      if (this.options.useTransforms) {\n\t        str = 'transform ' + speed + 'ms ' + easing + ', opacity ' + speed + 'ms ' + easing;\n\t      } else {\n\t        str = 'top ' + speed + 'ms ' + easing + ', left ' + speed + 'ms ' + easing + ', opacity ' + speed + 'ms ' + easing;\n\t      }\n\t\n\t      items.forEach(function (item) {\n\t        item.element.style.transition = str;\n\t      });\n\t    }\n\t  }, {\n\t    key: '_getItems',\n\t    value: function _getItems() {\n\t      var _this2 = this;\n\t\n\t      return toArray(this.element.children).filter(function (el) {\n\t        return (0, _matchesSelector2.default)(el, _this2.options.itemSelector);\n\t      }).map(function (el) {\n\t        return new _shuffleItem2.default(el);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * When new elements are added to the shuffle container, update the array of\n\t     * items because that is the order `_layout` calls them.\n\t     */\n\t\n\t  }, {\n\t    key: '_updateItemsOrder',\n\t    value: function _updateItemsOrder() {\n\t      var children = this.element.children;\n\t      this.items = (0, _sorter2.default)(this.items, {\n\t        by: function by(element) {\n\t          return Array.prototype.indexOf.call(children, element);\n\t        }\n\t      });\n\t    }\n\t  }, {\n\t    key: '_getFilteredItems',\n\t    value: function _getFilteredItems() {\n\t      return this.items.filter(function (item) {\n\t        return item.isVisible;\n\t      });\n\t    }\n\t  }, {\n\t    key: '_getConcealedItems',\n\t    value: function _getConcealedItems() {\n\t      return this.items.filter(function (item) {\n\t        return !item.isVisible;\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Returns the column size, based on column width and sizer options.\n\t     * @param {number} containerWidth Size of the parent container.\n\t     * @param {number} gutterSize Size of the gutters.\n\t     * @return {number}\n\t     * @private\n\t     */\n\t\n\t  }, {\n\t    key: '_getColumnSize',\n\t    value: function _getColumnSize(containerWidth, gutterSize) {\n\t      var size;\n\t\n\t      // If the columnWidth property is a function, then the grid is fluid\n\t      if (typeof this.options.columnWidth === 'function') {\n\t        size = this.options.columnWidth(containerWidth);\n\t\n\t        // columnWidth option isn't a function, are they using a sizing element?\n\t      } else if (this.useSizer) {\n\t        size = Shuffle.getSize(this.options.sizer).width;\n\t\n\t        // if not, how about the explicitly set option?\n\t      } else if (this.options.columnWidth) {\n\t        size = this.options.columnWidth;\n\t\n\t        // or use the size of the first item\n\t      } else if (this.items.length > 0) {\n\t        size = Shuffle.getSize(this.items[0].element, true).width;\n\t\n\t        // if there's no items, use size of container\n\t      } else {\n\t        size = containerWidth;\n\t      }\n\t\n\t      // Don't let them set a column width of zero.\n\t      if (size === 0) {\n\t        size = containerWidth;\n\t      }\n\t\n\t      return size + gutterSize;\n\t    }\n\t\n\t    /**\n\t     * Returns the gutter size, based on gutter width and sizer options.\n\t     * @param {number} containerWidth Size of the parent container.\n\t     * @return {number}\n\t     * @private\n\t     */\n\t\n\t  }, {\n\t    key: '_getGutterSize',\n\t    value: function _getGutterSize(containerWidth) {\n\t      var size;\n\t      if (typeof this.options.gutterWidth === 'function') {\n\t        size = this.options.gutterWidth(containerWidth);\n\t      } else if (this.useSizer) {\n\t        size = (0, _getNumberStyle2.default)(this.options.sizer, 'marginLeft');\n\t      } else {\n\t        size = this.options.gutterWidth;\n\t      }\n\t\n\t      return size;\n\t    }\n\t\n\t    /**\n\t     * Calculate the number of columns to be used. Gets css if using sizer element.\n\t     * @param {number} [containerWidth] Optionally specify a container width if\n\t     *    it's already available.\n\t     */\n\t\n\t  }, {\n\t    key: '_setColumns',\n\t    value: function _setColumns() {\n\t      var containerWidth = arguments.length <= 0 || arguments[0] === undefined ? Shuffle.getSize(this.element).width : arguments[0];\n\t\n\t      var gutter = this._getGutterSize(containerWidth);\n\t      var columnWidth = this._getColumnSize(containerWidth, gutter);\n\t      var calculatedColumns = (containerWidth + gutter) / columnWidth;\n\t\n\t      // Widths given from getStyles are not precise enough...\n\t      if (Math.abs(Math.round(calculatedColumns) - calculatedColumns) < this.options.columnThreshold) {\n\t        // e.g. calculatedColumns = 11.998876\n\t        calculatedColumns = Math.round(calculatedColumns);\n\t      }\n\t\n\t      this.cols = Math.max(Math.floor(calculatedColumns), 1);\n\t      this.containerWidth = containerWidth;\n\t      this.colWidth = columnWidth;\n\t    }\n\t\n\t    /**\n\t     * Adjust the height of the grid\n\t     */\n\t\n\t  }, {\n\t    key: '_setContainerSize',\n\t    value: function _setContainerSize() {\n\t      this.element.style.height = this._getContainerSize() + 'px';\n\t    }\n\t\n\t    /**\n\t     * Based on the column heights, it returns the biggest one.\n\t     * @return {number}\n\t     * @private\n\t     */\n\t\n\t  }, {\n\t    key: '_getContainerSize',\n\t    value: function _getContainerSize() {\n\t      return arrayMax(this.positions);\n\t    }\n\t\n\t    /**\n\t     * Get the clamped stagger amount.\n\t     * @param {number} index Index of the item to be staggered.\n\t     * @return {number}\n\t     */\n\t\n\t  }, {\n\t    key: '_getStaggerAmount',\n\t    value: function _getStaggerAmount(index) {\n\t      return Math.min(index * this.options.staggerAmount, this.options.staggerAmountMax);\n\t    }\n\t\n\t    /**\n\t     * @return {boolean} Whether the event was prevented or not.\n\t     */\n\t\n\t  }, {\n\t    key: '_dispatch',\n\t    value: function _dispatch(name) {\n\t      var details = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t      if (this.isDestroyed) {\n\t        return;\n\t      }\n\t\n\t      details.shuffle = this;\n\t      return !this.element.dispatchEvent(new CustomEvent(name, {\n\t        bubbles: true,\n\t        cancelable: false,\n\t        detail: details\n\t      }));\n\t    }\n\t\n\t    /**\n\t     * Zeros out the y columns array, which is used to determine item placement.\n\t     * @private\n\t     */\n\t\n\t  }, {\n\t    key: '_resetCols',\n\t    value: function _resetCols() {\n\t      var i = this.cols;\n\t      this.positions = [];\n\t      while (i--) {\n\t        this.positions.push(0);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Loops through each item that should be shown and calculates the x, y position.\n\t     * @param {Array.<ShuffleItem>} items Array of items that will be shown/layed\n\t     *     out in order in their array.\n\t     */\n\t\n\t  }, {\n\t    key: '_layout',\n\t    value: function _layout(items) {\n\t      var _this3 = this;\n\t\n\t      var count = 0;\n\t      items.forEach(function (item) {\n\t        var currPos = item.point;\n\t        var currScale = item.scale;\n\t        var itemSize = Shuffle.getSize(item.element, true);\n\t        var pos = _this3._getItemPosition(itemSize);\n\t\n\t        function callback() {\n\t          item.element.style.transitionDelay = '';\n\t          item.applyCss(_shuffleItem2.default.Css.VISIBLE.after);\n\t        }\n\t\n\t        // If the item will not change its position, do not add it to the render\n\t        // queue. Transitions don't fire when setting a property to the same value.\n\t        if (_point2.default.equals(currPos, pos) && currScale === _shuffleItem2.default.Scale.VISIBLE) {\n\t          callback();\n\t          return;\n\t        }\n\t\n\t        item.point = pos;\n\t        item.scale = _shuffleItem2.default.Scale.VISIBLE;\n\t\n\t        // Use xtend here to clone the object so that the `before` object isn't\n\t        // modified when the transition delay is added.\n\t        var styles = (0, _xtend2.default)(_shuffleItem2.default.Css.VISIBLE.before);\n\t        styles.transitionDelay = _this3._getStaggerAmount(count) + 'ms';\n\t\n\t        _this3._queue.push({\n\t          item: item,\n\t          styles: styles,\n\t          callback: callback\n\t        });\n\t\n\t        count++;\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Determine the location of the next item, based on its size.\n\t     * @param {{width: number, height: number}} itemSize Object with width and height.\n\t     * @return {Point}\n\t     * @private\n\t     */\n\t\n\t  }, {\n\t    key: '_getItemPosition',\n\t    value: function _getItemPosition(itemSize) {\n\t      return (0, _layout2.getItemPosition)({\n\t        itemSize: itemSize,\n\t        positions: this.positions,\n\t        gridSize: this.colWidth,\n\t        total: this.cols,\n\t        threshold: this.options.columnThreshold,\n\t        buffer: this.options.buffer\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Hides the elements that don't match our filter.\n\t     * @param {Array.<ShuffleItem>} collection Collection to shrink.\n\t     * @private\n\t     */\n\t\n\t  }, {\n\t    key: '_shrink',\n\t    value: function _shrink() {\n\t      var _this4 = this;\n\t\n\t      var collection = arguments.length <= 0 || arguments[0] === undefined ? this._getConcealedItems() : arguments[0];\n\t\n\t      var count = 0;\n\t      collection.forEach(function (item) {\n\t        function callback() {\n\t          item.applyCss(_shuffleItem2.default.Css.HIDDEN.after);\n\t        }\n\t\n\t        // Continuing would add a transitionend event listener to the element, but\n\t        // that listener would not execute because the transform and opacity would\n\t        // stay the same.\n\t        // The callback is executed here because it is not guaranteed to be called\n\t        // after the transitionend event because the transitionend could be\n\t        // canceled if another animation starts.\n\t        if (item.scale === _shuffleItem2.default.Scale.HIDDEN) {\n\t          callback();\n\t          return;\n\t        }\n\t\n\t        item.scale = _shuffleItem2.default.Scale.HIDDEN;\n\t\n\t        var styles = (0, _xtend2.default)(_shuffleItem2.default.Css.HIDDEN.before);\n\t        styles.transitionDelay = _this4._getStaggerAmount(count) + 'ms';\n\t\n\t        _this4._queue.push({\n\t          item: item,\n\t          styles: styles,\n\t          callback: callback\n\t        });\n\t\n\t        count++;\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Resize handler.\n\t     * @private\n\t     */\n\t\n\t  }, {\n\t    key: '_handleResize',\n\t    value: function _handleResize() {\n\t      // If shuffle is disabled, destroyed, don't do anything\n\t      if (!this.isEnabled || this.isDestroyed) {\n\t        return;\n\t      }\n\t\n\t      // Will need to check height in the future if it's layed out horizontaly\n\t      var containerWidth = Shuffle.getSize(this.element).width;\n\t\n\t      // containerWidth hasn't changed, don't do anything\n\t      if (containerWidth === this.containerWidth) {\n\t        return;\n\t      }\n\t\n\t      this.update();\n\t    }\n\t\n\t    /**\n\t     * Returns styles which will be applied to the an item for a transition.\n\t     * @param {Object} obj Transition options.\n\t     * @return {!Object} Transforms for transitions, left/top for animate.\n\t     * @private\n\t     */\n\t\n\t  }, {\n\t    key: '_getStylesForTransition',\n\t    value: function _getStylesForTransition(_ref2) {\n\t      var item = _ref2.item;\n\t      var styles = _ref2.styles;\n\t\n\t      if (!styles.transitionDelay) {\n\t        styles.transitionDelay = '0ms';\n\t      }\n\t\n\t      var x = item.point.x;\n\t      var y = item.point.y;\n\t\n\t      if (this.options.useTransforms) {\n\t        styles.transform = 'translate(' + x + 'px, ' + y + 'px) scale(' + item.scale + ')';\n\t      } else {\n\t        styles.left = x + 'px';\n\t        styles.top = y + 'px';\n\t      }\n\t\n\t      return styles;\n\t    }\n\t\n\t    /**\n\t     * Listen for the transition end on an element and execute the itemCallback\n\t     * when it finishes.\n\t     * @param {Element} element Element to listen on.\n\t     * @param {Function} itemCallback Callback for the item.\n\t     * @param {Function} done Callback to notify `parallel` that this one is done.\n\t     */\n\t\n\t  }, {\n\t    key: '_whenTransitionDone',\n\t    value: function _whenTransitionDone(element, itemCallback, done) {\n\t      var id = (0, _onTransitionEnd.onTransitionEnd)(element, function (evt) {\n\t        itemCallback();\n\t        done(null, evt);\n\t      });\n\t\n\t      this._transitions.push(id);\n\t    }\n\t\n\t    /**\n\t     * Return a function which will set CSS styles and call the `done` function\n\t     * when (if) the transition finishes.\n\t     * @param {Object} opts Transition object.\n\t     * @return {Function} A function to be called with a `done` function.\n\t     */\n\t\n\t  }, {\n\t    key: '_getTransitionFunction',\n\t    value: function _getTransitionFunction(opts) {\n\t      var _this5 = this;\n\t\n\t      return function (done) {\n\t        opts.item.applyCss(_this5._getStylesForTransition(opts));\n\t        _this5._whenTransitionDone(opts.item.element, opts.callback, done);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Execute the styles gathered in the style queue. This applies styles to elements,\n\t     * triggering transitions.\n\t     * @private\n\t     */\n\t\n\t  }, {\n\t    key: '_processQueue',\n\t    value: function _processQueue() {\n\t      if (this.isTransitioning) {\n\t        this._cancelMovement();\n\t      }\n\t\n\t      var hasSpeed = this.options.speed > 0;\n\t      var hasQueue = this._queue.length > 0;\n\t\n\t      if (hasQueue && hasSpeed && this.isInitialized) {\n\t        this._startTransitions(this._queue);\n\t      } else if (hasQueue) {\n\t        this._styleImmediately(this._queue);\n\t        this._dispatchLayout();\n\t\n\t        // A call to layout happened, but none of the newly visible items will\n\t        // change position or the transition duration is zero, which will not trigger\n\t        // the transitionend event.\n\t      } else {\n\t        this._dispatchLayout();\n\t      }\n\t\n\t      // Remove everything in the style queue\n\t      this._queue.length = 0;\n\t    }\n\t\n\t    /**\n\t     * Wait for each transition to finish, the emit the layout event.\n\t     * @param {Array.<Object>} transitions Array of transition objects.\n\t     */\n\t\n\t  }, {\n\t    key: '_startTransitions',\n\t    value: function _startTransitions(transitions) {\n\t      var _this6 = this;\n\t\n\t      // Set flag that shuffle is currently in motion.\n\t      this.isTransitioning = true;\n\t\n\t      // Create an array of functions to be called.\n\t      var callbacks = transitions.map(function (obj) {\n\t        return _this6._getTransitionFunction(obj);\n\t      });\n\t\n\t      (0, _arrayParallel2.default)(callbacks, this._movementFinished.bind(this));\n\t    }\n\t  }, {\n\t    key: '_cancelMovement',\n\t    value: function _cancelMovement() {\n\t      // Remove the transition end event for each listener.\n\t      this._transitions.forEach(_onTransitionEnd.cancelTransitionEnd);\n\t\n\t      // Reset the array.\n\t      this._transitions.length = 0;\n\t\n\t      // Show it's no longer active.\n\t      this.isTransitioning = false;\n\t    }\n\t\n\t    /**\n\t     * Apply styles without a transition.\n\t     * @param {Array.<Object>} objects Array of transition objects.\n\t     * @private\n\t     */\n\t\n\t  }, {\n\t    key: '_styleImmediately',\n\t    value: function _styleImmediately(objects) {\n\t      var _this7 = this;\n\t\n\t      if (objects.length) {\n\t        var elements = objects.map(function (obj) {\n\t          return obj.item.element;\n\t        });\n\t\n\t        Shuffle._skipTransitions(elements, function () {\n\t          objects.forEach(function (obj) {\n\t            obj.item.applyCss(_this7._getStylesForTransition(obj));\n\t            obj.callback();\n\t          });\n\t        });\n\t      }\n\t    }\n\t  }, {\n\t    key: '_movementFinished',\n\t    value: function _movementFinished() {\n\t      this._transitions.length = 0;\n\t      this.isTransitioning = false;\n\t      this._dispatchLayout();\n\t    }\n\t  }, {\n\t    key: '_dispatchLayout',\n\t    value: function _dispatchLayout() {\n\t      this._dispatch(Shuffle.EventType.LAYOUT);\n\t    }\n\t\n\t    /**\n\t     * The magic. This is what makes the plugin 'shuffle'\n\t     * @param {string|Function|Array.<string>} [category] Category to filter by.\n\t     *     Can be a function, string, or array of strings.\n\t     * @param {Object} [sortObj] A sort object which can sort the visible set\n\t     */\n\t\n\t  }, {\n\t    key: 'filter',\n\t    value: function filter(category, sortObj) {\n\t      if (!this.isEnabled) {\n\t        return;\n\t      }\n\t\n\t      if (!category || category && category.length === 0) {\n\t        category = Shuffle.ALL_ITEMS;\n\t      }\n\t\n\t      this._filter(category);\n\t\n\t      // Shrink each hidden item\n\t      this._shrink();\n\t\n\t      // How many visible elements?\n\t      this._updateItemCount();\n\t\n\t      // Update transforms on visible elements so they will animate to their new positions.\n\t      this.sort(sortObj);\n\t    }\n\t\n\t    /**\n\t     * Gets the visible elements, sorts them, and passes them to layout.\n\t     * @param {Object} opts the options object for the sorted plugin\n\t     */\n\t\n\t  }, {\n\t    key: 'sort',\n\t    value: function sort() {\n\t      var opts = arguments.length <= 0 || arguments[0] === undefined ? this.lastSort : arguments[0];\n\t\n\t      if (!this.isEnabled) {\n\t        return;\n\t      }\n\t\n\t      this._resetCols();\n\t\n\t      var items = this._getFilteredItems();\n\t      items = (0, _sorter2.default)(items, opts);\n\t\n\t      this._layout(items);\n\t\n\t      // `_layout` always happens after `_shrink`, so it's safe to process the style\n\t      // queue here with styles from the shrink method.\n\t      this._processQueue();\n\t\n\t      // Adjust the height of the container.\n\t      this._setContainerSize();\n\t\n\t      this.lastSort = opts;\n\t    }\n\t\n\t    /**\n\t     * Reposition everything.\n\t     * @param {boolean} isOnlyLayout If true, column and gutter widths won't be\n\t     *     recalculated.\n\t     */\n\t\n\t  }, {\n\t    key: 'update',\n\t    value: function update(isOnlyLayout) {\n\t      if (this.isEnabled) {\n\t\n\t        if (!isOnlyLayout) {\n\t          // Get updated colCount\n\t          this._setColumns();\n\t        }\n\t\n\t        // Layout items\n\t        this.sort();\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Use this instead of `update()` if you don't need the columns and gutters updated\n\t     * Maybe an image inside `shuffle` loaded (and now has a height), which means calculations\n\t     * could be off.\n\t     */\n\t\n\t  }, {\n\t    key: 'layout',\n\t    value: function layout() {\n\t      this.update(true);\n\t    }\n\t\n\t    /**\n\t     * New items have been appended to shuffle. Mix them in with the current\n\t     * filter or sort status.\n\t     * @param {Array.<Element>} newItems Collection of new items.\n\t     */\n\t\n\t  }, {\n\t    key: 'add',\n\t    value: function add(newItems) {\n\t      newItems = (0, _arrayUniq2.default)(newItems).map(function (el) {\n\t        return new _shuffleItem2.default(el);\n\t      });\n\t\n\t      // Add classes and set initial positions.\n\t      this._initItems(newItems);\n\t\n\t      // Add transition to each item.\n\t      this._setTransitions(newItems);\n\t\n\t      // Update the list of items.\n\t      this.items = this.items.concat(newItems);\n\t      this._updateItemsOrder();\n\t      this.filter(this.lastFilter);\n\t    }\n\t\n\t    /**\n\t     * Disables shuffle from updating dimensions and layout on resize\n\t     */\n\t\n\t  }, {\n\t    key: 'disable',\n\t    value: function disable() {\n\t      this.isEnabled = false;\n\t    }\n\t\n\t    /**\n\t     * Enables shuffle again\n\t     * @param {boolean} [isUpdateLayout=true] if undefined, shuffle will update columns and gutters\n\t     */\n\t\n\t  }, {\n\t    key: 'enable',\n\t    value: function enable(isUpdateLayout) {\n\t      this.isEnabled = true;\n\t      if (isUpdateLayout !== false) {\n\t        this.update();\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Remove 1 or more shuffle items\n\t     * @param {Array.<Element>} collection An array containing one or more\n\t     *     elements in shuffle\n\t     * @return {Shuffle} The shuffle object\n\t     */\n\t\n\t  }, {\n\t    key: 'remove',\n\t    value: function remove(collection) {\n\t      var _this8 = this;\n\t\n\t      if (!collection.length) {\n\t        return;\n\t      }\n\t\n\t      collection = (0, _arrayUniq2.default)(collection);\n\t\n\t      var oldItems = collection.map(function (element) {\n\t        return _this8.getItemByElement(element);\n\t      }).filter(function (item) {\n\t        return !!item;\n\t      });\n\t\n\t      var handleLayout = function handleLayout() {\n\t        _this8.element.removeEventListener(Shuffle.EventType.LAYOUT, handleLayout);\n\t        _this8._disposeItems(oldItems);\n\t\n\t        // Remove the collection in the callback\n\t        collection.forEach(function (element) {\n\t          element.parentNode.removeChild(element);\n\t        });\n\t\n\t        _this8._dispatch(Shuffle.EventType.REMOVED, { collection: collection });\n\t\n\t        // Let it get garbage collected\n\t        collection = null;\n\t        oldItems = null;\n\t      };\n\t\n\t      // Hide collection first.\n\t      this._toggleFilterClasses({\n\t        visible: [],\n\t        hidden: oldItems\n\t      });\n\t\n\t      this._shrink(oldItems);\n\t\n\t      this.sort();\n\t\n\t      // Update the list of items here because `remove` could be called again\n\t      // with an item that is in the process of being removed.\n\t      this.items = this.items.filter(function (item) {\n\t        return !arrayIncludes(oldItems, item);\n\t      });\n\t      this._updateItemCount();\n\t\n\t      this.element.addEventListener(Shuffle.EventType.LAYOUT, handleLayout);\n\t    }\n\t\n\t    /**\n\t     * Retrieve a shuffle item by its element.\n\t     * @param {Element} element Element to look for.\n\t     * @return {?ShuffleItem} A shuffle item or null if it's not found.\n\t     */\n\t\n\t  }, {\n\t    key: 'getItemByElement',\n\t    value: function getItemByElement(element) {\n\t      for (var i = this.items.length - 1; i >= 0; i--) {\n\t        if (this.items[i].element === element) {\n\t          return this.items[i];\n\t        }\n\t      }\n\t\n\t      return null;\n\t    }\n\t\n\t    /**\n\t     * Destroys shuffle, removes events, styles, and classes\n\t     */\n\t\n\t  }, {\n\t    key: 'destroy',\n\t    value: function destroy() {\n\t      this._cancelMovement();\n\t      window.removeEventListener('resize', this._onResize);\n\t\n\t      // Reset container styles\n\t      this.element.classList.remove('shuffle');\n\t      this.element.removeAttribute('style');\n\t\n\t      // Reset individual item styles\n\t      this._disposeItems();\n\t\n\t      // Null DOM references\n\t      this.items = null;\n\t      this.options.sizer = null;\n\t      this.element = null;\n\t      this._transitions = null;\n\t\n\t      // Set a flag so if a debounced resize has been triggered,\n\t      // it can first check if it is actually isDestroyed and not doing anything\n\t      this.isDestroyed = true;\n\t    }\n\t\n\t    /**\n\t     * Returns the outer width of an element, optionally including its margins.\n\t     *\n\t     * There are a few different methods for getting the width of an element, none of\n\t     * which work perfectly for all Shuffle's use cases.\n\t     *\n\t     * 1. getBoundingClientRect() `left` and `right` properties.\n\t     *   - Accounts for transform scaled elements, making it useless for Shuffle\n\t     *   elements which have shrunk.\n\t     * 2. The `offsetWidth` property.\n\t     *   - This value stays the same regardless of the elements transform property,\n\t     *   however, it does not return subpixel values.\n\t     * 3. getComputedStyle()\n\t     *   - This works great Chrome, Firefox, Safari, but IE<=11 does not include\n\t     *   padding and border when box-sizing: border-box is set, requiring a feature\n\t     *   test and extra work to add the padding back for IE and other browsers which\n\t     *   follow the W3C spec here.\n\t     *\n\t     * @param {Element} element The element.\n\t     * @param {boolean} [includeMargins] Whether to include margins. Default is false.\n\t     * @return {{width: number, height: number}} The width and height.\n\t     */\n\t\n\t  }], [{\n\t    key: 'getSize',\n\t    value: function getSize(element, includeMargins) {\n\t      // Store the styles so that they can be used by others without asking for it again.\n\t      var styles = window.getComputedStyle(element, null);\n\t      var width = (0, _getNumberStyle2.default)(element, 'width', styles);\n\t      var height = (0, _getNumberStyle2.default)(element, 'height', styles);\n\t\n\t      if (includeMargins) {\n\t        var marginLeft = (0, _getNumberStyle2.default)(element, 'marginLeft', styles);\n\t        var marginRight = (0, _getNumberStyle2.default)(element, 'marginRight', styles);\n\t        var marginTop = (0, _getNumberStyle2.default)(element, 'marginTop', styles);\n\t        var marginBottom = (0, _getNumberStyle2.default)(element, 'marginBottom', styles);\n\t        width += marginLeft + marginRight;\n\t        height += marginTop + marginBottom;\n\t      }\n\t\n\t      return {\n\t        width: width,\n\t        height: height\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Change a property or execute a function which will not have a transition\n\t     * @param {Array.<Element>} elements DOM elements that won't be transitioned.\n\t     * @param {Function} callback A function which will be called while transition\n\t     *     is set to 0ms.\n\t     * @private\n\t     */\n\t\n\t  }, {\n\t    key: '_skipTransitions',\n\t    value: function _skipTransitions(elements, callback) {\n\t      var zero = '0ms';\n\t\n\t      // Save current duration and delay.\n\t      var data = elements.map(function (element) {\n\t        var style = element.style;\n\t        var duration = style.transitionDuration;\n\t        var delay = style.transitionDelay;\n\t\n\t        // Set the duration to zero so it happens immediately\n\t        style.transitionDuration = zero;\n\t        style.transitionDelay = zero;\n\t\n\t        return {\n\t          duration: duration,\n\t          delay: delay\n\t        };\n\t      });\n\t\n\t      callback();\n\t\n\t      // Cause reflow.\n\t      elements[0].offsetWidth; // jshint ignore:line\n\t\n\t      // Put the duration back\n\t      elements.forEach(function (element, i) {\n\t        element.style.transitionDuration = data[i].duration;\n\t        element.style.transitionDelay = data[i].delay;\n\t      });\n\t    }\n\t  }]);\n\t\n\t  return Shuffle;\n\t}();\n\t\n\tShuffle.ShuffleItem = _shuffleItem2.default;\n\t\n\tShuffle.ALL_ITEMS = 'all';\n\tShuffle.FILTER_ATTRIBUTE_KEY = 'groups';\n\t\n\t/**\n\t * @enum {string}\n\t */\n\tShuffle.EventType = {\n\t  LAYOUT: 'shuffle:layout',\n\t  REMOVED: 'shuffle:removed'\n\t};\n\t\n\t/** @enum {string} */\n\tShuffle.Classes = _classes2.default;\n\t\n\t// Overrideable options\n\tShuffle.options = {\n\t  // Initial filter group.\n\t  group: Shuffle.ALL_ITEMS,\n\t\n\t  // Transition/animation speed (milliseconds).\n\t  speed: 250,\n\t\n\t  // CSS easing function to use.\n\t  easing: 'ease',\n\t\n\t  // e.g. '.picture-item'.\n\t  itemSelector: '*',\n\t\n\t  // Element or selector string. Use an element to determine the size of columns\n\t  // and gutters.\n\t  sizer: null,\n\t\n\t  // A static number or function that tells the plugin how wide the gutters\n\t  // between columns are (in pixels).\n\t  gutterWidth: 0,\n\t\n\t  // A static number or function that returns a number which tells the plugin\n\t  // how wide the columns are (in pixels).\n\t  columnWidth: 0,\n\t\n\t  // If your group is not json, and is comma delimeted, you could set delimeter\n\t  // to ','.\n\t  delimeter: null,\n\t\n\t  // Useful for percentage based heights when they might not always be exactly\n\t  // the same (in pixels).\n\t  buffer: 0,\n\t\n\t  // Reading the width of elements isn't precise enough and can cause columns to\n\t  // jump between values.\n\t  columnThreshold: 0.01,\n\t\n\t  // Shuffle can be isInitialized with a sort object. It is the same object\n\t  // given to the sort method.\n\t  initialSort: null,\n\t\n\t  // By default, shuffle will throttle resize events. This can be changed or\n\t  // removed.\n\t  throttle: _throttleit2.default,\n\t\n\t  // How often shuffle can be called on resize (in milliseconds).\n\t  throttleTime: 300,\n\t\n\t  // Transition delay offset for each item in milliseconds.\n\t  staggerAmount: 15,\n\t\n\t  // Maximum stagger delay in milliseconds.\n\t  staggerAmountMax: 250,\n\t\n\t  // Whether to use transforms or absolute positioning.\n\t  useTransforms: true\n\t};\n\t\n\t// Expose for testing. Hack at your own risk.\n\tShuffle.__Point = _point2.default;\n\tShuffle.__sorter = _sorter2.default;\n\tShuffle.__getColumnSpan = _layout2.getColumnSpan;\n\tShuffle.__getAvailablePositions = _layout2.getAvailablePositions;\n\tShuffle.__getShortColumn = _layout2.getShortColumn;\n\t\n\texports.default = Shuffle;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t// Polyfill for creating CustomEvents on IE9/10/11\n\t\n\t// code pulled from:\n\t// https://github.com/d4tocchini/customevent-polyfill\n\t// https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent#Polyfill\n\t\n\ttry {\n\t  new window.CustomEvent(\"test\");\n\t} catch(e) {\n\t var CustomEvent = function(event, params) {\n\t      var evt;\n\t      params = params || {\n\t          bubbles: false,\n\t          cancelable: false,\n\t          detail: undefined\n\t      };\n\t\n\t      evt = document.createEvent(\"CustomEvent\");\n\t      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n\t      return evt;\n\t  };\n\t\n\t  CustomEvent.prototype = window.Event.prototype;\n\t  window.CustomEvent = CustomEvent; // expose definition to window\n\t}\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar proto = Element.prototype;\n\tvar vendor = proto.matches\n\t  || proto.matchesSelector\n\t  || proto.webkitMatchesSelector\n\t  || proto.mozMatchesSelector\n\t  || proto.msMatchesSelector\n\t  || proto.oMatchesSelector;\n\t\n\tmodule.exports = match;\n\t\n\t/**\n\t * Match `el` to `selector`.\n\t *\n\t * @param {Element} el\n\t * @param {String} selector\n\t * @return {Boolean}\n\t * @api public\n\t */\n\t\n\tfunction match(el, selector) {\n\t  if (vendor) return vendor.call(el, selector);\n\t  var nodes = el.parentNode.querySelectorAll(selector);\n\t  for (var i = 0; i < nodes.length; i++) {\n\t    if (nodes[i] == el) return true;\n\t  }\n\t  return false;\n\t}\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\t\n\t// there's 3 implementations written in increasing order of efficiency\n\t\n\t// 1 - no Set type is defined\n\tfunction uniqNoSet(arr) {\n\t\tvar ret = [];\n\t\n\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\tif (ret.indexOf(arr[i]) === -1) {\n\t\t\t\tret.push(arr[i]);\n\t\t\t}\n\t\t}\n\t\n\t\treturn ret;\n\t}\n\t\n\t// 2 - a simple Set type is defined\n\tfunction uniqSet(arr) {\n\t\tvar seen = new Set();\n\t\treturn arr.filter(function (el) {\n\t\t\tif (!seen.has(el)) {\n\t\t\t\tseen.add(el);\n\t\t\t\treturn true;\n\t\t\t}\n\t\n\t\t\treturn false;\n\t\t});\n\t}\n\t\n\t// 3 - a standard Set type is defined and it has a forEach method\n\tfunction uniqSetWithForEach(arr) {\n\t\tvar ret = [];\n\t\n\t\t(new Set(arr)).forEach(function (el) {\n\t\t\tret.push(el);\n\t\t});\n\t\n\t\treturn ret;\n\t}\n\t\n\t// V8 currently has a broken implementation\n\t// https://github.com/joyent/node/issues/8449\n\tfunction doesForEachActuallyWork() {\n\t\tvar ret = false;\n\t\n\t\t(new Set([true])).forEach(function (el) {\n\t\t\tret = el;\n\t\t});\n\t\n\t\treturn ret === true;\n\t}\n\t\n\tif ('Set' in global) {\n\t\tif (typeof Set.prototype.forEach === 'function' && doesForEachActuallyWork()) {\n\t\t\tmodule.exports = uniqSetWithForEach;\n\t\t} else {\n\t\t\tmodule.exports = uniqSet;\n\t\t}\n\t} else {\n\t\tmodule.exports = uniqNoSet;\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\tmodule.exports = extend\n\t\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\t\n\tfunction extend() {\n\t    var target = {}\n\t\n\t    for (var i = 0; i < arguments.length; i++) {\n\t        var source = arguments[i]\n\t\n\t        for (var key in source) {\n\t            if (hasOwnProperty.call(source, key)) {\n\t                target[key] = source[key]\n\t            }\n\t        }\n\t    }\n\t\n\t    return target\n\t}\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\tmodule.exports = throttle;\n\t\n\t/**\n\t * Returns a new function that, when invoked, invokes `func` at most once per `wait` milliseconds.\n\t *\n\t * @param {Function} func Function to wrap.\n\t * @param {Number} wait Number of milliseconds that must elapse between `func` invocations.\n\t * @return {Function} A new function that wraps the `func` function passed in.\n\t */\n\t\n\tfunction throttle (func, wait) {\n\t  var ctx, args, rtn, timeoutID; // caching\n\t  var last = 0;\n\t\n\t  return function throttled () {\n\t    ctx = this;\n\t    args = arguments;\n\t    var delta = new Date() - last;\n\t    if (!timeoutID)\n\t      if (delta >= wait) call();\n\t      else timeoutID = setTimeout(call, wait - delta);\n\t    return rtn;\n\t  };\n\t\n\t  function call () {\n\t    timeoutID = 0;\n\t    last = +new Date();\n\t    rtn = func.apply(ctx, args);\n\t    ctx = null;\n\t    args = null;\n\t  }\n\t}\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function parallel(fns, context, callback) {\n\t  if (!callback) {\n\t    if (typeof context === 'function') {\n\t      callback = context\n\t      context = null\n\t    } else {\n\t      callback = noop\n\t    }\n\t  }\n\t\n\t  var pending = fns && fns.length\n\t  if (!pending) return callback(null, []);\n\t\n\t  var finished = false\n\t  var results = new Array(pending)\n\t\n\t  fns.forEach(context ? function (fn, i) {\n\t    fn.call(context, maybeDone(i))\n\t  } : function (fn, i) {\n\t    fn(maybeDone(i))\n\t  })\n\t\n\t  function maybeDone(i) {\n\t    return function (err, result) {\n\t      if (finished) return;\n\t\n\t      if (err) {\n\t        callback(err, results)\n\t        finished = true\n\t        return\n\t      }\n\t\n\t      results[i] = result\n\t\n\t      if (!--pending) callback(null, results);\n\t    }\n\t  }\n\t}\n\t\n\tfunction noop() {}\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _getNumber = __webpack_require__(9);\n\t\n\tvar _getNumber2 = _interopRequireDefault(_getNumber);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\n\t * Represents a coordinate pair.\n\t * @param {number} [x=0] X.\n\t * @param {number} [y=0] Y.\n\t */\n\tvar Point = function Point(x, y) {\n\t  this.x = (0, _getNumber2.default)(x);\n\t  this.y = (0, _getNumber2.default)(y);\n\t};\n\t\n\t/**\n\t * Whether two points are equal.\n\t * @param {Point} a Point A.\n\t * @param {Point} b Point B.\n\t * @return {boolean}\n\t */\n\tPoint.equals = function (a, b) {\n\t  return a.x === b.x && a.y === b.y;\n\t};\n\t\n\texports.default = Point;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Always returns a numeric value, given a value. Logic from jQuery's `isNumeric`.\n\t * @param {*} value Possibly numeric value.\n\t * @return {number} `value` or zero if `value` isn't numeric.\n\t */\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = getNumber;\n\tfunction getNumber(value) {\n\t  return parseFloat(value) || 0;\n\t}\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _point = __webpack_require__(8);\n\t\n\tvar _point2 = _interopRequireDefault(_point);\n\t\n\tvar _classes = __webpack_require__(11);\n\t\n\tvar _classes2 = _interopRequireDefault(_classes);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar id = 0;\n\t\n\tvar ShuffleItem = function () {\n\t  function ShuffleItem(element) {\n\t    _classCallCheck(this, ShuffleItem);\n\t\n\t    this.id = id++;\n\t    this.element = element;\n\t    this.isVisible = true;\n\t  }\n\t\n\t  _createClass(ShuffleItem, [{\n\t    key: 'show',\n\t    value: function show() {\n\t      this.isVisible = true;\n\t      this.element.classList.remove(_classes2.default.HIDDEN);\n\t      this.element.classList.add(_classes2.default.VISIBLE);\n\t    }\n\t  }, {\n\t    key: 'hide',\n\t    value: function hide() {\n\t      this.isVisible = false;\n\t      this.element.classList.remove(_classes2.default.VISIBLE);\n\t      this.element.classList.add(_classes2.default.HIDDEN);\n\t    }\n\t  }, {\n\t    key: 'init',\n\t    value: function init() {\n\t      this.addClasses([_classes2.default.SHUFFLE_ITEM, _classes2.default.VISIBLE]);\n\t      this.applyCss(ShuffleItem.Css.INITIAL);\n\t      this.scale = ShuffleItem.Scale.VISIBLE;\n\t      this.point = new _point2.default();\n\t    }\n\t  }, {\n\t    key: 'addClasses',\n\t    value: function addClasses(classes) {\n\t      var _this = this;\n\t\n\t      classes.forEach(function (className) {\n\t        _this.element.classList.add(className);\n\t      });\n\t    }\n\t  }, {\n\t    key: 'removeClasses',\n\t    value: function removeClasses(classes) {\n\t      var _this2 = this;\n\t\n\t      classes.forEach(function (className) {\n\t        _this2.element.classList.remove(className);\n\t      });\n\t    }\n\t  }, {\n\t    key: 'applyCss',\n\t    value: function applyCss(obj) {\n\t      for (var key in obj) {\n\t        this.element.style[key] = obj[key];\n\t      }\n\t    }\n\t  }, {\n\t    key: 'dispose',\n\t    value: function dispose() {\n\t      this.removeClasses([_classes2.default.HIDDEN, _classes2.default.VISIBLE, _classes2.default.SHUFFLE_ITEM]);\n\t\n\t      this.element.removeAttribute('style');\n\t      this.element = null;\n\t    }\n\t  }]);\n\t\n\t  return ShuffleItem;\n\t}();\n\t\n\tShuffleItem.Css = {\n\t  INITIAL: {\n\t    position: 'absolute',\n\t    top: 0,\n\t    left: 0,\n\t    visibility: 'visible',\n\t    'will-change': 'transform'\n\t  },\n\t  VISIBLE: {\n\t    before: {\n\t      opacity: 1,\n\t      visibility: 'visible'\n\t    },\n\t    after: {}\n\t  },\n\t  HIDDEN: {\n\t    before: {\n\t      opacity: 0\n\t    },\n\t    after: {\n\t      visibility: 'hidden'\n\t    }\n\t  }\n\t};\n\t\n\tShuffleItem.Scale = {\n\t  VISIBLE: 1,\n\t  HIDDEN: 0.001\n\t};\n\t\n\texports.default = ShuffleItem;\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = {\n\t  BASE: 'shuffle',\n\t  SHUFFLE_ITEM: 'shuffle-item',\n\t  VISIBLE: 'shuffle-item--visible',\n\t  HIDDEN: 'shuffle-item--hidden'\n\t};\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = getNumberStyle;\n\t\n\tvar _getNumber = __webpack_require__(9);\n\t\n\tvar _getNumber2 = _interopRequireDefault(_getNumber);\n\t\n\tvar _computedSize = __webpack_require__(13);\n\t\n\tvar _computedSize2 = _interopRequireDefault(_computedSize);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\n\t * Retrieve the computed style for an element, parsed as a float.\n\t * @param {Element} element Element to get style for.\n\t * @param {string} style Style property.\n\t * @param {CSSStyleDeclaration} [styles] Optionally include clean styles to\n\t *     use instead of asking for them again.\n\t * @return {number} The parsed computed value or zero if that fails because IE\n\t *     will return 'auto' when the element doesn't have margins instead of\n\t *     the computed style.\n\t */\n\tfunction getNumberStyle(element, style) {\n\t  var styles = arguments.length <= 2 || arguments[2] === undefined ? window.getComputedStyle(element, null) : arguments[2];\n\t\n\t  var value = (0, _getNumber2.default)(styles[style]);\n\t\n\t  // Support IE<=11 and W3C spec.\n\t  if (!_computedSize2.default && style === 'width') {\n\t    value += (0, _getNumber2.default)(styles.paddingLeft) + (0, _getNumber2.default)(styles.paddingRight) + (0, _getNumber2.default)(styles.borderLeftWidth) + (0, _getNumber2.default)(styles.borderRightWidth);\n\t  } else if (!_computedSize2.default && style === 'height') {\n\t    value += (0, _getNumber2.default)(styles.paddingTop) + (0, _getNumber2.default)(styles.paddingBottom) + (0, _getNumber2.default)(styles.borderTopWidth) + (0, _getNumber2.default)(styles.borderBottomWidth);\n\t  }\n\t\n\t  return value;\n\t}\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar element = document.body || document.documentElement;\n\tvar e = document.createElement('div');\n\te.style.cssText = 'width:10px;padding:2px;box-sizing:border-box;';\n\telement.appendChild(e);\n\t\n\tvar width = window.getComputedStyle(e, null).width;\n\tvar ret = width === '10px';\n\t\n\telement.removeChild(e);\n\t\n\texports.default = ret;\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = sorter;\n\t\n\tvar _xtend = __webpack_require__(5);\n\t\n\tvar _xtend2 = _interopRequireDefault(_xtend);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t// http://stackoverflow.com/a/962890/373422\n\tfunction randomize(array) {\n\t  var tmp;\n\t  var current;\n\t  var top = array.length;\n\t\n\t  if (!top) {\n\t    return array;\n\t  }\n\t\n\t  while (--top) {\n\t    current = Math.floor(Math.random() * (top + 1));\n\t    tmp = array[current];\n\t    array[current] = array[top];\n\t    array[top] = tmp;\n\t  }\n\t\n\t  return array;\n\t}\n\t\n\tvar defaults = {\n\t  // Use array.reverse() to reverse the results\n\t  reverse: false,\n\t\n\t  // Sorting function\n\t  by: null,\n\t\n\t  // If true, this will skip the sorting and return a randomized order in the array\n\t  randomize: false,\n\t\n\t  // Determines which property of each item in the array is passed to the\n\t  // sorting method.\n\t  key: 'element'\n\t};\n\t\n\t// You can return `undefined` from the `by` function to revert to DOM order.\n\tfunction sorter(arr, options) {\n\t  var opts = (0, _xtend2.default)(defaults, options);\n\t  var original = [].slice.call(arr);\n\t  var revert = false;\n\t\n\t  if (!arr.length) {\n\t    return [];\n\t  }\n\t\n\t  if (opts.randomize) {\n\t    return randomize(arr);\n\t  }\n\t\n\t  // Sort the elements by the opts.by function.\n\t  // If we don't have opts.by, default to DOM order\n\t  if (typeof opts.by === 'function') {\n\t    arr.sort(function (a, b) {\n\t\n\t      // Exit early if we already know we want to revert\n\t      if (revert) {\n\t        return 0;\n\t      }\n\t\n\t      var valA = opts.by(a[opts.key]);\n\t      var valB = opts.by(b[opts.key]);\n\t\n\t      // If both values are undefined, use the DOM order\n\t      if (valA === undefined && valB === undefined) {\n\t        revert = true;\n\t        return 0;\n\t      }\n\t\n\t      if (valA < valB || valA === 'sortFirst' || valB === 'sortLast') {\n\t        return -1;\n\t      }\n\t\n\t      if (valA > valB || valA === 'sortLast' || valB === 'sortFirst') {\n\t        return 1;\n\t      }\n\t\n\t      return 0;\n\t    });\n\t  }\n\t\n\t  // Revert to the original array if necessary\n\t  if (revert) {\n\t    return original;\n\t  }\n\t\n\t  if (opts.reverse) {\n\t    arr.reverse();\n\t  }\n\t\n\t  return arr;\n\t}\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.onTransitionEnd = onTransitionEnd;\n\texports.cancelTransitionEnd = cancelTransitionEnd;\n\tvar transitions = {};\n\tvar eventName = 'transitionend';\n\tvar count = 0;\n\t\n\tfunction uniqueId() {\n\t  return eventName + count++;\n\t}\n\t\n\tfunction onTransitionEnd(element, callback) {\n\t  var id = uniqueId();\n\t  var listener = function listener(evt) {\n\t    if (evt.currentTarget === evt.target) {\n\t      cancelTransitionEnd(id);\n\t      callback(evt);\n\t    }\n\t  };\n\t\n\t  element.addEventListener(eventName, listener);\n\t\n\t  transitions[id] = { element: element, listener: listener };\n\t\n\t  return id;\n\t}\n\t\n\tfunction cancelTransitionEnd(id) {\n\t  if (transitions[id]) {\n\t    transitions[id].element.removeEventListener(eventName, transitions[id].listener);\n\t    transitions[id] = null;\n\t    return true;\n\t  }\n\t\n\t  return false;\n\t}\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.getItemPosition = getItemPosition;\n\texports.getColumnSpan = getColumnSpan;\n\texports.getAvailablePositions = getAvailablePositions;\n\texports.getShortColumn = getShortColumn;\n\t\n\tvar _point = __webpack_require__(8);\n\t\n\tvar _point2 = _interopRequireDefault(_point);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction arrayMax(array) {\n\t  return Math.max.apply(Math, array);\n\t}\n\t\n\tfunction arrayMin(array) {\n\t  return Math.min.apply(Math, array);\n\t}\n\t\n\t/**\n\t * Determine the location of the next item, based on its size.\n\t * @param {Object} itemSize Object with width and height.\n\t * @param {Array.<number>} positions Positions of the other current items.\n\t * @param {number} gridSize The column width or row height.\n\t * @param {number} total The total number of columns or rows.\n\t * @param {number} threshold Buffer value for the column to fit.\n\t * @param {number} buffer Vertical buffer for the height of items.\n\t * @return {Point}\n\t */\n\tfunction getItemPosition(_ref) {\n\t  var itemSize = _ref.itemSize;\n\t  var positions = _ref.positions;\n\t  var gridSize = _ref.gridSize;\n\t  var total = _ref.total;\n\t  var threshold = _ref.threshold;\n\t  var buffer = _ref.buffer;\n\t\n\t  var span = getColumnSpan(itemSize.width, gridSize, total, threshold);\n\t  var setY = getAvailablePositions(positions, span, total);\n\t  var shortColumnIndex = getShortColumn(setY, buffer);\n\t\n\t  // Position the item\n\t  var point = new _point2.default(Math.round(gridSize * shortColumnIndex), Math.round(setY[shortColumnIndex]));\n\t\n\t  // Update the columns array with the new values for each column.\n\t  // e.g. before the update the columns could be [250, 0, 0, 0] for an item\n\t  // which spans 2 columns. After it would be [250, itemHeight, itemHeight, 0].\n\t  var setHeight = setY[shortColumnIndex] + itemSize.height;\n\t  for (var i = 0; i < span; i++) {\n\t    positions[shortColumnIndex + i] = setHeight;\n\t  }\n\t\n\t  return point;\n\t}\n\t\n\t/**\n\t * Determine the number of columns an items spans.\n\t * @param {number} itemWidth Width of the item.\n\t * @param {number} columnWidth Width of the column (includes gutter).\n\t * @param {number} columns Total number of columns\n\t * @param {number} threshold A buffer value for the size of the column to fit.\n\t * @return {number}\n\t */\n\tfunction getColumnSpan(itemWidth, columnWidth, columns, threshold) {\n\t  var columnSpan = itemWidth / columnWidth;\n\t\n\t  // If the difference between the rounded column span number and the\n\t  // calculated column span number is really small, round the number to\n\t  // make it fit.\n\t  if (Math.abs(Math.round(columnSpan) - columnSpan) < threshold) {\n\t    // e.g. columnSpan = 4.0089945390298745\n\t    columnSpan = Math.round(columnSpan);\n\t  }\n\t\n\t  // Ensure the column span is not more than the amount of columns in the whole layout.\n\t  return Math.min(Math.ceil(columnSpan), columns);\n\t}\n\t\n\t/**\n\t * Retrieves the column set to use for placement.\n\t * @param {number} columnSpan The number of columns this current item spans.\n\t * @param {number} columns The total columns in the grid.\n\t * @return {Array.<number>} An array of numbers represeting the column set.\n\t */\n\tfunction getAvailablePositions(positions, columnSpan, columns) {\n\t  // The item spans only one column.\n\t  if (columnSpan === 1) {\n\t    return positions;\n\t  }\n\t\n\t  // The item spans more than one column, figure out how many different\n\t  // places it could fit horizontally.\n\t  // The group count is the number of places within the positions this block\n\t  // could fit, ignoring the current positions of items.\n\t  // Imagine a 2 column brick as the second item in a 4 column grid with\n\t  // 10px height each. Find the places it would fit:\n\t  // [20, 10, 10, 0]\n\t  //  |   |   |\n\t  //  *   *   *\n\t  //\n\t  // Then take the places which fit and get the bigger of the two:\n\t  // max([20, 10]), max([10, 10]), max([10, 0]) = [20, 10, 0]\n\t  //\n\t  // Next, find the first smallest number (the short column).\n\t  // [20, 10, 0]\n\t  //          |\n\t  //          *\n\t  //\n\t  // And that's where it should be placed!\n\t  //\n\t  // Another example where the second column's item extends past the first:\n\t  // [10, 20, 10, 0] => [20, 20, 10] => 10\n\t  var available = [];\n\t\n\t  // For how many possible positions for this item there are.\n\t  for (var i = 0; i <= columns - columnSpan; i++) {\n\t    // Find the bigger value for each place it could fit.\n\t    available.push(arrayMax(positions.slice(i, i + columnSpan)));\n\t  }\n\t\n\t  return available;\n\t}\n\t\n\t/**\n\t * Find index of short column, the first from the left where this item will go.\n\t *\n\t * @param {Array.<number>} positions The array to search for the smallest number.\n\t * @param {number} buffer Optional buffer which is very useful when the height\n\t *     is a percentage of the width.\n\t * @return {number} Index of the short column.\n\t */\n\tfunction getShortColumn(positions, buffer) {\n\t  var minPosition = arrayMin(positions);\n\t  for (var i = 0, len = positions.length; i < len; i++) {\n\t    if (positions[i] >= minPosition - buffer && positions[i] <= minPosition + buffer) {\n\t      return i;\n\t    }\n\t  }\n\t\n\t  return 0;\n\t}\n\n/***/ }\n/******/ ])\n});\n;\n//# sourceMappingURL=shuffle.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTgwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9zaHVmZmxlanMvZGlzdC9zaHVmZmxlLmpzP2ZhYzYiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wic2h1ZmZsZVwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJzaHVmZmxlXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMSkuZGVmYXVsdDtcblxuLyoqKi8gfSxcbi8qIDEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRcblx0dmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblx0XG5cdF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cdFxuXHR2YXIgX21hdGNoZXNTZWxlY3RvciA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cdFxuXHR2YXIgX21hdGNoZXNTZWxlY3RvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXRjaGVzU2VsZWN0b3IpO1xuXHRcblx0dmFyIF9hcnJheVVuaXEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHRcblx0dmFyIF9hcnJheVVuaXEyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXJyYXlVbmlxKTtcblx0XG5cdHZhciBfeHRlbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHRcblx0dmFyIF94dGVuZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF94dGVuZCk7XG5cdFxuXHR2YXIgX3Rocm90dGxlaXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHRcblx0dmFyIF90aHJvdHRsZWl0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Rocm90dGxlaXQpO1xuXHRcblx0dmFyIF9hcnJheVBhcmFsbGVsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblx0XG5cdHZhciBfYXJyYXlQYXJhbGxlbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hcnJheVBhcmFsbGVsKTtcblx0XG5cdHZhciBfcG9pbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXHRcblx0dmFyIF9wb2ludDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb2ludCk7XG5cdFxuXHR2YXIgX3NodWZmbGVJdGVtID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cdFxuXHR2YXIgX3NodWZmbGVJdGVtMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NodWZmbGVJdGVtKTtcblx0XG5cdHZhciBfY2xhc3NlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXHRcblx0dmFyIF9jbGFzc2VzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzZXMpO1xuXHRcblx0dmFyIF9nZXROdW1iZXJTdHlsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuXHRcblx0dmFyIF9nZXROdW1iZXJTdHlsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXROdW1iZXJTdHlsZSk7XG5cdFxuXHR2YXIgX3NvcnRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXHRcblx0dmFyIF9zb3J0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc29ydGVyKTtcblx0XG5cdHZhciBfb25UcmFuc2l0aW9uRW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cdFxuXHR2YXIgX2xheW91dDIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcblx0XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cdFxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXHRcblx0ZnVuY3Rpb24gdG9BcnJheShhcnJheUxpa2UpIHtcblx0ICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyYXlMaWtlKTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gYXJyYXlNYXgoYXJyYXkpIHtcblx0ICByZXR1cm4gTWF0aC5tYXguYXBwbHkoTWF0aCwgYXJyYXkpO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBhcnJheUluY2x1ZGVzKGFycmF5LCBvYmopIHtcblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuXHQgICAgcmV0dXJuIGFycmF5SW5jbHVkZXMoYXJyYXkpKG9iaik7XG5cdCAgfVxuXHRcblx0ICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuXHQgICAgcmV0dXJuIGFycmF5LmluZGV4T2Yob2JqKSA+IC0xO1xuXHQgIH07XG5cdH1cblx0XG5cdC8vIFVzZWQgZm9yIHVuaXF1ZSBpbnN0YW5jZSB2YXJpYWJsZXNcblx0dmFyIGlkID0gMDtcblx0XG5cdHZhciBTaHVmZmxlID0gZnVuY3Rpb24gKCkge1xuXHRcblx0ICAvKipcblx0ICAgKiBDYXRlZ29yaXplLCBzb3J0LCBhbmQgZmlsdGVyIGEgcmVzcG9uc2l2ZSBncmlkIG9mIGl0ZW1zLlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IEFuIGVsZW1lbnQgd2hpY2ggaXMgdGhlIHBhcmVudCBjb250YWluZXIgZm9yIHRoZSBncmlkIGl0ZW1zLlxuXHQgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz1TaHVmZmxlLm9wdGlvbnNdIE9wdGlvbnMgb2JqZWN0LlxuXHQgICAqIEBjb25zdHJ1Y3RvclxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIFNodWZmbGUoZWxlbWVudCkge1xuXHQgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1sxXTtcblx0XG5cdCAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2h1ZmZsZSk7XG5cdFxuXHQgICAgdGhpcy5vcHRpb25zID0gKDAsIF94dGVuZDIuZGVmYXVsdCkoU2h1ZmZsZS5vcHRpb25zLCBvcHRpb25zKTtcblx0XG5cdCAgICB0aGlzLnVzZVNpemVyID0gZmFsc2U7XG5cdCAgICB0aGlzLmxhc3RTb3J0ID0ge307XG5cdCAgICB0aGlzLmdyb3VwID0gdGhpcy5sYXN0RmlsdGVyID0gU2h1ZmZsZS5BTExfSVRFTVM7XG5cdCAgICB0aGlzLmlzRW5hYmxlZCA9IHRydWU7XG5cdCAgICB0aGlzLmlzRGVzdHJveWVkID0gZmFsc2U7XG5cdCAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcblx0ICAgIHRoaXMuX3RyYW5zaXRpb25zID0gW107XG5cdCAgICB0aGlzLmlzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuXHQgICAgdGhpcy5fcXVldWUgPSBbXTtcblx0XG5cdCAgICBlbGVtZW50ID0gdGhpcy5fZ2V0RWxlbWVudE9wdGlvbihlbGVtZW50KTtcblx0XG5cdCAgICBpZiAoIWVsZW1lbnQpIHtcblx0ICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU2h1ZmZsZSBuZWVkcyB0byBiZSBpbml0aWFsaXplZCB3aXRoIGFuIGVsZW1lbnQuJyk7XG5cdCAgICB9XG5cdFxuXHQgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcblx0ICAgIHRoaXMuaWQgPSAnc2h1ZmZsZV8nICsgaWQrKztcblx0XG5cdCAgICB0aGlzLl9pbml0KCk7XG5cdCAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuXHQgIH1cblx0XG5cdCAgX2NyZWF0ZUNsYXNzKFNodWZmbGUsIFt7XG5cdCAgICBrZXk6ICdfaW5pdCcsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XG5cdCAgICAgIHRoaXMuaXRlbXMgPSB0aGlzLl9nZXRJdGVtcygpO1xuXHRcblx0ICAgICAgdGhpcy5vcHRpb25zLnNpemVyID0gdGhpcy5fZ2V0RWxlbWVudE9wdGlvbih0aGlzLm9wdGlvbnMuc2l6ZXIpO1xuXHRcblx0ICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaXplcikge1xuXHQgICAgICAgIHRoaXMudXNlU2l6ZXIgPSB0cnVlO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICAvLyBBZGQgY2xhc3MgYW5kIGludmFsaWRhdGUgc3R5bGVzXG5cdCAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKFNodWZmbGUuQ2xhc3Nlcy5CQVNFKTtcblx0XG5cdCAgICAgIC8vIFNldCBpbml0aWFsIGNzcyBmb3IgZWFjaCBpdGVtXG5cdCAgICAgIHRoaXMuX2luaXRJdGVtcygpO1xuXHRcblx0ICAgICAgLy8gQmluZCByZXNpemUgZXZlbnRzXG5cdCAgICAgIHRoaXMuX29uUmVzaXplID0gdGhpcy5fZ2V0UmVzaXplRnVuY3Rpb24oKTtcblx0ICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplKTtcblx0XG5cdCAgICAgIC8vIEdldCBjb250YWluZXIgY3NzIGFsbCBpbiBvbmUgcmVxdWVzdC4gQ2F1c2VzIHJlZmxvd1xuXHQgICAgICB2YXIgY29udGFpbmVyQ3NzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5lbGVtZW50LCBudWxsKTtcblx0ICAgICAgdmFyIGNvbnRhaW5lcldpZHRoID0gU2h1ZmZsZS5nZXRTaXplKHRoaXMuZWxlbWVudCkud2lkdGg7XG5cdFxuXHQgICAgICAvLyBBZGQgc3R5bGVzIHRvIHRoZSBjb250YWluZXIgaWYgaXQgZG9lc24ndCBoYXZlIHRoZW0uXG5cdCAgICAgIHRoaXMuX3ZhbGlkYXRlU3R5bGVzKGNvbnRhaW5lckNzcyk7XG5cdFxuXHQgICAgICAvLyBXZSBhbHJlYWR5IGdvdCB0aGUgY29udGFpbmVyJ3Mgd2lkdGggYWJvdmUsIG5vIG5lZWQgdG8gY2F1c2UgYW5vdGhlclxuXHQgICAgICAvLyByZWZsb3cgZ2V0dGluZyBpdCBhZ2Fpbi4uLiBDYWxjdWxhdGUgdGhlIG51bWJlciBvZiBjb2x1bW5zIHRoZXJlIHdpbGwgYmVcblx0ICAgICAgdGhpcy5fc2V0Q29sdW1ucyhjb250YWluZXJXaWR0aCk7XG5cdFxuXHQgICAgICAvLyBLaWNrIG9mZiFcblx0ICAgICAgdGhpcy5maWx0ZXIodGhpcy5vcHRpb25zLmdyb3VwLCB0aGlzLm9wdGlvbnMuaW5pdGlhbFNvcnQpO1xuXHRcblx0ICAgICAgLy8gVGhlIHNodWZmbGUgaXRlbXMgaGF2ZW4ndCBoYWQgdHJhbnNpdGlvbnMgc2V0IG9uIHRoZW0geWV0IHNvIHRoZSB1c2VyXG5cdCAgICAgIC8vIGRvZXNuJ3Qgc2VlIHRoZSBmaXJzdCBsYXlvdXQuIFNldCB0aGVtIG5vdyB0aGF0IHRoZSBmaXJzdCBsYXlvdXQgaXMgZG9uZS5cblx0ICAgICAgLy8gRmlyc3QsIGhvd2V2ZXIsIGEgc3luY2hyb25vdXMgbGF5b3V0IG11c3QgYmUgY2F1c2VkIGZvciB0aGUgcHJldmlvdXNcblx0ICAgICAgLy8gc3R5bGVzIHRvIGJlIGFwcGxpZWQgd2l0aG91dCB0cmFuc2l0aW9ucy5cblx0ICAgICAgdGhpcy5lbGVtZW50Lm9mZnNldFdpZHRoOyAvLyBqc2hpbnQgaWdub3JlOiBsaW5lXG5cdCAgICAgIHRoaXMuX3NldFRyYW5zaXRpb25zKCk7XG5cdCAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS50cmFuc2l0aW9uID0gJ2hlaWdodCAnICsgdGhpcy5vcHRpb25zLnNwZWVkICsgJ21zICcgKyB0aGlzLm9wdGlvbnMuZWFzaW5nO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogUmV0dXJucyBhIHRocm90dGxlZCBhbmQgcHJveGllZCBmdW5jdGlvbiBmb3IgdGhlIHJlc2l6ZSBoYW5kbGVyLlxuXHQgICAgICogQHJldHVybiB7RnVuY3Rpb259XG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICovXG5cdFxuXHQgIH0sIHtcblx0ICAgIGtleTogJ19nZXRSZXNpemVGdW5jdGlvbicsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFJlc2l6ZUZ1bmN0aW9uKCkge1xuXHQgICAgICB2YXIgcmVzaXplRnVuY3Rpb24gPSB0aGlzLl9oYW5kbGVSZXNpemUuYmluZCh0aGlzKTtcblx0ICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy50aHJvdHRsZSA/IHRoaXMub3B0aW9ucy50aHJvdHRsZShyZXNpemVGdW5jdGlvbiwgdGhpcy5vcHRpb25zLnRocm90dGxlVGltZSkgOiByZXNpemVGdW5jdGlvbjtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFJldHJpZXZlIGFuIGVsZW1lbnQgZnJvbSBhbiBvcHRpb24uXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ3xqUXVlcnl8RWxlbWVudH0gb3B0aW9uIFRoZSBvcHRpb24gdG8gY2hlY2suXG5cdCAgICAgKiBAcmV0dXJuIHs/RWxlbWVudH0gVGhlIHBsYWluIGVsZW1lbnQgb3IgbnVsbC5cblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKi9cblx0XG5cdCAgfSwge1xuXHQgICAga2V5OiAnX2dldEVsZW1lbnRPcHRpb24nLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRFbGVtZW50T3B0aW9uKG9wdGlvbikge1xuXHQgICAgICAvLyBJZiBjb2x1bW4gd2lkdGggaXMgYSBzdHJpbmcsIHRyZWF0IGlzIGFzIGEgc2VsZWN0b3IgYW5kIHNlYXJjaCBmb3IgdGhlXG5cdCAgICAgIC8vIHNpemVyIGVsZW1lbnQgd2l0aGluIHRoZSBvdXRlcm1vc3QgY29udGFpbmVyXG5cdCAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09PSAnc3RyaW5nJykge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihvcHRpb24pO1xuXHRcblx0ICAgICAgICAvLyBDaGVjayBmb3IgYW4gZWxlbWVudFxuXHQgICAgICB9IGVsc2UgaWYgKG9wdGlvbiAmJiBvcHRpb24ubm9kZVR5cGUgJiYgb3B0aW9uLm5vZGVUeXBlID09PSAxKSB7XG5cdCAgICAgICAgcmV0dXJuIG9wdGlvbjtcblx0XG5cdCAgICAgICAgLy8gQ2hlY2sgZm9yIGpRdWVyeSBvYmplY3Rcblx0ICAgICAgfSBlbHNlIGlmIChvcHRpb24gJiYgb3B0aW9uLmpxdWVyeSkge1xuXHQgICAgICAgIHJldHVybiBvcHRpb25bMF07XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogRW5zdXJlcyB0aGUgc2h1ZmZsZSBjb250YWluZXIgaGFzIHRoZSBjc3Mgc3R5bGVzIGl0IG5lZWRzIGFwcGxpZWQgdG8gaXQuXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVzIEtleSB2YWx1ZSBwYWlycyBmb3IgcG9zaXRpb24gYW5kIG92ZXJmbG93LlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqL1xuXHRcblx0ICB9LCB7XG5cdCAgICBrZXk6ICdfdmFsaWRhdGVTdHlsZXMnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIF92YWxpZGF0ZVN0eWxlcyhzdHlsZXMpIHtcblx0ICAgICAgLy8gUG9zaXRpb24gY2Fubm90IGJlIHN0YXRpYy5cblx0ICAgICAgaWYgKHN0eWxlcy5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcblx0ICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICAvLyBPdmVyZmxvdyBoYXMgdG8gYmUgaGlkZGVuLlxuXHQgICAgICBpZiAoc3R5bGVzLm92ZXJmbG93ICE9PSAnaGlkZGVuJykge1xuXHQgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBGaWx0ZXIgdGhlIGVsZW1lbnRzIGJ5IGEgY2F0ZWdvcnkuXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NhdGVnb3J5XSBDYXRlZ29yeSB0byBmaWx0ZXIgYnkuIElmIGl0J3MgZ2l2ZW4sIHRoZSBsYXN0XG5cdCAgICAgKiAgICAgY2F0ZWdvcnkgd2lsbCBiZSB1c2VkIHRvIGZpbHRlciB0aGUgaXRlbXMuXG5cdCAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29sbGVjdGlvbl0gT3B0aW9uYWxseSBmaWx0ZXIgYSBjb2xsZWN0aW9uLiBEZWZhdWx0cyB0b1xuXHQgICAgICogICAgIGFsbCB0aGUgaXRlbXMuXG5cdCAgICAgKiBAcmV0dXJuIHshe3Zpc2libGU6IEFycmF5LCBoaWRkZW46IEFycmF5fX1cblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKi9cblx0XG5cdCAgfSwge1xuXHQgICAga2V5OiAnX2ZpbHRlcicsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbHRlcigpIHtcblx0ICAgICAgdmFyIGNhdGVnb3J5ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gdGhpcy5sYXN0RmlsdGVyIDogYXJndW1lbnRzWzBdO1xuXHQgICAgICB2YXIgY29sbGVjdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHRoaXMuaXRlbXMgOiBhcmd1bWVudHNbMV07XG5cdFxuXHQgICAgICB2YXIgc2V0ID0gdGhpcy5fZ2V0RmlsdGVyZWRTZXRzKGNhdGVnb3J5LCBjb2xsZWN0aW9uKTtcblx0XG5cdCAgICAgIC8vIEluZGl2aWR1YWxseSBhZGQvcmVtb3ZlIGhpZGRlbi92aXNpYmxlIGNsYXNzZXNcblx0ICAgICAgdGhpcy5fdG9nZ2xlRmlsdGVyQ2xhc3NlcyhzZXQpO1xuXHRcblx0ICAgICAgLy8gU2F2ZSB0aGUgbGFzdCBmaWx0ZXIgaW4gY2FzZSBlbGVtZW50cyBhcmUgYXBwZW5kZWQuXG5cdCAgICAgIHRoaXMubGFzdEZpbHRlciA9IGNhdGVnb3J5O1xuXHRcblx0ICAgICAgLy8gVGhpcyBpcyBzYXZlZCBtYWlubHkgYmVjYXVzZSBwcm92aWRpbmcgYSBmaWx0ZXIgZnVuY3Rpb24gKGxpa2Ugc2VhcmNoaW5nKVxuXHQgICAgICAvLyB3aWxsIG92ZXJ3cml0ZSB0aGUgYGxhc3RGaWx0ZXJgIHByb3BlcnR5IGV2ZXJ5IHRpbWUgaXRzIGNhbGxlZC5cblx0ICAgICAgaWYgKHR5cGVvZiBjYXRlZ29yeSA9PT0gJ3N0cmluZycpIHtcblx0ICAgICAgICB0aGlzLmdyb3VwID0gY2F0ZWdvcnk7XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIHJldHVybiBzZXQ7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSB2aXNpYmxlIGFuZCBoaWRkZW4gZWxlbWVudHMuXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ3xGdW5jdGlvbn0gY2F0ZWdvcnkgQ2F0ZWdvcnkgb3IgZnVuY3Rpb24gdG8gZmlsdGVyIGJ5LlxuXHQgICAgICogQHBhcmFtIHtBcnJheS48RWxlbWVudD59IGl0ZW1zIEEgY29sbGVjdGlvbiBvZiBpdGVtcyB0byBmaWx0ZXIuXG5cdCAgICAgKiBAcmV0dXJuIHshe3Zpc2libGU6IEFycmF5LCBoaWRkZW46IEFycmF5fX1cblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKi9cblx0XG5cdCAgfSwge1xuXHQgICAga2V5OiAnX2dldEZpbHRlcmVkU2V0cycsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEZpbHRlcmVkU2V0cyhjYXRlZ29yeSwgaXRlbXMpIHtcblx0ICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0XG5cdCAgICAgIHZhciB2aXNpYmxlID0gW107XG5cdCAgICAgIHZhciBoaWRkZW4gPSBbXTtcblx0XG5cdCAgICAgIC8vIGNhdGVnb3J5ID09PSAnYWxsJywgYWRkIHZpc2libGUgY2xhc3MgdG8gZXZlcnl0aGluZ1xuXHQgICAgICBpZiAoY2F0ZWdvcnkgPT09IFNodWZmbGUuQUxMX0lURU1TKSB7XG5cdCAgICAgICAgdmlzaWJsZSA9IGl0ZW1zO1xuXHRcblx0ICAgICAgICAvLyBMb29wIHRocm91Z2ggZWFjaCBpdGVtIGFuZCB1c2UgcHJvdmlkZWQgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lXG5cdCAgICAgICAgLy8gd2hldGhlciB0byBoaWRlIGl0IG9yIG5vdC5cblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG5cdCAgICAgICAgICBpZiAoX3RoaXMuX2RvZXNQYXNzRmlsdGVyKGNhdGVnb3J5LCBpdGVtLmVsZW1lbnQpKSB7XG5cdCAgICAgICAgICAgIHZpc2libGUucHVzaChpdGVtKTtcblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIGhpZGRlbi5wdXNoKGl0ZW0pO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICByZXR1cm4ge1xuXHQgICAgICAgIHZpc2libGU6IHZpc2libGUsXG5cdCAgICAgICAgaGlkZGVuOiBoaWRkZW5cblx0ICAgICAgfTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFRlc3QgYW4gaXRlbSB0byBzZWUgaWYgaXQgcGFzc2VzIGEgY2F0ZWdvcnkuXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ3xGdW5jdGlvbn0gY2F0ZWdvcnkgQ2F0ZWdvcnkgb3IgZnVuY3Rpb24gdG8gZmlsdGVyIGJ5LlxuXHQgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IEFuIGVsZW1lbnQgdG8gdGVzdC5cblx0ICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgaXQgcGFzc2VzIHRoZSBjYXRlZ29yeS9maWx0ZXIuXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICovXG5cdFxuXHQgIH0sIHtcblx0ICAgIGtleTogJ19kb2VzUGFzc0ZpbHRlcicsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gX2RvZXNQYXNzRmlsdGVyKGNhdGVnb3J5LCBlbGVtZW50KSB7XG5cdFxuXHQgICAgICBpZiAodHlwZW9mIGNhdGVnb3J5ID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgcmV0dXJuIGNhdGVnb3J5LmNhbGwoZWxlbWVudCwgZWxlbWVudCwgdGhpcyk7XG5cdFxuXHQgICAgICAgIC8vIENoZWNrIGVhY2ggZWxlbWVudCdzIGRhdGEtZ3JvdXBzIGF0dHJpYnV0ZSBhZ2FpbnN0IHRoZSBnaXZlbiBjYXRlZ29yeS5cblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB2YXIgYXR0ciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLScgKyBTaHVmZmxlLkZJTFRFUl9BVFRSSUJVVEVfS0VZKTtcblx0ICAgICAgICB2YXIga2V5cyA9IHRoaXMub3B0aW9ucy5kZWxpbWV0ZXIgPyBhdHRyLnNwbGl0KHRoaXMub3B0aW9ucy5kZWxpbWV0ZXIpIDogSlNPTi5wYXJzZShhdHRyKTtcblx0XG5cdCAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2F0ZWdvcnkpKSB7XG5cdCAgICAgICAgICByZXR1cm4gY2F0ZWdvcnkuc29tZShhcnJheUluY2x1ZGVzKGtleXMpKTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIHJldHVybiBhcnJheUluY2x1ZGVzKGtleXMsIGNhdGVnb3J5KTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogVG9nZ2xlcyB0aGUgdmlzaWJsZSBhbmQgaGlkZGVuIGNsYXNzIG5hbWVzLlxuXHQgICAgICogQHBhcmFtIHt7dmlzaWJsZSwgaGlkZGVufX0gT2JqZWN0IHdpdGggdmlzaWJsZSBhbmQgaGlkZGVuIGFycmF5cy5cblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKi9cblx0XG5cdCAgfSwge1xuXHQgICAga2V5OiAnX3RvZ2dsZUZpbHRlckNsYXNzZXMnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIF90b2dnbGVGaWx0ZXJDbGFzc2VzKF9yZWYpIHtcblx0ICAgICAgdmFyIHZpc2libGUgPSBfcmVmLnZpc2libGU7XG5cdCAgICAgIHZhciBoaWRkZW4gPSBfcmVmLmhpZGRlbjtcblx0XG5cdCAgICAgIHZpc2libGUuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuXHQgICAgICAgIGl0ZW0uc2hvdygpO1xuXHQgICAgICB9KTtcblx0XG5cdCAgICAgIGhpZGRlbi5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG5cdCAgICAgICAgaXRlbS5oaWRlKCk7XG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogU2V0IHRoZSBpbml0aWFsIGNzcyBmb3IgZWFjaCBpdGVtXG5cdCAgICAgKiBAcGFyYW0ge0FycmF5LjxTaHVmZmxlSXRlbT59IFtpdGVtc10gT3B0aW9uYWxseSBzcGVjaWZpeSBhdCBzZXQgdG8gaW5pdGlhbGl6ZS5cblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKi9cblx0XG5cdCAgfSwge1xuXHQgICAga2V5OiAnX2luaXRJdGVtcycsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXRJdGVtcygpIHtcblx0ICAgICAgdmFyIGl0ZW1zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gdGhpcy5pdGVtcyA6IGFyZ3VtZW50c1swXTtcblx0XG5cdCAgICAgIGl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcblx0ICAgICAgICBpdGVtLmluaXQoKTtcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBSZW1vdmUgZWxlbWVudCByZWZlcmVuY2UgYW5kIHN0eWxlcy5cblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKi9cblx0XG5cdCAgfSwge1xuXHQgICAga2V5OiAnX2Rpc3Bvc2VJdGVtcycsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gX2Rpc3Bvc2VJdGVtcygpIHtcblx0ICAgICAgdmFyIGl0ZW1zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gdGhpcy5pdGVtcyA6IGFyZ3VtZW50c1swXTtcblx0XG5cdCAgICAgIGl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcblx0ICAgICAgICBpdGVtLmRpc3Bvc2UoKTtcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBVcGRhdGVzIHRoZSB2aXNpYmxlIGl0ZW0gY291bnQuXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICovXG5cdFxuXHQgIH0sIHtcblx0ICAgIGtleTogJ191cGRhdGVJdGVtQ291bnQnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVJdGVtQ291bnQoKSB7XG5cdCAgICAgIHRoaXMudmlzaWJsZUl0ZW1zID0gdGhpcy5fZ2V0RmlsdGVyZWRJdGVtcygpLmxlbmd0aDtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFNldHMgY3NzIHRyYW5zZm9ybSB0cmFuc2l0aW9uIG9uIGEgZ3JvdXAgb2YgZWxlbWVudHMuIFRoaXMgaXMgbm90IGV4ZWN1dGVkXG5cdCAgICAgKiBhdCB0aGUgc2FtZSB0aW1lIGFzIGBpdGVtLmluaXRgIHNvIHRoYXQgdHJhbnNpdGlvbnMgZG9uJ3Qgb2NjdXIgdXBvblxuXHQgICAgICogaW5pdGlhbGl6YXRpb24gb2YgU2h1ZmZsZS5cblx0ICAgICAqIEBwYXJhbSB7QXJyYXkuPFNodWZmbGVJdGVtPn0gaXRlbXMgU2h1ZmZsZSBpdGVtcyB0byBzZXQgdHJhbnNpdGlvbnMgb24uXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICovXG5cdFxuXHQgIH0sIHtcblx0ICAgIGtleTogJ19zZXRUcmFuc2l0aW9ucycsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFRyYW5zaXRpb25zKCkge1xuXHQgICAgICB2YXIgaXRlbXMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB0aGlzLml0ZW1zIDogYXJndW1lbnRzWzBdO1xuXHRcblx0ICAgICAgdmFyIHNwZWVkID0gdGhpcy5vcHRpb25zLnNwZWVkO1xuXHQgICAgICB2YXIgZWFzaW5nID0gdGhpcy5vcHRpb25zLmVhc2luZztcblx0XG5cdCAgICAgIHZhciBzdHI7XG5cdCAgICAgIGlmICh0aGlzLm9wdGlvbnMudXNlVHJhbnNmb3Jtcykge1xuXHQgICAgICAgIHN0ciA9ICd0cmFuc2Zvcm0gJyArIHNwZWVkICsgJ21zICcgKyBlYXNpbmcgKyAnLCBvcGFjaXR5ICcgKyBzcGVlZCArICdtcyAnICsgZWFzaW5nO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHN0ciA9ICd0b3AgJyArIHNwZWVkICsgJ21zICcgKyBlYXNpbmcgKyAnLCBsZWZ0ICcgKyBzcGVlZCArICdtcyAnICsgZWFzaW5nICsgJywgb3BhY2l0eSAnICsgc3BlZWQgKyAnbXMgJyArIGVhc2luZztcblx0ICAgICAgfVxuXHRcblx0ICAgICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuXHQgICAgICAgIGl0ZW0uZWxlbWVudC5zdHlsZS50cmFuc2l0aW9uID0gc3RyO1xuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdfZ2V0SXRlbXMnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRJdGVtcygpIHtcblx0ICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cdFxuXHQgICAgICByZXR1cm4gdG9BcnJheSh0aGlzLmVsZW1lbnQuY2hpbGRyZW4pLmZpbHRlcihmdW5jdGlvbiAoZWwpIHtcblx0ICAgICAgICByZXR1cm4gKDAsIF9tYXRjaGVzU2VsZWN0b3IyLmRlZmF1bHQpKGVsLCBfdGhpczIub3B0aW9ucy5pdGVtU2VsZWN0b3IpO1xuXHQgICAgICB9KS5tYXAoZnVuY3Rpb24gKGVsKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBfc2h1ZmZsZUl0ZW0yLmRlZmF1bHQoZWwpO1xuXHQgICAgICB9KTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFdoZW4gbmV3IGVsZW1lbnRzIGFyZSBhZGRlZCB0byB0aGUgc2h1ZmZsZSBjb250YWluZXIsIHVwZGF0ZSB0aGUgYXJyYXkgb2Zcblx0ICAgICAqIGl0ZW1zIGJlY2F1c2UgdGhhdCBpcyB0aGUgb3JkZXIgYF9sYXlvdXRgIGNhbGxzIHRoZW0uXG5cdCAgICAgKi9cblx0XG5cdCAgfSwge1xuXHQgICAga2V5OiAnX3VwZGF0ZUl0ZW1zT3JkZXInLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVJdGVtc09yZGVyKCkge1xuXHQgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmVsZW1lbnQuY2hpbGRyZW47XG5cdCAgICAgIHRoaXMuaXRlbXMgPSAoMCwgX3NvcnRlcjIuZGVmYXVsdCkodGhpcy5pdGVtcywge1xuXHQgICAgICAgIGJ5OiBmdW5jdGlvbiBieShlbGVtZW50KSB7XG5cdCAgICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChjaGlsZHJlbiwgZWxlbWVudCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdfZ2V0RmlsdGVyZWRJdGVtcycsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEZpbHRlcmVkSXRlbXMoKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLml0ZW1zLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuXHQgICAgICAgIHJldHVybiBpdGVtLmlzVmlzaWJsZTtcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnX2dldENvbmNlYWxlZEl0ZW1zJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q29uY2VhbGVkSXRlbXMoKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLml0ZW1zLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuXHQgICAgICAgIHJldHVybiAhaXRlbS5pc1Zpc2libGU7XG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogUmV0dXJucyB0aGUgY29sdW1uIHNpemUsIGJhc2VkIG9uIGNvbHVtbiB3aWR0aCBhbmQgc2l6ZXIgb3B0aW9ucy5cblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb250YWluZXJXaWR0aCBTaXplIG9mIHRoZSBwYXJlbnQgY29udGFpbmVyLlxuXHQgICAgICogQHBhcmFtIHtudW1iZXJ9IGd1dHRlclNpemUgU2l6ZSBvZiB0aGUgZ3V0dGVycy5cblx0ICAgICAqIEByZXR1cm4ge251bWJlcn1cblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKi9cblx0XG5cdCAgfSwge1xuXHQgICAga2V5OiAnX2dldENvbHVtblNpemUnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDb2x1bW5TaXplKGNvbnRhaW5lcldpZHRoLCBndXR0ZXJTaXplKSB7XG5cdCAgICAgIHZhciBzaXplO1xuXHRcblx0ICAgICAgLy8gSWYgdGhlIGNvbHVtbldpZHRoIHByb3BlcnR5IGlzIGEgZnVuY3Rpb24sIHRoZW4gdGhlIGdyaWQgaXMgZmx1aWRcblx0ICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuY29sdW1uV2lkdGggPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICBzaXplID0gdGhpcy5vcHRpb25zLmNvbHVtbldpZHRoKGNvbnRhaW5lcldpZHRoKTtcblx0XG5cdCAgICAgICAgLy8gY29sdW1uV2lkdGggb3B0aW9uIGlzbid0IGEgZnVuY3Rpb24sIGFyZSB0aGV5IHVzaW5nIGEgc2l6aW5nIGVsZW1lbnQ/XG5cdCAgICAgIH0gZWxzZSBpZiAodGhpcy51c2VTaXplcikge1xuXHQgICAgICAgIHNpemUgPSBTaHVmZmxlLmdldFNpemUodGhpcy5vcHRpb25zLnNpemVyKS53aWR0aDtcblx0XG5cdCAgICAgICAgLy8gaWYgbm90LCBob3cgYWJvdXQgdGhlIGV4cGxpY2l0bHkgc2V0IG9wdGlvbj9cblx0ICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuY29sdW1uV2lkdGgpIHtcblx0ICAgICAgICBzaXplID0gdGhpcy5vcHRpb25zLmNvbHVtbldpZHRoO1xuXHRcblx0ICAgICAgICAvLyBvciB1c2UgdGhlIHNpemUgb2YgdGhlIGZpcnN0IGl0ZW1cblx0ICAgICAgfSBlbHNlIGlmICh0aGlzLml0ZW1zLmxlbmd0aCA+IDApIHtcblx0ICAgICAgICBzaXplID0gU2h1ZmZsZS5nZXRTaXplKHRoaXMuaXRlbXNbMF0uZWxlbWVudCwgdHJ1ZSkud2lkdGg7XG5cdFxuXHQgICAgICAgIC8vIGlmIHRoZXJlJ3Mgbm8gaXRlbXMsIHVzZSBzaXplIG9mIGNvbnRhaW5lclxuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHNpemUgPSBjb250YWluZXJXaWR0aDtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgLy8gRG9uJ3QgbGV0IHRoZW0gc2V0IGEgY29sdW1uIHdpZHRoIG9mIHplcm8uXG5cdCAgICAgIGlmIChzaXplID09PSAwKSB7XG5cdCAgICAgICAgc2l6ZSA9IGNvbnRhaW5lcldpZHRoO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICByZXR1cm4gc2l6ZSArIGd1dHRlclNpemU7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBSZXR1cm5zIHRoZSBndXR0ZXIgc2l6ZSwgYmFzZWQgb24gZ3V0dGVyIHdpZHRoIGFuZCBzaXplciBvcHRpb25zLlxuXHQgICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbnRhaW5lcldpZHRoIFNpemUgb2YgdGhlIHBhcmVudCBjb250YWluZXIuXG5cdCAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICovXG5cdFxuXHQgIH0sIHtcblx0ICAgIGtleTogJ19nZXRHdXR0ZXJTaXplJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0R3V0dGVyU2l6ZShjb250YWluZXJXaWR0aCkge1xuXHQgICAgICB2YXIgc2l6ZTtcblx0ICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuZ3V0dGVyV2lkdGggPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICBzaXplID0gdGhpcy5vcHRpb25zLmd1dHRlcldpZHRoKGNvbnRhaW5lcldpZHRoKTtcblx0ICAgICAgfSBlbHNlIGlmICh0aGlzLnVzZVNpemVyKSB7XG5cdCAgICAgICAgc2l6ZSA9ICgwLCBfZ2V0TnVtYmVyU3R5bGUyLmRlZmF1bHQpKHRoaXMub3B0aW9ucy5zaXplciwgJ21hcmdpbkxlZnQnKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBzaXplID0gdGhpcy5vcHRpb25zLmd1dHRlcldpZHRoO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICByZXR1cm4gc2l6ZTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgdG8gYmUgdXNlZC4gR2V0cyBjc3MgaWYgdXNpbmcgc2l6ZXIgZWxlbWVudC5cblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29udGFpbmVyV2lkdGhdIE9wdGlvbmFsbHkgc3BlY2lmeSBhIGNvbnRhaW5lciB3aWR0aCBpZlxuXHQgICAgICogICAgaXQncyBhbHJlYWR5IGF2YWlsYWJsZS5cblx0ICAgICAqL1xuXHRcblx0ICB9LCB7XG5cdCAgICBrZXk6ICdfc2V0Q29sdW1ucycsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gX3NldENvbHVtbnMoKSB7XG5cdCAgICAgIHZhciBjb250YWluZXJXaWR0aCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IFNodWZmbGUuZ2V0U2l6ZSh0aGlzLmVsZW1lbnQpLndpZHRoIDogYXJndW1lbnRzWzBdO1xuXHRcblx0ICAgICAgdmFyIGd1dHRlciA9IHRoaXMuX2dldEd1dHRlclNpemUoY29udGFpbmVyV2lkdGgpO1xuXHQgICAgICB2YXIgY29sdW1uV2lkdGggPSB0aGlzLl9nZXRDb2x1bW5TaXplKGNvbnRhaW5lcldpZHRoLCBndXR0ZXIpO1xuXHQgICAgICB2YXIgY2FsY3VsYXRlZENvbHVtbnMgPSAoY29udGFpbmVyV2lkdGggKyBndXR0ZXIpIC8gY29sdW1uV2lkdGg7XG5cdFxuXHQgICAgICAvLyBXaWR0aHMgZ2l2ZW4gZnJvbSBnZXRTdHlsZXMgYXJlIG5vdCBwcmVjaXNlIGVub3VnaC4uLlxuXHQgICAgICBpZiAoTWF0aC5hYnMoTWF0aC5yb3VuZChjYWxjdWxhdGVkQ29sdW1ucykgLSBjYWxjdWxhdGVkQ29sdW1ucykgPCB0aGlzLm9wdGlvbnMuY29sdW1uVGhyZXNob2xkKSB7XG5cdCAgICAgICAgLy8gZS5nLiBjYWxjdWxhdGVkQ29sdW1ucyA9IDExLjk5ODg3NlxuXHQgICAgICAgIGNhbGN1bGF0ZWRDb2x1bW5zID0gTWF0aC5yb3VuZChjYWxjdWxhdGVkQ29sdW1ucyk7XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIHRoaXMuY29scyA9IE1hdGgubWF4KE1hdGguZmxvb3IoY2FsY3VsYXRlZENvbHVtbnMpLCAxKTtcblx0ICAgICAgdGhpcy5jb250YWluZXJXaWR0aCA9IGNvbnRhaW5lcldpZHRoO1xuXHQgICAgICB0aGlzLmNvbFdpZHRoID0gY29sdW1uV2lkdGg7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBBZGp1c3QgdGhlIGhlaWdodCBvZiB0aGUgZ3JpZFxuXHQgICAgICovXG5cdFxuXHQgIH0sIHtcblx0ICAgIGtleTogJ19zZXRDb250YWluZXJTaXplJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0Q29udGFpbmVyU2l6ZSgpIHtcblx0ICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmhlaWdodCA9IHRoaXMuX2dldENvbnRhaW5lclNpemUoKSArICdweCc7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBCYXNlZCBvbiB0aGUgY29sdW1uIGhlaWdodHMsIGl0IHJldHVybnMgdGhlIGJpZ2dlc3Qgb25lLlxuXHQgICAgICogQHJldHVybiB7bnVtYmVyfVxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqL1xuXHRcblx0ICB9LCB7XG5cdCAgICBrZXk6ICdfZ2V0Q29udGFpbmVyU2l6ZScsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gX2dldENvbnRhaW5lclNpemUoKSB7XG5cdCAgICAgIHJldHVybiBhcnJheU1heCh0aGlzLnBvc2l0aW9ucyk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBHZXQgdGhlIGNsYW1wZWQgc3RhZ2dlciBhbW91bnQuXG5cdCAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggb2YgdGhlIGl0ZW0gdG8gYmUgc3RhZ2dlcmVkLlxuXHQgICAgICogQHJldHVybiB7bnVtYmVyfVxuXHQgICAgICovXG5cdFxuXHQgIH0sIHtcblx0ICAgIGtleTogJ19nZXRTdGFnZ2VyQW1vdW50Jyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U3RhZ2dlckFtb3VudChpbmRleCkge1xuXHQgICAgICByZXR1cm4gTWF0aC5taW4oaW5kZXggKiB0aGlzLm9wdGlvbnMuc3RhZ2dlckFtb3VudCwgdGhpcy5vcHRpb25zLnN0YWdnZXJBbW91bnRNYXgpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgZXZlbnQgd2FzIHByZXZlbnRlZCBvciBub3QuXG5cdCAgICAgKi9cblx0XG5cdCAgfSwge1xuXHQgICAga2V5OiAnX2Rpc3BhdGNoJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBfZGlzcGF0Y2gobmFtZSkge1xuXHQgICAgICB2YXIgZGV0YWlscyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuXHRcblx0ICAgICAgaWYgKHRoaXMuaXNEZXN0cm95ZWQpIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIGRldGFpbHMuc2h1ZmZsZSA9IHRoaXM7XG5cdCAgICAgIHJldHVybiAhdGhpcy5lbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KG5hbWUsIHtcblx0ICAgICAgICBidWJibGVzOiB0cnVlLFxuXHQgICAgICAgIGNhbmNlbGFibGU6IGZhbHNlLFxuXHQgICAgICAgIGRldGFpbDogZGV0YWlsc1xuXHQgICAgICB9KSk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBaZXJvcyBvdXQgdGhlIHkgY29sdW1ucyBhcnJheSwgd2hpY2ggaXMgdXNlZCB0byBkZXRlcm1pbmUgaXRlbSBwbGFjZW1lbnQuXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICovXG5cdFxuXHQgIH0sIHtcblx0ICAgIGtleTogJ19yZXNldENvbHMnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXNldENvbHMoKSB7XG5cdCAgICAgIHZhciBpID0gdGhpcy5jb2xzO1xuXHQgICAgICB0aGlzLnBvc2l0aW9ucyA9IFtdO1xuXHQgICAgICB3aGlsZSAoaS0tKSB7XG5cdCAgICAgICAgdGhpcy5wb3NpdGlvbnMucHVzaCgwKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogTG9vcHMgdGhyb3VnaCBlYWNoIGl0ZW0gdGhhdCBzaG91bGQgYmUgc2hvd24gYW5kIGNhbGN1bGF0ZXMgdGhlIHgsIHkgcG9zaXRpb24uXG5cdCAgICAgKiBAcGFyYW0ge0FycmF5LjxTaHVmZmxlSXRlbT59IGl0ZW1zIEFycmF5IG9mIGl0ZW1zIHRoYXQgd2lsbCBiZSBzaG93bi9sYXllZFxuXHQgICAgICogICAgIG91dCBpbiBvcmRlciBpbiB0aGVpciBhcnJheS5cblx0ICAgICAqL1xuXHRcblx0ICB9LCB7XG5cdCAgICBrZXk6ICdfbGF5b3V0Jyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBfbGF5b3V0KGl0ZW1zKSB7XG5cdCAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXHRcblx0ICAgICAgdmFyIGNvdW50ID0gMDtcblx0ICAgICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuXHQgICAgICAgIHZhciBjdXJyUG9zID0gaXRlbS5wb2ludDtcblx0ICAgICAgICB2YXIgY3VyclNjYWxlID0gaXRlbS5zY2FsZTtcblx0ICAgICAgICB2YXIgaXRlbVNpemUgPSBTaHVmZmxlLmdldFNpemUoaXRlbS5lbGVtZW50LCB0cnVlKTtcblx0ICAgICAgICB2YXIgcG9zID0gX3RoaXMzLl9nZXRJdGVtUG9zaXRpb24oaXRlbVNpemUpO1xuXHRcblx0ICAgICAgICBmdW5jdGlvbiBjYWxsYmFjaygpIHtcblx0ICAgICAgICAgIGl0ZW0uZWxlbWVudC5zdHlsZS50cmFuc2l0aW9uRGVsYXkgPSAnJztcblx0ICAgICAgICAgIGl0ZW0uYXBwbHlDc3MoX3NodWZmbGVJdGVtMi5kZWZhdWx0LkNzcy5WSVNJQkxFLmFmdGVyKTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8vIElmIHRoZSBpdGVtIHdpbGwgbm90IGNoYW5nZSBpdHMgcG9zaXRpb24sIGRvIG5vdCBhZGQgaXQgdG8gdGhlIHJlbmRlclxuXHQgICAgICAgIC8vIHF1ZXVlLiBUcmFuc2l0aW9ucyBkb24ndCBmaXJlIHdoZW4gc2V0dGluZyBhIHByb3BlcnR5IHRvIHRoZSBzYW1lIHZhbHVlLlxuXHQgICAgICAgIGlmIChfcG9pbnQyLmRlZmF1bHQuZXF1YWxzKGN1cnJQb3MsIHBvcykgJiYgY3VyclNjYWxlID09PSBfc2h1ZmZsZUl0ZW0yLmRlZmF1bHQuU2NhbGUuVklTSUJMRSkge1xuXHQgICAgICAgICAgY2FsbGJhY2soKTtcblx0ICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIGl0ZW0ucG9pbnQgPSBwb3M7XG5cdCAgICAgICAgaXRlbS5zY2FsZSA9IF9zaHVmZmxlSXRlbTIuZGVmYXVsdC5TY2FsZS5WSVNJQkxFO1xuXHRcblx0ICAgICAgICAvLyBVc2UgeHRlbmQgaGVyZSB0byBjbG9uZSB0aGUgb2JqZWN0IHNvIHRoYXQgdGhlIGBiZWZvcmVgIG9iamVjdCBpc24ndFxuXHQgICAgICAgIC8vIG1vZGlmaWVkIHdoZW4gdGhlIHRyYW5zaXRpb24gZGVsYXkgaXMgYWRkZWQuXG5cdCAgICAgICAgdmFyIHN0eWxlcyA9ICgwLCBfeHRlbmQyLmRlZmF1bHQpKF9zaHVmZmxlSXRlbTIuZGVmYXVsdC5Dc3MuVklTSUJMRS5iZWZvcmUpO1xuXHQgICAgICAgIHN0eWxlcy50cmFuc2l0aW9uRGVsYXkgPSBfdGhpczMuX2dldFN0YWdnZXJBbW91bnQoY291bnQpICsgJ21zJztcblx0XG5cdCAgICAgICAgX3RoaXMzLl9xdWV1ZS5wdXNoKHtcblx0ICAgICAgICAgIGl0ZW06IGl0ZW0sXG5cdCAgICAgICAgICBzdHlsZXM6IHN0eWxlcyxcblx0ICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuXHQgICAgICAgIH0pO1xuXHRcblx0ICAgICAgICBjb3VudCsrO1xuXHQgICAgICB9KTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIERldGVybWluZSB0aGUgbG9jYXRpb24gb2YgdGhlIG5leHQgaXRlbSwgYmFzZWQgb24gaXRzIHNpemUuXG5cdCAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGl0ZW1TaXplIE9iamVjdCB3aXRoIHdpZHRoIGFuZCBoZWlnaHQuXG5cdCAgICAgKiBAcmV0dXJuIHtQb2ludH1cblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKi9cblx0XG5cdCAgfSwge1xuXHQgICAga2V5OiAnX2dldEl0ZW1Qb3NpdGlvbicsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEl0ZW1Qb3NpdGlvbihpdGVtU2l6ZSkge1xuXHQgICAgICByZXR1cm4gKDAsIF9sYXlvdXQyLmdldEl0ZW1Qb3NpdGlvbikoe1xuXHQgICAgICAgIGl0ZW1TaXplOiBpdGVtU2l6ZSxcblx0ICAgICAgICBwb3NpdGlvbnM6IHRoaXMucG9zaXRpb25zLFxuXHQgICAgICAgIGdyaWRTaXplOiB0aGlzLmNvbFdpZHRoLFxuXHQgICAgICAgIHRvdGFsOiB0aGlzLmNvbHMsXG5cdCAgICAgICAgdGhyZXNob2xkOiB0aGlzLm9wdGlvbnMuY29sdW1uVGhyZXNob2xkLFxuXHQgICAgICAgIGJ1ZmZlcjogdGhpcy5vcHRpb25zLmJ1ZmZlclxuXHQgICAgICB9KTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIEhpZGVzIHRoZSBlbGVtZW50cyB0aGF0IGRvbid0IG1hdGNoIG91ciBmaWx0ZXIuXG5cdCAgICAgKiBAcGFyYW0ge0FycmF5LjxTaHVmZmxlSXRlbT59IGNvbGxlY3Rpb24gQ29sbGVjdGlvbiB0byBzaHJpbmsuXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICovXG5cdFxuXHQgIH0sIHtcblx0ICAgIGtleTogJ19zaHJpbmsnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIF9zaHJpbmsoKSB7XG5cdCAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXHRcblx0ICAgICAgdmFyIGNvbGxlY3Rpb24gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB0aGlzLl9nZXRDb25jZWFsZWRJdGVtcygpIDogYXJndW1lbnRzWzBdO1xuXHRcblx0ICAgICAgdmFyIGNvdW50ID0gMDtcblx0ICAgICAgY29sbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG5cdCAgICAgICAgZnVuY3Rpb24gY2FsbGJhY2soKSB7XG5cdCAgICAgICAgICBpdGVtLmFwcGx5Q3NzKF9zaHVmZmxlSXRlbTIuZGVmYXVsdC5Dc3MuSElEREVOLmFmdGVyKTtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8vIENvbnRpbnVpbmcgd291bGQgYWRkIGEgdHJhbnNpdGlvbmVuZCBldmVudCBsaXN0ZW5lciB0byB0aGUgZWxlbWVudCwgYnV0XG5cdCAgICAgICAgLy8gdGhhdCBsaXN0ZW5lciB3b3VsZCBub3QgZXhlY3V0ZSBiZWNhdXNlIHRoZSB0cmFuc2Zvcm0gYW5kIG9wYWNpdHkgd291bGRcblx0ICAgICAgICAvLyBzdGF5IHRoZSBzYW1lLlxuXHQgICAgICAgIC8vIFRoZSBjYWxsYmFjayBpcyBleGVjdXRlZCBoZXJlIGJlY2F1c2UgaXQgaXMgbm90IGd1YXJhbnRlZWQgdG8gYmUgY2FsbGVkXG5cdCAgICAgICAgLy8gYWZ0ZXIgdGhlIHRyYW5zaXRpb25lbmQgZXZlbnQgYmVjYXVzZSB0aGUgdHJhbnNpdGlvbmVuZCBjb3VsZCBiZVxuXHQgICAgICAgIC8vIGNhbmNlbGVkIGlmIGFub3RoZXIgYW5pbWF0aW9uIHN0YXJ0cy5cblx0ICAgICAgICBpZiAoaXRlbS5zY2FsZSA9PT0gX3NodWZmbGVJdGVtMi5kZWZhdWx0LlNjYWxlLkhJRERFTikge1xuXHQgICAgICAgICAgY2FsbGJhY2soKTtcblx0ICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIGl0ZW0uc2NhbGUgPSBfc2h1ZmZsZUl0ZW0yLmRlZmF1bHQuU2NhbGUuSElEREVOO1xuXHRcblx0ICAgICAgICB2YXIgc3R5bGVzID0gKDAsIF94dGVuZDIuZGVmYXVsdCkoX3NodWZmbGVJdGVtMi5kZWZhdWx0LkNzcy5ISURERU4uYmVmb3JlKTtcblx0ICAgICAgICBzdHlsZXMudHJhbnNpdGlvbkRlbGF5ID0gX3RoaXM0Ll9nZXRTdGFnZ2VyQW1vdW50KGNvdW50KSArICdtcyc7XG5cdFxuXHQgICAgICAgIF90aGlzNC5fcXVldWUucHVzaCh7XG5cdCAgICAgICAgICBpdGVtOiBpdGVtLFxuXHQgICAgICAgICAgc3R5bGVzOiBzdHlsZXMsXG5cdCAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2tcblx0ICAgICAgICB9KTtcblx0XG5cdCAgICAgICAgY291bnQrKztcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBSZXNpemUgaGFuZGxlci5cblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKi9cblx0XG5cdCAgfSwge1xuXHQgICAga2V5OiAnX2hhbmRsZVJlc2l6ZScsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZVJlc2l6ZSgpIHtcblx0ICAgICAgLy8gSWYgc2h1ZmZsZSBpcyBkaXNhYmxlZCwgZGVzdHJveWVkLCBkb24ndCBkbyBhbnl0aGluZ1xuXHQgICAgICBpZiAoIXRoaXMuaXNFbmFibGVkIHx8IHRoaXMuaXNEZXN0cm95ZWQpIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIC8vIFdpbGwgbmVlZCB0byBjaGVjayBoZWlnaHQgaW4gdGhlIGZ1dHVyZSBpZiBpdCdzIGxheWVkIG91dCBob3Jpem9udGFseVxuXHQgICAgICB2YXIgY29udGFpbmVyV2lkdGggPSBTaHVmZmxlLmdldFNpemUodGhpcy5lbGVtZW50KS53aWR0aDtcblx0XG5cdCAgICAgIC8vIGNvbnRhaW5lcldpZHRoIGhhc24ndCBjaGFuZ2VkLCBkb24ndCBkbyBhbnl0aGluZ1xuXHQgICAgICBpZiAoY29udGFpbmVyV2lkdGggPT09IHRoaXMuY29udGFpbmVyV2lkdGgpIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIHRoaXMudXBkYXRlKCk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBSZXR1cm5zIHN0eWxlcyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGFuIGl0ZW0gZm9yIGEgdHJhbnNpdGlvbi5cblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVHJhbnNpdGlvbiBvcHRpb25zLlxuXHQgICAgICogQHJldHVybiB7IU9iamVjdH0gVHJhbnNmb3JtcyBmb3IgdHJhbnNpdGlvbnMsIGxlZnQvdG9wIGZvciBhbmltYXRlLlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqL1xuXHRcblx0ICB9LCB7XG5cdCAgICBrZXk6ICdfZ2V0U3R5bGVzRm9yVHJhbnNpdGlvbicsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFN0eWxlc0ZvclRyYW5zaXRpb24oX3JlZjIpIHtcblx0ICAgICAgdmFyIGl0ZW0gPSBfcmVmMi5pdGVtO1xuXHQgICAgICB2YXIgc3R5bGVzID0gX3JlZjIuc3R5bGVzO1xuXHRcblx0ICAgICAgaWYgKCFzdHlsZXMudHJhbnNpdGlvbkRlbGF5KSB7XG5cdCAgICAgICAgc3R5bGVzLnRyYW5zaXRpb25EZWxheSA9ICcwbXMnO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICB2YXIgeCA9IGl0ZW0ucG9pbnQueDtcblx0ICAgICAgdmFyIHkgPSBpdGVtLnBvaW50Lnk7XG5cdFxuXHQgICAgICBpZiAodGhpcy5vcHRpb25zLnVzZVRyYW5zZm9ybXMpIHtcblx0ICAgICAgICBzdHlsZXMudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgnICsgeCArICdweCwgJyArIHkgKyAncHgpIHNjYWxlKCcgKyBpdGVtLnNjYWxlICsgJyknO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHN0eWxlcy5sZWZ0ID0geCArICdweCc7XG5cdCAgICAgICAgc3R5bGVzLnRvcCA9IHkgKyAncHgnO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICByZXR1cm4gc3R5bGVzO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogTGlzdGVuIGZvciB0aGUgdHJhbnNpdGlvbiBlbmQgb24gYW4gZWxlbWVudCBhbmQgZXhlY3V0ZSB0aGUgaXRlbUNhbGxiYWNrXG5cdCAgICAgKiB3aGVuIGl0IGZpbmlzaGVzLlxuXHQgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gbGlzdGVuIG9uLlxuXHQgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlbUNhbGxiYWNrIENhbGxiYWNrIGZvciB0aGUgaXRlbS5cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmUgQ2FsbGJhY2sgdG8gbm90aWZ5IGBwYXJhbGxlbGAgdGhhdCB0aGlzIG9uZSBpcyBkb25lLlxuXHQgICAgICovXG5cdFxuXHQgIH0sIHtcblx0ICAgIGtleTogJ193aGVuVHJhbnNpdGlvbkRvbmUnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIF93aGVuVHJhbnNpdGlvbkRvbmUoZWxlbWVudCwgaXRlbUNhbGxiYWNrLCBkb25lKSB7XG5cdCAgICAgIHZhciBpZCA9ICgwLCBfb25UcmFuc2l0aW9uRW5kLm9uVHJhbnNpdGlvbkVuZCkoZWxlbWVudCwgZnVuY3Rpb24gKGV2dCkge1xuXHQgICAgICAgIGl0ZW1DYWxsYmFjaygpO1xuXHQgICAgICAgIGRvbmUobnVsbCwgZXZ0KTtcblx0ICAgICAgfSk7XG5cdFxuXHQgICAgICB0aGlzLl90cmFuc2l0aW9ucy5wdXNoKGlkKTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFJldHVybiBhIGZ1bmN0aW9uIHdoaWNoIHdpbGwgc2V0IENTUyBzdHlsZXMgYW5kIGNhbGwgdGhlIGBkb25lYCBmdW5jdGlvblxuXHQgICAgICogd2hlbiAoaWYpIHRoZSB0cmFuc2l0aW9uIGZpbmlzaGVzLlxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVHJhbnNpdGlvbiBvYmplY3QuXG5cdCAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2l0aCBhIGBkb25lYCBmdW5jdGlvbi5cblx0ICAgICAqL1xuXHRcblx0ICB9LCB7XG5cdCAgICBrZXk6ICdfZ2V0VHJhbnNpdGlvbkZ1bmN0aW9uJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VHJhbnNpdGlvbkZ1bmN0aW9uKG9wdHMpIHtcblx0ICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cdFxuXHQgICAgICByZXR1cm4gZnVuY3Rpb24gKGRvbmUpIHtcblx0ICAgICAgICBvcHRzLml0ZW0uYXBwbHlDc3MoX3RoaXM1Ll9nZXRTdHlsZXNGb3JUcmFuc2l0aW9uKG9wdHMpKTtcblx0ICAgICAgICBfdGhpczUuX3doZW5UcmFuc2l0aW9uRG9uZShvcHRzLml0ZW0uZWxlbWVudCwgb3B0cy5jYWxsYmFjaywgZG9uZSk7XG5cdCAgICAgIH07XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBFeGVjdXRlIHRoZSBzdHlsZXMgZ2F0aGVyZWQgaW4gdGhlIHN0eWxlIHF1ZXVlLiBUaGlzIGFwcGxpZXMgc3R5bGVzIHRvIGVsZW1lbnRzLFxuXHQgICAgICogdHJpZ2dlcmluZyB0cmFuc2l0aW9ucy5cblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKi9cblx0XG5cdCAgfSwge1xuXHQgICAga2V5OiAnX3Byb2Nlc3NRdWV1ZScsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gX3Byb2Nlc3NRdWV1ZSgpIHtcblx0ICAgICAgaWYgKHRoaXMuaXNUcmFuc2l0aW9uaW5nKSB7XG5cdCAgICAgICAgdGhpcy5fY2FuY2VsTW92ZW1lbnQoKTtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgdmFyIGhhc1NwZWVkID0gdGhpcy5vcHRpb25zLnNwZWVkID4gMDtcblx0ICAgICAgdmFyIGhhc1F1ZXVlID0gdGhpcy5fcXVldWUubGVuZ3RoID4gMDtcblx0XG5cdCAgICAgIGlmIChoYXNRdWV1ZSAmJiBoYXNTcGVlZCAmJiB0aGlzLmlzSW5pdGlhbGl6ZWQpIHtcblx0ICAgICAgICB0aGlzLl9zdGFydFRyYW5zaXRpb25zKHRoaXMuX3F1ZXVlKTtcblx0ICAgICAgfSBlbHNlIGlmIChoYXNRdWV1ZSkge1xuXHQgICAgICAgIHRoaXMuX3N0eWxlSW1tZWRpYXRlbHkodGhpcy5fcXVldWUpO1xuXHQgICAgICAgIHRoaXMuX2Rpc3BhdGNoTGF5b3V0KCk7XG5cdFxuXHQgICAgICAgIC8vIEEgY2FsbCB0byBsYXlvdXQgaGFwcGVuZWQsIGJ1dCBub25lIG9mIHRoZSBuZXdseSB2aXNpYmxlIGl0ZW1zIHdpbGxcblx0ICAgICAgICAvLyBjaGFuZ2UgcG9zaXRpb24gb3IgdGhlIHRyYW5zaXRpb24gZHVyYXRpb24gaXMgemVybywgd2hpY2ggd2lsbCBub3QgdHJpZ2dlclxuXHQgICAgICAgIC8vIHRoZSB0cmFuc2l0aW9uZW5kIGV2ZW50LlxuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHRoaXMuX2Rpc3BhdGNoTGF5b3V0KCk7XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIC8vIFJlbW92ZSBldmVyeXRoaW5nIGluIHRoZSBzdHlsZSBxdWV1ZVxuXHQgICAgICB0aGlzLl9xdWV1ZS5sZW5ndGggPSAwO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogV2FpdCBmb3IgZWFjaCB0cmFuc2l0aW9uIHRvIGZpbmlzaCwgdGhlIGVtaXQgdGhlIGxheW91dCBldmVudC5cblx0ICAgICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IHRyYW5zaXRpb25zIEFycmF5IG9mIHRyYW5zaXRpb24gb2JqZWN0cy5cblx0ICAgICAqL1xuXHRcblx0ICB9LCB7XG5cdCAgICBrZXk6ICdfc3RhcnRUcmFuc2l0aW9ucycsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gX3N0YXJ0VHJhbnNpdGlvbnModHJhbnNpdGlvbnMpIHtcblx0ICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cdFxuXHQgICAgICAvLyBTZXQgZmxhZyB0aGF0IHNodWZmbGUgaXMgY3VycmVudGx5IGluIG1vdGlvbi5cblx0ICAgICAgdGhpcy5pc1RyYW5zaXRpb25pbmcgPSB0cnVlO1xuXHRcblx0ICAgICAgLy8gQ3JlYXRlIGFuIGFycmF5IG9mIGZ1bmN0aW9ucyB0byBiZSBjYWxsZWQuXG5cdCAgICAgIHZhciBjYWxsYmFja3MgPSB0cmFuc2l0aW9ucy5tYXAoZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICAgIHJldHVybiBfdGhpczYuX2dldFRyYW5zaXRpb25GdW5jdGlvbihvYmopO1xuXHQgICAgICB9KTtcblx0XG5cdCAgICAgICgwLCBfYXJyYXlQYXJhbGxlbDIuZGVmYXVsdCkoY2FsbGJhY2tzLCB0aGlzLl9tb3ZlbWVudEZpbmlzaGVkLmJpbmQodGhpcykpO1xuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ19jYW5jZWxNb3ZlbWVudCcsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbmNlbE1vdmVtZW50KCkge1xuXHQgICAgICAvLyBSZW1vdmUgdGhlIHRyYW5zaXRpb24gZW5kIGV2ZW50IGZvciBlYWNoIGxpc3RlbmVyLlxuXHQgICAgICB0aGlzLl90cmFuc2l0aW9ucy5mb3JFYWNoKF9vblRyYW5zaXRpb25FbmQuY2FuY2VsVHJhbnNpdGlvbkVuZCk7XG5cdFxuXHQgICAgICAvLyBSZXNldCB0aGUgYXJyYXkuXG5cdCAgICAgIHRoaXMuX3RyYW5zaXRpb25zLmxlbmd0aCA9IDA7XG5cdFxuXHQgICAgICAvLyBTaG93IGl0J3Mgbm8gbG9uZ2VyIGFjdGl2ZS5cblx0ICAgICAgdGhpcy5pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIEFwcGx5IHN0eWxlcyB3aXRob3V0IGEgdHJhbnNpdGlvbi5cblx0ICAgICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IG9iamVjdHMgQXJyYXkgb2YgdHJhbnNpdGlvbiBvYmplY3RzLlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqL1xuXHRcblx0ICB9LCB7XG5cdCAgICBrZXk6ICdfc3R5bGVJbW1lZGlhdGVseScsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gX3N0eWxlSW1tZWRpYXRlbHkob2JqZWN0cykge1xuXHQgICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblx0XG5cdCAgICAgIGlmIChvYmplY3RzLmxlbmd0aCkge1xuXHQgICAgICAgIHZhciBlbGVtZW50cyA9IG9iamVjdHMubWFwKGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgICAgIHJldHVybiBvYmouaXRlbS5lbGVtZW50O1xuXHQgICAgICAgIH0pO1xuXHRcblx0ICAgICAgICBTaHVmZmxlLl9za2lwVHJhbnNpdGlvbnMoZWxlbWVudHMsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgIG9iamVjdHMuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG5cdCAgICAgICAgICAgIG9iai5pdGVtLmFwcGx5Q3NzKF90aGlzNy5fZ2V0U3R5bGVzRm9yVHJhbnNpdGlvbihvYmopKTtcblx0ICAgICAgICAgICAgb2JqLmNhbGxiYWNrKCk7XG5cdCAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ19tb3ZlbWVudEZpbmlzaGVkJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBfbW92ZW1lbnRGaW5pc2hlZCgpIHtcblx0ICAgICAgdGhpcy5fdHJhbnNpdGlvbnMubGVuZ3RoID0gMDtcblx0ICAgICAgdGhpcy5pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcblx0ICAgICAgdGhpcy5fZGlzcGF0Y2hMYXlvdXQoKTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdfZGlzcGF0Y2hMYXlvdXQnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIF9kaXNwYXRjaExheW91dCgpIHtcblx0ICAgICAgdGhpcy5fZGlzcGF0Y2goU2h1ZmZsZS5FdmVudFR5cGUuTEFZT1VUKTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFRoZSBtYWdpYy4gVGhpcyBpcyB3aGF0IG1ha2VzIHRoZSBwbHVnaW4gJ3NodWZmbGUnXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ3xGdW5jdGlvbnxBcnJheS48c3RyaW5nPn0gW2NhdGVnb3J5XSBDYXRlZ29yeSB0byBmaWx0ZXIgYnkuXG5cdCAgICAgKiAgICAgQ2FuIGJlIGEgZnVuY3Rpb24sIHN0cmluZywgb3IgYXJyYXkgb2Ygc3RyaW5ncy5cblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc29ydE9ial0gQSBzb3J0IG9iamVjdCB3aGljaCBjYW4gc29ydCB0aGUgdmlzaWJsZSBzZXRcblx0ICAgICAqL1xuXHRcblx0ICB9LCB7XG5cdCAgICBrZXk6ICdmaWx0ZXInLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGZpbHRlcihjYXRlZ29yeSwgc29ydE9iaikge1xuXHQgICAgICBpZiAoIXRoaXMuaXNFbmFibGVkKSB7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICBpZiAoIWNhdGVnb3J5IHx8IGNhdGVnb3J5ICYmIGNhdGVnb3J5Lmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgIGNhdGVnb3J5ID0gU2h1ZmZsZS5BTExfSVRFTVM7XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIHRoaXMuX2ZpbHRlcihjYXRlZ29yeSk7XG5cdFxuXHQgICAgICAvLyBTaHJpbmsgZWFjaCBoaWRkZW4gaXRlbVxuXHQgICAgICB0aGlzLl9zaHJpbmsoKTtcblx0XG5cdCAgICAgIC8vIEhvdyBtYW55IHZpc2libGUgZWxlbWVudHM/XG5cdCAgICAgIHRoaXMuX3VwZGF0ZUl0ZW1Db3VudCgpO1xuXHRcblx0ICAgICAgLy8gVXBkYXRlIHRyYW5zZm9ybXMgb24gdmlzaWJsZSBlbGVtZW50cyBzbyB0aGV5IHdpbGwgYW5pbWF0ZSB0byB0aGVpciBuZXcgcG9zaXRpb25zLlxuXHQgICAgICB0aGlzLnNvcnQoc29ydE9iaik7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBHZXRzIHRoZSB2aXNpYmxlIGVsZW1lbnRzLCBzb3J0cyB0aGVtLCBhbmQgcGFzc2VzIHRoZW0gdG8gbGF5b3V0LlxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgdGhlIG9wdGlvbnMgb2JqZWN0IGZvciB0aGUgc29ydGVkIHBsdWdpblxuXHQgICAgICovXG5cdFxuXHQgIH0sIHtcblx0ICAgIGtleTogJ3NvcnQnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHNvcnQoKSB7XG5cdCAgICAgIHZhciBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gdGhpcy5sYXN0U29ydCA6IGFyZ3VtZW50c1swXTtcblx0XG5cdCAgICAgIGlmICghdGhpcy5pc0VuYWJsZWQpIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIHRoaXMuX3Jlc2V0Q29scygpO1xuXHRcblx0ICAgICAgdmFyIGl0ZW1zID0gdGhpcy5fZ2V0RmlsdGVyZWRJdGVtcygpO1xuXHQgICAgICBpdGVtcyA9ICgwLCBfc29ydGVyMi5kZWZhdWx0KShpdGVtcywgb3B0cyk7XG5cdFxuXHQgICAgICB0aGlzLl9sYXlvdXQoaXRlbXMpO1xuXHRcblx0ICAgICAgLy8gYF9sYXlvdXRgIGFsd2F5cyBoYXBwZW5zIGFmdGVyIGBfc2hyaW5rYCwgc28gaXQncyBzYWZlIHRvIHByb2Nlc3MgdGhlIHN0eWxlXG5cdCAgICAgIC8vIHF1ZXVlIGhlcmUgd2l0aCBzdHlsZXMgZnJvbSB0aGUgc2hyaW5rIG1ldGhvZC5cblx0ICAgICAgdGhpcy5fcHJvY2Vzc1F1ZXVlKCk7XG5cdFxuXHQgICAgICAvLyBBZGp1c3QgdGhlIGhlaWdodCBvZiB0aGUgY29udGFpbmVyLlxuXHQgICAgICB0aGlzLl9zZXRDb250YWluZXJTaXplKCk7XG5cdFxuXHQgICAgICB0aGlzLmxhc3RTb3J0ID0gb3B0cztcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFJlcG9zaXRpb24gZXZlcnl0aGluZy5cblx0ICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNPbmx5TGF5b3V0IElmIHRydWUsIGNvbHVtbiBhbmQgZ3V0dGVyIHdpZHRocyB3b24ndCBiZVxuXHQgICAgICogICAgIHJlY2FsY3VsYXRlZC5cblx0ICAgICAqL1xuXHRcblx0ICB9LCB7XG5cdCAgICBrZXk6ICd1cGRhdGUnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShpc09ubHlMYXlvdXQpIHtcblx0ICAgICAgaWYgKHRoaXMuaXNFbmFibGVkKSB7XG5cdFxuXHQgICAgICAgIGlmICghaXNPbmx5TGF5b3V0KSB7XG5cdCAgICAgICAgICAvLyBHZXQgdXBkYXRlZCBjb2xDb3VudFxuXHQgICAgICAgICAgdGhpcy5fc2V0Q29sdW1ucygpO1xuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgLy8gTGF5b3V0IGl0ZW1zXG5cdCAgICAgICAgdGhpcy5zb3J0KCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIFVzZSB0aGlzIGluc3RlYWQgb2YgYHVwZGF0ZSgpYCBpZiB5b3UgZG9uJ3QgbmVlZCB0aGUgY29sdW1ucyBhbmQgZ3V0dGVycyB1cGRhdGVkXG5cdCAgICAgKiBNYXliZSBhbiBpbWFnZSBpbnNpZGUgYHNodWZmbGVgIGxvYWRlZCAoYW5kIG5vdyBoYXMgYSBoZWlnaHQpLCB3aGljaCBtZWFucyBjYWxjdWxhdGlvbnNcblx0ICAgICAqIGNvdWxkIGJlIG9mZi5cblx0ICAgICAqL1xuXHRcblx0ICB9LCB7XG5cdCAgICBrZXk6ICdsYXlvdXQnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGxheW91dCgpIHtcblx0ICAgICAgdGhpcy51cGRhdGUodHJ1ZSk7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBOZXcgaXRlbXMgaGF2ZSBiZWVuIGFwcGVuZGVkIHRvIHNodWZmbGUuIE1peCB0aGVtIGluIHdpdGggdGhlIGN1cnJlbnRcblx0ICAgICAqIGZpbHRlciBvciBzb3J0IHN0YXR1cy5cblx0ICAgICAqIEBwYXJhbSB7QXJyYXkuPEVsZW1lbnQ+fSBuZXdJdGVtcyBDb2xsZWN0aW9uIG9mIG5ldyBpdGVtcy5cblx0ICAgICAqL1xuXHRcblx0ICB9LCB7XG5cdCAgICBrZXk6ICdhZGQnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChuZXdJdGVtcykge1xuXHQgICAgICBuZXdJdGVtcyA9ICgwLCBfYXJyYXlVbmlxMi5kZWZhdWx0KShuZXdJdGVtcykubWFwKGZ1bmN0aW9uIChlbCkge1xuXHQgICAgICAgIHJldHVybiBuZXcgX3NodWZmbGVJdGVtMi5kZWZhdWx0KGVsKTtcblx0ICAgICAgfSk7XG5cdFxuXHQgICAgICAvLyBBZGQgY2xhc3NlcyBhbmQgc2V0IGluaXRpYWwgcG9zaXRpb25zLlxuXHQgICAgICB0aGlzLl9pbml0SXRlbXMobmV3SXRlbXMpO1xuXHRcblx0ICAgICAgLy8gQWRkIHRyYW5zaXRpb24gdG8gZWFjaCBpdGVtLlxuXHQgICAgICB0aGlzLl9zZXRUcmFuc2l0aW9ucyhuZXdJdGVtcyk7XG5cdFxuXHQgICAgICAvLyBVcGRhdGUgdGhlIGxpc3Qgb2YgaXRlbXMuXG5cdCAgICAgIHRoaXMuaXRlbXMgPSB0aGlzLml0ZW1zLmNvbmNhdChuZXdJdGVtcyk7XG5cdCAgICAgIHRoaXMuX3VwZGF0ZUl0ZW1zT3JkZXIoKTtcblx0ICAgICAgdGhpcy5maWx0ZXIodGhpcy5sYXN0RmlsdGVyKTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIERpc2FibGVzIHNodWZmbGUgZnJvbSB1cGRhdGluZyBkaW1lbnNpb25zIGFuZCBsYXlvdXQgb24gcmVzaXplXG5cdCAgICAgKi9cblx0XG5cdCAgfSwge1xuXHQgICAga2V5OiAnZGlzYWJsZScsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZSgpIHtcblx0ICAgICAgdGhpcy5pc0VuYWJsZWQgPSBmYWxzZTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIEVuYWJsZXMgc2h1ZmZsZSBhZ2FpblxuXHQgICAgICogQHBhcmFtIHtib29sZWFufSBbaXNVcGRhdGVMYXlvdXQ9dHJ1ZV0gaWYgdW5kZWZpbmVkLCBzaHVmZmxlIHdpbGwgdXBkYXRlIGNvbHVtbnMgYW5kIGd1dHRlcnNcblx0ICAgICAqL1xuXHRcblx0ICB9LCB7XG5cdCAgICBrZXk6ICdlbmFibGUnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZShpc1VwZGF0ZUxheW91dCkge1xuXHQgICAgICB0aGlzLmlzRW5hYmxlZCA9IHRydWU7XG5cdCAgICAgIGlmIChpc1VwZGF0ZUxheW91dCAhPT0gZmFsc2UpIHtcblx0ICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBSZW1vdmUgMSBvciBtb3JlIHNodWZmbGUgaXRlbXNcblx0ICAgICAqIEBwYXJhbSB7QXJyYXkuPEVsZW1lbnQ+fSBjb2xsZWN0aW9uIEFuIGFycmF5IGNvbnRhaW5pbmcgb25lIG9yIG1vcmVcblx0ICAgICAqICAgICBlbGVtZW50cyBpbiBzaHVmZmxlXG5cdCAgICAgKiBAcmV0dXJuIHtTaHVmZmxlfSBUaGUgc2h1ZmZsZSBvYmplY3Rcblx0ICAgICAqL1xuXHRcblx0ICB9LCB7XG5cdCAgICBrZXk6ICdyZW1vdmUnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZShjb2xsZWN0aW9uKSB7XG5cdCAgICAgIHZhciBfdGhpczggPSB0aGlzO1xuXHRcblx0ICAgICAgaWYgKCFjb2xsZWN0aW9uLmxlbmd0aCkge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgY29sbGVjdGlvbiA9ICgwLCBfYXJyYXlVbmlxMi5kZWZhdWx0KShjb2xsZWN0aW9uKTtcblx0XG5cdCAgICAgIHZhciBvbGRJdGVtcyA9IGNvbGxlY3Rpb24ubWFwKGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzOC5nZXRJdGVtQnlFbGVtZW50KGVsZW1lbnQpO1xuXHQgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcblx0ICAgICAgICByZXR1cm4gISFpdGVtO1xuXHQgICAgICB9KTtcblx0XG5cdCAgICAgIHZhciBoYW5kbGVMYXlvdXQgPSBmdW5jdGlvbiBoYW5kbGVMYXlvdXQoKSB7XG5cdCAgICAgICAgX3RoaXM4LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihTaHVmZmxlLkV2ZW50VHlwZS5MQVlPVVQsIGhhbmRsZUxheW91dCk7XG5cdCAgICAgICAgX3RoaXM4Ll9kaXNwb3NlSXRlbXMob2xkSXRlbXMpO1xuXHRcblx0ICAgICAgICAvLyBSZW1vdmUgdGhlIGNvbGxlY3Rpb24gaW4gdGhlIGNhbGxiYWNrXG5cdCAgICAgICAgY29sbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cdCAgICAgICAgICBlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG5cdCAgICAgICAgfSk7XG5cdFxuXHQgICAgICAgIF90aGlzOC5fZGlzcGF0Y2goU2h1ZmZsZS5FdmVudFR5cGUuUkVNT1ZFRCwgeyBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uIH0pO1xuXHRcblx0ICAgICAgICAvLyBMZXQgaXQgZ2V0IGdhcmJhZ2UgY29sbGVjdGVkXG5cdCAgICAgICAgY29sbGVjdGlvbiA9IG51bGw7XG5cdCAgICAgICAgb2xkSXRlbXMgPSBudWxsO1xuXHQgICAgICB9O1xuXHRcblx0ICAgICAgLy8gSGlkZSBjb2xsZWN0aW9uIGZpcnN0LlxuXHQgICAgICB0aGlzLl90b2dnbGVGaWx0ZXJDbGFzc2VzKHtcblx0ICAgICAgICB2aXNpYmxlOiBbXSxcblx0ICAgICAgICBoaWRkZW46IG9sZEl0ZW1zXG5cdCAgICAgIH0pO1xuXHRcblx0ICAgICAgdGhpcy5fc2hyaW5rKG9sZEl0ZW1zKTtcblx0XG5cdCAgICAgIHRoaXMuc29ydCgpO1xuXHRcblx0ICAgICAgLy8gVXBkYXRlIHRoZSBsaXN0IG9mIGl0ZW1zIGhlcmUgYmVjYXVzZSBgcmVtb3ZlYCBjb3VsZCBiZSBjYWxsZWQgYWdhaW5cblx0ICAgICAgLy8gd2l0aCBhbiBpdGVtIHRoYXQgaXMgaW4gdGhlIHByb2Nlc3Mgb2YgYmVpbmcgcmVtb3ZlZC5cblx0ICAgICAgdGhpcy5pdGVtcyA9IHRoaXMuaXRlbXMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG5cdCAgICAgICAgcmV0dXJuICFhcnJheUluY2x1ZGVzKG9sZEl0ZW1zLCBpdGVtKTtcblx0ICAgICAgfSk7XG5cdCAgICAgIHRoaXMuX3VwZGF0ZUl0ZW1Db3VudCgpO1xuXHRcblx0ICAgICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoU2h1ZmZsZS5FdmVudFR5cGUuTEFZT1VULCBoYW5kbGVMYXlvdXQpO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogUmV0cmlldmUgYSBzaHVmZmxlIGl0ZW0gYnkgaXRzIGVsZW1lbnQuXG5cdCAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBsb29rIGZvci5cblx0ICAgICAqIEByZXR1cm4gez9TaHVmZmxlSXRlbX0gQSBzaHVmZmxlIGl0ZW0gb3IgbnVsbCBpZiBpdCdzIG5vdCBmb3VuZC5cblx0ICAgICAqL1xuXHRcblx0ICB9LCB7XG5cdCAgICBrZXk6ICdnZXRJdGVtQnlFbGVtZW50Jyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJdGVtQnlFbGVtZW50KGVsZW1lbnQpIHtcblx0ICAgICAgZm9yICh2YXIgaSA9IHRoaXMuaXRlbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgICBpZiAodGhpcy5pdGVtc1tpXS5lbGVtZW50ID09PSBlbGVtZW50KSB7XG5cdCAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtc1tpXTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfVxuXHRcblx0ICAgIC8qKlxuXHQgICAgICogRGVzdHJveXMgc2h1ZmZsZSwgcmVtb3ZlcyBldmVudHMsIHN0eWxlcywgYW5kIGNsYXNzZXNcblx0ICAgICAqL1xuXHRcblx0ICB9LCB7XG5cdCAgICBrZXk6ICdkZXN0cm95Jyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuXHQgICAgICB0aGlzLl9jYW5jZWxNb3ZlbWVudCgpO1xuXHQgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fb25SZXNpemUpO1xuXHRcblx0ICAgICAgLy8gUmVzZXQgY29udGFpbmVyIHN0eWxlc1xuXHQgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnc2h1ZmZsZScpO1xuXHQgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuXHRcblx0ICAgICAgLy8gUmVzZXQgaW5kaXZpZHVhbCBpdGVtIHN0eWxlc1xuXHQgICAgICB0aGlzLl9kaXNwb3NlSXRlbXMoKTtcblx0XG5cdCAgICAgIC8vIE51bGwgRE9NIHJlZmVyZW5jZXNcblx0ICAgICAgdGhpcy5pdGVtcyA9IG51bGw7XG5cdCAgICAgIHRoaXMub3B0aW9ucy5zaXplciA9IG51bGw7XG5cdCAgICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG5cdCAgICAgIHRoaXMuX3RyYW5zaXRpb25zID0gbnVsbDtcblx0XG5cdCAgICAgIC8vIFNldCBhIGZsYWcgc28gaWYgYSBkZWJvdW5jZWQgcmVzaXplIGhhcyBiZWVuIHRyaWdnZXJlZCxcblx0ICAgICAgLy8gaXQgY2FuIGZpcnN0IGNoZWNrIGlmIGl0IGlzIGFjdHVhbGx5IGlzRGVzdHJveWVkIGFuZCBub3QgZG9pbmcgYW55dGhpbmdcblx0ICAgICAgdGhpcy5pc0Rlc3Ryb3llZCA9IHRydWU7XG5cdCAgICB9XG5cdFxuXHQgICAgLyoqXG5cdCAgICAgKiBSZXR1cm5zIHRoZSBvdXRlciB3aWR0aCBvZiBhbiBlbGVtZW50LCBvcHRpb25hbGx5IGluY2x1ZGluZyBpdHMgbWFyZ2lucy5cblx0ICAgICAqXG5cdCAgICAgKiBUaGVyZSBhcmUgYSBmZXcgZGlmZmVyZW50IG1ldGhvZHMgZm9yIGdldHRpbmcgdGhlIHdpZHRoIG9mIGFuIGVsZW1lbnQsIG5vbmUgb2Zcblx0ICAgICAqIHdoaWNoIHdvcmsgcGVyZmVjdGx5IGZvciBhbGwgU2h1ZmZsZSdzIHVzZSBjYXNlcy5cblx0ICAgICAqXG5cdCAgICAgKiAxLiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSBgbGVmdGAgYW5kIGByaWdodGAgcHJvcGVydGllcy5cblx0ICAgICAqICAgLSBBY2NvdW50cyBmb3IgdHJhbnNmb3JtIHNjYWxlZCBlbGVtZW50cywgbWFraW5nIGl0IHVzZWxlc3MgZm9yIFNodWZmbGVcblx0ICAgICAqICAgZWxlbWVudHMgd2hpY2ggaGF2ZSBzaHJ1bmsuXG5cdCAgICAgKiAyLiBUaGUgYG9mZnNldFdpZHRoYCBwcm9wZXJ0eS5cblx0ICAgICAqICAgLSBUaGlzIHZhbHVlIHN0YXlzIHRoZSBzYW1lIHJlZ2FyZGxlc3Mgb2YgdGhlIGVsZW1lbnRzIHRyYW5zZm9ybSBwcm9wZXJ0eSxcblx0ICAgICAqICAgaG93ZXZlciwgaXQgZG9lcyBub3QgcmV0dXJuIHN1YnBpeGVsIHZhbHVlcy5cblx0ICAgICAqIDMuIGdldENvbXB1dGVkU3R5bGUoKVxuXHQgICAgICogICAtIFRoaXMgd29ya3MgZ3JlYXQgQ2hyb21lLCBGaXJlZm94LCBTYWZhcmksIGJ1dCBJRTw9MTEgZG9lcyBub3QgaW5jbHVkZVxuXHQgICAgICogICBwYWRkaW5nIGFuZCBib3JkZXIgd2hlbiBib3gtc2l6aW5nOiBib3JkZXItYm94IGlzIHNldCwgcmVxdWlyaW5nIGEgZmVhdHVyZVxuXHQgICAgICogICB0ZXN0IGFuZCBleHRyYSB3b3JrIHRvIGFkZCB0aGUgcGFkZGluZyBiYWNrIGZvciBJRSBhbmQgb3RoZXIgYnJvd3NlcnMgd2hpY2hcblx0ICAgICAqICAgZm9sbG93IHRoZSBXM0Mgc3BlYyBoZXJlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudC5cblx0ICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVNYXJnaW5zXSBXaGV0aGVyIHRvIGluY2x1ZGUgbWFyZ2lucy4gRGVmYXVsdCBpcyBmYWxzZS5cblx0ICAgICAqIEByZXR1cm4ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IFRoZSB3aWR0aCBhbmQgaGVpZ2h0LlxuXHQgICAgICovXG5cdFxuXHQgIH1dLCBbe1xuXHQgICAga2V5OiAnZ2V0U2l6ZScsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2l6ZShlbGVtZW50LCBpbmNsdWRlTWFyZ2lucykge1xuXHQgICAgICAvLyBTdG9yZSB0aGUgc3R5bGVzIHNvIHRoYXQgdGhleSBjYW4gYmUgdXNlZCBieSBvdGhlcnMgd2l0aG91dCBhc2tpbmcgZm9yIGl0IGFnYWluLlxuXHQgICAgICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG5cdCAgICAgIHZhciB3aWR0aCA9ICgwLCBfZ2V0TnVtYmVyU3R5bGUyLmRlZmF1bHQpKGVsZW1lbnQsICd3aWR0aCcsIHN0eWxlcyk7XG5cdCAgICAgIHZhciBoZWlnaHQgPSAoMCwgX2dldE51bWJlclN0eWxlMi5kZWZhdWx0KShlbGVtZW50LCAnaGVpZ2h0Jywgc3R5bGVzKTtcblx0XG5cdCAgICAgIGlmIChpbmNsdWRlTWFyZ2lucykge1xuXHQgICAgICAgIHZhciBtYXJnaW5MZWZ0ID0gKDAsIF9nZXROdW1iZXJTdHlsZTIuZGVmYXVsdCkoZWxlbWVudCwgJ21hcmdpbkxlZnQnLCBzdHlsZXMpO1xuXHQgICAgICAgIHZhciBtYXJnaW5SaWdodCA9ICgwLCBfZ2V0TnVtYmVyU3R5bGUyLmRlZmF1bHQpKGVsZW1lbnQsICdtYXJnaW5SaWdodCcsIHN0eWxlcyk7XG5cdCAgICAgICAgdmFyIG1hcmdpblRvcCA9ICgwLCBfZ2V0TnVtYmVyU3R5bGUyLmRlZmF1bHQpKGVsZW1lbnQsICdtYXJnaW5Ub3AnLCBzdHlsZXMpO1xuXHQgICAgICAgIHZhciBtYXJnaW5Cb3R0b20gPSAoMCwgX2dldE51bWJlclN0eWxlMi5kZWZhdWx0KShlbGVtZW50LCAnbWFyZ2luQm90dG9tJywgc3R5bGVzKTtcblx0ICAgICAgICB3aWR0aCArPSBtYXJnaW5MZWZ0ICsgbWFyZ2luUmlnaHQ7XG5cdCAgICAgICAgaGVpZ2h0ICs9IG1hcmdpblRvcCArIG1hcmdpbkJvdHRvbTtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICB3aWR0aDogd2lkdGgsXG5cdCAgICAgICAgaGVpZ2h0OiBoZWlnaHRcblx0ICAgICAgfTtcblx0ICAgIH1cblx0XG5cdCAgICAvKipcblx0ICAgICAqIENoYW5nZSBhIHByb3BlcnR5IG9yIGV4ZWN1dGUgYSBmdW5jdGlvbiB3aGljaCB3aWxsIG5vdCBoYXZlIGEgdHJhbnNpdGlvblxuXHQgICAgICogQHBhcmFtIHtBcnJheS48RWxlbWVudD59IGVsZW1lbnRzIERPTSBlbGVtZW50cyB0aGF0IHdvbid0IGJlIHRyYW5zaXRpb25lZC5cblx0ICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEEgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWQgd2hpbGUgdHJhbnNpdGlvblxuXHQgICAgICogICAgIGlzIHNldCB0byAwbXMuXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICovXG5cdFxuXHQgIH0sIHtcblx0ICAgIGtleTogJ19za2lwVHJhbnNpdGlvbnMnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIF9za2lwVHJhbnNpdGlvbnMoZWxlbWVudHMsIGNhbGxiYWNrKSB7XG5cdCAgICAgIHZhciB6ZXJvID0gJzBtcyc7XG5cdFxuXHQgICAgICAvLyBTYXZlIGN1cnJlbnQgZHVyYXRpb24gYW5kIGRlbGF5LlxuXHQgICAgICB2YXIgZGF0YSA9IGVsZW1lbnRzLm1hcChmdW5jdGlvbiAoZWxlbWVudCkge1xuXHQgICAgICAgIHZhciBzdHlsZSA9IGVsZW1lbnQuc3R5bGU7XG5cdCAgICAgICAgdmFyIGR1cmF0aW9uID0gc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uO1xuXHQgICAgICAgIHZhciBkZWxheSA9IHN0eWxlLnRyYW5zaXRpb25EZWxheTtcblx0XG5cdCAgICAgICAgLy8gU2V0IHRoZSBkdXJhdGlvbiB0byB6ZXJvIHNvIGl0IGhhcHBlbnMgaW1tZWRpYXRlbHlcblx0ICAgICAgICBzdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSB6ZXJvO1xuXHQgICAgICAgIHN0eWxlLnRyYW5zaXRpb25EZWxheSA9IHplcm87XG5cdFxuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG5cdCAgICAgICAgICBkZWxheTogZGVsYXlcblx0ICAgICAgICB9O1xuXHQgICAgICB9KTtcblx0XG5cdCAgICAgIGNhbGxiYWNrKCk7XG5cdFxuXHQgICAgICAvLyBDYXVzZSByZWZsb3cuXG5cdCAgICAgIGVsZW1lbnRzWzBdLm9mZnNldFdpZHRoOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblx0XG5cdCAgICAgIC8vIFB1dCB0aGUgZHVyYXRpb24gYmFja1xuXHQgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50LCBpKSB7XG5cdCAgICAgICAgZWxlbWVudC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBkYXRhW2ldLmR1cmF0aW9uO1xuXHQgICAgICAgIGVsZW1lbnQuc3R5bGUudHJhbnNpdGlvbkRlbGF5ID0gZGF0YVtpXS5kZWxheTtcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfV0pO1xuXHRcblx0ICByZXR1cm4gU2h1ZmZsZTtcblx0fSgpO1xuXHRcblx0U2h1ZmZsZS5TaHVmZmxlSXRlbSA9IF9zaHVmZmxlSXRlbTIuZGVmYXVsdDtcblx0XG5cdFNodWZmbGUuQUxMX0lURU1TID0gJ2FsbCc7XG5cdFNodWZmbGUuRklMVEVSX0FUVFJJQlVURV9LRVkgPSAnZ3JvdXBzJztcblx0XG5cdC8qKlxuXHQgKiBAZW51bSB7c3RyaW5nfVxuXHQgKi9cblx0U2h1ZmZsZS5FdmVudFR5cGUgPSB7XG5cdCAgTEFZT1VUOiAnc2h1ZmZsZTpsYXlvdXQnLFxuXHQgIFJFTU9WRUQ6ICdzaHVmZmxlOnJlbW92ZWQnXG5cdH07XG5cdFxuXHQvKiogQGVudW0ge3N0cmluZ30gKi9cblx0U2h1ZmZsZS5DbGFzc2VzID0gX2NsYXNzZXMyLmRlZmF1bHQ7XG5cdFxuXHQvLyBPdmVycmlkZWFibGUgb3B0aW9uc1xuXHRTaHVmZmxlLm9wdGlvbnMgPSB7XG5cdCAgLy8gSW5pdGlhbCBmaWx0ZXIgZ3JvdXAuXG5cdCAgZ3JvdXA6IFNodWZmbGUuQUxMX0lURU1TLFxuXHRcblx0ICAvLyBUcmFuc2l0aW9uL2FuaW1hdGlvbiBzcGVlZCAobWlsbGlzZWNvbmRzKS5cblx0ICBzcGVlZDogMjUwLFxuXHRcblx0ICAvLyBDU1MgZWFzaW5nIGZ1bmN0aW9uIHRvIHVzZS5cblx0ICBlYXNpbmc6ICdlYXNlJyxcblx0XG5cdCAgLy8gZS5nLiAnLnBpY3R1cmUtaXRlbScuXG5cdCAgaXRlbVNlbGVjdG9yOiAnKicsXG5cdFxuXHQgIC8vIEVsZW1lbnQgb3Igc2VsZWN0b3Igc3RyaW5nLiBVc2UgYW4gZWxlbWVudCB0byBkZXRlcm1pbmUgdGhlIHNpemUgb2YgY29sdW1uc1xuXHQgIC8vIGFuZCBndXR0ZXJzLlxuXHQgIHNpemVyOiBudWxsLFxuXHRcblx0ICAvLyBBIHN0YXRpYyBudW1iZXIgb3IgZnVuY3Rpb24gdGhhdCB0ZWxscyB0aGUgcGx1Z2luIGhvdyB3aWRlIHRoZSBndXR0ZXJzXG5cdCAgLy8gYmV0d2VlbiBjb2x1bW5zIGFyZSAoaW4gcGl4ZWxzKS5cblx0ICBndXR0ZXJXaWR0aDogMCxcblx0XG5cdCAgLy8gQSBzdGF0aWMgbnVtYmVyIG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIG51bWJlciB3aGljaCB0ZWxscyB0aGUgcGx1Z2luXG5cdCAgLy8gaG93IHdpZGUgdGhlIGNvbHVtbnMgYXJlIChpbiBwaXhlbHMpLlxuXHQgIGNvbHVtbldpZHRoOiAwLFxuXHRcblx0ICAvLyBJZiB5b3VyIGdyb3VwIGlzIG5vdCBqc29uLCBhbmQgaXMgY29tbWEgZGVsaW1ldGVkLCB5b3UgY291bGQgc2V0IGRlbGltZXRlclxuXHQgIC8vIHRvICcsJy5cblx0ICBkZWxpbWV0ZXI6IG51bGwsXG5cdFxuXHQgIC8vIFVzZWZ1bCBmb3IgcGVyY2VudGFnZSBiYXNlZCBoZWlnaHRzIHdoZW4gdGhleSBtaWdodCBub3QgYWx3YXlzIGJlIGV4YWN0bHlcblx0ICAvLyB0aGUgc2FtZSAoaW4gcGl4ZWxzKS5cblx0ICBidWZmZXI6IDAsXG5cdFxuXHQgIC8vIFJlYWRpbmcgdGhlIHdpZHRoIG9mIGVsZW1lbnRzIGlzbid0IHByZWNpc2UgZW5vdWdoIGFuZCBjYW4gY2F1c2UgY29sdW1ucyB0b1xuXHQgIC8vIGp1bXAgYmV0d2VlbiB2YWx1ZXMuXG5cdCAgY29sdW1uVGhyZXNob2xkOiAwLjAxLFxuXHRcblx0ICAvLyBTaHVmZmxlIGNhbiBiZSBpc0luaXRpYWxpemVkIHdpdGggYSBzb3J0IG9iamVjdC4gSXQgaXMgdGhlIHNhbWUgb2JqZWN0XG5cdCAgLy8gZ2l2ZW4gdG8gdGhlIHNvcnQgbWV0aG9kLlxuXHQgIGluaXRpYWxTb3J0OiBudWxsLFxuXHRcblx0ICAvLyBCeSBkZWZhdWx0LCBzaHVmZmxlIHdpbGwgdGhyb3R0bGUgcmVzaXplIGV2ZW50cy4gVGhpcyBjYW4gYmUgY2hhbmdlZCBvclxuXHQgIC8vIHJlbW92ZWQuXG5cdCAgdGhyb3R0bGU6IF90aHJvdHRsZWl0Mi5kZWZhdWx0LFxuXHRcblx0ICAvLyBIb3cgb2Z0ZW4gc2h1ZmZsZSBjYW4gYmUgY2FsbGVkIG9uIHJlc2l6ZSAoaW4gbWlsbGlzZWNvbmRzKS5cblx0ICB0aHJvdHRsZVRpbWU6IDMwMCxcblx0XG5cdCAgLy8gVHJhbnNpdGlvbiBkZWxheSBvZmZzZXQgZm9yIGVhY2ggaXRlbSBpbiBtaWxsaXNlY29uZHMuXG5cdCAgc3RhZ2dlckFtb3VudDogMTUsXG5cdFxuXHQgIC8vIE1heGltdW0gc3RhZ2dlciBkZWxheSBpbiBtaWxsaXNlY29uZHMuXG5cdCAgc3RhZ2dlckFtb3VudE1heDogMjUwLFxuXHRcblx0ICAvLyBXaGV0aGVyIHRvIHVzZSB0cmFuc2Zvcm1zIG9yIGFic29sdXRlIHBvc2l0aW9uaW5nLlxuXHQgIHVzZVRyYW5zZm9ybXM6IHRydWVcblx0fTtcblx0XG5cdC8vIEV4cG9zZSBmb3IgdGVzdGluZy4gSGFjayBhdCB5b3VyIG93biByaXNrLlxuXHRTaHVmZmxlLl9fUG9pbnQgPSBfcG9pbnQyLmRlZmF1bHQ7XG5cdFNodWZmbGUuX19zb3J0ZXIgPSBfc29ydGVyMi5kZWZhdWx0O1xuXHRTaHVmZmxlLl9fZ2V0Q29sdW1uU3BhbiA9IF9sYXlvdXQyLmdldENvbHVtblNwYW47XG5cdFNodWZmbGUuX19nZXRBdmFpbGFibGVQb3NpdGlvbnMgPSBfbGF5b3V0Mi5nZXRBdmFpbGFibGVQb3NpdGlvbnM7XG5cdFNodWZmbGUuX19nZXRTaG9ydENvbHVtbiA9IF9sYXlvdXQyLmdldFNob3J0Q29sdW1uO1xuXHRcblx0ZXhwb3J0cy5kZWZhdWx0ID0gU2h1ZmZsZTtcblxuLyoqKi8gfSxcbi8qIDIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8vIFBvbHlmaWxsIGZvciBjcmVhdGluZyBDdXN0b21FdmVudHMgb24gSUU5LzEwLzExXG5cdFxuXHQvLyBjb2RlIHB1bGxlZCBmcm9tOlxuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vZDR0b2NjaGluaS9jdXN0b21ldmVudC1wb2x5ZmlsbFxuXHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQjUG9seWZpbGxcblx0XG5cdHRyeSB7XG5cdCAgbmV3IHdpbmRvdy5DdXN0b21FdmVudChcInRlc3RcIik7XG5cdH0gY2F0Y2goZSkge1xuXHQgdmFyIEN1c3RvbUV2ZW50ID0gZnVuY3Rpb24oZXZlbnQsIHBhcmFtcykge1xuXHQgICAgICB2YXIgZXZ0O1xuXHQgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge1xuXHQgICAgICAgICAgYnViYmxlczogZmFsc2UsXG5cdCAgICAgICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcblx0ICAgICAgICAgIGRldGFpbDogdW5kZWZpbmVkXG5cdCAgICAgIH07XG5cdFxuXHQgICAgICBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpO1xuXHQgICAgICBldnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUsIHBhcmFtcy5kZXRhaWwpO1xuXHQgICAgICByZXR1cm4gZXZ0O1xuXHQgIH07XG5cdFxuXHQgIEN1c3RvbUV2ZW50LnByb3RvdHlwZSA9IHdpbmRvdy5FdmVudC5wcm90b3R5cGU7XG5cdCAgd2luZG93LkN1c3RvbUV2ZW50ID0gQ3VzdG9tRXZlbnQ7IC8vIGV4cG9zZSBkZWZpbml0aW9uIHRvIHdpbmRvd1xuXHR9XG5cblxuLyoqKi8gfSxcbi8qIDMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdHZhciBwcm90byA9IEVsZW1lbnQucHJvdG90eXBlO1xuXHR2YXIgdmVuZG9yID0gcHJvdG8ubWF0Y2hlc1xuXHQgIHx8IHByb3RvLm1hdGNoZXNTZWxlY3RvclxuXHQgIHx8IHByb3RvLndlYmtpdE1hdGNoZXNTZWxlY3RvclxuXHQgIHx8IHByb3RvLm1vek1hdGNoZXNTZWxlY3RvclxuXHQgIHx8IHByb3RvLm1zTWF0Y2hlc1NlbGVjdG9yXG5cdCAgfHwgcHJvdG8ub01hdGNoZXNTZWxlY3Rvcjtcblx0XG5cdG1vZHVsZS5leHBvcnRzID0gbWF0Y2g7XG5cdFxuXHQvKipcblx0ICogTWF0Y2ggYGVsYCB0byBgc2VsZWN0b3JgLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdGZ1bmN0aW9uIG1hdGNoKGVsLCBzZWxlY3Rvcikge1xuXHQgIGlmICh2ZW5kb3IpIHJldHVybiB2ZW5kb3IuY2FsbChlbCwgc2VsZWN0b3IpO1xuXHQgIHZhciBub2RlcyA9IGVsLnBhcmVudE5vZGUucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgaWYgKG5vZGVzW2ldID09IGVsKSByZXR1cm4gdHJ1ZTtcblx0ICB9XG5cdCAgcmV0dXJuIGZhbHNlO1xuXHR9XG5cbi8qKiovIH0sXG4vKiA0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7J3VzZSBzdHJpY3QnO1xuXHRcblx0Ly8gdGhlcmUncyAzIGltcGxlbWVudGF0aW9ucyB3cml0dGVuIGluIGluY3JlYXNpbmcgb3JkZXIgb2YgZWZmaWNpZW5jeVxuXHRcblx0Ly8gMSAtIG5vIFNldCB0eXBlIGlzIGRlZmluZWRcblx0ZnVuY3Rpb24gdW5pcU5vU2V0KGFycikge1xuXHRcdHZhciByZXQgPSBbXTtcblx0XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChyZXQuaW5kZXhPZihhcnJbaV0pID09PSAtMSkge1xuXHRcdFx0XHRyZXQucHVzaChhcnJbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XG5cdFx0cmV0dXJuIHJldDtcblx0fVxuXHRcblx0Ly8gMiAtIGEgc2ltcGxlIFNldCB0eXBlIGlzIGRlZmluZWRcblx0ZnVuY3Rpb24gdW5pcVNldChhcnIpIHtcblx0XHR2YXIgc2VlbiA9IG5ldyBTZXQoKTtcblx0XHRyZXR1cm4gYXJyLmZpbHRlcihmdW5jdGlvbiAoZWwpIHtcblx0XHRcdGlmICghc2Vlbi5oYXMoZWwpKSB7XG5cdFx0XHRcdHNlZW4uYWRkKGVsKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0pO1xuXHR9XG5cdFxuXHQvLyAzIC0gYSBzdGFuZGFyZCBTZXQgdHlwZSBpcyBkZWZpbmVkIGFuZCBpdCBoYXMgYSBmb3JFYWNoIG1ldGhvZFxuXHRmdW5jdGlvbiB1bmlxU2V0V2l0aEZvckVhY2goYXJyKSB7XG5cdFx0dmFyIHJldCA9IFtdO1xuXHRcblx0XHQobmV3IFNldChhcnIpKS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuXHRcdFx0cmV0LnB1c2goZWwpO1xuXHRcdH0pO1xuXHRcblx0XHRyZXR1cm4gcmV0O1xuXHR9XG5cdFxuXHQvLyBWOCBjdXJyZW50bHkgaGFzIGEgYnJva2VuIGltcGxlbWVudGF0aW9uXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvODQ0OVxuXHRmdW5jdGlvbiBkb2VzRm9yRWFjaEFjdHVhbGx5V29yaygpIHtcblx0XHR2YXIgcmV0ID0gZmFsc2U7XG5cdFxuXHRcdChuZXcgU2V0KFt0cnVlXSkpLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG5cdFx0XHRyZXQgPSBlbDtcblx0XHR9KTtcblx0XG5cdFx0cmV0dXJuIHJldCA9PT0gdHJ1ZTtcblx0fVxuXHRcblx0aWYgKCdTZXQnIGluIGdsb2JhbCkge1xuXHRcdGlmICh0eXBlb2YgU2V0LnByb3RvdHlwZS5mb3JFYWNoID09PSAnZnVuY3Rpb24nICYmIGRvZXNGb3JFYWNoQWN0dWFsbHlXb3JrKCkpIHtcblx0XHRcdG1vZHVsZS5leHBvcnRzID0gdW5pcVNldFdpdGhGb3JFYWNoO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtb2R1bGUuZXhwb3J0cyA9IHVuaXFTZXQ7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gdW5pcU5vU2V0O1xuXHR9XG5cdFxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0sXG4vKiA1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGV4dGVuZFxuXHRcblx0dmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblx0XG5cdGZ1bmN0aW9uIGV4dGVuZCgpIHtcblx0ICAgIHZhciB0YXJnZXQgPSB7fVxuXHRcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXVxuXHRcblx0ICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG5cdCAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuXHQgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHRcblx0ICAgIHJldHVybiB0YXJnZXRcblx0fVxuXG5cbi8qKiovIH0sXG4vKiA2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IHRocm90dGxlO1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgYSBuZXcgZnVuY3Rpb24gdGhhdCwgd2hlbiBpbnZva2VkLCBpbnZva2VzIGBmdW5jYCBhdCBtb3N0IG9uY2UgcGVyIGB3YWl0YCBtaWxsaXNlY29uZHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgRnVuY3Rpb24gdG8gd3JhcC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdhaXQgTnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IG11c3QgZWxhcHNlIGJldHdlZW4gYGZ1bmNgIGludm9jYXRpb25zLlxuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24gdGhhdCB3cmFwcyB0aGUgYGZ1bmNgIGZ1bmN0aW9uIHBhc3NlZCBpbi5cblx0ICovXG5cdFxuXHRmdW5jdGlvbiB0aHJvdHRsZSAoZnVuYywgd2FpdCkge1xuXHQgIHZhciBjdHgsIGFyZ3MsIHJ0biwgdGltZW91dElEOyAvLyBjYWNoaW5nXG5cdCAgdmFyIGxhc3QgPSAwO1xuXHRcblx0ICByZXR1cm4gZnVuY3Rpb24gdGhyb3R0bGVkICgpIHtcblx0ICAgIGN0eCA9IHRoaXM7XG5cdCAgICBhcmdzID0gYXJndW1lbnRzO1xuXHQgICAgdmFyIGRlbHRhID0gbmV3IERhdGUoKSAtIGxhc3Q7XG5cdCAgICBpZiAoIXRpbWVvdXRJRClcblx0ICAgICAgaWYgKGRlbHRhID49IHdhaXQpIGNhbGwoKTtcblx0ICAgICAgZWxzZSB0aW1lb3V0SUQgPSBzZXRUaW1lb3V0KGNhbGwsIHdhaXQgLSBkZWx0YSk7XG5cdCAgICByZXR1cm4gcnRuO1xuXHQgIH07XG5cdFxuXHQgIGZ1bmN0aW9uIGNhbGwgKCkge1xuXHQgICAgdGltZW91dElEID0gMDtcblx0ICAgIGxhc3QgPSArbmV3IERhdGUoKTtcblx0ICAgIHJ0biA9IGZ1bmMuYXBwbHkoY3R4LCBhcmdzKTtcblx0ICAgIGN0eCA9IG51bGw7XG5cdCAgICBhcmdzID0gbnVsbDtcblx0ICB9XG5cdH1cblxuXG4vKioqLyB9LFxuLyogNyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJhbGxlbChmbnMsIGNvbnRleHQsIGNhbGxiYWNrKSB7XG5cdCAgaWYgKCFjYWxsYmFjaykge1xuXHQgICAgaWYgKHR5cGVvZiBjb250ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIGNhbGxiYWNrID0gY29udGV4dFxuXHQgICAgICBjb250ZXh0ID0gbnVsbFxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgY2FsbGJhY2sgPSBub29wXG5cdCAgICB9XG5cdCAgfVxuXHRcblx0ICB2YXIgcGVuZGluZyA9IGZucyAmJiBmbnMubGVuZ3RoXG5cdCAgaWYgKCFwZW5kaW5nKSByZXR1cm4gY2FsbGJhY2sobnVsbCwgW10pO1xuXHRcblx0ICB2YXIgZmluaXNoZWQgPSBmYWxzZVxuXHQgIHZhciByZXN1bHRzID0gbmV3IEFycmF5KHBlbmRpbmcpXG5cdFxuXHQgIGZucy5mb3JFYWNoKGNvbnRleHQgPyBmdW5jdGlvbiAoZm4sIGkpIHtcblx0ICAgIGZuLmNhbGwoY29udGV4dCwgbWF5YmVEb25lKGkpKVxuXHQgIH0gOiBmdW5jdGlvbiAoZm4sIGkpIHtcblx0ICAgIGZuKG1heWJlRG9uZShpKSlcblx0ICB9KVxuXHRcblx0ICBmdW5jdGlvbiBtYXliZURvbmUoaSkge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuXHQgICAgICBpZiAoZmluaXNoZWQpIHJldHVybjtcblx0XG5cdCAgICAgIGlmIChlcnIpIHtcblx0ICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdHMpXG5cdCAgICAgICAgZmluaXNoZWQgPSB0cnVlXG5cdCAgICAgICAgcmV0dXJuXG5cdCAgICAgIH1cblx0XG5cdCAgICAgIHJlc3VsdHNbaV0gPSByZXN1bHRcblx0XG5cdCAgICAgIGlmICghLS1wZW5kaW5nKSBjYWxsYmFjayhudWxsLCByZXN1bHRzKTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblx0XG5cdGZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5cbi8qKiovIH0sXG4vKiA4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0XG5cdHZhciBfZ2V0TnVtYmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblx0XG5cdHZhciBfZ2V0TnVtYmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldE51bWJlcik7XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXHRcblx0LyoqXG5cdCAqIFJlcHJlc2VudHMgYSBjb29yZGluYXRlIHBhaXIuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSBYLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3k9MF0gWS5cblx0ICovXG5cdHZhciBQb2ludCA9IGZ1bmN0aW9uIFBvaW50KHgsIHkpIHtcblx0ICB0aGlzLnggPSAoMCwgX2dldE51bWJlcjIuZGVmYXVsdCkoeCk7XG5cdCAgdGhpcy55ID0gKDAsIF9nZXROdW1iZXIyLmRlZmF1bHQpKHkpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFdoZXRoZXIgdHdvIHBvaW50cyBhcmUgZXF1YWwuXG5cdCAqIEBwYXJhbSB7UG9pbnR9IGEgUG9pbnQgQS5cblx0ICogQHBhcmFtIHtQb2ludH0gYiBQb2ludCBCLlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0UG9pbnQuZXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcblx0ICByZXR1cm4gYS54ID09PSBiLnggJiYgYS55ID09PSBiLnk7XG5cdH07XG5cdFxuXHRleHBvcnRzLmRlZmF1bHQgPSBQb2ludDtcblxuLyoqKi8gfSxcbi8qIDkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdC8qKlxuXHQgKiBBbHdheXMgcmV0dXJucyBhIG51bWVyaWMgdmFsdWUsIGdpdmVuIGEgdmFsdWUuIExvZ2ljIGZyb20galF1ZXJ5J3MgYGlzTnVtZXJpY2AuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgUG9zc2libHkgbnVtZXJpYyB2YWx1ZS5cblx0ICogQHJldHVybiB7bnVtYmVyfSBgdmFsdWVgIG9yIHplcm8gaWYgYHZhbHVlYCBpc24ndCBudW1lcmljLlxuXHQgKi9cblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRleHBvcnRzLmRlZmF1bHQgPSBnZXROdW1iZXI7XG5cdGZ1bmN0aW9uIGdldE51bWJlcih2YWx1ZSkge1xuXHQgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKSB8fCAwO1xuXHR9XG5cbi8qKiovIH0sXG4vKiAxMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgdmFsdWU6IHRydWVcblx0fSk7XG5cdFxuXHR2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXHRcblx0dmFyIF9wb2ludCA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cdFxuXHR2YXIgX3BvaW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BvaW50KTtcblx0XG5cdHZhciBfY2xhc3NlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXHRcblx0dmFyIF9jbGFzc2VzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzZXMpO1xuXHRcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblx0XG5cdGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cdFxuXHR2YXIgaWQgPSAwO1xuXHRcblx0dmFyIFNodWZmbGVJdGVtID0gZnVuY3Rpb24gKCkge1xuXHQgIGZ1bmN0aW9uIFNodWZmbGVJdGVtKGVsZW1lbnQpIHtcblx0ICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTaHVmZmxlSXRlbSk7XG5cdFxuXHQgICAgdGhpcy5pZCA9IGlkKys7XG5cdCAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuXHQgICAgdGhpcy5pc1Zpc2libGUgPSB0cnVlO1xuXHQgIH1cblx0XG5cdCAgX2NyZWF0ZUNsYXNzKFNodWZmbGVJdGVtLCBbe1xuXHQgICAga2V5OiAnc2hvdycsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gc2hvdygpIHtcblx0ICAgICAgdGhpcy5pc1Zpc2libGUgPSB0cnVlO1xuXHQgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShfY2xhc3NlczIuZGVmYXVsdC5ISURERU4pO1xuXHQgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChfY2xhc3NlczIuZGVmYXVsdC5WSVNJQkxFKTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdoaWRlJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlKCkge1xuXHQgICAgICB0aGlzLmlzVmlzaWJsZSA9IGZhbHNlO1xuXHQgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShfY2xhc3NlczIuZGVmYXVsdC5WSVNJQkxFKTtcblx0ICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoX2NsYXNzZXMyLmRlZmF1bHQuSElEREVOKTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdpbml0Jyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuXHQgICAgICB0aGlzLmFkZENsYXNzZXMoW19jbGFzc2VzMi5kZWZhdWx0LlNIVUZGTEVfSVRFTSwgX2NsYXNzZXMyLmRlZmF1bHQuVklTSUJMRV0pO1xuXHQgICAgICB0aGlzLmFwcGx5Q3NzKFNodWZmbGVJdGVtLkNzcy5JTklUSUFMKTtcblx0ICAgICAgdGhpcy5zY2FsZSA9IFNodWZmbGVJdGVtLlNjYWxlLlZJU0lCTEU7XG5cdCAgICAgIHRoaXMucG9pbnQgPSBuZXcgX3BvaW50Mi5kZWZhdWx0KCk7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnYWRkQ2xhc3NlcycsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQ2xhc3NlcyhjbGFzc2VzKSB7XG5cdCAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdFxuXHQgICAgICBjbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuXHQgICAgICAgIF90aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6ICdyZW1vdmVDbGFzc2VzJyxcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVDbGFzc2VzKGNsYXNzZXMpIHtcblx0ICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cdFxuXHQgICAgICBjbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuXHQgICAgICAgIF90aGlzMi5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiAnYXBwbHlDc3MnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5Q3NzKG9iaikge1xuXHQgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG5cdCAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlW2tleV0gPSBvYmpba2V5XTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0sIHtcblx0ICAgIGtleTogJ2Rpc3Bvc2UnLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG5cdCAgICAgIHRoaXMucmVtb3ZlQ2xhc3NlcyhbX2NsYXNzZXMyLmRlZmF1bHQuSElEREVOLCBfY2xhc3NlczIuZGVmYXVsdC5WSVNJQkxFLCBfY2xhc3NlczIuZGVmYXVsdC5TSFVGRkxFX0lURU1dKTtcblx0XG5cdCAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG5cdCAgICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG5cdCAgICB9XG5cdCAgfV0pO1xuXHRcblx0ICByZXR1cm4gU2h1ZmZsZUl0ZW07XG5cdH0oKTtcblx0XG5cdFNodWZmbGVJdGVtLkNzcyA9IHtcblx0ICBJTklUSUFMOiB7XG5cdCAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcblx0ICAgIHRvcDogMCxcblx0ICAgIGxlZnQ6IDAsXG5cdCAgICB2aXNpYmlsaXR5OiAndmlzaWJsZScsXG5cdCAgICAnd2lsbC1jaGFuZ2UnOiAndHJhbnNmb3JtJ1xuXHQgIH0sXG5cdCAgVklTSUJMRToge1xuXHQgICAgYmVmb3JlOiB7XG5cdCAgICAgIG9wYWNpdHk6IDEsXG5cdCAgICAgIHZpc2liaWxpdHk6ICd2aXNpYmxlJ1xuXHQgICAgfSxcblx0ICAgIGFmdGVyOiB7fVxuXHQgIH0sXG5cdCAgSElEREVOOiB7XG5cdCAgICBiZWZvcmU6IHtcblx0ICAgICAgb3BhY2l0eTogMFxuXHQgICAgfSxcblx0ICAgIGFmdGVyOiB7XG5cdCAgICAgIHZpc2liaWxpdHk6ICdoaWRkZW4nXG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXHRcblx0U2h1ZmZsZUl0ZW0uU2NhbGUgPSB7XG5cdCAgVklTSUJMRTogMSxcblx0ICBISURERU46IDAuMDAxXG5cdH07XG5cdFxuXHRleHBvcnRzLmRlZmF1bHQgPSBTaHVmZmxlSXRlbTtcblxuLyoqKi8gfSxcbi8qIDExICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0ZXhwb3J0cy5kZWZhdWx0ID0ge1xuXHQgIEJBU0U6ICdzaHVmZmxlJyxcblx0ICBTSFVGRkxFX0lURU06ICdzaHVmZmxlLWl0ZW0nLFxuXHQgIFZJU0lCTEU6ICdzaHVmZmxlLWl0ZW0tLXZpc2libGUnLFxuXHQgIEhJRERFTjogJ3NodWZmbGUtaXRlbS0taGlkZGVuJ1xuXHR9O1xuXG4vKioqLyB9LFxuLyogMTIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRleHBvcnRzLmRlZmF1bHQgPSBnZXROdW1iZXJTdHlsZTtcblx0XG5cdHZhciBfZ2V0TnVtYmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblx0XG5cdHZhciBfZ2V0TnVtYmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldE51bWJlcik7XG5cdFxuXHR2YXIgX2NvbXB1dGVkU2l6ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXHRcblx0dmFyIF9jb21wdXRlZFNpemUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcHV0ZWRTaXplKTtcblx0XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cdFxuXHQvKipcblx0ICogUmV0cmlldmUgdGhlIGNvbXB1dGVkIHN0eWxlIGZvciBhbiBlbGVtZW50LCBwYXJzZWQgYXMgYSBmbG9hdC5cblx0ICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gZ2V0IHN0eWxlIGZvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlIFN0eWxlIHByb3BlcnR5LlxuXHQgKiBAcGFyYW0ge0NTU1N0eWxlRGVjbGFyYXRpb259IFtzdHlsZXNdIE9wdGlvbmFsbHkgaW5jbHVkZSBjbGVhbiBzdHlsZXMgdG9cblx0ICogICAgIHVzZSBpbnN0ZWFkIG9mIGFza2luZyBmb3IgdGhlbSBhZ2Fpbi5cblx0ICogQHJldHVybiB7bnVtYmVyfSBUaGUgcGFyc2VkIGNvbXB1dGVkIHZhbHVlIG9yIHplcm8gaWYgdGhhdCBmYWlscyBiZWNhdXNlIElFXG5cdCAqICAgICB3aWxsIHJldHVybiAnYXV0bycgd2hlbiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgbWFyZ2lucyBpbnN0ZWFkIG9mXG5cdCAqICAgICB0aGUgY29tcHV0ZWQgc3R5bGUuXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXROdW1iZXJTdHlsZShlbGVtZW50LCBzdHlsZSkge1xuXHQgIHZhciBzdHlsZXMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKSA6IGFyZ3VtZW50c1syXTtcblx0XG5cdCAgdmFyIHZhbHVlID0gKDAsIF9nZXROdW1iZXIyLmRlZmF1bHQpKHN0eWxlc1tzdHlsZV0pO1xuXHRcblx0ICAvLyBTdXBwb3J0IElFPD0xMSBhbmQgVzNDIHNwZWMuXG5cdCAgaWYgKCFfY29tcHV0ZWRTaXplMi5kZWZhdWx0ICYmIHN0eWxlID09PSAnd2lkdGgnKSB7XG5cdCAgICB2YWx1ZSArPSAoMCwgX2dldE51bWJlcjIuZGVmYXVsdCkoc3R5bGVzLnBhZGRpbmdMZWZ0KSArICgwLCBfZ2V0TnVtYmVyMi5kZWZhdWx0KShzdHlsZXMucGFkZGluZ1JpZ2h0KSArICgwLCBfZ2V0TnVtYmVyMi5kZWZhdWx0KShzdHlsZXMuYm9yZGVyTGVmdFdpZHRoKSArICgwLCBfZ2V0TnVtYmVyMi5kZWZhdWx0KShzdHlsZXMuYm9yZGVyUmlnaHRXaWR0aCk7XG5cdCAgfSBlbHNlIGlmICghX2NvbXB1dGVkU2l6ZTIuZGVmYXVsdCAmJiBzdHlsZSA9PT0gJ2hlaWdodCcpIHtcblx0ICAgIHZhbHVlICs9ICgwLCBfZ2V0TnVtYmVyMi5kZWZhdWx0KShzdHlsZXMucGFkZGluZ1RvcCkgKyAoMCwgX2dldE51bWJlcjIuZGVmYXVsdCkoc3R5bGVzLnBhZGRpbmdCb3R0b20pICsgKDAsIF9nZXROdW1iZXIyLmRlZmF1bHQpKHN0eWxlcy5ib3JkZXJUb3BXaWR0aCkgKyAoMCwgX2dldE51bWJlcjIuZGVmYXVsdCkoc3R5bGVzLmJvcmRlckJvdHRvbVdpZHRoKTtcblx0ICB9XG5cdFxuXHQgIHJldHVybiB2YWx1ZTtcblx0fVxuXG4vKioqLyB9LFxuLyogMTMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRcblx0dmFyIGVsZW1lbnQgPSBkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblx0dmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0ZS5zdHlsZS5jc3NUZXh0ID0gJ3dpZHRoOjEwcHg7cGFkZGluZzoycHg7Ym94LXNpemluZzpib3JkZXItYm94Oyc7XG5cdGVsZW1lbnQuYXBwZW5kQ2hpbGQoZSk7XG5cdFxuXHR2YXIgd2lkdGggPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlLCBudWxsKS53aWR0aDtcblx0dmFyIHJldCA9IHdpZHRoID09PSAnMTBweCc7XG5cdFxuXHRlbGVtZW50LnJlbW92ZUNoaWxkKGUpO1xuXHRcblx0ZXhwb3J0cy5kZWZhdWx0ID0gcmV0O1xuXG4vKioqLyB9LFxuLyogMTQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRleHBvcnRzLmRlZmF1bHQgPSBzb3J0ZXI7XG5cdFxuXHR2YXIgX3h0ZW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0XG5cdHZhciBfeHRlbmQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfeHRlbmQpO1xuXHRcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblx0XG5cdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzk2Mjg5MC8zNzM0MjJcblx0ZnVuY3Rpb24gcmFuZG9taXplKGFycmF5KSB7XG5cdCAgdmFyIHRtcDtcblx0ICB2YXIgY3VycmVudDtcblx0ICB2YXIgdG9wID0gYXJyYXkubGVuZ3RoO1xuXHRcblx0ICBpZiAoIXRvcCkge1xuXHQgICAgcmV0dXJuIGFycmF5O1xuXHQgIH1cblx0XG5cdCAgd2hpbGUgKC0tdG9wKSB7XG5cdCAgICBjdXJyZW50ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKHRvcCArIDEpKTtcblx0ICAgIHRtcCA9IGFycmF5W2N1cnJlbnRdO1xuXHQgICAgYXJyYXlbY3VycmVudF0gPSBhcnJheVt0b3BdO1xuXHQgICAgYXJyYXlbdG9wXSA9IHRtcDtcblx0ICB9XG5cdFxuXHQgIHJldHVybiBhcnJheTtcblx0fVxuXHRcblx0dmFyIGRlZmF1bHRzID0ge1xuXHQgIC8vIFVzZSBhcnJheS5yZXZlcnNlKCkgdG8gcmV2ZXJzZSB0aGUgcmVzdWx0c1xuXHQgIHJldmVyc2U6IGZhbHNlLFxuXHRcblx0ICAvLyBTb3J0aW5nIGZ1bmN0aW9uXG5cdCAgYnk6IG51bGwsXG5cdFxuXHQgIC8vIElmIHRydWUsIHRoaXMgd2lsbCBza2lwIHRoZSBzb3J0aW5nIGFuZCByZXR1cm4gYSByYW5kb21pemVkIG9yZGVyIGluIHRoZSBhcnJheVxuXHQgIHJhbmRvbWl6ZTogZmFsc2UsXG5cdFxuXHQgIC8vIERldGVybWluZXMgd2hpY2ggcHJvcGVydHkgb2YgZWFjaCBpdGVtIGluIHRoZSBhcnJheSBpcyBwYXNzZWQgdG8gdGhlXG5cdCAgLy8gc29ydGluZyBtZXRob2QuXG5cdCAga2V5OiAnZWxlbWVudCdcblx0fTtcblx0XG5cdC8vIFlvdSBjYW4gcmV0dXJuIGB1bmRlZmluZWRgIGZyb20gdGhlIGBieWAgZnVuY3Rpb24gdG8gcmV2ZXJ0IHRvIERPTSBvcmRlci5cblx0ZnVuY3Rpb24gc29ydGVyKGFyciwgb3B0aW9ucykge1xuXHQgIHZhciBvcHRzID0gKDAsIF94dGVuZDIuZGVmYXVsdCkoZGVmYXVsdHMsIG9wdGlvbnMpO1xuXHQgIHZhciBvcmlnaW5hbCA9IFtdLnNsaWNlLmNhbGwoYXJyKTtcblx0ICB2YXIgcmV2ZXJ0ID0gZmFsc2U7XG5cdFxuXHQgIGlmICghYXJyLmxlbmd0aCkge1xuXHQgICAgcmV0dXJuIFtdO1xuXHQgIH1cblx0XG5cdCAgaWYgKG9wdHMucmFuZG9taXplKSB7XG5cdCAgICByZXR1cm4gcmFuZG9taXplKGFycik7XG5cdCAgfVxuXHRcblx0ICAvLyBTb3J0IHRoZSBlbGVtZW50cyBieSB0aGUgb3B0cy5ieSBmdW5jdGlvbi5cblx0ICAvLyBJZiB3ZSBkb24ndCBoYXZlIG9wdHMuYnksIGRlZmF1bHQgdG8gRE9NIG9yZGVyXG5cdCAgaWYgKHR5cGVvZiBvcHRzLmJ5ID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICBhcnIuc29ydChmdW5jdGlvbiAoYSwgYikge1xuXHRcblx0ICAgICAgLy8gRXhpdCBlYXJseSBpZiB3ZSBhbHJlYWR5IGtub3cgd2Ugd2FudCB0byByZXZlcnRcblx0ICAgICAgaWYgKHJldmVydCkge1xuXHQgICAgICAgIHJldHVybiAwO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICB2YXIgdmFsQSA9IG9wdHMuYnkoYVtvcHRzLmtleV0pO1xuXHQgICAgICB2YXIgdmFsQiA9IG9wdHMuYnkoYltvcHRzLmtleV0pO1xuXHRcblx0ICAgICAgLy8gSWYgYm90aCB2YWx1ZXMgYXJlIHVuZGVmaW5lZCwgdXNlIHRoZSBET00gb3JkZXJcblx0ICAgICAgaWYgKHZhbEEgPT09IHVuZGVmaW5lZCAmJiB2YWxCID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICByZXZlcnQgPSB0cnVlO1xuXHQgICAgICAgIHJldHVybiAwO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICBpZiAodmFsQSA8IHZhbEIgfHwgdmFsQSA9PT0gJ3NvcnRGaXJzdCcgfHwgdmFsQiA9PT0gJ3NvcnRMYXN0Jykge1xuXHQgICAgICAgIHJldHVybiAtMTtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgaWYgKHZhbEEgPiB2YWxCIHx8IHZhbEEgPT09ICdzb3J0TGFzdCcgfHwgdmFsQiA9PT0gJ3NvcnRGaXJzdCcpIHtcblx0ICAgICAgICByZXR1cm4gMTtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgcmV0dXJuIDA7XG5cdCAgICB9KTtcblx0ICB9XG5cdFxuXHQgIC8vIFJldmVydCB0byB0aGUgb3JpZ2luYWwgYXJyYXkgaWYgbmVjZXNzYXJ5XG5cdCAgaWYgKHJldmVydCkge1xuXHQgICAgcmV0dXJuIG9yaWdpbmFsO1xuXHQgIH1cblx0XG5cdCAgaWYgKG9wdHMucmV2ZXJzZSkge1xuXHQgICAgYXJyLnJldmVyc2UoKTtcblx0ICB9XG5cdFxuXHQgIHJldHVybiBhcnI7XG5cdH1cblxuLyoqKi8gfSxcbi8qIDE1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0ZXhwb3J0cy5vblRyYW5zaXRpb25FbmQgPSBvblRyYW5zaXRpb25FbmQ7XG5cdGV4cG9ydHMuY2FuY2VsVHJhbnNpdGlvbkVuZCA9IGNhbmNlbFRyYW5zaXRpb25FbmQ7XG5cdHZhciB0cmFuc2l0aW9ucyA9IHt9O1xuXHR2YXIgZXZlbnROYW1lID0gJ3RyYW5zaXRpb25lbmQnO1xuXHR2YXIgY291bnQgPSAwO1xuXHRcblx0ZnVuY3Rpb24gdW5pcXVlSWQoKSB7XG5cdCAgcmV0dXJuIGV2ZW50TmFtZSArIGNvdW50Kys7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIG9uVHJhbnNpdGlvbkVuZChlbGVtZW50LCBjYWxsYmFjaykge1xuXHQgIHZhciBpZCA9IHVuaXF1ZUlkKCk7XG5cdCAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gbGlzdGVuZXIoZXZ0KSB7XG5cdCAgICBpZiAoZXZ0LmN1cnJlbnRUYXJnZXQgPT09IGV2dC50YXJnZXQpIHtcblx0ICAgICAgY2FuY2VsVHJhbnNpdGlvbkVuZChpZCk7XG5cdCAgICAgIGNhbGxiYWNrKGV2dCk7XG5cdCAgICB9XG5cdCAgfTtcblx0XG5cdCAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuXHRcblx0ICB0cmFuc2l0aW9uc1tpZF0gPSB7IGVsZW1lbnQ6IGVsZW1lbnQsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuXHRcblx0ICByZXR1cm4gaWQ7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGNhbmNlbFRyYW5zaXRpb25FbmQoaWQpIHtcblx0ICBpZiAodHJhbnNpdGlvbnNbaWRdKSB7XG5cdCAgICB0cmFuc2l0aW9uc1tpZF0uZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgdHJhbnNpdGlvbnNbaWRdLmxpc3RlbmVyKTtcblx0ICAgIHRyYW5zaXRpb25zW2lkXSA9IG51bGw7XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9XG5cdFxuXHQgIHJldHVybiBmYWxzZTtcblx0fVxuXG4vKioqLyB9LFxuLyogMTYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRleHBvcnRzLmdldEl0ZW1Qb3NpdGlvbiA9IGdldEl0ZW1Qb3NpdGlvbjtcblx0ZXhwb3J0cy5nZXRDb2x1bW5TcGFuID0gZ2V0Q29sdW1uU3Bhbjtcblx0ZXhwb3J0cy5nZXRBdmFpbGFibGVQb3NpdGlvbnMgPSBnZXRBdmFpbGFibGVQb3NpdGlvbnM7XG5cdGV4cG9ydHMuZ2V0U2hvcnRDb2x1bW4gPSBnZXRTaG9ydENvbHVtbjtcblx0XG5cdHZhciBfcG9pbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXHRcblx0dmFyIF9wb2ludDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb2ludCk7XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXHRcblx0ZnVuY3Rpb24gYXJyYXlNYXgoYXJyYXkpIHtcblx0ICByZXR1cm4gTWF0aC5tYXguYXBwbHkoTWF0aCwgYXJyYXkpO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBhcnJheU1pbihhcnJheSkge1xuXHQgIHJldHVybiBNYXRoLm1pbi5hcHBseShNYXRoLCBhcnJheSk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgdGhlIGxvY2F0aW9uIG9mIHRoZSBuZXh0IGl0ZW0sIGJhc2VkIG9uIGl0cyBzaXplLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbVNpemUgT2JqZWN0IHdpdGggd2lkdGggYW5kIGhlaWdodC5cblx0ICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcG9zaXRpb25zIFBvc2l0aW9ucyBvZiB0aGUgb3RoZXIgY3VycmVudCBpdGVtcy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGdyaWRTaXplIFRoZSBjb2x1bW4gd2lkdGggb3Igcm93IGhlaWdodC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHRvdGFsIFRoZSB0b3RhbCBudW1iZXIgb2YgY29sdW1ucyBvciByb3dzLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGhyZXNob2xkIEJ1ZmZlciB2YWx1ZSBmb3IgdGhlIGNvbHVtbiB0byBmaXQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBidWZmZXIgVmVydGljYWwgYnVmZmVyIGZvciB0aGUgaGVpZ2h0IG9mIGl0ZW1zLlxuXHQgKiBAcmV0dXJuIHtQb2ludH1cblx0ICovXG5cdGZ1bmN0aW9uIGdldEl0ZW1Qb3NpdGlvbihfcmVmKSB7XG5cdCAgdmFyIGl0ZW1TaXplID0gX3JlZi5pdGVtU2l6ZTtcblx0ICB2YXIgcG9zaXRpb25zID0gX3JlZi5wb3NpdGlvbnM7XG5cdCAgdmFyIGdyaWRTaXplID0gX3JlZi5ncmlkU2l6ZTtcblx0ICB2YXIgdG90YWwgPSBfcmVmLnRvdGFsO1xuXHQgIHZhciB0aHJlc2hvbGQgPSBfcmVmLnRocmVzaG9sZDtcblx0ICB2YXIgYnVmZmVyID0gX3JlZi5idWZmZXI7XG5cdFxuXHQgIHZhciBzcGFuID0gZ2V0Q29sdW1uU3BhbihpdGVtU2l6ZS53aWR0aCwgZ3JpZFNpemUsIHRvdGFsLCB0aHJlc2hvbGQpO1xuXHQgIHZhciBzZXRZID0gZ2V0QXZhaWxhYmxlUG9zaXRpb25zKHBvc2l0aW9ucywgc3BhbiwgdG90YWwpO1xuXHQgIHZhciBzaG9ydENvbHVtbkluZGV4ID0gZ2V0U2hvcnRDb2x1bW4oc2V0WSwgYnVmZmVyKTtcblx0XG5cdCAgLy8gUG9zaXRpb24gdGhlIGl0ZW1cblx0ICB2YXIgcG9pbnQgPSBuZXcgX3BvaW50Mi5kZWZhdWx0KE1hdGgucm91bmQoZ3JpZFNpemUgKiBzaG9ydENvbHVtbkluZGV4KSwgTWF0aC5yb3VuZChzZXRZW3Nob3J0Q29sdW1uSW5kZXhdKSk7XG5cdFxuXHQgIC8vIFVwZGF0ZSB0aGUgY29sdW1ucyBhcnJheSB3aXRoIHRoZSBuZXcgdmFsdWVzIGZvciBlYWNoIGNvbHVtbi5cblx0ICAvLyBlLmcuIGJlZm9yZSB0aGUgdXBkYXRlIHRoZSBjb2x1bW5zIGNvdWxkIGJlIFsyNTAsIDAsIDAsIDBdIGZvciBhbiBpdGVtXG5cdCAgLy8gd2hpY2ggc3BhbnMgMiBjb2x1bW5zLiBBZnRlciBpdCB3b3VsZCBiZSBbMjUwLCBpdGVtSGVpZ2h0LCBpdGVtSGVpZ2h0LCAwXS5cblx0ICB2YXIgc2V0SGVpZ2h0ID0gc2V0WVtzaG9ydENvbHVtbkluZGV4XSArIGl0ZW1TaXplLmhlaWdodDtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW47IGkrKykge1xuXHQgICAgcG9zaXRpb25zW3Nob3J0Q29sdW1uSW5kZXggKyBpXSA9IHNldEhlaWdodDtcblx0ICB9XG5cdFxuXHQgIHJldHVybiBwb2ludDtcblx0fVxuXHRcblx0LyoqXG5cdCAqIERldGVybWluZSB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgYW4gaXRlbXMgc3BhbnMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpdGVtV2lkdGggV2lkdGggb2YgdGhlIGl0ZW0uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5XaWR0aCBXaWR0aCBvZiB0aGUgY29sdW1uIChpbmNsdWRlcyBndXR0ZXIpLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gY29sdW1ucyBUb3RhbCBudW1iZXIgb2YgY29sdW1uc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gdGhyZXNob2xkIEEgYnVmZmVyIHZhbHVlIGZvciB0aGUgc2l6ZSBvZiB0aGUgY29sdW1uIHRvIGZpdC5cblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0Q29sdW1uU3BhbihpdGVtV2lkdGgsIGNvbHVtbldpZHRoLCBjb2x1bW5zLCB0aHJlc2hvbGQpIHtcblx0ICB2YXIgY29sdW1uU3BhbiA9IGl0ZW1XaWR0aCAvIGNvbHVtbldpZHRoO1xuXHRcblx0ICAvLyBJZiB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSByb3VuZGVkIGNvbHVtbiBzcGFuIG51bWJlciBhbmQgdGhlXG5cdCAgLy8gY2FsY3VsYXRlZCBjb2x1bW4gc3BhbiBudW1iZXIgaXMgcmVhbGx5IHNtYWxsLCByb3VuZCB0aGUgbnVtYmVyIHRvXG5cdCAgLy8gbWFrZSBpdCBmaXQuXG5cdCAgaWYgKE1hdGguYWJzKE1hdGgucm91bmQoY29sdW1uU3BhbikgLSBjb2x1bW5TcGFuKSA8IHRocmVzaG9sZCkge1xuXHQgICAgLy8gZS5nLiBjb2x1bW5TcGFuID0gNC4wMDg5OTQ1MzkwMjk4NzQ1XG5cdCAgICBjb2x1bW5TcGFuID0gTWF0aC5yb3VuZChjb2x1bW5TcGFuKTtcblx0ICB9XG5cdFxuXHQgIC8vIEVuc3VyZSB0aGUgY29sdW1uIHNwYW4gaXMgbm90IG1vcmUgdGhhbiB0aGUgYW1vdW50IG9mIGNvbHVtbnMgaW4gdGhlIHdob2xlIGxheW91dC5cblx0ICByZXR1cm4gTWF0aC5taW4oTWF0aC5jZWlsKGNvbHVtblNwYW4pLCBjb2x1bW5zKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFJldHJpZXZlcyB0aGUgY29sdW1uIHNldCB0byB1c2UgZm9yIHBsYWNlbWVudC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtblNwYW4gVGhlIG51bWJlciBvZiBjb2x1bW5zIHRoaXMgY3VycmVudCBpdGVtIHNwYW5zLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gY29sdW1ucyBUaGUgdG90YWwgY29sdW1ucyBpbiB0aGUgZ3JpZC5cblx0ICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IEFuIGFycmF5IG9mIG51bWJlcnMgcmVwcmVzZXRpbmcgdGhlIGNvbHVtbiBzZXQuXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRBdmFpbGFibGVQb3NpdGlvbnMocG9zaXRpb25zLCBjb2x1bW5TcGFuLCBjb2x1bW5zKSB7XG5cdCAgLy8gVGhlIGl0ZW0gc3BhbnMgb25seSBvbmUgY29sdW1uLlxuXHQgIGlmIChjb2x1bW5TcGFuID09PSAxKSB7XG5cdCAgICByZXR1cm4gcG9zaXRpb25zO1xuXHQgIH1cblx0XG5cdCAgLy8gVGhlIGl0ZW0gc3BhbnMgbW9yZSB0aGFuIG9uZSBjb2x1bW4sIGZpZ3VyZSBvdXQgaG93IG1hbnkgZGlmZmVyZW50XG5cdCAgLy8gcGxhY2VzIGl0IGNvdWxkIGZpdCBob3Jpem9udGFsbHkuXG5cdCAgLy8gVGhlIGdyb3VwIGNvdW50IGlzIHRoZSBudW1iZXIgb2YgcGxhY2VzIHdpdGhpbiB0aGUgcG9zaXRpb25zIHRoaXMgYmxvY2tcblx0ICAvLyBjb3VsZCBmaXQsIGlnbm9yaW5nIHRoZSBjdXJyZW50IHBvc2l0aW9ucyBvZiBpdGVtcy5cblx0ICAvLyBJbWFnaW5lIGEgMiBjb2x1bW4gYnJpY2sgYXMgdGhlIHNlY29uZCBpdGVtIGluIGEgNCBjb2x1bW4gZ3JpZCB3aXRoXG5cdCAgLy8gMTBweCBoZWlnaHQgZWFjaC4gRmluZCB0aGUgcGxhY2VzIGl0IHdvdWxkIGZpdDpcblx0ICAvLyBbMjAsIDEwLCAxMCwgMF1cblx0ICAvLyAgfCAgIHwgICB8XG5cdCAgLy8gICogICAqICAgKlxuXHQgIC8vXG5cdCAgLy8gVGhlbiB0YWtlIHRoZSBwbGFjZXMgd2hpY2ggZml0IGFuZCBnZXQgdGhlIGJpZ2dlciBvZiB0aGUgdHdvOlxuXHQgIC8vIG1heChbMjAsIDEwXSksIG1heChbMTAsIDEwXSksIG1heChbMTAsIDBdKSA9IFsyMCwgMTAsIDBdXG5cdCAgLy9cblx0ICAvLyBOZXh0LCBmaW5kIHRoZSBmaXJzdCBzbWFsbGVzdCBudW1iZXIgKHRoZSBzaG9ydCBjb2x1bW4pLlxuXHQgIC8vIFsyMCwgMTAsIDBdXG5cdCAgLy8gICAgICAgICAgfFxuXHQgIC8vICAgICAgICAgICpcblx0ICAvL1xuXHQgIC8vIEFuZCB0aGF0J3Mgd2hlcmUgaXQgc2hvdWxkIGJlIHBsYWNlZCFcblx0ICAvL1xuXHQgIC8vIEFub3RoZXIgZXhhbXBsZSB3aGVyZSB0aGUgc2Vjb25kIGNvbHVtbidzIGl0ZW0gZXh0ZW5kcyBwYXN0IHRoZSBmaXJzdDpcblx0ICAvLyBbMTAsIDIwLCAxMCwgMF0gPT4gWzIwLCAyMCwgMTBdID0+IDEwXG5cdCAgdmFyIGF2YWlsYWJsZSA9IFtdO1xuXHRcblx0ICAvLyBGb3IgaG93IG1hbnkgcG9zc2libGUgcG9zaXRpb25zIGZvciB0aGlzIGl0ZW0gdGhlcmUgYXJlLlxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDw9IGNvbHVtbnMgLSBjb2x1bW5TcGFuOyBpKyspIHtcblx0ICAgIC8vIEZpbmQgdGhlIGJpZ2dlciB2YWx1ZSBmb3IgZWFjaCBwbGFjZSBpdCBjb3VsZCBmaXQuXG5cdCAgICBhdmFpbGFibGUucHVzaChhcnJheU1heChwb3NpdGlvbnMuc2xpY2UoaSwgaSArIGNvbHVtblNwYW4pKSk7XG5cdCAgfVxuXHRcblx0ICByZXR1cm4gYXZhaWxhYmxlO1xuXHR9XG5cdFxuXHQvKipcblx0ICogRmluZCBpbmRleCBvZiBzaG9ydCBjb2x1bW4sIHRoZSBmaXJzdCBmcm9tIHRoZSBsZWZ0IHdoZXJlIHRoaXMgaXRlbSB3aWxsIGdvLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBwb3NpdGlvbnMgVGhlIGFycmF5IHRvIHNlYXJjaCBmb3IgdGhlIHNtYWxsZXN0IG51bWJlci5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGJ1ZmZlciBPcHRpb25hbCBidWZmZXIgd2hpY2ggaXMgdmVyeSB1c2VmdWwgd2hlbiB0aGUgaGVpZ2h0XG5cdCAqICAgICBpcyBhIHBlcmNlbnRhZ2Ugb2YgdGhlIHdpZHRoLlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IEluZGV4IG9mIHRoZSBzaG9ydCBjb2x1bW4uXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRTaG9ydENvbHVtbihwb3NpdGlvbnMsIGJ1ZmZlcikge1xuXHQgIHZhciBtaW5Qb3NpdGlvbiA9IGFycmF5TWluKHBvc2l0aW9ucyk7XG5cdCAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHQgICAgaWYgKHBvc2l0aW9uc1tpXSA+PSBtaW5Qb3NpdGlvbiAtIGJ1ZmZlciAmJiBwb3NpdGlvbnNbaV0gPD0gbWluUG9zaXRpb24gKyBidWZmZXIpIHtcblx0ICAgICAgcmV0dXJuIGk7XG5cdCAgICB9XG5cdCAgfVxuXHRcblx0ICByZXR1cm4gMDtcblx0fVxuXG4vKioqLyB9XG4vKioqKioqLyBdKVxufSk7XG47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaHVmZmxlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zaHVmZmxlanMvZGlzdC9zaHVmZmxlLmpzXG4vLyBtb2R1bGUgaWQgPSA5ODBcbi8vIG1vZHVsZSBjaHVua3MgPSA1Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ })

});